{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME.ml","path":"CNAME.ml","modified":1,"renderable":0},{"_id":"themes/smackdown/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/smackdown/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/smackdown/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/smackdown/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/smackdown/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/smackdown/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/smackdown/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/coderwall.png","path":"img/coderwall.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/delicious.png","path":"img/delicious.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/douban.png","path":"img/douban.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/facebook.png","path":"img/facebook.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/github.png","path":"img/github.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/google.png","path":"img/google.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/img-err.png","path":"img/img-err.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/img-loading.png","path":"img/img-loading.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/linkedin.png","path":"img/linkedin.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/mail.png","path":"img/mail.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/pinboard.png","path":"img/pinboard.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/pinterest.png","path":"img/pinterest.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/qq.png","path":"img/qq.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/rss.png","path":"img/rss.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/search.png","path":"img/search.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/stackoverflow.png","path":"img/stackoverflow.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/twitter.png","path":"img/twitter.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/weibo.png","path":"img/weibo.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/zhihu.png","path":"img/zhihu.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/js/Counter.js","path":"js/Counter.js","modified":1,"renderable":1},{"_id":"themes/smackdown/source/js/instagram.js","path":"js/instagram.js","modified":1,"renderable":1},{"_id":"themes/smackdown/source/js/jquery.lazyload.js","path":"js/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/smackdown/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/smackdown/source/js/mobile.js","path":"js/mobile.js","modified":1,"renderable":1},{"_id":"themes/smackdown/source/js/particles.js","path":"js/particles.js","modified":1,"renderable":1},{"_id":"themes/smackdown/source/js/pc.js","path":"js/pc.js","modified":1,"renderable":1},{"_id":"themes/smackdown/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/smackdown/source/css/fonts/fontawesome-webfont.svgz","path":"css/fonts/fontawesome-webfont.svgz","modified":1,"renderable":1},{"_id":"themes/smackdown/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/smackdown/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/smackdown/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/smackdown/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/smackdown/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/smackdown/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/smackdown/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/smackdown/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"936bd0773fccc5f1c930a43e760ecf1a89099d92","modified":1543849020319},{"_id":"source/CNAME.ml","hash":"d62d122efe6c38068bd2f4d2e6e1bbf301eb9c80","modified":1528639626000},{"_id":"themes/smackdown/.gitignore","hash":"eaa3d84cb77d92a21b111fd1e37f53edc1ff9de0","modified":1543848912065},{"_id":"themes/smackdown/READMEzh.md","hash":"f32722cc30aa85927ef2d6e59683e6c221c56ebf","modified":1543848912065},{"_id":"themes/smackdown/README.md","hash":"3df2f1237738e3a36666f9f88058f2b5833692f4","modified":1543848912065},{"_id":"themes/smackdown/_config.yml","hash":"239d32511438ddcb9b64633115f2a8298927e663","modified":1543848912065},{"_id":"themes/smackdown/package.json","hash":"ebe2d9263420f16841f55414538485e9b8a01643","modified":1543848912069},{"_id":"source/_posts/Blocks.md","hash":"b4f66aa7c7b7d6416b1ce3587d9457ab07e16a93","modified":1543848912063},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1528639626000},{"_id":"source/_posts/JavaScript.md","hash":"8db137d48e5d2e8046c16099e59b2b9979ce9b35","modified":1528639626000},{"_id":"source/_posts/OC使用静态库中的类别.md","hash":"b33b0110d25c848d3ec3f4f5ff86413dc4ffc4c1","modified":1528639626000},{"_id":"source/_posts/Untitled.md","hash":"c43775ea2c21066b61765461f6a37e668d1f322b","modified":1528639626000},{"_id":"source/_posts/Xcode8 报错resource fork, Finder information, or similar detritus not allowed.md","hash":"0bcd1c365e43174385c552b316dbe523c36ad952","modified":1528639626000},{"_id":"source/_posts/appium测试时候的那些事.md","hash":"2b20e37d1d2988de01b9e3c75a20c4d76c55ac8c","modified":1528639626000},{"_id":"source/_posts/bridged.md","hash":"cdcbd70821b65c6e3ad68dbd2f0c7f0fba034ff3","modified":1536073521037},{"_id":"source/_posts/centOS系统命令.md","hash":"8f8732fb483c64b07f10b29d11f6a34d29d00de5","modified":1543848912064},{"_id":"source/_posts/hello-world.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1528639626000},{"_id":"source/_posts/ios与os x多线程与内存管理","hash":"3ff361ba18c430818d50c2b9d50b8ca3bff5ea8e","modified":1528639626000},{"_id":"source/_posts/my-first-blog.md","hash":"0680931befcaa34f362706642599c0276f6704be","modified":1528639626000},{"_id":"source/_posts/ssh连接报错.md","hash":"2663779c010ae1fc30ccc0c671807f18c535cada","modified":1528639626000},{"_id":"source/_posts/枚举的实现方式(移位枚举).md","hash":"699c4495723f65e8cfa4801b33f1cf8c6ccda834","modified":1528639626000},{"_id":"source/_posts/读《iOS与OS X多线程和内存管理》——前言.md","hash":"02257ab2d3c114bfd01a730feb829832d57854cd","modified":1536073521038},{"_id":"source/_posts/读《iOS与OS X多线程和内存管理》——引用计数.md","hash":"2b5c8c654dd81811755e8cd56af86ff39bf98d20","modified":1536073521038},{"_id":"source/iOS日常/index.md","hash":"61f20f7ba6d3c1511e4c30c0a7254128358523fa","modified":1543848912065},{"_id":"source/tags/index.md","hash":"129c3aa7f5ea53a996a6d703a7181f42af45567f","modified":1543848912065},{"_id":"themes/smackdown/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1543848912068},{"_id":"themes/smackdown/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1543848912068},{"_id":"themes/smackdown/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1543848912069},{"_id":"themes/smackdown/layout/layout.ejs","hash":"2a03159a20b9b8c65fd1a62c24f5e93ddb0f18c8","modified":1543848912069},{"_id":"themes/smackdown/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1543848912069},{"_id":"themes/smackdown/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1543848912069},{"_id":"themes/smackdown/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1543848912069},{"_id":"source/_posts/OC使用静态库中的类别/OC使用静态库中的类别.md","hash":"6d0182bc2ed10369e15ba6f99775b37072805e51","modified":1543848912063},{"_id":"source/_posts/WeView 2 使用翻译/WeView 2 使用翻译.md","hash":"b5a0e6ddb12b2eb09ab6bda8c41f895a6daa46dd","modified":1543848912063},{"_id":"source/_posts/Xcode8 报错resource fork, Finder information, or similar detritus not allowed/Xcode8 报错resource fork, Finder information, or similar detritus not allowed.md","hash":"7e59017c88f693ce0a6120e720c874edd9e86ad2","modified":1543848912064},{"_id":"source/_posts/内存管理/内存管理.md","hash":"457a275c7c71b8f3646e0a93aaa262d8075b12c3","modified":1543848912064},{"_id":"source/_posts/加密算法/加密算法.md","hash":"e6520b8a8905ddf764d146c71ac41451480dcfdc","modified":1543848912064},{"_id":"source/_posts/枚举的实现方式(移位枚举)/枚举的实现方式(移位枚举).md","hash":"86c8baeba8b19c5263344b516176869553c1940f","modified":1543848912065},{"_id":"themes/smackdown/layout/_partial/after-footer.ejs","hash":"4bf1d05755851ffae61b281d63d273af82f72676","modified":1543848912066},{"_id":"themes/smackdown/layout/_partial/archive-post.ejs","hash":"3bbedf799e1788b3e62494eb6d0f7bd5df985cfc","modified":1543848912066},{"_id":"themes/smackdown/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1543848912066},{"_id":"themes/smackdown/layout/_partial/article.ejs","hash":"050bf4301b3b42426b7d1f896951cfb489fe3741","modified":1543848912066},{"_id":"themes/smackdown/layout/_partial/baidu_tongji.ejs","hash":"b227224a73bfbcb31ebeece59f31723f32ed5b1d","modified":1543848912066},{"_id":"themes/smackdown/layout/_partial/footer.ejs","hash":"c4e0ac111ad70deee307a394dff9e2c2ce543759","modified":1543848912066},{"_id":"themes/smackdown/layout/_partial/google_analytics.ejs","hash":"354f8553dffba0a6bcea8294d5d656ed11315394","modified":1543848912066},{"_id":"themes/smackdown/layout/_partial/head.ejs","hash":"a3a39aa8f03e4a368e7d137cadbc66b25f60dade","modified":1543848912066},{"_id":"themes/smackdown/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1543848912067},{"_id":"themes/smackdown/layout/_partial/left-col.ejs","hash":"70a9951e4e2d30aabba88e75c3fa54b9235ce6a6","modified":1543848912067},{"_id":"themes/smackdown/layout/_partial/mathjax.ejs","hash":"960ee249eb0cfae9746589f3a4c3ece79359cae7","modified":1543848912067},{"_id":"themes/smackdown/layout/_partial/mobile-nav.ejs","hash":"cd0af87ee781ac9c2b0e6a2a05b063d4bd497d9c","modified":1543848912067},{"_id":"themes/smackdown/layout/_partial/search.ejs","hash":"87f9a4f472808398f9c7041642520d4345efac24","modified":1543848912068},{"_id":"themes/smackdown/layout/_widget/Counter.ejs","hash":"e0395ba653817d9b385f69a8733f370e5d60343d","modified":1543848912068},{"_id":"themes/smackdown/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1543848912069},{"_id":"themes/smackdown/source/css/_variables.styl","hash":"5e37a6571caf87149af83ac1cc0cdef99f117350","modified":1543848912072},{"_id":"themes/smackdown/source/css/style.styl","hash":"c6eb98c09466bde2804f122431406141ce1e9015","modified":1543848912073},{"_id":"themes/smackdown/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1543848912073},{"_id":"themes/smackdown/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1543848912073},{"_id":"themes/smackdown/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1543848912074},{"_id":"themes/smackdown/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1543848912074},{"_id":"themes/smackdown/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1543848912074},{"_id":"themes/smackdown/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1543848912074},{"_id":"themes/smackdown/source/fancybox/jquery.fancybox.css","hash":"b6aa6692c2e5f8bd74d96827b78570f0c5683c20","modified":1543848912133},{"_id":"themes/smackdown/source/fancybox/jquery.fancybox.js","hash":"a82597493d75ea989ca586e09173cff332efe41e","modified":1543848912133},{"_id":"themes/smackdown/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1543848912076},{"_id":"themes/smackdown/source/img/coderwall.png","hash":"fa84676c4d654e040e51fd34bfcd9f9348cd5331","modified":1543848912076},{"_id":"themes/smackdown/source/img/delicious.png","hash":"9553a5f5189e4a953e04a58a49dbfa74b86b73dd","modified":1543848912076},{"_id":"themes/smackdown/source/img/douban.png","hash":"e2ade003ffadd5826ee66ec23901c2d6e8607e4e","modified":1543848912076},{"_id":"themes/smackdown/source/img/facebook.png","hash":"d19ad7a0903daf26817afd8753cd97e0cc714f54","modified":1543848912076},{"_id":"themes/smackdown/source/img/github.png","hash":"b84d03b32fa388dcbf149296ebd16dce6223d48d","modified":1543848912076},{"_id":"themes/smackdown/source/img/google.png","hash":"61a21fec7346fa3400b747ac9a201cf3d5bc013d","modified":1543848912077},{"_id":"themes/smackdown/source/img/img-err.png","hash":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1543848912077},{"_id":"themes/smackdown/source/img/img-loading.png","hash":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1543848912077},{"_id":"themes/smackdown/source/img/linkedin.png","hash":"e203138fb53c257cb214e97f4e30091b9c568d2c","modified":1543848912077},{"_id":"themes/smackdown/source/img/mail.png","hash":"fca8199cc77fdbd700a45bf56d091c82f4a67fe7","modified":1543848912077},{"_id":"themes/smackdown/source/img/pinboard.png","hash":"0891fbb6d092fa012bf936019923383d84c6aeb0","modified":1543848912077},{"_id":"themes/smackdown/source/img/pinterest.png","hash":"9c72917f8779c083157c6ce7a5d62ed4874f0630","modified":1543848912077},{"_id":"themes/smackdown/source/img/qq.png","hash":"93e6e87ec8cef56573a08c8f8fbb0bb53313354a","modified":1543848912077},{"_id":"themes/smackdown/source/img/rss.png","hash":"430fd47340e75214c081abd05cd7410cf7c71b86","modified":1543848912078},{"_id":"themes/smackdown/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1543848912078},{"_id":"themes/smackdown/source/img/search.png","hash":"1ab76b03297ae2ce61ec59dd9bf8727f1fbbcedd","modified":1543848912078},{"_id":"themes/smackdown/source/img/stackoverflow.png","hash":"da5dfe9043055c95e479d49c78cd3b020de608f2","modified":1543848912078},{"_id":"themes/smackdown/source/img/twitter.png","hash":"14dbb8e62d056525253bc0de13acd1723da7a934","modified":1543848912078},{"_id":"themes/smackdown/source/img/weibo.png","hash":"280dae3fd38086158b4a1b57edb94c06b1a5014b","modified":1543848912078},{"_id":"themes/smackdown/source/img/zhihu.png","hash":"a6d6ef65e9ac82e613a311810391ebb90d9b1c1d","modified":1543848912078},{"_id":"themes/smackdown/source/js/Counter.js","hash":"6697d5dfba2700c059722b62d856d4c86c73031a","modified":1543848912079},{"_id":"themes/smackdown/source/js/instagram.js","hash":"f19adbcc0dac33536bc6660598059048ec901882","modified":1543848912079},{"_id":"themes/smackdown/source/js/jquery.lazyload.js","hash":"c11a2e7b330d16d06feabd0a8477099adf9d6799","modified":1543848912079},{"_id":"themes/smackdown/source/js/main.js","hash":"5e92a3694111e5ae5aca37c79157218d35f2e63b","modified":1543848912079},{"_id":"themes/smackdown/source/js/mobile.js","hash":"b68cc01d24e80973c48205f551da87f3f3427644","modified":1543848912079},{"_id":"themes/smackdown/source/js/particles.js","hash":"c4286268c2071a624bf3c8565f6328eccecacf30","modified":1543848912079},{"_id":"themes/smackdown/source/js/pc.js","hash":"fdbc039fc9ffa70815b5fc4daaa587ae29693f10","modified":1543848912079},{"_id":"themes/smackdown/layout/_partial/post/category.ejs","hash":"d4f0e36f9a2167e91082dbd7d52425a06d2bebbf","modified":1543848912067},{"_id":"themes/smackdown/layout/_partial/post/date.ejs","hash":"c0c988334e857a77ba455a056dfa21809e7e76a5","modified":1543848912067},{"_id":"themes/smackdown/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1543848912067},{"_id":"themes/smackdown/layout/_partial/post/nav.ejs","hash":"1939c94f24ba0f25dd728eef559509ba8647b546","modified":1543848912067},{"_id":"themes/smackdown/layout/_partial/post/share.ejs","hash":"fbfe1306e3092ab8965cddba11db164c5a96ed85","modified":1543848912068},{"_id":"themes/smackdown/layout/_partial/post/tag.ejs","hash":"78612cfc091d7d861a70455a0dc8c3036e460879","modified":1543848912068},{"_id":"themes/smackdown/layout/_partial/post/title.ejs","hash":"efa58f58564d44b819175ad11b10d77347c92891","modified":1543848912068},{"_id":"themes/smackdown/layout/_partial/post/viewCounter.ejs","hash":"07ef10241d92479fd4dafbee361c0bf9664e4452","modified":1543848912068},{"_id":"themes/smackdown/source/css/_partial/archive.styl","hash":"da0a72fb05a6ebfff9b4ba013e35e8a67b047e15","modified":1543848912069},{"_id":"themes/smackdown/source/css/_partial/article.styl","hash":"26a17e97521c77bd3724a721a28d267ce250a63f","modified":1543848912070},{"_id":"themes/smackdown/source/css/_partial/footer.styl","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1543848912070},{"_id":"themes/smackdown/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1543848912070},{"_id":"themes/smackdown/source/css/_partial/highlight.styl","hash":"17a9b4fb6e746dd1f03757e89f5e3eff02b1fba6","modified":1543848912070},{"_id":"themes/smackdown/source/css/_partial/instagram.styl","hash":"4de333144b00c58a5d41d682d83f78794f75d19d","modified":1543848912070},{"_id":"themes/smackdown/source/css/_partial/main.styl","hash":"a8d7b2735bab91e5651433880aedb0c900f269b9","modified":1543848912070},{"_id":"themes/smackdown/source/css/_partial/mobile-slider.styl","hash":"96eee8fb0d3f1108eae9a04682d4bbd0e968be22","modified":1543848912070},{"_id":"themes/smackdown/source/css/_partial/mobile.styl","hash":"dd601ea98944c8fdf0d6776ef5bae4d68e967835","modified":1543848912070},{"_id":"themes/smackdown/source/css/_partial/page.styl","hash":"97371f551ed051780f8632142ea00a705d76c845","modified":1543848912071},{"_id":"themes/smackdown/source/css/_partial/scroll.styl","hash":"a0bd4b253b28f694de59bec217f48f59f92cbaf2","modified":1543848912071},{"_id":"themes/smackdown/source/css/_partial/share.styl","hash":"6ac15a6815b1bbdbea89d3fe933c2821aa80b926","modified":1543848912071},{"_id":"themes/smackdown/source/css/_partial/tagcloud.styl","hash":"84a678fe6b78befb4cf6e7523f8a40313a544fbd","modified":1543848912071},{"_id":"themes/smackdown/source/css/_partial/wheelmenu.styl","hash":"74630c56944e27bef53ef0c0e391611a2eec2ed0","modified":1543848912071},{"_id":"themes/smackdown/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1543848912071},{"_id":"themes/smackdown/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1543848912071},{"_id":"themes/smackdown/source/css/fonts/fontawesome-webfont.eot","hash":"3ce87b82c7a4ffdf65e96765c2ffda10b1a283c6","modified":1543848912072},{"_id":"themes/smackdown/source/css/fonts/fontawesome-webfont.svgz","hash":"4bfdd33ed702e32ae01399fcc2652377f78e7626","modified":1543848912072},{"_id":"themes/smackdown/source/css/fonts/fontawesome-webfont.ttf","hash":"1480b8101b02da9bc4c60341b5e185e63e585064","modified":1543848912073},{"_id":"themes/smackdown/source/css/fonts/fontawesome-webfont.woff","hash":"cafc4ac5761a0a252d33dce4ea3952cf9a38d832","modified":1543848912073},{"_id":"themes/smackdown/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1543848912074},{"_id":"themes/smackdown/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1543848912075},{"_id":"themes/smackdown/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1543848912134},{"_id":"themes/smackdown/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1543848912075},{"_id":"themes/smackdown/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1543848912075},{"_id":"themes/smackdown/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1543848912134},{"_id":"source/_posts/WeView 2 使用翻译/resources/9AF089FB76B2ADB18C4B3E9423098F77.jpg","hash":"cdf10d2b08adcfbfc5aa0cd0f2f2c99ce95e6bea","modified":1543848912064},{"_id":"themes/smackdown/source/css/fonts/fontawesome-webfont.svg","hash":"23a6f5b2ff76de9cb3cf1e886194c67647fd868a","modified":1543848912072},{"_id":"public/content.json","hash":"d5bead5a80e902ff40cc1ec0c81c09cda15c2c32","modified":1543930896048},{"_id":"public/iOS日常/index.html","hash":"0160221df71ca5dadcb9492f0c1e0118ac0729c0","modified":1543930896257},{"_id":"public/tags/index.html","hash":"c91f00d6e05dd2291e073c71b0090bd70329e920","modified":1543930896257},{"_id":"public/2018/12/03/Xcode8 报错resource fork, Finder information, or similar detritus not allowed/Xcode8 报错resource fork, Finder information, or similar detritus not allowed/index.html","hash":"3f8f55fc59676aa3fa3a8332eb29f3465361f0cc","modified":1543930896257},{"_id":"public/2018/12/03/内存管理/内存管理/index.html","hash":"528ff581f3e9d6b465b347e9e111b2d0a062eb14","modified":1543930896257},{"_id":"public/2018/12/03/加密算法/加密算法/index.html","hash":"f60ba7e80849bc0edba4958f6740e2446e0cbf19","modified":1543930896257},{"_id":"public/2018/06/10/Untitled/index.html","hash":"dc3c392fc64622aff0be703108e84cf05aeceb10","modified":1543930896257},{"_id":"public/2018/06/10/hello-world/index.html","hash":"c9d6f769280fa3d349eed276b918d8ed0387b417","modified":1543930896257},{"_id":"public/2017/04/05/OC使用静态库中的类别/index.html","hash":"80acac0e270eb4f7cdb1cbe74ace2809877662e2","modified":1543930896257},{"_id":"public/2017/04/05/OC使用静态库中的类别/OC使用静态库中的类别/index.html","hash":"018117ed47deb5d3a419751c7d52885cf5f5b0a4","modified":1543930896257},{"_id":"public/2017/03/31/Xcode8 报错resource fork, Finder information, or similar detritus not allowed/index.html","hash":"78fd4012a084f4a6d10f2783509c00c337cbd184","modified":1543930896257},{"_id":"public/2017/01/11/appium测试时候的那些事/index.html","hash":"7cee5ab95a8f43ee3190c49db35f7bafdad42550","modified":1543930896257},{"_id":"public/2017/01/11/my-first-blog/index.html","hash":"1f698b91f98e09fd4d30db8dfe996c87ab7a23fa","modified":1543930896257},{"_id":"public/2016/12/11/ssh连接报错/index.html","hash":"9ade8b0dd65b404f91cb3c4ec816ea5fa9356a22","modified":1543930896257},{"_id":"public/archives/index.html","hash":"c6c7f6f651668b605be79d69dc2fe6eb454d1a69","modified":1543930896257},{"_id":"public/archives/page/2/index.html","hash":"6b70a3a5025cc8f6bf4ce37af67c0e1347249de7","modified":1543930896257},{"_id":"public/archives/2016/index.html","hash":"41dee5e011453de91881345c538f04f3933413a7","modified":1543930896257},{"_id":"public/archives/2016/05/index.html","hash":"8c2df71626fe149589a4da60e24ee2ea364ec8fd","modified":1543930896258},{"_id":"public/archives/2016/12/index.html","hash":"ba48f11ce7cbaf1e4a92b414a86bc9965c88c643","modified":1543930896258},{"_id":"public/archives/2017/index.html","hash":"401df17120919946136dedee198482c310ba857e","modified":1543930896258},{"_id":"public/archives/2017/01/index.html","hash":"ddff369e5cb3c01fd821de22ae0812ed70673ab8","modified":1543930896258},{"_id":"public/archives/2017/03/index.html","hash":"9fb70e2640dd904c44dda9410c0b6346a373e1ff","modified":1543930896258},{"_id":"public/archives/2017/04/index.html","hash":"696a02d3041e0abeafe3072ab6d58cc19e7e0e56","modified":1543930896258},{"_id":"public/archives/2018/index.html","hash":"6ff9a8e1e30f1289e5692b55bd11567de7e793a0","modified":1543930896258},{"_id":"public/archives/2018/06/index.html","hash":"2cbc5c25d48cbc411627d207ee52e5676289bc60","modified":1543930896258},{"_id":"public/archives/2018/12/index.html","hash":"240872766cd8216ec9ad0c0e29688d017a9ed4ea","modified":1543930896258},{"_id":"public/tags/iOS/index.html","hash":"5c44cd8d031e147999929b3a97b9e919c7496b32","modified":1543930896258},{"_id":"public/tags/appium/index.html","hash":"3ba269c8775ae57e647b9f841b5fd80a9bc85fa9","modified":1543930896258},{"_id":"public/tags/Linux/index.html","hash":"a2948eacf9af112c54d4ec4cddf7603fcf2df5f0","modified":1543930896258},{"_id":"public/tags/hello/index.html","hash":"db814657d9c1af905d190ca7650b36146f9e5826","modified":1543930896258},{"_id":"public/tags/VPS那些事/index.html","hash":"4e194b0110a63ca921784753dc2f84f25da0f237","modified":1543930896258},{"_id":"public/tags/JavaScript/index.html","hash":"7463be8c78929aba013a7b07fc742a222813e0df","modified":1543930896258},{"_id":"public/2018/12/03/枚举的实现方式(移位枚举)/枚举的实现方式(移位枚举)/index.html","hash":"59d29b9be5664502ac2cdf3287de50e915de7ea6","modified":1543930896258},{"_id":"public/2018/12/03/Blocks/index.html","hash":"5fef105020a89d7e26df15fcea9e28c0c59e32ea","modified":1543930896258},{"_id":"public/2018/12/03/WeView 2 使用翻译/WeView 2 使用翻译/index.html","hash":"e0ec2184f1e7b6797f219c290ef619c19a4c664b","modified":1543930896258},{"_id":"public/2017/01/11/bridged/index.html","hash":"2a7f3a0389f21850cea09c4e37b4a5f5444c2fb0","modified":1543930896258},{"_id":"public/2017/01/11/读《iOS与OS X多线程和内存管理》——前言/index.html","hash":"91cdab3950b236d7b546770c5b2e10c01a32ee91","modified":1543930896258},{"_id":"public/2017/01/11/读《iOS与OS X多线程和内存管理》——引用计数/index.html","hash":"7041f80cff4229e85b5cc7585d714e8a1b31049c","modified":1543930896259},{"_id":"public/2017/01/11/JavaScript/index.html","hash":"cdfe9473a134b74525c6de651e71bd488cb34ddc","modified":1543930896259},{"_id":"public/2016/12/11/centOS系统命令/index.html","hash":"495eb7fa10e108deb3195b850e921b787b51bfaf","modified":1543930896259},{"_id":"public/2016/05/11/枚举的实现方式(移位枚举)/index.html","hash":"bea5fefa0c8f3d73b6f79cbbc19570c9cd0492af","modified":1543930896259},{"_id":"public/index.html","hash":"5c514a458033b8c5918cb3f92fcb2b0c4b6be2ea","modified":1543930896259},{"_id":"public/page/2/index.html","hash":"2e69dbd98bed7cd41b9c716487c4e1be8d5675d9","modified":1543930896259},{"_id":"public/CNAME.ml","hash":"d62d122efe6c38068bd2f4d2e6e1bbf301eb9c80","modified":1543930896265},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1543930896266},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1543930896266},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1543930896266},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1543930896266},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1543930896266},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1543930896266},{"_id":"public/img/coderwall.png","hash":"fa84676c4d654e040e51fd34bfcd9f9348cd5331","modified":1543930896266},{"_id":"public/img/delicious.png","hash":"9553a5f5189e4a953e04a58a49dbfa74b86b73dd","modified":1543930896266},{"_id":"public/img/douban.png","hash":"e2ade003ffadd5826ee66ec23901c2d6e8607e4e","modified":1543930896266},{"_id":"public/img/facebook.png","hash":"d19ad7a0903daf26817afd8753cd97e0cc714f54","modified":1543930896266},{"_id":"public/img/github.png","hash":"b84d03b32fa388dcbf149296ebd16dce6223d48d","modified":1543930896266},{"_id":"public/img/google.png","hash":"61a21fec7346fa3400b747ac9a201cf3d5bc013d","modified":1543930896266},{"_id":"public/img/img-err.png","hash":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1543930896266},{"_id":"public/img/img-loading.png","hash":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1543930896266},{"_id":"public/img/linkedin.png","hash":"e203138fb53c257cb214e97f4e30091b9c568d2c","modified":1543930896266},{"_id":"public/img/mail.png","hash":"fca8199cc77fdbd700a45bf56d091c82f4a67fe7","modified":1543930896266},{"_id":"public/img/pinboard.png","hash":"0891fbb6d092fa012bf936019923383d84c6aeb0","modified":1543930896266},{"_id":"public/img/pinterest.png","hash":"9c72917f8779c083157c6ce7a5d62ed4874f0630","modified":1543930896267},{"_id":"public/img/rss.png","hash":"430fd47340e75214c081abd05cd7410cf7c71b86","modified":1543930896267},{"_id":"public/img/qq.png","hash":"93e6e87ec8cef56573a08c8f8fbb0bb53313354a","modified":1543930896267},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1543930896267},{"_id":"public/img/search.png","hash":"1ab76b03297ae2ce61ec59dd9bf8727f1fbbcedd","modified":1543930896267},{"_id":"public/img/stackoverflow.png","hash":"da5dfe9043055c95e479d49c78cd3b020de608f2","modified":1543930896267},{"_id":"public/img/twitter.png","hash":"14dbb8e62d056525253bc0de13acd1723da7a934","modified":1543930896267},{"_id":"public/img/weibo.png","hash":"280dae3fd38086158b4a1b57edb94c06b1a5014b","modified":1543930896267},{"_id":"public/img/zhihu.png","hash":"a6d6ef65e9ac82e613a311810391ebb90d9b1c1d","modified":1543930896267},{"_id":"public/css/fonts/fontawesome-webfont.svgz","hash":"4bfdd33ed702e32ae01399fcc2652377f78e7626","modified":1543930896267},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"3ce87b82c7a4ffdf65e96765c2ffda10b1a283c6","modified":1543930896267},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"cafc4ac5761a0a252d33dce4ea3952cf9a38d832","modified":1543930896267},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1543930896267},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"1480b8101b02da9bc4c60341b5e185e63e585064","modified":1543930896267},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"23a6f5b2ff76de9cb3cf1e886194c67647fd868a","modified":1543930896635},{"_id":"public/fancybox/jquery.fancybox.css","hash":"b6aa6692c2e5f8bd74d96827b78570f0c5683c20","modified":1543930896643},{"_id":"public/js/Counter.js","hash":"6697d5dfba2700c059722b62d856d4c86c73031a","modified":1543930896643},{"_id":"public/js/instagram.js","hash":"f19adbcc0dac33536bc6660598059048ec901882","modified":1543930896643},{"_id":"public/js/main.js","hash":"5e92a3694111e5ae5aca37c79157218d35f2e63b","modified":1543930896643},{"_id":"public/js/jquery.lazyload.js","hash":"c11a2e7b330d16d06feabd0a8477099adf9d6799","modified":1543930896643},{"_id":"public/js/mobile.js","hash":"b68cc01d24e80973c48205f551da87f3f3427644","modified":1543930896643},{"_id":"public/js/pc.js","hash":"fdbc039fc9ffa70815b5fc4daaa587ae29693f10","modified":1543930896643},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1543930896643},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1543930896643},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1543930896643},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1543930896643},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1543930896643},{"_id":"public/css/style.css","hash":"bee40950f5650ca1ff4f755782f3f80df34e5b72","modified":1543930896643},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1543930896649},{"_id":"public/fancybox/jquery.fancybox.js","hash":"a82597493d75ea989ca586e09173cff332efe41e","modified":1543930896657},{"_id":"public/js/particles.js","hash":"c4286268c2071a624bf3c8565f6328eccecacf30","modified":1543930896657}],"Category":[],"Data":[],"Page":[{"title":"iOS日常","date":"2018-10-19T05:14:08.000Z","_content":"","source":"iOS日常/index.md","raw":"---\ntitle: iOS日常\ndate: 2018-10-19 13:14:08\n---\n","updated":"2018-12-03T14:55:12.065Z","path":"iOS日常/index.html","comments":1,"layout":"page","_id":"cjp9slb9n000108oz5yuch4vk","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2018-10-19T04:13:33.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2018-10-19 12:13:33\n---\n","updated":"2018-12-03T14:55:12.065Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjp9slb9p000308ozzur2yicq","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"_content":"# Blocks #\n\n## 什么是Blocks ##\n\n```blocks```是带有自动变量（局部变量）的匿名函数\n\n匿名函数，通过```Blocks``` 源码中能够使用不带名称的函数\n\n\n\n\n\n## Block 截获自动变量的值 ##\n\n```blocks```被称为“带有自动变量（局部变量）的匿名函数”\n\n\n那么```blocks```如何带自动变量呢？\n\n```\nvoid subMain() {\n    \n    int val = 10;\n    char *fmt = \"the val is %d\";\n    \n    void (^blk)(void) = ^{printf(fmt,val);};\n    blk();//the val is 10\n    val = 2;\n    blk();//the val is 10\n}\n```\n\n上面这个函数中两次调用block变量 blk，输出的都是“the val is 10”，因为block截获自动变量的值，\n所谓block截获自动变量的值，指的是在block表达式中会保存该自动变量的瞬间值\n\n\n如果要在block中改变局部变量呢？\n\n```\nvoid subMain() {\n    \n    int val = 10;\n    char *fmt = \"the val is %d\";\n    \n    void (^blk)(void) = ^{ val = 2};\n    blk();\n    \n}\n```\n\n这个函数想在block中改变局部变量的值，但是会报编译错误，显然，直接在block中改变自动变量的值也是不可以的\n\n如果想要在block中改变局部变量的值需要在局部变量前面加上一个```__blcok```修饰\n\n```\nvoid subMain() {\n    \n    __block int val = 10;\n    char *fmt = \"the val is %d\";\n    \n    void (^blk)(void) = ^{ val = 2};\n    blk();\n    \n}\n```\n\n这样就不会报错，而且可以改变局部变量的值\n\n\nclang -rewrite-objc\n\n\n\n\nblock 会在以下情况从栈拷贝到堆上\n\n1. 调用copy的实例方法\n2. block作为函数返回值返回时\n3. 将block赋值给附有__strong修饰符id类型的类或block类型成员变量时\n4. 在方法名中含有usingBlock的cocoa框架方法或GCD的API中传递Block时\n\n\n\n栈区(stack)\n概述：栈是向低地址扩展的数据结构，是一块连续的内存区域。由栈顶的地址和栈的最大容量是系统预先规定好的。栈的空间很小，大概1-2M。超出overflow。\n\n使用：栈区，就是函数(方法)运行时向系统请求的内存。栈中的局部变量，参数由编译器分配和释放，函数运行就分配，函数结束就释放，由系统完成。是系统数据结构，对应进程唯一。\n\n特别注意：系统栈的剩余空间 大于 所申请的空间，系统为程序提供内存，不然，报错异常，提示栈的溢出。\n\n堆区(heap)\n概述：堆是向高地址扩展的数据结构，不连续的内存区域。系统用链表储存空闲地址的。链表遍历由低向高。堆大小直接受设备有效虚拟内存影响。\n\n1.首先应该知道操作系统有一个记录空闲内存地址的链表。\n2.当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。\n3.由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中\n1\n2\n3\n使用: 存放实体对象的。由程序员分配和释放(arc自动插入分配和释放代码)，例如alloc 申请的会放入堆中。\n\n全局\\静态区(static)\n静态变量和全局变量是存储在一起的。初始化的全局变量和静态变量存放在一块区域，未初始化的全局变量和静态变量在相邻的另一块区域，程序结束后有系统释放。\n\nint a;//未初始化的静态区\nint b = 10;//初始化的静态区\n1\n2\n文字常量区\n存放常量字符串，程序结束系统释放\n\n程序代码区\n存放函数的二进制代码\n\n```\nmain{\n   int b; 栈区\n   char s[] = \"abc\" 栈\n   char *p1; 栈 \n   char *p2 = \"123456\";  //123456在文字常量区，p2在栈上。\n   static int c =0； 全局（静态）初始化区 \n\n   w1 = (char *)malloc(10); \n   w2 = (char *)malloc(20); \n   分配得来得10和20字节的区域就在堆区。 \n }\n\n```\n\n\n# GCD\n\n同步添加\ndispatch_sync(Queue,Block) \n\n等待 queue 中的所有任务都完成了之后，把block任务添加进入\n\n异步添加\ndispatch_async(Queue,Block) \n\n不做任何等待，直接把block中的任务添加进入queue\n\n\n注意：\n\n1. 如果是dispatch_sync（同步添加），但是queue 就是当前dispatch_sync运行的队列，就会造成死锁\n\n\n打比方：\n\nblock ：每个学生\n\nqueue ： 学生所站的队 （有两类）\n\ndispatch_sync 和 dispatch_async\n\n线程 ： 在哪个跑道上跑步\n\n\n\n把一个任务使用GCD让其在线程中执行，比喻下来就是安排一个学生到跑道上跑步\n\n\nqueue：这里有两种队列，一直叫串行队列，一种叫并行队列，\n\n串行队列：只能有一个学生在排队，如果有多个学生想要去排队，只能等前一个学生跑玩步，跑道空出来才能去排队\n\n\n\n\neg：\n\n异步并行队列：\n\n```\nvoid GCD_async_Test() {\n    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); //获得一个并行队列\n    NSLog(@\"任务1加入队列1前\");\n    dispatch_async(queue, ^{\n        NSLog(@\"开始长时间任务1\");\n        [NSThread sleepForTimeInterval:3];\n        NSLog(@\"长时间任务1完成\");\n    });//把任务放入并行队列中\n    NSLog(@\"任务1加入队列后\");\n}\n```\n\n输出：\n\n任务1加入队列1前\n任务1加入队列后\n开始长时间任务1\n长时间任务1完成\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Blocks.md","raw":"# Blocks #\n\n## 什么是Blocks ##\n\n```blocks```是带有自动变量（局部变量）的匿名函数\n\n匿名函数，通过```Blocks``` 源码中能够使用不带名称的函数\n\n\n\n\n\n## Block 截获自动变量的值 ##\n\n```blocks```被称为“带有自动变量（局部变量）的匿名函数”\n\n\n那么```blocks```如何带自动变量呢？\n\n```\nvoid subMain() {\n    \n    int val = 10;\n    char *fmt = \"the val is %d\";\n    \n    void (^blk)(void) = ^{printf(fmt,val);};\n    blk();//the val is 10\n    val = 2;\n    blk();//the val is 10\n}\n```\n\n上面这个函数中两次调用block变量 blk，输出的都是“the val is 10”，因为block截获自动变量的值，\n所谓block截获自动变量的值，指的是在block表达式中会保存该自动变量的瞬间值\n\n\n如果要在block中改变局部变量呢？\n\n```\nvoid subMain() {\n    \n    int val = 10;\n    char *fmt = \"the val is %d\";\n    \n    void (^blk)(void) = ^{ val = 2};\n    blk();\n    \n}\n```\n\n这个函数想在block中改变局部变量的值，但是会报编译错误，显然，直接在block中改变自动变量的值也是不可以的\n\n如果想要在block中改变局部变量的值需要在局部变量前面加上一个```__blcok```修饰\n\n```\nvoid subMain() {\n    \n    __block int val = 10;\n    char *fmt = \"the val is %d\";\n    \n    void (^blk)(void) = ^{ val = 2};\n    blk();\n    \n}\n```\n\n这样就不会报错，而且可以改变局部变量的值\n\n\nclang -rewrite-objc\n\n\n\n\nblock 会在以下情况从栈拷贝到堆上\n\n1. 调用copy的实例方法\n2. block作为函数返回值返回时\n3. 将block赋值给附有__strong修饰符id类型的类或block类型成员变量时\n4. 在方法名中含有usingBlock的cocoa框架方法或GCD的API中传递Block时\n\n\n\n栈区(stack)\n概述：栈是向低地址扩展的数据结构，是一块连续的内存区域。由栈顶的地址和栈的最大容量是系统预先规定好的。栈的空间很小，大概1-2M。超出overflow。\n\n使用：栈区，就是函数(方法)运行时向系统请求的内存。栈中的局部变量，参数由编译器分配和释放，函数运行就分配，函数结束就释放，由系统完成。是系统数据结构，对应进程唯一。\n\n特别注意：系统栈的剩余空间 大于 所申请的空间，系统为程序提供内存，不然，报错异常，提示栈的溢出。\n\n堆区(heap)\n概述：堆是向高地址扩展的数据结构，不连续的内存区域。系统用链表储存空闲地址的。链表遍历由低向高。堆大小直接受设备有效虚拟内存影响。\n\n1.首先应该知道操作系统有一个记录空闲内存地址的链表。\n2.当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。\n3.由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中\n1\n2\n3\n使用: 存放实体对象的。由程序员分配和释放(arc自动插入分配和释放代码)，例如alloc 申请的会放入堆中。\n\n全局\\静态区(static)\n静态变量和全局变量是存储在一起的。初始化的全局变量和静态变量存放在一块区域，未初始化的全局变量和静态变量在相邻的另一块区域，程序结束后有系统释放。\n\nint a;//未初始化的静态区\nint b = 10;//初始化的静态区\n1\n2\n文字常量区\n存放常量字符串，程序结束系统释放\n\n程序代码区\n存放函数的二进制代码\n\n```\nmain{\n   int b; 栈区\n   char s[] = \"abc\" 栈\n   char *p1; 栈 \n   char *p2 = \"123456\";  //123456在文字常量区，p2在栈上。\n   static int c =0； 全局（静态）初始化区 \n\n   w1 = (char *)malloc(10); \n   w2 = (char *)malloc(20); \n   分配得来得10和20字节的区域就在堆区。 \n }\n\n```\n\n\n# GCD\n\n同步添加\ndispatch_sync(Queue,Block) \n\n等待 queue 中的所有任务都完成了之后，把block任务添加进入\n\n异步添加\ndispatch_async(Queue,Block) \n\n不做任何等待，直接把block中的任务添加进入queue\n\n\n注意：\n\n1. 如果是dispatch_sync（同步添加），但是queue 就是当前dispatch_sync运行的队列，就会造成死锁\n\n\n打比方：\n\nblock ：每个学生\n\nqueue ： 学生所站的队 （有两类）\n\ndispatch_sync 和 dispatch_async\n\n线程 ： 在哪个跑道上跑步\n\n\n\n把一个任务使用GCD让其在线程中执行，比喻下来就是安排一个学生到跑道上跑步\n\n\nqueue：这里有两种队列，一直叫串行队列，一种叫并行队列，\n\n串行队列：只能有一个学生在排队，如果有多个学生想要去排队，只能等前一个学生跑玩步，跑道空出来才能去排队\n\n\n\n\neg：\n\n异步并行队列：\n\n```\nvoid GCD_async_Test() {\n    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); //获得一个并行队列\n    NSLog(@\"任务1加入队列1前\");\n    dispatch_async(queue, ^{\n        NSLog(@\"开始长时间任务1\");\n        [NSThread sleepForTimeInterval:3];\n        NSLog(@\"长时间任务1完成\");\n    });//把任务放入并行队列中\n    NSLog(@\"任务1加入队列后\");\n}\n```\n\n输出：\n\n任务1加入队列1前\n任务1加入队列后\n开始长时间任务1\n长时间任务1完成\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Blocks","published":1,"date":"2018-12-03T14:55:12.063Z","updated":"2018-12-03T14:55:12.063Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9slb9k000008oz8l2xcfkm","content":"<h1 id=\"Blocks\"><a href=\"#Blocks\" class=\"headerlink\" title=\"Blocks\"></a>Blocks</h1><h2 id=\"什么是Blocks\"><a href=\"#什么是Blocks\" class=\"headerlink\" title=\"什么是Blocks\"></a>什么是Blocks</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">匿名函数，通过```Blocks``` 源码中能够使用不带名称的函数</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## Block 截获自动变量的值 ##</span><br><span class=\"line\"></span><br><span class=\"line\">```blocks```被称为“带有自动变量（局部变量）的匿名函数”</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">那么```blocks```如何带自动变量呢？</span><br></pre></td></tr></table></figure>\n<p>void subMain() {</p>\n<pre><code>int val = 10;\nchar *fmt = &quot;the val is %d&quot;;\n\nvoid (^blk)(void) = ^{printf(fmt,val);};\nblk();//the val is 10\nval = 2;\nblk();//the val is 10\n</code></pre><p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">上面这个函数中两次调用block变量 blk，输出的都是“the val is 10”，因为block截获自动变量的值，</span><br><span class=\"line\">所谓block截获自动变量的值，指的是在block表达式中会保存该自动变量的瞬间值</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">如果要在block中改变局部变量呢？</span><br></pre></td></tr></table></figure></p>\n<p>void subMain() {</p>\n<pre><code>int val = 10;\nchar *fmt = &quot;the val is %d&quot;;\n\nvoid (^blk)(void) = ^{ val = 2};\nblk();\n</code></pre><p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">这个函数想在block中改变局部变量的值，但是会报编译错误，显然，直接在block中改变自动变量的值也是不可以的</span><br><span class=\"line\"></span><br><span class=\"line\">如果想要在block中改变局部变量的值需要在局部变量前面加上一个```__blcok```修饰</span><br></pre></td></tr></table></figure></p>\n<p>void subMain() {</p>\n<pre><code>__block int val = 10;\nchar *fmt = &quot;the val is %d&quot;;\n\nvoid (^blk)(void) = ^{ val = 2};\nblk();\n</code></pre><p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">这样就不会报错，而且可以改变局部变量的值</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">clang -rewrite-objc</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">block 会在以下情况从栈拷贝到堆上</span><br><span class=\"line\"></span><br><span class=\"line\">1. 调用copy的实例方法</span><br><span class=\"line\">2. block作为函数返回值返回时</span><br><span class=\"line\">3. 将block赋值给附有__strong修饰符id类型的类或block类型成员变量时</span><br><span class=\"line\">4. 在方法名中含有usingBlock的cocoa框架方法或GCD的API中传递Block时</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">栈区(stack)</span><br><span class=\"line\">概述：栈是向低地址扩展的数据结构，是一块连续的内存区域。由栈顶的地址和栈的最大容量是系统预先规定好的。栈的空间很小，大概1-2M。超出overflow。</span><br><span class=\"line\"></span><br><span class=\"line\">使用：栈区，就是函数(方法)运行时向系统请求的内存。栈中的局部变量，参数由编译器分配和释放，函数运行就分配，函数结束就释放，由系统完成。是系统数据结构，对应进程唯一。</span><br><span class=\"line\"></span><br><span class=\"line\">特别注意：系统栈的剩余空间 大于 所申请的空间，系统为程序提供内存，不然，报错异常，提示栈的溢出。</span><br><span class=\"line\"></span><br><span class=\"line\">堆区(heap)</span><br><span class=\"line\">概述：堆是向高地址扩展的数据结构，不连续的内存区域。系统用链表储存空闲地址的。链表遍历由低向高。堆大小直接受设备有效虚拟内存影响。</span><br><span class=\"line\"></span><br><span class=\"line\">1.首先应该知道操作系统有一个记录空闲内存地址的链表。</span><br><span class=\"line\">2.当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。</span><br><span class=\"line\">3.由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">使用: 存放实体对象的。由程序员分配和释放(arc自动插入分配和释放代码)，例如alloc 申请的会放入堆中。</span><br><span class=\"line\"></span><br><span class=\"line\">全局\\静态区(static)</span><br><span class=\"line\">静态变量和全局变量是存储在一起的。初始化的全局变量和静态变量存放在一块区域，未初始化的全局变量和静态变量在相邻的另一块区域，程序结束后有系统释放。</span><br><span class=\"line\"></span><br><span class=\"line\">int a;//未初始化的静态区</span><br><span class=\"line\">int b = 10;//初始化的静态区</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">文字常量区</span><br><span class=\"line\">存放常量字符串，程序结束系统释放</span><br><span class=\"line\"></span><br><span class=\"line\">程序代码区</span><br><span class=\"line\">存放函数的二进制代码</span><br></pre></td></tr></table></figure></p>\n<p>main{<br>   int b; 栈区<br>   char s[] = “abc” 栈<br>   char <em>p1; 栈<br>   char </em>p2 = “123456”;  //123456在文字常量区，p2在栈上。<br>   static int c =0； 全局（静态）初始化区 </p>\n<p>   w1 = (char <em>)malloc(10);<br>   w2 = (char </em>)malloc(20);<br>   分配得来得10和20字节的区域就在堆区。<br> }</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># GCD</span><br><span class=\"line\"></span><br><span class=\"line\">同步添加</span><br><span class=\"line\">dispatch_sync(Queue,Block) </span><br><span class=\"line\"></span><br><span class=\"line\">等待 queue 中的所有任务都完成了之后，把block任务添加进入</span><br><span class=\"line\"></span><br><span class=\"line\">异步添加</span><br><span class=\"line\">dispatch_async(Queue,Block) </span><br><span class=\"line\"></span><br><span class=\"line\">不做任何等待，直接把block中的任务添加进入queue</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">注意：</span><br><span class=\"line\"></span><br><span class=\"line\">1. 如果是dispatch_sync（同步添加），但是queue 就是当前dispatch_sync运行的队列，就会造成死锁</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">打比方：</span><br><span class=\"line\"></span><br><span class=\"line\">block ：每个学生</span><br><span class=\"line\"></span><br><span class=\"line\">queue ： 学生所站的队 （有两类）</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_sync 和 dispatch_async</span><br><span class=\"line\"></span><br><span class=\"line\">线程 ： 在哪个跑道上跑步</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">把一个任务使用GCD让其在线程中执行，比喻下来就是安排一个学生到跑道上跑步</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">queue：这里有两种队列，一直叫串行队列，一种叫并行队列，</span><br><span class=\"line\"></span><br><span class=\"line\">串行队列：只能有一个学生在排队，如果有多个学生想要去排队，只能等前一个学生跑玩步，跑道空出来才能去排队</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">eg：</span><br><span class=\"line\"></span><br><span class=\"line\">异步并行队列：</span><br></pre></td></tr></table></figure>\n<p>void GCD_async_Test() {<br>    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); //获得一个并行队列<br>    NSLog(@”任务1加入队列1前”);<br>    dispatch_async(queue, ^{<br>        NSLog(@”开始长时间任务1”);<br>        [NSThread sleepForTimeInterval:3];<br>        NSLog(@”长时间任务1完成”);<br>    });//把任务放入并行队列中<br>    NSLog(@”任务1加入队列后”);<br>}<br><code>`</code></p>\n<p>输出：</p>\n<p>任务1加入队列1前<br>任务1加入队列后<br>开始长时间任务1<br>长时间任务1完成</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Blocks\"><a href=\"#Blocks\" class=\"headerlink\" title=\"Blocks\"></a>Blocks</h1><h2 id=\"什么是Blocks\"><a href=\"#什么是Blocks\" class=\"headerlink\" title=\"什么是Blocks\"></a>什么是Blocks</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">匿名函数，通过```Blocks``` 源码中能够使用不带名称的函数</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## Block 截获自动变量的值 ##</span><br><span class=\"line\"></span><br><span class=\"line\">```blocks```被称为“带有自动变量（局部变量）的匿名函数”</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">那么```blocks```如何带自动变量呢？</span><br></pre></td></tr></table></figure>\n<p>void subMain() {</p>\n<pre><code>int val = 10;\nchar *fmt = &quot;the val is %d&quot;;\n\nvoid (^blk)(void) = ^{printf(fmt,val);};\nblk();//the val is 10\nval = 2;\nblk();//the val is 10\n</code></pre><p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">上面这个函数中两次调用block变量 blk，输出的都是“the val is 10”，因为block截获自动变量的值，</span><br><span class=\"line\">所谓block截获自动变量的值，指的是在block表达式中会保存该自动变量的瞬间值</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">如果要在block中改变局部变量呢？</span><br></pre></td></tr></table></figure></p>\n<p>void subMain() {</p>\n<pre><code>int val = 10;\nchar *fmt = &quot;the val is %d&quot;;\n\nvoid (^blk)(void) = ^{ val = 2};\nblk();\n</code></pre><p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">这个函数想在block中改变局部变量的值，但是会报编译错误，显然，直接在block中改变自动变量的值也是不可以的</span><br><span class=\"line\"></span><br><span class=\"line\">如果想要在block中改变局部变量的值需要在局部变量前面加上一个```__blcok```修饰</span><br></pre></td></tr></table></figure></p>\n<p>void subMain() {</p>\n<pre><code>__block int val = 10;\nchar *fmt = &quot;the val is %d&quot;;\n\nvoid (^blk)(void) = ^{ val = 2};\nblk();\n</code></pre><p>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">这样就不会报错，而且可以改变局部变量的值</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">clang -rewrite-objc</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">block 会在以下情况从栈拷贝到堆上</span><br><span class=\"line\"></span><br><span class=\"line\">1. 调用copy的实例方法</span><br><span class=\"line\">2. block作为函数返回值返回时</span><br><span class=\"line\">3. 将block赋值给附有__strong修饰符id类型的类或block类型成员变量时</span><br><span class=\"line\">4. 在方法名中含有usingBlock的cocoa框架方法或GCD的API中传递Block时</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">栈区(stack)</span><br><span class=\"line\">概述：栈是向低地址扩展的数据结构，是一块连续的内存区域。由栈顶的地址和栈的最大容量是系统预先规定好的。栈的空间很小，大概1-2M。超出overflow。</span><br><span class=\"line\"></span><br><span class=\"line\">使用：栈区，就是函数(方法)运行时向系统请求的内存。栈中的局部变量，参数由编译器分配和释放，函数运行就分配，函数结束就释放，由系统完成。是系统数据结构，对应进程唯一。</span><br><span class=\"line\"></span><br><span class=\"line\">特别注意：系统栈的剩余空间 大于 所申请的空间，系统为程序提供内存，不然，报错异常，提示栈的溢出。</span><br><span class=\"line\"></span><br><span class=\"line\">堆区(heap)</span><br><span class=\"line\">概述：堆是向高地址扩展的数据结构，不连续的内存区域。系统用链表储存空闲地址的。链表遍历由低向高。堆大小直接受设备有效虚拟内存影响。</span><br><span class=\"line\"></span><br><span class=\"line\">1.首先应该知道操作系统有一个记录空闲内存地址的链表。</span><br><span class=\"line\">2.当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。</span><br><span class=\"line\">3.由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">使用: 存放实体对象的。由程序员分配和释放(arc自动插入分配和释放代码)，例如alloc 申请的会放入堆中。</span><br><span class=\"line\"></span><br><span class=\"line\">全局\\静态区(static)</span><br><span class=\"line\">静态变量和全局变量是存储在一起的。初始化的全局变量和静态变量存放在一块区域，未初始化的全局变量和静态变量在相邻的另一块区域，程序结束后有系统释放。</span><br><span class=\"line\"></span><br><span class=\"line\">int a;//未初始化的静态区</span><br><span class=\"line\">int b = 10;//初始化的静态区</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">文字常量区</span><br><span class=\"line\">存放常量字符串，程序结束系统释放</span><br><span class=\"line\"></span><br><span class=\"line\">程序代码区</span><br><span class=\"line\">存放函数的二进制代码</span><br></pre></td></tr></table></figure></p>\n<p>main{<br>   int b; 栈区<br>   char s[] = “abc” 栈<br>   char <em>p1; 栈<br>   char </em>p2 = “123456”;  //123456在文字常量区，p2在栈上。<br>   static int c =0； 全局（静态）初始化区 </p>\n<p>   w1 = (char <em>)malloc(10);<br>   w2 = (char </em>)malloc(20);<br>   分配得来得10和20字节的区域就在堆区。<br> }</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># GCD</span><br><span class=\"line\"></span><br><span class=\"line\">同步添加</span><br><span class=\"line\">dispatch_sync(Queue,Block) </span><br><span class=\"line\"></span><br><span class=\"line\">等待 queue 中的所有任务都完成了之后，把block任务添加进入</span><br><span class=\"line\"></span><br><span class=\"line\">异步添加</span><br><span class=\"line\">dispatch_async(Queue,Block) </span><br><span class=\"line\"></span><br><span class=\"line\">不做任何等待，直接把block中的任务添加进入queue</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">注意：</span><br><span class=\"line\"></span><br><span class=\"line\">1. 如果是dispatch_sync（同步添加），但是queue 就是当前dispatch_sync运行的队列，就会造成死锁</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">打比方：</span><br><span class=\"line\"></span><br><span class=\"line\">block ：每个学生</span><br><span class=\"line\"></span><br><span class=\"line\">queue ： 学生所站的队 （有两类）</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_sync 和 dispatch_async</span><br><span class=\"line\"></span><br><span class=\"line\">线程 ： 在哪个跑道上跑步</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">把一个任务使用GCD让其在线程中执行，比喻下来就是安排一个学生到跑道上跑步</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">queue：这里有两种队列，一直叫串行队列，一种叫并行队列，</span><br><span class=\"line\"></span><br><span class=\"line\">串行队列：只能有一个学生在排队，如果有多个学生想要去排队，只能等前一个学生跑玩步，跑道空出来才能去排队</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">eg：</span><br><span class=\"line\"></span><br><span class=\"line\">异步并行队列：</span><br></pre></td></tr></table></figure>\n<p>void GCD_async_Test() {<br>    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); //获得一个并行队列<br>    NSLog(@”任务1加入队列1前”);<br>    dispatch_async(queue, ^{<br>        NSLog(@”开始长时间任务1”);<br>        [NSThread sleepForTimeInterval:3];<br>        NSLog(@”长时间任务1完成”);<br>    });//把任务放入并行队列中<br>    NSLog(@”任务1加入队列后”);<br>}<br><code>`</code></p>\n<p>输出：</p>\n<p>任务1加入队列1前<br>任务1加入队列后<br>开始长时间任务1<br>长时间任务1完成</p>\n"},{"title":"OC使用静态库中的类别","date":"2017-04-05T12:02:30.000Z","_content":"\n## OC中使用静态库中的类别的问题 ##\n\nOC的源文件经过 `clang` 编译首先生成中间代码,接着通过优化生成目标代码(目标代码中包括符号表,标示了此代码中的全局符号和静态符号,还标示了导入符号等),连接器会根据符号表分析各个目标代码之间的调用关系,然后将使用到的代码进行连接和重定位,最后生成可执行文件.\n\n在编译Objective-C源文件到目标文件时,编译器并不知道方法的对应实现,只能在运行时才知道,所以编译器只会为类生成连接符号,不会对类中的方法生成连接符号,由于Category方法并不对应一个新类,所以不会生成连接符号,连接器也不会将Category方法合并到原始的类中,最终导致连接器忽略了Category方法,不会将其连接到可执行文件中.\n\n\n> 在OC使用静态库中的类别,需要设置下面5种方法中的一种\n\n\n## Other Linker Flags 设置 ##\n\n* 1.通过在Other Linder Flags 添加 `-all\\_load` 它会告诉编译器对”所有文档中的所有对象文件,不管里面的符号有没有被用到,全部都载入”,这样会产生比较大的二进制文件\n\n* 2.通过在Other Linder Flags 添加 `-force\\_load 和指定路径` e.g: `-force\\_load $(SRCROOT)/RHAddressBook/libRHAddressBook.a` 这种方法会只载入指定的归档\n\n* 3.通过在Other Linder Flags 添加 `-ObjC` ,这个标识告诉编译器”如果在文档中发现了OC代码,就把文档载入” \n\n* 4.在Xcode里build setting中的 Perform Single-Object PreLink，如果启用这个选项，所有的对象文件都会被合并成一个单文件（这不是真正的链接，所以叫做预链接），这个对象文件（有时被称做主对象文件(master object file)）被添加到文档中。现在如果主对象文件中的任何符号被认为是“在使用”，整个主对象文件都会被认为在使用，这样它里面的OC部分就会被载入了。因为里面的类都被正常符号化了，所以能使从这样的静态库中使用所有的Category\n\n* 5.最后一种解决方法是在只有Category的源文件里添加Fake symbol。如果你想在运行时使用Category，一定要确保你以某种方法在编译时引用了fake symbol，这会使得对象文件以及它里面的OC代码被载入。例如，它可以是一个有空函数体的函数，也可以是一个被访问的全局变量（例如一个全局的int变量，只要它被读或者写了一次就足够了）。和上面其他的解决方法不一样，这种解决方法可以控制哪些category可以在运行时被编译后的代码使用（可以通过使用这个符号，使它们被链接并变得可用；也可以不使用这个符号，这样链接器就会忽略它）\n","source":"_posts/OC使用静态库中的类别.md","raw":"---\ntitle: OC使用静态库中的类别\ndate: 2017-04-05 20:02:30\ntags: iOS\n---\n\n## OC中使用静态库中的类别的问题 ##\n\nOC的源文件经过 `clang` 编译首先生成中间代码,接着通过优化生成目标代码(目标代码中包括符号表,标示了此代码中的全局符号和静态符号,还标示了导入符号等),连接器会根据符号表分析各个目标代码之间的调用关系,然后将使用到的代码进行连接和重定位,最后生成可执行文件.\n\n在编译Objective-C源文件到目标文件时,编译器并不知道方法的对应实现,只能在运行时才知道,所以编译器只会为类生成连接符号,不会对类中的方法生成连接符号,由于Category方法并不对应一个新类,所以不会生成连接符号,连接器也不会将Category方法合并到原始的类中,最终导致连接器忽略了Category方法,不会将其连接到可执行文件中.\n\n\n> 在OC使用静态库中的类别,需要设置下面5种方法中的一种\n\n\n## Other Linker Flags 设置 ##\n\n* 1.通过在Other Linder Flags 添加 `-all\\_load` 它会告诉编译器对”所有文档中的所有对象文件,不管里面的符号有没有被用到,全部都载入”,这样会产生比较大的二进制文件\n\n* 2.通过在Other Linder Flags 添加 `-force\\_load 和指定路径` e.g: `-force\\_load $(SRCROOT)/RHAddressBook/libRHAddressBook.a` 这种方法会只载入指定的归档\n\n* 3.通过在Other Linder Flags 添加 `-ObjC` ,这个标识告诉编译器”如果在文档中发现了OC代码,就把文档载入” \n\n* 4.在Xcode里build setting中的 Perform Single-Object PreLink，如果启用这个选项，所有的对象文件都会被合并成一个单文件（这不是真正的链接，所以叫做预链接），这个对象文件（有时被称做主对象文件(master object file)）被添加到文档中。现在如果主对象文件中的任何符号被认为是“在使用”，整个主对象文件都会被认为在使用，这样它里面的OC部分就会被载入了。因为里面的类都被正常符号化了，所以能使从这样的静态库中使用所有的Category\n\n* 5.最后一种解决方法是在只有Category的源文件里添加Fake symbol。如果你想在运行时使用Category，一定要确保你以某种方法在编译时引用了fake symbol，这会使得对象文件以及它里面的OC代码被载入。例如，它可以是一个有空函数体的函数，也可以是一个被访问的全局变量（例如一个全局的int变量，只要它被读或者写了一次就足够了）。和上面其他的解决方法不一样，这种解决方法可以控制哪些category可以在运行时被编译后的代码使用（可以通过使用这个符号，使它们被链接并变得可用；也可以不使用这个符号，这样链接器就会忽略它）\n","slug":"OC使用静态库中的类别","published":1,"updated":"2018-06-10T14:07:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9slb9n000208oz8naxbcd1","content":"<h2 id=\"OC中使用静态库中的类别的问题\"><a href=\"#OC中使用静态库中的类别的问题\" class=\"headerlink\" title=\"OC中使用静态库中的类别的问题\"></a>OC中使用静态库中的类别的问题</h2><p>OC的源文件经过 <code>clang</code> 编译首先生成中间代码,接着通过优化生成目标代码(目标代码中包括符号表,标示了此代码中的全局符号和静态符号,还标示了导入符号等),连接器会根据符号表分析各个目标代码之间的调用关系,然后将使用到的代码进行连接和重定位,最后生成可执行文件.</p>\n<p>在编译Objective-C源文件到目标文件时,编译器并不知道方法的对应实现,只能在运行时才知道,所以编译器只会为类生成连接符号,不会对类中的方法生成连接符号,由于Category方法并不对应一个新类,所以不会生成连接符号,连接器也不会将Category方法合并到原始的类中,最终导致连接器忽略了Category方法,不会将其连接到可执行文件中.</p>\n<blockquote>\n<p>在OC使用静态库中的类别,需要设置下面5种方法中的一种</p>\n</blockquote>\n<h2 id=\"Other-Linker-Flags-设置\"><a href=\"#Other-Linker-Flags-设置\" class=\"headerlink\" title=\"Other Linker Flags 设置\"></a>Other Linker Flags 设置</h2><ul>\n<li><p>1.通过在Other Linder Flags 添加 <code>-all\\_load</code> 它会告诉编译器对”所有文档中的所有对象文件,不管里面的符号有没有被用到,全部都载入”,这样会产生比较大的二进制文件</p>\n</li>\n<li><p>2.通过在Other Linder Flags 添加 <code>-force\\_load 和指定路径</code> e.g: <code>-force\\_load $(SRCROOT)/RHAddressBook/libRHAddressBook.a</code> 这种方法会只载入指定的归档</p>\n</li>\n<li><p>3.通过在Other Linder Flags 添加 <code>-ObjC</code> ,这个标识告诉编译器”如果在文档中发现了OC代码,就把文档载入” </p>\n</li>\n<li><p>4.在Xcode里build setting中的 Perform Single-Object PreLink，如果启用这个选项，所有的对象文件都会被合并成一个单文件（这不是真正的链接，所以叫做预链接），这个对象文件（有时被称做主对象文件(master object file)）被添加到文档中。现在如果主对象文件中的任何符号被认为是“在使用”，整个主对象文件都会被认为在使用，这样它里面的OC部分就会被载入了。因为里面的类都被正常符号化了，所以能使从这样的静态库中使用所有的Category</p>\n</li>\n<li><p>5.最后一种解决方法是在只有Category的源文件里添加Fake symbol。如果你想在运行时使用Category，一定要确保你以某种方法在编译时引用了fake symbol，这会使得对象文件以及它里面的OC代码被载入。例如，它可以是一个有空函数体的函数，也可以是一个被访问的全局变量（例如一个全局的int变量，只要它被读或者写了一次就足够了）。和上面其他的解决方法不一样，这种解决方法可以控制哪些category可以在运行时被编译后的代码使用（可以通过使用这个符号，使它们被链接并变得可用；也可以不使用这个符号，这样链接器就会忽略它）</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"OC中使用静态库中的类别的问题\"><a href=\"#OC中使用静态库中的类别的问题\" class=\"headerlink\" title=\"OC中使用静态库中的类别的问题\"></a>OC中使用静态库中的类别的问题</h2><p>OC的源文件经过 <code>clang</code> 编译首先生成中间代码,接着通过优化生成目标代码(目标代码中包括符号表,标示了此代码中的全局符号和静态符号,还标示了导入符号等),连接器会根据符号表分析各个目标代码之间的调用关系,然后将使用到的代码进行连接和重定位,最后生成可执行文件.</p>\n<p>在编译Objective-C源文件到目标文件时,编译器并不知道方法的对应实现,只能在运行时才知道,所以编译器只会为类生成连接符号,不会对类中的方法生成连接符号,由于Category方法并不对应一个新类,所以不会生成连接符号,连接器也不会将Category方法合并到原始的类中,最终导致连接器忽略了Category方法,不会将其连接到可执行文件中.</p>\n<blockquote>\n<p>在OC使用静态库中的类别,需要设置下面5种方法中的一种</p>\n</blockquote>\n<h2 id=\"Other-Linker-Flags-设置\"><a href=\"#Other-Linker-Flags-设置\" class=\"headerlink\" title=\"Other Linker Flags 设置\"></a>Other Linker Flags 设置</h2><ul>\n<li><p>1.通过在Other Linder Flags 添加 <code>-all\\_load</code> 它会告诉编译器对”所有文档中的所有对象文件,不管里面的符号有没有被用到,全部都载入”,这样会产生比较大的二进制文件</p>\n</li>\n<li><p>2.通过在Other Linder Flags 添加 <code>-force\\_load 和指定路径</code> e.g: <code>-force\\_load $(SRCROOT)/RHAddressBook/libRHAddressBook.a</code> 这种方法会只载入指定的归档</p>\n</li>\n<li><p>3.通过在Other Linder Flags 添加 <code>-ObjC</code> ,这个标识告诉编译器”如果在文档中发现了OC代码,就把文档载入” </p>\n</li>\n<li><p>4.在Xcode里build setting中的 Perform Single-Object PreLink，如果启用这个选项，所有的对象文件都会被合并成一个单文件（这不是真正的链接，所以叫做预链接），这个对象文件（有时被称做主对象文件(master object file)）被添加到文档中。现在如果主对象文件中的任何符号被认为是“在使用”，整个主对象文件都会被认为在使用，这样它里面的OC部分就会被载入了。因为里面的类都被正常符号化了，所以能使从这样的静态库中使用所有的Category</p>\n</li>\n<li><p>5.最后一种解决方法是在只有Category的源文件里添加Fake symbol。如果你想在运行时使用Category，一定要确保你以某种方法在编译时引用了fake symbol，这会使得对象文件以及它里面的OC代码被载入。例如，它可以是一个有空函数体的函数，也可以是一个被访问的全局变量（例如一个全局的int变量，只要它被读或者写了一次就足够了）。和上面其他的解决方法不一样，这种解决方法可以控制哪些category可以在运行时被编译后的代码使用（可以通过使用这个符号，使它们被链接并变得可用；也可以不使用这个符号，这样链接器就会忽略它）</p>\n</li>\n</ul>\n"},{"_content":"# AFNetworking 相关 #\n\n## 网络通讯 ##\n建立一个`TCP`协议的连接通常需要三次\"握手\",断开一个`TCP`协议的连接需要四次\"挥手\"\n\n### 三次\"握手\" ###\n* 1.\"Client\"端(客户端)发送连接请求报文.\n* 2.\"Server\"端(服务端)接受连接后回复ACK(指令正确)报文,并为这次连接分配资源\n* 3.\"Client\"端(客户端)收到ACK报文后像\"Server\"端发送ACK(指令正确报文),并分配资源\n\n举个栗子:\n    A(客户端)和B(服务端)进行交易\n    A:\"我要的东西带来了么?\" (客户端向服务端请求)\n    B:\"天王盖地府,先对暗号\" (服务端给客户端一个回应,表示知道客户端要请求了,并且准备好了请求资源)\n    A:\"小鸡炖蘑菇\" (客户端给服务端一个回应,表示自己知道已经连接上服务端,并且知道服务端准备好了,且自己也准备好了)\n    接头完成,进行可以进行交易(连接成功)\n","source":"_posts/Untitled.md","raw":"# AFNetworking 相关 #\n\n## 网络通讯 ##\n建立一个`TCP`协议的连接通常需要三次\"握手\",断开一个`TCP`协议的连接需要四次\"挥手\"\n\n### 三次\"握手\" ###\n* 1.\"Client\"端(客户端)发送连接请求报文.\n* 2.\"Server\"端(服务端)接受连接后回复ACK(指令正确)报文,并为这次连接分配资源\n* 3.\"Client\"端(客户端)收到ACK报文后像\"Server\"端发送ACK(指令正确报文),并分配资源\n\n举个栗子:\n    A(客户端)和B(服务端)进行交易\n    A:\"我要的东西带来了么?\" (客户端向服务端请求)\n    B:\"天王盖地府,先对暗号\" (服务端给客户端一个回应,表示知道客户端要请求了,并且准备好了请求资源)\n    A:\"小鸡炖蘑菇\" (客户端给服务端一个回应,表示自己知道已经连接上服务端,并且知道服务端准备好了,且自己也准备好了)\n    接头完成,进行可以进行交易(连接成功)\n","slug":"Untitled","published":1,"date":"2018-06-10T14:07:06.000Z","updated":"2018-06-10T14:07:06.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9slb9q000408ozudgqvf1a","content":"<h1 id=\"AFNetworking-相关\"><a href=\"#AFNetworking-相关\" class=\"headerlink\" title=\"AFNetworking 相关\"></a>AFNetworking 相关</h1><h2 id=\"网络通讯\"><a href=\"#网络通讯\" class=\"headerlink\" title=\"网络通讯\"></a>网络通讯</h2><p>建立一个<code>TCP</code>协议的连接通常需要三次”握手”,断开一个<code>TCP</code>协议的连接需要四次”挥手”</p>\n<h3 id=\"三次”握手”\"><a href=\"#三次”握手”\" class=\"headerlink\" title=\"三次”握手”\"></a>三次”握手”</h3><ul>\n<li>1.”Client”端(客户端)发送连接请求报文.</li>\n<li>2.”Server”端(服务端)接受连接后回复ACK(指令正确)报文,并为这次连接分配资源</li>\n<li>3.”Client”端(客户端)收到ACK报文后像”Server”端发送ACK(指令正确报文),并分配资源</li>\n</ul>\n<p>举个栗子:<br>    A(客户端)和B(服务端)进行交易<br>    A:”我要的东西带来了么?” (客户端向服务端请求)<br>    B:”天王盖地府,先对暗号” (服务端给客户端一个回应,表示知道客户端要请求了,并且准备好了请求资源)<br>    A:”小鸡炖蘑菇” (客户端给服务端一个回应,表示自己知道已经连接上服务端,并且知道服务端准备好了,且自己也准备好了)<br>    接头完成,进行可以进行交易(连接成功)</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"AFNetworking-相关\"><a href=\"#AFNetworking-相关\" class=\"headerlink\" title=\"AFNetworking 相关\"></a>AFNetworking 相关</h1><h2 id=\"网络通讯\"><a href=\"#网络通讯\" class=\"headerlink\" title=\"网络通讯\"></a>网络通讯</h2><p>建立一个<code>TCP</code>协议的连接通常需要三次”握手”,断开一个<code>TCP</code>协议的连接需要四次”挥手”</p>\n<h3 id=\"三次”握手”\"><a href=\"#三次”握手”\" class=\"headerlink\" title=\"三次”握手”\"></a>三次”握手”</h3><ul>\n<li>1.”Client”端(客户端)发送连接请求报文.</li>\n<li>2.”Server”端(服务端)接受连接后回复ACK(指令正确)报文,并为这次连接分配资源</li>\n<li>3.”Client”端(客户端)收到ACK报文后像”Server”端发送ACK(指令正确报文),并分配资源</li>\n</ul>\n<p>举个栗子:<br>    A(客户端)和B(服务端)进行交易<br>    A:”我要的东西带来了么?” (客户端向服务端请求)<br>    B:”天王盖地府,先对暗号” (服务端给客户端一个回应,表示知道客户端要请求了,并且准备好了请求资源)<br>    A:”小鸡炖蘑菇” (客户端给服务端一个回应,表示自己知道已经连接上服务端,并且知道服务端准备好了,且自己也准备好了)<br>    接头完成,进行可以进行交易(连接成功)</p>\n"},{"title":"Xcode8报错","date":"2017-03-31T03:02:30.000Z","_content":"\nXcode8 报错resource fork, Finder information, or similar detritus not allowed\n\n## 原因 ##\n\n这是因为Xcode8引进的新的安全机制, Code signing不允许app的bundle里面的文件有未知的文件系统扩展属性\n\n## 解决方法 ##\n在终端中输入 `xattr -lr <path_to_app_bundle>` 可以查看存在未知扩展属性的文件\n\n在终端中输入 `xattr -cr <path_to_app_bundle>` 可以移除所有未知的扩展属性\n\n然后清理Xcode 重新build 工程\n","source":"_posts/Xcode8 报错resource fork, Finder information, or similar detritus not allowed.md","raw":"---\ntitle: Xcode8报错\ndate: 2017-03-31 11:02:30\ntags: iOS\n---\n\nXcode8 报错resource fork, Finder information, or similar detritus not allowed\n\n## 原因 ##\n\n这是因为Xcode8引进的新的安全机制, Code signing不允许app的bundle里面的文件有未知的文件系统扩展属性\n\n## 解决方法 ##\n在终端中输入 `xattr -lr <path_to_app_bundle>` 可以查看存在未知扩展属性的文件\n\n在终端中输入 `xattr -cr <path_to_app_bundle>` 可以移除所有未知的扩展属性\n\n然后清理Xcode 重新build 工程\n","slug":"Xcode8 报错resource fork, Finder information, or similar detritus not allowed","published":1,"updated":"2018-06-10T14:07:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9slb9t000608ozxrtrtwb1","content":"<p>Xcode8 报错resource fork, Finder information, or similar detritus not allowed</p>\n<h2 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h2><p>这是因为Xcode8引进的新的安全机制, Code signing不允许app的bundle里面的文件有未知的文件系统扩展属性</p>\n<h2 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h2><p>在终端中输入 <code>xattr -lr &lt;path_to_app_bundle&gt;</code> 可以查看存在未知扩展属性的文件</p>\n<p>在终端中输入 <code>xattr -cr &lt;path_to_app_bundle&gt;</code> 可以移除所有未知的扩展属性</p>\n<p>然后清理Xcode 重新build 工程</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Xcode8 报错resource fork, Finder information, or similar detritus not allowed</p>\n<h2 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h2><p>这是因为Xcode8引进的新的安全机制, Code signing不允许app的bundle里面的文件有未知的文件系统扩展属性</p>\n<h2 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h2><p>在终端中输入 <code>xattr -lr &lt;path_to_app_bundle&gt;</code> 可以查看存在未知扩展属性的文件</p>\n<p>在终端中输入 <code>xattr -cr &lt;path_to_app_bundle&gt;</code> 可以移除所有未知的扩展属性</p>\n<p>然后清理Xcode 重新build 工程</p>\n"},{"title":"appium测试时候的那些事","date":"2017-01-11T03:10:12.000Z","_content":"\n# 遇到的问题 #\n\n## 1.org.openqa.selenium.WebDriverException: Method has not yet been implemented ##\n\n<!----- more ----->\n\n在使用appium跑java脚本的时候,如果出现异常,提示如上面显示的,说明你的appium安装出现了问题,具体原因是我的appium当时卸载的时候没有完全卸载干净,导致appium无法连接到WebDriverException\n\n解决方法: 卸载appium ,最好再使用清理工具如:cleanMyMac 清理一下残留文件,然后从新安装新的appium ,问题就可以解决,如果还不行,可以新建一个电脑账户,在新的账户中重新搭建appium也可以","source":"_posts/appium测试时候的那些事.md","raw":"---\ntitle: appium测试时候的那些事\ndate: 2017-01-11 11:10:12\ntags: appium\n---\n\n# 遇到的问题 #\n\n## 1.org.openqa.selenium.WebDriverException: Method has not yet been implemented ##\n\n<!----- more ----->\n\n在使用appium跑java脚本的时候,如果出现异常,提示如上面显示的,说明你的appium安装出现了问题,具体原因是我的appium当时卸载的时候没有完全卸载干净,导致appium无法连接到WebDriverException\n\n解决方法: 卸载appium ,最好再使用清理工具如:cleanMyMac 清理一下残留文件,然后从新安装新的appium ,问题就可以解决,如果还不行,可以新建一个电脑账户,在新的账户中重新搭建appium也可以","slug":"appium测试时候的那些事","published":1,"updated":"2018-06-10T14:07:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9slb9u000708ozm9gyo78c","content":"<h1 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h1><h2 id=\"1-org-openqa-selenium-WebDriverException-Method-has-not-yet-been-implemented\"><a href=\"#1-org-openqa-selenium-WebDriverException-Method-has-not-yet-been-implemented\" class=\"headerlink\" title=\"1.org.openqa.selenium.WebDriverException: Method has not yet been implemented\"></a>1.org.openqa.selenium.WebDriverException: Method has not yet been implemented</h2><a id=\"more\"></a>\n<p>在使用appium跑java脚本的时候,如果出现异常,提示如上面显示的,说明你的appium安装出现了问题,具体原因是我的appium当时卸载的时候没有完全卸载干净,导致appium无法连接到WebDriverException</p>\n<p>解决方法: 卸载appium ,最好再使用清理工具如:cleanMyMac 清理一下残留文件,然后从新安装新的appium ,问题就可以解决,如果还不行,可以新建一个电脑账户,在新的账户中重新搭建appium也可以</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h1><h2 id=\"1-org-openqa-selenium-WebDriverException-Method-has-not-yet-been-implemented\"><a href=\"#1-org-openqa-selenium-WebDriverException-Method-has-not-yet-been-implemented\" class=\"headerlink\" title=\"1.org.openqa.selenium.WebDriverException: Method has not yet been implemented\"></a>1.org.openqa.selenium.WebDriverException: Method has not yet been implemented</h2>","more":"<p>在使用appium跑java脚本的时候,如果出现异常,提示如上面显示的,说明你的appium安装出现了问题,具体原因是我的appium当时卸载的时候没有完全卸载干净,导致appium无法连接到WebDriverException</p>\n<p>解决方法: 卸载appium ,最好再使用清理工具如:cleanMyMac 清理一下残留文件,然后从新安装新的appium ,问题就可以解决,如果还不行,可以新建一个电脑账户,在新的账户中重新搭建appium也可以</p>"},{"title":"iOS的CF和OC中间的类型转换","date":"2017-01-11T03:10:12.000Z","_content":"\n# iOS的CF和OC中间的类型转换 #\n\n## Toll-Free bridged ##\n\n`Toll-Free bridged`  是Core Foundation和Foundation之间交换使用数据类型的技术.即同一数据类型既可作为Core Foundation函数的参数,也可以作为接收者向其发送Objective-C消息.\n\n说的简单点,就是OC中的有些类型,通过`Toll-Free bridged` 既可以当做Core Foundation的类型使用(CFxxxx),又可以当做Foundation的类型使用(NSxxxx).\n\n\n<!----- more ----->\n\n\n## Toll-Free bridged原理 ##\n\n每一个能够bridge的ObjC类，都是一个类簇（class cluster）。类簇是一个公开的抽象类，但其核心功能的是在不同的私有子类中实现的，公开类只暴露一致的接口和实现一些辅助的创建方法。而与该ObjC类相对应的Core Foundation类的内存结构，正好与类簇的其中一个私有子类相同。\n\n举个例子，NSString是一个类簇，一个公开的抽象类，但每次创建一个NSString的实例时，实际上我们会获得其中一个私有子类的实例。而NSString的其中一个私有子类实现既为NSCFString，其内存的结构与CFString是相同的，CFString的isa指针就指向NSCFString类，即CFString对象就是一个NSCFString类的实例。\n所以，当NSString的实现刚好是NSCFString的时候，他们两者之间的转换是相当容易而直接的，他们就是同一个类的实例。\n\n当NSString的实现不是NSCFString的时候（比如我们自己subclass了NSString），我们调用CF函数，就需要先检查对象的具体实现。如果发现其不是NSCFString，我们不会调用CF函数的实现来获得结果，而是通过给对象发送与函数功能相对应的ObjC消息（调用相对应的NSString的接口）来获得其结果。\n\n例如CFStringGetLength函数，当收到一个作为参数传递进来的对象时，会先确认该对象到底是不是NSCFString实现。如果是的话，就会直接调用CFStringGetLength函数的实现来获得字符串的长度；如果不是的话，会给对象发送length消息（调用NSString的length接口），来得到字符串的长度。\n\n## Toll-Free bridged的内存管理 ##\n\n在ARC中编译器不知道如何处理这个同时拥有ObjC和CFTypeRef指向的对象,所以你必须为编译器提供额外的信息：将类型显示转换为互换类型；同时可能需明确对象的声明周期。 因此我们需要使用 `__bridge`, `__bridge_retained`, `__bridge_transfer` 修饰符告诉编译器该如何去做。\n\n### __bridge ###\n\n```objectivec\n//objc to cf\n NSString *str = @\"hello\";\n CFStringRef cfStr = (__bridge CFStringRef)str;\n CFRelease(cfStr);//这里不需要release\n```\n编译器会继续负责nsStr的内存管理的事情，不会在bridge的时候retain对象，所以也不需要开发者在CF 一端释放。需要注意的是，当nsStr被释放的时候（比如出了作用域），意味着cfStr指向的对象被释放了，这时如果继续使用cfStr将会引起程序崩溃。\n\n```objectivec\n//cf to objc\n CFStringRef cfStr = CFStringCreateWithCString(kCFAllpacatorDefaule,\"hello\",kCFStringEncodingUTF8);\n NSString *str = (__bridge NSString *)(cfStr);\n CFRelease(cfStr);//这里需要release\n```\n\n bridge的时候编译器不会做任何内存管理的事情，bridge之后，编译器会负责ObjC一端的内存管理的事情。同时，开发者需要负责管理CF 一端的内存管理的事情，需要在bridge之后，负责release对象。\n\n### __bridge_retained ###\n接着上面的例子，Foundation类型对应的Core Foundation类型时，为了防止str被释放，引起我们使用cfStr的时候程序崩溃，可以使用__bridge_retained修饰符。这意味着，在bridge的时候，编译器会retain对象，而由开发者在CF一端负责release。这样，就算str在objc一端被释放，只要开发者不手动去释放cfStr，其指向的对象就不会被真的销毁。但同时，开发者也必须保证和负责对象的释放。\n\n```objectivec\n//objc to cf\n NSString *str = @\"hello\";\n CFStringRef cfStr = (__bridge_retained CFStringRef)str;\n CFRelease(cfStr);//这里不需要release\n```\n\n### __bridge_transfer ###\n当Core Foundation类型转化为Foundation类型时，如果使用__bridge修饰符在cf转objc的时候非常的麻烦，我们既需要一个CFTypeRef的变量，还需要在bridge之后负责释放。这时我们可以使用__bridge_transfer，意味着在bridge的时候，编译器转移了对象的所有权，开发者不再需要负责对象的释放。\n\n```objectivec\n//cf to objc\n CFStringRef cfStr = CFStringCreateWithCString(kCFAllpacatorDefaule,\"hello\",kCFStringEncodingUTF8);\n NSString *str = (__bridge NSString *)(cfStr);\n CFRelease(cfStr);//这里需要release\n```\n\n## 总结 ##\n\n  * `__bridge` :编译器在bridge的时候不要做任何事情\n  * `__bridge_retained` :（ObjC转CF的时候使用）编译器在bridge的时候retain对象，开发者需要在CF一端负责释放对象\n  * `__bridge_transfer` :（CF转ObjC的时候使用）编译器转移CF对象的所有权，开发者不再需要在CF一端负责释放对象\n","source":"_posts/bridged.md","raw":"---\ntitle: iOS的CF和OC中间的类型转换\ndate: 2017-01-11 11:10:12\ntags: iOS\n---\n\n# iOS的CF和OC中间的类型转换 #\n\n## Toll-Free bridged ##\n\n`Toll-Free bridged`  是Core Foundation和Foundation之间交换使用数据类型的技术.即同一数据类型既可作为Core Foundation函数的参数,也可以作为接收者向其发送Objective-C消息.\n\n说的简单点,就是OC中的有些类型,通过`Toll-Free bridged` 既可以当做Core Foundation的类型使用(CFxxxx),又可以当做Foundation的类型使用(NSxxxx).\n\n\n<!----- more ----->\n\n\n## Toll-Free bridged原理 ##\n\n每一个能够bridge的ObjC类，都是一个类簇（class cluster）。类簇是一个公开的抽象类，但其核心功能的是在不同的私有子类中实现的，公开类只暴露一致的接口和实现一些辅助的创建方法。而与该ObjC类相对应的Core Foundation类的内存结构，正好与类簇的其中一个私有子类相同。\n\n举个例子，NSString是一个类簇，一个公开的抽象类，但每次创建一个NSString的实例时，实际上我们会获得其中一个私有子类的实例。而NSString的其中一个私有子类实现既为NSCFString，其内存的结构与CFString是相同的，CFString的isa指针就指向NSCFString类，即CFString对象就是一个NSCFString类的实例。\n所以，当NSString的实现刚好是NSCFString的时候，他们两者之间的转换是相当容易而直接的，他们就是同一个类的实例。\n\n当NSString的实现不是NSCFString的时候（比如我们自己subclass了NSString），我们调用CF函数，就需要先检查对象的具体实现。如果发现其不是NSCFString，我们不会调用CF函数的实现来获得结果，而是通过给对象发送与函数功能相对应的ObjC消息（调用相对应的NSString的接口）来获得其结果。\n\n例如CFStringGetLength函数，当收到一个作为参数传递进来的对象时，会先确认该对象到底是不是NSCFString实现。如果是的话，就会直接调用CFStringGetLength函数的实现来获得字符串的长度；如果不是的话，会给对象发送length消息（调用NSString的length接口），来得到字符串的长度。\n\n## Toll-Free bridged的内存管理 ##\n\n在ARC中编译器不知道如何处理这个同时拥有ObjC和CFTypeRef指向的对象,所以你必须为编译器提供额外的信息：将类型显示转换为互换类型；同时可能需明确对象的声明周期。 因此我们需要使用 `__bridge`, `__bridge_retained`, `__bridge_transfer` 修饰符告诉编译器该如何去做。\n\n### __bridge ###\n\n```objectivec\n//objc to cf\n NSString *str = @\"hello\";\n CFStringRef cfStr = (__bridge CFStringRef)str;\n CFRelease(cfStr);//这里不需要release\n```\n编译器会继续负责nsStr的内存管理的事情，不会在bridge的时候retain对象，所以也不需要开发者在CF 一端释放。需要注意的是，当nsStr被释放的时候（比如出了作用域），意味着cfStr指向的对象被释放了，这时如果继续使用cfStr将会引起程序崩溃。\n\n```objectivec\n//cf to objc\n CFStringRef cfStr = CFStringCreateWithCString(kCFAllpacatorDefaule,\"hello\",kCFStringEncodingUTF8);\n NSString *str = (__bridge NSString *)(cfStr);\n CFRelease(cfStr);//这里需要release\n```\n\n bridge的时候编译器不会做任何内存管理的事情，bridge之后，编译器会负责ObjC一端的内存管理的事情。同时，开发者需要负责管理CF 一端的内存管理的事情，需要在bridge之后，负责release对象。\n\n### __bridge_retained ###\n接着上面的例子，Foundation类型对应的Core Foundation类型时，为了防止str被释放，引起我们使用cfStr的时候程序崩溃，可以使用__bridge_retained修饰符。这意味着，在bridge的时候，编译器会retain对象，而由开发者在CF一端负责release。这样，就算str在objc一端被释放，只要开发者不手动去释放cfStr，其指向的对象就不会被真的销毁。但同时，开发者也必须保证和负责对象的释放。\n\n```objectivec\n//objc to cf\n NSString *str = @\"hello\";\n CFStringRef cfStr = (__bridge_retained CFStringRef)str;\n CFRelease(cfStr);//这里不需要release\n```\n\n### __bridge_transfer ###\n当Core Foundation类型转化为Foundation类型时，如果使用__bridge修饰符在cf转objc的时候非常的麻烦，我们既需要一个CFTypeRef的变量，还需要在bridge之后负责释放。这时我们可以使用__bridge_transfer，意味着在bridge的时候，编译器转移了对象的所有权，开发者不再需要负责对象的释放。\n\n```objectivec\n//cf to objc\n CFStringRef cfStr = CFStringCreateWithCString(kCFAllpacatorDefaule,\"hello\",kCFStringEncodingUTF8);\n NSString *str = (__bridge NSString *)(cfStr);\n CFRelease(cfStr);//这里需要release\n```\n\n## 总结 ##\n\n  * `__bridge` :编译器在bridge的时候不要做任何事情\n  * `__bridge_retained` :（ObjC转CF的时候使用）编译器在bridge的时候retain对象，开发者需要在CF一端负责释放对象\n  * `__bridge_transfer` :（CF转ObjC的时候使用）编译器转移CF对象的所有权，开发者不再需要在CF一端负责释放对象\n","slug":"bridged","published":1,"updated":"2018-09-04T15:05:21.037Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9slb9v000808oz62qqqakg","content":"<h1 id=\"iOS的CF和OC中间的类型转换\"><a href=\"#iOS的CF和OC中间的类型转换\" class=\"headerlink\" title=\"iOS的CF和OC中间的类型转换\"></a>iOS的CF和OC中间的类型转换</h1><h2 id=\"Toll-Free-bridged\"><a href=\"#Toll-Free-bridged\" class=\"headerlink\" title=\"Toll-Free bridged\"></a>Toll-Free bridged</h2><p><code>Toll-Free bridged</code>  是Core Foundation和Foundation之间交换使用数据类型的技术.即同一数据类型既可作为Core Foundation函数的参数,也可以作为接收者向其发送Objective-C消息.</p>\n<p>说的简单点,就是OC中的有些类型,通过<code>Toll-Free bridged</code> 既可以当做Core Foundation的类型使用(CFxxxx),又可以当做Foundation的类型使用(NSxxxx).</p>\n<a id=\"more\"></a>\n<h2 id=\"Toll-Free-bridged原理\"><a href=\"#Toll-Free-bridged原理\" class=\"headerlink\" title=\"Toll-Free bridged原理\"></a>Toll-Free bridged原理</h2><p>每一个能够bridge的ObjC类，都是一个类簇（class cluster）。类簇是一个公开的抽象类，但其核心功能的是在不同的私有子类中实现的，公开类只暴露一致的接口和实现一些辅助的创建方法。而与该ObjC类相对应的Core Foundation类的内存结构，正好与类簇的其中一个私有子类相同。</p>\n<p>举个例子，NSString是一个类簇，一个公开的抽象类，但每次创建一个NSString的实例时，实际上我们会获得其中一个私有子类的实例。而NSString的其中一个私有子类实现既为NSCFString，其内存的结构与CFString是相同的，CFString的isa指针就指向NSCFString类，即CFString对象就是一个NSCFString类的实例。<br>所以，当NSString的实现刚好是NSCFString的时候，他们两者之间的转换是相当容易而直接的，他们就是同一个类的实例。</p>\n<p>当NSString的实现不是NSCFString的时候（比如我们自己subclass了NSString），我们调用CF函数，就需要先检查对象的具体实现。如果发现其不是NSCFString，我们不会调用CF函数的实现来获得结果，而是通过给对象发送与函数功能相对应的ObjC消息（调用相对应的NSString的接口）来获得其结果。</p>\n<p>例如CFStringGetLength函数，当收到一个作为参数传递进来的对象时，会先确认该对象到底是不是NSCFString实现。如果是的话，就会直接调用CFStringGetLength函数的实现来获得字符串的长度；如果不是的话，会给对象发送length消息（调用NSString的length接口），来得到字符串的长度。</p>\n<h2 id=\"Toll-Free-bridged的内存管理\"><a href=\"#Toll-Free-bridged的内存管理\" class=\"headerlink\" title=\"Toll-Free bridged的内存管理\"></a>Toll-Free bridged的内存管理</h2><p>在ARC中编译器不知道如何处理这个同时拥有ObjC和CFTypeRef指向的对象,所以你必须为编译器提供额外的信息：将类型显示转换为互换类型；同时可能需明确对象的声明周期。 因此我们需要使用 <code>__bridge</code>, <code>__bridge_retained</code>, <code>__bridge_transfer</code> 修饰符告诉编译器该如何去做。</p>\n<h3 id=\"bridge\"><a href=\"#bridge\" class=\"headerlink\" title=\"__bridge\"></a>__bridge</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//objc to cf</span></span><br><span class=\"line\"> <span class=\"built_in\">NSString</span> *str = <span class=\"string\">@\"hello\"</span>;</span><br><span class=\"line\"> <span class=\"built_in\">CFStringRef</span> cfStr = (__bridge <span class=\"built_in\">CFStringRef</span>)str;</span><br><span class=\"line\"> <span class=\"built_in\">CFRelease</span>(cfStr);<span class=\"comment\">//这里不需要release</span></span><br></pre></td></tr></table></figure>\n<p>编译器会继续负责nsStr的内存管理的事情，不会在bridge的时候retain对象，所以也不需要开发者在CF 一端释放。需要注意的是，当nsStr被释放的时候（比如出了作用域），意味着cfStr指向的对象被释放了，这时如果继续使用cfStr将会引起程序崩溃。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//cf to objc</span></span><br><span class=\"line\"> <span class=\"built_in\">CFStringRef</span> cfStr = <span class=\"built_in\">CFStringCreateWithCString</span>(kCFAllpacatorDefaule,<span class=\"string\">\"hello\"</span>,kCFStringEncodingUTF8);</span><br><span class=\"line\"> <span class=\"built_in\">NSString</span> *str = (__bridge <span class=\"built_in\">NSString</span> *)(cfStr);</span><br><span class=\"line\"> <span class=\"built_in\">CFRelease</span>(cfStr);<span class=\"comment\">//这里需要release</span></span><br></pre></td></tr></table></figure>\n<p> bridge的时候编译器不会做任何内存管理的事情，bridge之后，编译器会负责ObjC一端的内存管理的事情。同时，开发者需要负责管理CF 一端的内存管理的事情，需要在bridge之后，负责release对象。</p>\n<h3 id=\"bridge-retained\"><a href=\"#bridge-retained\" class=\"headerlink\" title=\"__bridge_retained\"></a>__bridge_retained</h3><p>接着上面的例子，Foundation类型对应的Core Foundation类型时，为了防止str被释放，引起我们使用cfStr的时候程序崩溃，可以使用__bridge_retained修饰符。这意味着，在bridge的时候，编译器会retain对象，而由开发者在CF一端负责release。这样，就算str在objc一端被释放，只要开发者不手动去释放cfStr，其指向的对象就不会被真的销毁。但同时，开发者也必须保证和负责对象的释放。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//objc to cf</span></span><br><span class=\"line\"> <span class=\"built_in\">NSString</span> *str = <span class=\"string\">@\"hello\"</span>;</span><br><span class=\"line\"> <span class=\"built_in\">CFStringRef</span> cfStr = (__bridge_retained <span class=\"built_in\">CFStringRef</span>)str;</span><br><span class=\"line\"> <span class=\"built_in\">CFRelease</span>(cfStr);<span class=\"comment\">//这里不需要release</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"bridge-transfer\"><a href=\"#bridge-transfer\" class=\"headerlink\" title=\"__bridge_transfer\"></a>__bridge_transfer</h3><p>当Core Foundation类型转化为Foundation类型时，如果使用<strong>bridge修饰符在cf转objc的时候非常的麻烦，我们既需要一个CFTypeRef的变量，还需要在bridge之后负责释放。这时我们可以使用</strong>bridge_transfer，意味着在bridge的时候，编译器转移了对象的所有权，开发者不再需要负责对象的释放。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//cf to objc</span></span><br><span class=\"line\"> <span class=\"built_in\">CFStringRef</span> cfStr = <span class=\"built_in\">CFStringCreateWithCString</span>(kCFAllpacatorDefaule,<span class=\"string\">\"hello\"</span>,kCFStringEncodingUTF8);</span><br><span class=\"line\"> <span class=\"built_in\">NSString</span> *str = (__bridge <span class=\"built_in\">NSString</span> *)(cfStr);</span><br><span class=\"line\"> <span class=\"built_in\">CFRelease</span>(cfStr);<span class=\"comment\">//这里需要release</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li><code>__bridge</code> :编译器在bridge的时候不要做任何事情</li>\n<li><code>__bridge_retained</code> :（ObjC转CF的时候使用）编译器在bridge的时候retain对象，开发者需要在CF一端负责释放对象</li>\n<li><code>__bridge_transfer</code> :（CF转ObjC的时候使用）编译器转移CF对象的所有权，开发者不再需要在CF一端负责释放对象</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"iOS的CF和OC中间的类型转换\"><a href=\"#iOS的CF和OC中间的类型转换\" class=\"headerlink\" title=\"iOS的CF和OC中间的类型转换\"></a>iOS的CF和OC中间的类型转换</h1><h2 id=\"Toll-Free-bridged\"><a href=\"#Toll-Free-bridged\" class=\"headerlink\" title=\"Toll-Free bridged\"></a>Toll-Free bridged</h2><p><code>Toll-Free bridged</code>  是Core Foundation和Foundation之间交换使用数据类型的技术.即同一数据类型既可作为Core Foundation函数的参数,也可以作为接收者向其发送Objective-C消息.</p>\n<p>说的简单点,就是OC中的有些类型,通过<code>Toll-Free bridged</code> 既可以当做Core Foundation的类型使用(CFxxxx),又可以当做Foundation的类型使用(NSxxxx).</p>","more":"<h2 id=\"Toll-Free-bridged原理\"><a href=\"#Toll-Free-bridged原理\" class=\"headerlink\" title=\"Toll-Free bridged原理\"></a>Toll-Free bridged原理</h2><p>每一个能够bridge的ObjC类，都是一个类簇（class cluster）。类簇是一个公开的抽象类，但其核心功能的是在不同的私有子类中实现的，公开类只暴露一致的接口和实现一些辅助的创建方法。而与该ObjC类相对应的Core Foundation类的内存结构，正好与类簇的其中一个私有子类相同。</p>\n<p>举个例子，NSString是一个类簇，一个公开的抽象类，但每次创建一个NSString的实例时，实际上我们会获得其中一个私有子类的实例。而NSString的其中一个私有子类实现既为NSCFString，其内存的结构与CFString是相同的，CFString的isa指针就指向NSCFString类，即CFString对象就是一个NSCFString类的实例。<br>所以，当NSString的实现刚好是NSCFString的时候，他们两者之间的转换是相当容易而直接的，他们就是同一个类的实例。</p>\n<p>当NSString的实现不是NSCFString的时候（比如我们自己subclass了NSString），我们调用CF函数，就需要先检查对象的具体实现。如果发现其不是NSCFString，我们不会调用CF函数的实现来获得结果，而是通过给对象发送与函数功能相对应的ObjC消息（调用相对应的NSString的接口）来获得其结果。</p>\n<p>例如CFStringGetLength函数，当收到一个作为参数传递进来的对象时，会先确认该对象到底是不是NSCFString实现。如果是的话，就会直接调用CFStringGetLength函数的实现来获得字符串的长度；如果不是的话，会给对象发送length消息（调用NSString的length接口），来得到字符串的长度。</p>\n<h2 id=\"Toll-Free-bridged的内存管理\"><a href=\"#Toll-Free-bridged的内存管理\" class=\"headerlink\" title=\"Toll-Free bridged的内存管理\"></a>Toll-Free bridged的内存管理</h2><p>在ARC中编译器不知道如何处理这个同时拥有ObjC和CFTypeRef指向的对象,所以你必须为编译器提供额外的信息：将类型显示转换为互换类型；同时可能需明确对象的声明周期。 因此我们需要使用 <code>__bridge</code>, <code>__bridge_retained</code>, <code>__bridge_transfer</code> 修饰符告诉编译器该如何去做。</p>\n<h3 id=\"bridge\"><a href=\"#bridge\" class=\"headerlink\" title=\"__bridge\"></a>__bridge</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//objc to cf</span></span><br><span class=\"line\"> <span class=\"built_in\">NSString</span> *str = <span class=\"string\">@\"hello\"</span>;</span><br><span class=\"line\"> <span class=\"built_in\">CFStringRef</span> cfStr = (__bridge <span class=\"built_in\">CFStringRef</span>)str;</span><br><span class=\"line\"> <span class=\"built_in\">CFRelease</span>(cfStr);<span class=\"comment\">//这里不需要release</span></span><br></pre></td></tr></table></figure>\n<p>编译器会继续负责nsStr的内存管理的事情，不会在bridge的时候retain对象，所以也不需要开发者在CF 一端释放。需要注意的是，当nsStr被释放的时候（比如出了作用域），意味着cfStr指向的对象被释放了，这时如果继续使用cfStr将会引起程序崩溃。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//cf to objc</span></span><br><span class=\"line\"> <span class=\"built_in\">CFStringRef</span> cfStr = <span class=\"built_in\">CFStringCreateWithCString</span>(kCFAllpacatorDefaule,<span class=\"string\">\"hello\"</span>,kCFStringEncodingUTF8);</span><br><span class=\"line\"> <span class=\"built_in\">NSString</span> *str = (__bridge <span class=\"built_in\">NSString</span> *)(cfStr);</span><br><span class=\"line\"> <span class=\"built_in\">CFRelease</span>(cfStr);<span class=\"comment\">//这里需要release</span></span><br></pre></td></tr></table></figure>\n<p> bridge的时候编译器不会做任何内存管理的事情，bridge之后，编译器会负责ObjC一端的内存管理的事情。同时，开发者需要负责管理CF 一端的内存管理的事情，需要在bridge之后，负责release对象。</p>\n<h3 id=\"bridge-retained\"><a href=\"#bridge-retained\" class=\"headerlink\" title=\"__bridge_retained\"></a>__bridge_retained</h3><p>接着上面的例子，Foundation类型对应的Core Foundation类型时，为了防止str被释放，引起我们使用cfStr的时候程序崩溃，可以使用__bridge_retained修饰符。这意味着，在bridge的时候，编译器会retain对象，而由开发者在CF一端负责release。这样，就算str在objc一端被释放，只要开发者不手动去释放cfStr，其指向的对象就不会被真的销毁。但同时，开发者也必须保证和负责对象的释放。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//objc to cf</span></span><br><span class=\"line\"> <span class=\"built_in\">NSString</span> *str = <span class=\"string\">@\"hello\"</span>;</span><br><span class=\"line\"> <span class=\"built_in\">CFStringRef</span> cfStr = (__bridge_retained <span class=\"built_in\">CFStringRef</span>)str;</span><br><span class=\"line\"> <span class=\"built_in\">CFRelease</span>(cfStr);<span class=\"comment\">//这里不需要release</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"bridge-transfer\"><a href=\"#bridge-transfer\" class=\"headerlink\" title=\"__bridge_transfer\"></a>__bridge_transfer</h3><p>当Core Foundation类型转化为Foundation类型时，如果使用<strong>bridge修饰符在cf转objc的时候非常的麻烦，我们既需要一个CFTypeRef的变量，还需要在bridge之后负责释放。这时我们可以使用</strong>bridge_transfer，意味着在bridge的时候，编译器转移了对象的所有权，开发者不再需要负责对象的释放。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//cf to objc</span></span><br><span class=\"line\"> <span class=\"built_in\">CFStringRef</span> cfStr = <span class=\"built_in\">CFStringCreateWithCString</span>(kCFAllpacatorDefaule,<span class=\"string\">\"hello\"</span>,kCFStringEncodingUTF8);</span><br><span class=\"line\"> <span class=\"built_in\">NSString</span> *str = (__bridge <span class=\"built_in\">NSString</span> *)(cfStr);</span><br><span class=\"line\"> <span class=\"built_in\">CFRelease</span>(cfStr);<span class=\"comment\">//这里需要release</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li><code>__bridge</code> :编译器在bridge的时候不要做任何事情</li>\n<li><code>__bridge_retained</code> :（ObjC转CF的时候使用）编译器在bridge的时候retain对象，开发者需要在CF一端负责释放对象</li>\n<li><code>__bridge_transfer</code> :（CF转ObjC的时候使用）编译器转移CF对象的所有权，开发者不再需要在CF一端负责释放对象</li>\n</ul>"},{"title":"centOS Linux系统命令--VPS那些事","date":"2016-12-11T03:02:30.000Z","_content":"\n## 升级系统 ##\n\n```\nyum update -y\n```\n\n## 安装wget ##\nwget是一个从网络上自动下载文件的自由工具，支持通过HTTP、HTTPS、FTP三个最常见的TCP/IP协议下载，并可以使用HTTP代理。wget名称的由来是“World Wide Web”与“get”的结合\n\n```\nyum -y install wget\n```\n\n## 查看当前内核版本 ##\n```\nuname -r\n```\n\n<!----- more ----->\n\n## 修改内核 ##\n```\nrpm -ivh http://gongju.wn789.com/neihei/kernel-firmware-2.6.32-504.3.3.el6.noarch.rpm\n```\n\n```\nrpm -ivh http://gongju.wn789.com/neihei/kernel-2.6.32-504.3.3.el6.x86_64.rpm --force\n```\n\n## 查看内核 ##\n```\nrpm -qa | grep kernel\n```\n\n## 安装锐速破解版 ##\n```\nwget -N --no-check-certificate https://github.com/91yun/serverspeeder/raw/master/serverspeeder.sh && bash serverspeeder.sh\n```\n\n## 锐速卸载 ##\n```\nchattr -i /serverspeeder/etc/apx* && /serverspeeder/bin/serverSpeeder.sh uninstall -f\n```\n\n## 查看锐速状态 ##\n```\nservice serverSpeeder status\n```\n\n## 锐速相关 ##\n```\n service serverSpeeder start | stop | restart\n```\n\n## 搭建shadowsocks ##\n\n1. 安装\n\n安装pip\n```\nyum install python-setuptools && easy_install pip\n```\n\n安装shadowsocks\n```\npip install shadowsocks\n```\n\n2. 配置\n\n创建一个文件在```/etc/shadowsocks.json```\n```\ncd /etc\n\nvi shadowsocks.json\n```\n\n在json文件中写入如下信息\n\n```\n{\n        \"server\":\"x.x.x.x\",            #服务器IP地址\n        \"server_port\":8388,                 #服务监听端口\n        \"local_port\":1080,                  #本地连接端口\n        \"password\":\"barfoo\",               #加密传输使用到的密码\n        \"timeout\":600,                      #连接超时时间\n        \"method\":\"aes-256-cfb\"            #加密算法\n}\n```\n\n3. 启动、停止\n\n```\nssserver -c /etc/shadowsocks.json -d start | stop\n```\n\n4. 配置定时任务\n\n在vps的内存比较小的时候，shadowsocks容易被系统给kill掉，这时，我们就要有个定时任务去查看shadowsocks的服务状态\n\n首先，创建一个查看服务脚本\n\n```\n#! /bin/sh\n\nproc_name=\"shadowsocks.json\"\n\nnumber=`ps -ef | grep $proc_name | grep -v grep | wc -l`\n\nif [ $number -eq 0 ];then\n        ssserver -c /etc/shadowsocks.json -d start\nelse\n        ssserver -c /etc/shadowsocks.json -d restart\nfi\n```\n\n给脚本添加运行权限\n\n```\nchmod 777 xxxx.sh\n```\n\n将脚本加入定时任务中\n\n```\ncrontab -e  //打开定时任务配置\n```\n\n加入上面的脚本\n\n```\n*/1 * * * * ./xxx.sh  //注意脚本路径\n\n```\n\n启动定时任务\n\n```\nservice crond start\n```\n\n\n\n## 安装使用Apache ##\n\n在Linux中Apache的名字叫 ```httpd```\n\n查看服务器版本\n```\napachectl -v    \n```\n\n安装Apache\n```\nyum install httpd\n```\n\n打开Apache\n```\n/etc/init.d/httpd start\n或者\nhttpd -k start | stop | restart\n```\n\nApache的配置文件路径\n```\n/etc/httpd/conf/httpd.conf\n```\n\n## 安装Mysql ##\n\n```\nyum list installed | grep mysql#查看是否已经安装\nyum install mysql-server#安装服务端\nyum install mysql-devel#这个应该是组件，不知道有什么用\nyum install mysql#安装客户端\n\nservice mysqld start#启动\nservice mysqld stop#停止\nservice mysqld restart#重启\nmysqladmin -u root password 123456#设置密码\nmysql -u root -p #登录\n```\n","source":"_posts/centOS系统命令.md","raw":"---\ntitle: centOS Linux系统命令--VPS那些事\ndate: 2016-12-11 11:02:30\ntags: Linux\n---\n\n## 升级系统 ##\n\n```\nyum update -y\n```\n\n## 安装wget ##\nwget是一个从网络上自动下载文件的自由工具，支持通过HTTP、HTTPS、FTP三个最常见的TCP/IP协议下载，并可以使用HTTP代理。wget名称的由来是“World Wide Web”与“get”的结合\n\n```\nyum -y install wget\n```\n\n## 查看当前内核版本 ##\n```\nuname -r\n```\n\n<!----- more ----->\n\n## 修改内核 ##\n```\nrpm -ivh http://gongju.wn789.com/neihei/kernel-firmware-2.6.32-504.3.3.el6.noarch.rpm\n```\n\n```\nrpm -ivh http://gongju.wn789.com/neihei/kernel-2.6.32-504.3.3.el6.x86_64.rpm --force\n```\n\n## 查看内核 ##\n```\nrpm -qa | grep kernel\n```\n\n## 安装锐速破解版 ##\n```\nwget -N --no-check-certificate https://github.com/91yun/serverspeeder/raw/master/serverspeeder.sh && bash serverspeeder.sh\n```\n\n## 锐速卸载 ##\n```\nchattr -i /serverspeeder/etc/apx* && /serverspeeder/bin/serverSpeeder.sh uninstall -f\n```\n\n## 查看锐速状态 ##\n```\nservice serverSpeeder status\n```\n\n## 锐速相关 ##\n```\n service serverSpeeder start | stop | restart\n```\n\n## 搭建shadowsocks ##\n\n1. 安装\n\n安装pip\n```\nyum install python-setuptools && easy_install pip\n```\n\n安装shadowsocks\n```\npip install shadowsocks\n```\n\n2. 配置\n\n创建一个文件在```/etc/shadowsocks.json```\n```\ncd /etc\n\nvi shadowsocks.json\n```\n\n在json文件中写入如下信息\n\n```\n{\n        \"server\":\"x.x.x.x\",            #服务器IP地址\n        \"server_port\":8388,                 #服务监听端口\n        \"local_port\":1080,                  #本地连接端口\n        \"password\":\"barfoo\",               #加密传输使用到的密码\n        \"timeout\":600,                      #连接超时时间\n        \"method\":\"aes-256-cfb\"            #加密算法\n}\n```\n\n3. 启动、停止\n\n```\nssserver -c /etc/shadowsocks.json -d start | stop\n```\n\n4. 配置定时任务\n\n在vps的内存比较小的时候，shadowsocks容易被系统给kill掉，这时，我们就要有个定时任务去查看shadowsocks的服务状态\n\n首先，创建一个查看服务脚本\n\n```\n#! /bin/sh\n\nproc_name=\"shadowsocks.json\"\n\nnumber=`ps -ef | grep $proc_name | grep -v grep | wc -l`\n\nif [ $number -eq 0 ];then\n        ssserver -c /etc/shadowsocks.json -d start\nelse\n        ssserver -c /etc/shadowsocks.json -d restart\nfi\n```\n\n给脚本添加运行权限\n\n```\nchmod 777 xxxx.sh\n```\n\n将脚本加入定时任务中\n\n```\ncrontab -e  //打开定时任务配置\n```\n\n加入上面的脚本\n\n```\n*/1 * * * * ./xxx.sh  //注意脚本路径\n\n```\n\n启动定时任务\n\n```\nservice crond start\n```\n\n\n\n## 安装使用Apache ##\n\n在Linux中Apache的名字叫 ```httpd```\n\n查看服务器版本\n```\napachectl -v    \n```\n\n安装Apache\n```\nyum install httpd\n```\n\n打开Apache\n```\n/etc/init.d/httpd start\n或者\nhttpd -k start | stop | restart\n```\n\nApache的配置文件路径\n```\n/etc/httpd/conf/httpd.conf\n```\n\n## 安装Mysql ##\n\n```\nyum list installed | grep mysql#查看是否已经安装\nyum install mysql-server#安装服务端\nyum install mysql-devel#这个应该是组件，不知道有什么用\nyum install mysql#安装客户端\n\nservice mysqld start#启动\nservice mysqld stop#停止\nservice mysqld restart#重启\nmysqladmin -u root password 123456#设置密码\nmysql -u root -p #登录\n```\n","slug":"centOS系统命令","published":1,"updated":"2018-12-03T14:55:12.064Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9slb9x000b08oz37skiw9p","content":"<h2 id=\"升级系统\"><a href=\"#升级系统\" class=\"headerlink\" title=\"升级系统\"></a>升级系统</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum update -y</span><br></pre></td></tr></table></figure>\n<h2 id=\"安装wget\"><a href=\"#安装wget\" class=\"headerlink\" title=\"安装wget\"></a>安装wget</h2><p>wget是一个从网络上自动下载文件的自由工具，支持通过HTTP、HTTPS、FTP三个最常见的TCP/IP协议下载，并可以使用HTTP代理。wget名称的由来是“World Wide Web”与“get”的结合</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum -y install wget</span><br></pre></td></tr></table></figure>\n<h2 id=\"查看当前内核版本\"><a href=\"#查看当前内核版本\" class=\"headerlink\" title=\"查看当前内核版本\"></a>查看当前内核版本</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uname -r</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h2 id=\"修改内核\"><a href=\"#修改内核\" class=\"headerlink\" title=\"修改内核\"></a>修改内核</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpm -ivh http://gongju.wn789.com/neihei/kernel-firmware-2.6.32-504.3.3.el6.noarch.rpm</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpm -ivh http://gongju.wn789.com/neihei/kernel-2.6.32-504.3.3.el6.x86_64.rpm --force</span><br></pre></td></tr></table></figure>\n<h2 id=\"查看内核\"><a href=\"#查看内核\" class=\"headerlink\" title=\"查看内核\"></a>查看内核</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpm -qa | grep kernel</span><br></pre></td></tr></table></figure>\n<h2 id=\"安装锐速破解版\"><a href=\"#安装锐速破解版\" class=\"headerlink\" title=\"安装锐速破解版\"></a>安装锐速破解版</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget -N --no-check-certificate https://github.com/91yun/serverspeeder/raw/master/serverspeeder.sh &amp;&amp; bash serverspeeder.sh</span><br></pre></td></tr></table></figure>\n<h2 id=\"锐速卸载\"><a href=\"#锐速卸载\" class=\"headerlink\" title=\"锐速卸载\"></a>锐速卸载</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chattr -i /serverspeeder/etc/apx* &amp;&amp; /serverspeeder/bin/serverSpeeder.sh uninstall -f</span><br></pre></td></tr></table></figure>\n<h2 id=\"查看锐速状态\"><a href=\"#查看锐速状态\" class=\"headerlink\" title=\"查看锐速状态\"></a>查看锐速状态</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service serverSpeeder status</span><br></pre></td></tr></table></figure>\n<h2 id=\"锐速相关\"><a href=\"#锐速相关\" class=\"headerlink\" title=\"锐速相关\"></a>锐速相关</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service serverSpeeder start | stop | restart</span><br></pre></td></tr></table></figure>\n<h2 id=\"搭建shadowsocks\"><a href=\"#搭建shadowsocks\" class=\"headerlink\" title=\"搭建shadowsocks\"></a>搭建shadowsocks</h2><ol>\n<li>安装</li>\n</ol>\n<p>安装pip<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install python-setuptools &amp;&amp; easy_install pip</span><br></pre></td></tr></table></figure></p>\n<p>安装shadowsocks<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install shadowsocks</span><br></pre></td></tr></table></figure></p>\n<ol start=\"2\">\n<li>配置</li>\n</ol>\n<p>创建一个文件在<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">```</span><br><span class=\"line\">cd /etc</span><br><span class=\"line\"></span><br><span class=\"line\">vi shadowsocks.json</span><br></pre></td></tr></table></figure></p>\n<p>在json文件中写入如下信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">        &quot;server&quot;:&quot;x.x.x.x&quot;,            #服务器IP地址</span><br><span class=\"line\">        &quot;server_port&quot;:8388,                 #服务监听端口</span><br><span class=\"line\">        &quot;local_port&quot;:1080,                  #本地连接端口</span><br><span class=\"line\">        &quot;password&quot;:&quot;barfoo&quot;,               #加密传输使用到的密码</span><br><span class=\"line\">        &quot;timeout&quot;:600,                      #连接超时时间</span><br><span class=\"line\">        &quot;method&quot;:&quot;aes-256-cfb&quot;            #加密算法</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>启动、停止</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssserver -c /etc/shadowsocks.json -d start | stop</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>配置定时任务</li>\n</ol>\n<p>在vps的内存比较小的时候，shadowsocks容易被系统给kill掉，这时，我们就要有个定时任务去查看shadowsocks的服务状态</p>\n<p>首先，创建一个查看服务脚本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#! /bin/sh</span><br><span class=\"line\"></span><br><span class=\"line\">proc_name=&quot;shadowsocks.json&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">number=`ps -ef | grep $proc_name | grep -v grep | wc -l`</span><br><span class=\"line\"></span><br><span class=\"line\">if [ $number -eq 0 ];then</span><br><span class=\"line\">        ssserver -c /etc/shadowsocks.json -d start</span><br><span class=\"line\">else</span><br><span class=\"line\">        ssserver -c /etc/shadowsocks.json -d restart</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n<p>给脚本添加运行权限</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod 777 xxxx.sh</span><br></pre></td></tr></table></figure>\n<p>将脚本加入定时任务中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">crontab -e  //打开定时任务配置</span><br></pre></td></tr></table></figure>\n<p>加入上面的脚本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*/1 * * * * ./xxx.sh  //注意脚本路径</span><br></pre></td></tr></table></figure>\n<p>启动定时任务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service crond start</span><br></pre></td></tr></table></figure>\n<h2 id=\"安装使用Apache\"><a href=\"#安装使用Apache\" class=\"headerlink\" title=\"安装使用Apache\"></a>安装使用Apache</h2><p>在Linux中Apache的名字叫 <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">查看服务器版本</span><br></pre></td></tr></table></figure></p>\n<p>apachectl -v<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">安装Apache</span><br></pre></td></tr></table></figure></p>\n<p>yum install httpd<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">打开Apache</span><br></pre></td></tr></table></figure></p>\n<p>/etc/init.d/httpd start<br>或者<br>httpd -k start | stop | restart<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Apache的配置文件路径</span><br></pre></td></tr></table></figure></p>\n<p>/etc/httpd/conf/httpd.conf<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## 安装Mysql ##</span><br></pre></td></tr></table></figure></p>\n<p>yum list installed | grep mysql#查看是否已经安装<br>yum install mysql-server#安装服务端<br>yum install mysql-devel#这个应该是组件，不知道有什么用<br>yum install mysql#安装客户端</p>\n<p>service mysqld start#启动<br>service mysqld stop#停止<br>service mysqld restart#重启<br>mysqladmin -u root password 123456#设置密码<br>mysql -u root -p #登录<br><code>`</code></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"升级系统\"><a href=\"#升级系统\" class=\"headerlink\" title=\"升级系统\"></a>升级系统</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum update -y</span><br></pre></td></tr></table></figure>\n<h2 id=\"安装wget\"><a href=\"#安装wget\" class=\"headerlink\" title=\"安装wget\"></a>安装wget</h2><p>wget是一个从网络上自动下载文件的自由工具，支持通过HTTP、HTTPS、FTP三个最常见的TCP/IP协议下载，并可以使用HTTP代理。wget名称的由来是“World Wide Web”与“get”的结合</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum -y install wget</span><br></pre></td></tr></table></figure>\n<h2 id=\"查看当前内核版本\"><a href=\"#查看当前内核版本\" class=\"headerlink\" title=\"查看当前内核版本\"></a>查看当前内核版本</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uname -r</span><br></pre></td></tr></table></figure>","more":"<h2 id=\"修改内核\"><a href=\"#修改内核\" class=\"headerlink\" title=\"修改内核\"></a>修改内核</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpm -ivh http://gongju.wn789.com/neihei/kernel-firmware-2.6.32-504.3.3.el6.noarch.rpm</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpm -ivh http://gongju.wn789.com/neihei/kernel-2.6.32-504.3.3.el6.x86_64.rpm --force</span><br></pre></td></tr></table></figure>\n<h2 id=\"查看内核\"><a href=\"#查看内核\" class=\"headerlink\" title=\"查看内核\"></a>查看内核</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpm -qa | grep kernel</span><br></pre></td></tr></table></figure>\n<h2 id=\"安装锐速破解版\"><a href=\"#安装锐速破解版\" class=\"headerlink\" title=\"安装锐速破解版\"></a>安装锐速破解版</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget -N --no-check-certificate https://github.com/91yun/serverspeeder/raw/master/serverspeeder.sh &amp;&amp; bash serverspeeder.sh</span><br></pre></td></tr></table></figure>\n<h2 id=\"锐速卸载\"><a href=\"#锐速卸载\" class=\"headerlink\" title=\"锐速卸载\"></a>锐速卸载</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chattr -i /serverspeeder/etc/apx* &amp;&amp; /serverspeeder/bin/serverSpeeder.sh uninstall -f</span><br></pre></td></tr></table></figure>\n<h2 id=\"查看锐速状态\"><a href=\"#查看锐速状态\" class=\"headerlink\" title=\"查看锐速状态\"></a>查看锐速状态</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service serverSpeeder status</span><br></pre></td></tr></table></figure>\n<h2 id=\"锐速相关\"><a href=\"#锐速相关\" class=\"headerlink\" title=\"锐速相关\"></a>锐速相关</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service serverSpeeder start | stop | restart</span><br></pre></td></tr></table></figure>\n<h2 id=\"搭建shadowsocks\"><a href=\"#搭建shadowsocks\" class=\"headerlink\" title=\"搭建shadowsocks\"></a>搭建shadowsocks</h2><ol>\n<li>安装</li>\n</ol>\n<p>安装pip<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install python-setuptools &amp;&amp; easy_install pip</span><br></pre></td></tr></table></figure></p>\n<p>安装shadowsocks<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install shadowsocks</span><br></pre></td></tr></table></figure></p>\n<ol start=\"2\">\n<li>配置</li>\n</ol>\n<p>创建一个文件在<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">```</span><br><span class=\"line\">cd /etc</span><br><span class=\"line\"></span><br><span class=\"line\">vi shadowsocks.json</span><br></pre></td></tr></table></figure></p>\n<p>在json文件中写入如下信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">        &quot;server&quot;:&quot;x.x.x.x&quot;,            #服务器IP地址</span><br><span class=\"line\">        &quot;server_port&quot;:8388,                 #服务监听端口</span><br><span class=\"line\">        &quot;local_port&quot;:1080,                  #本地连接端口</span><br><span class=\"line\">        &quot;password&quot;:&quot;barfoo&quot;,               #加密传输使用到的密码</span><br><span class=\"line\">        &quot;timeout&quot;:600,                      #连接超时时间</span><br><span class=\"line\">        &quot;method&quot;:&quot;aes-256-cfb&quot;            #加密算法</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>启动、停止</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssserver -c /etc/shadowsocks.json -d start | stop</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>配置定时任务</li>\n</ol>\n<p>在vps的内存比较小的时候，shadowsocks容易被系统给kill掉，这时，我们就要有个定时任务去查看shadowsocks的服务状态</p>\n<p>首先，创建一个查看服务脚本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#! /bin/sh</span><br><span class=\"line\"></span><br><span class=\"line\">proc_name=&quot;shadowsocks.json&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">number=`ps -ef | grep $proc_name | grep -v grep | wc -l`</span><br><span class=\"line\"></span><br><span class=\"line\">if [ $number -eq 0 ];then</span><br><span class=\"line\">        ssserver -c /etc/shadowsocks.json -d start</span><br><span class=\"line\">else</span><br><span class=\"line\">        ssserver -c /etc/shadowsocks.json -d restart</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n<p>给脚本添加运行权限</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod 777 xxxx.sh</span><br></pre></td></tr></table></figure>\n<p>将脚本加入定时任务中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">crontab -e  //打开定时任务配置</span><br></pre></td></tr></table></figure>\n<p>加入上面的脚本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*/1 * * * * ./xxx.sh  //注意脚本路径</span><br></pre></td></tr></table></figure>\n<p>启动定时任务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service crond start</span><br></pre></td></tr></table></figure>\n<h2 id=\"安装使用Apache\"><a href=\"#安装使用Apache\" class=\"headerlink\" title=\"安装使用Apache\"></a>安装使用Apache</h2><p>在Linux中Apache的名字叫 <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">查看服务器版本</span><br></pre></td></tr></table></figure></p>\n<p>apachectl -v<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">安装Apache</span><br></pre></td></tr></table></figure></p>\n<p>yum install httpd<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">打开Apache</span><br></pre></td></tr></table></figure></p>\n<p>/etc/init.d/httpd start<br>或者<br>httpd -k start | stop | restart<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Apache的配置文件路径</span><br></pre></td></tr></table></figure></p>\n<p>/etc/httpd/conf/httpd.conf<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## 安装Mysql ##</span><br></pre></td></tr></table></figure></p>\n<p>yum list installed | grep mysql#查看是否已经安装<br>yum install mysql-server#安装服务端<br>yum install mysql-devel#这个应该是组件，不知道有什么用<br>yum install mysql#安装客户端</p>\n<p>service mysqld start#启动<br>service mysqld stop#停止<br>service mysqld restart#重启<br>mysqladmin -u root password 123456#设置密码<br>mysql -u root -p #登录<br><code>`</code></p>"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2018-06-10T14:07:06.000Z","updated":"2018-06-10T14:07:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9slb9z000d08oztpafs23g","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"my first blog","date":"2017-01-11T03:02:30.000Z","_content":"\n这就是传说中的第一个blog\n\n\n<!------ 查看全文 ------>\n\n\n#超级偶像\n\n<embed src=\"http://www.xiami.com/widget/52304397_1773753998/singlePlayer.swf\" type=\"application/x-shockwave-flash\" width=\"257\" height=\"33\" wmode=\"transparent\"></embed>\n","source":"_posts/my-first-blog.md","raw":"---\ntitle: my first blog\ndate: 2017-01-11 11:02:30\ntags: hello\n---\n\n这就是传说中的第一个blog\n\n\n<!------ 查看全文 ------>\n\n\n#超级偶像\n\n<embed src=\"http://www.xiami.com/widget/52304397_1773753998/singlePlayer.swf\" type=\"application/x-shockwave-flash\" width=\"257\" height=\"33\" wmode=\"transparent\"></embed>\n","slug":"my-first-blog","published":1,"updated":"2018-06-10T14:07:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9slba0000g08oz8k5chhfy","content":"<p>这就是传说中的第一个blog</p>\n<!------ 查看全文 ------>\n<p>#超级偶像</p>\n<embed src=\"http://www.xiami.com/widget/52304397_1773753998/singlePlayer.swf\" type=\"application/x-shockwave-flash\" width=\"257\" height=\"33\" wmode=\"transparent\">\n","site":{"data":{}},"excerpt":"","more":"<p>这就是传说中的第一个blog</p>\n<!------ 查看全文 ------>\n<p>#超级偶像</p>\n<embed src=\"http://www.xiami.com/widget/52304397_1773753998/singlePlayer.swf\" type=\"application/x-shockwave-flash\" width=\"257\" height=\"33\" wmode=\"transparent\">\n"},{"title":"ssh连接报错","date":"2016-12-11T03:02:30.000Z","_content":"\n## 使用ssh连接远程服务器 ##\n\n在使用VPS的时候由于更换了数据中心，导致远程服务```ip```地址改变，使用```ssh```连接的时候报如下错误\n\n\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\nIT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\nSomeone could be eavesdropping on you right now (man-in-the-middle attack)!\nIt is also possible that a host key has just been changed.\nThe fingerprint for the RSA key sent by the remote host is\n6e:45:f9:a8:af:38:3d:a1:a5:c7:76:1d:02:f8:77:00.\nPlease contact your system administrator.\nAdd correct host key in /home/hostname /.ssh/known_hosts to get rid of this message.\nOffending RSA key in /var/lib/sss/pubconf/known_hosts:4\nRSA host key for pong has changed and you have requested strict checking.\nHost key verification failed.\n\n\n## 解决办法 ##\n\n找到```~/.ssh/```路径下的```known_hosts```打开，删除对应的```ip```以及对应信息保存就好\n","source":"_posts/ssh连接报错.md","raw":"---\ntitle: ssh连接报错\ndate: 2016-12-11 11:02:30\ntags: VPS那些事\n---\n\n## 使用ssh连接远程服务器 ##\n\n在使用VPS的时候由于更换了数据中心，导致远程服务```ip```地址改变，使用```ssh```连接的时候报如下错误\n\n\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\nIT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\nSomeone could be eavesdropping on you right now (man-in-the-middle attack)!\nIt is also possible that a host key has just been changed.\nThe fingerprint for the RSA key sent by the remote host is\n6e:45:f9:a8:af:38:3d:a1:a5:c7:76:1d:02:f8:77:00.\nPlease contact your system administrator.\nAdd correct host key in /home/hostname /.ssh/known_hosts to get rid of this message.\nOffending RSA key in /var/lib/sss/pubconf/known_hosts:4\nRSA host key for pong has changed and you have requested strict checking.\nHost key verification failed.\n\n\n## 解决办法 ##\n\n找到```~/.ssh/```路径下的```known_hosts```打开，删除对应的```ip```以及对应信息保存就好\n","slug":"ssh连接报错","published":1,"updated":"2018-06-10T14:07:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9slba4000h08ozhdpyc2nw","content":"<h2 id=\"使用ssh连接远程服务器\"><a href=\"#使用ssh连接远程服务器\" class=\"headerlink\" title=\"使用ssh连接远程服务器\"></a>使用ssh连接远程服务器</h2><p>在使用VPS的时候由于更换了数据中心，导致远程服务<code>ip</code>地址改变，使用<code>ssh</code>连接的时候报如下错误</p>\n<p>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@<br>@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @<br>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@<br>IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!<br>Someone could be eavesdropping on you right now (man-in-the-middle attack)!<br>It is also possible that a host key has just been changed.<br>The fingerprint for the RSA key sent by the remote host is<br>6e:45:f9:a8:af:38:3d:a1:a5:c7:76:1d:02:f8:77:00.<br>Please contact your system administrator.<br>Add correct host key in /home/hostname /.ssh/known_hosts to get rid of this message.<br>Offending RSA key in /var/lib/sss/pubconf/known_hosts:4<br>RSA host key for pong has changed and you have requested strict checking.<br>Host key verification failed.</p>\n<h2 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h2><p>找到<code>~/.ssh/</code>路径下的<code>known_hosts</code>打开，删除对应的<code>ip</code>以及对应信息保存就好</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"使用ssh连接远程服务器\"><a href=\"#使用ssh连接远程服务器\" class=\"headerlink\" title=\"使用ssh连接远程服务器\"></a>使用ssh连接远程服务器</h2><p>在使用VPS的时候由于更换了数据中心，导致远程服务<code>ip</code>地址改变，使用<code>ssh</code>连接的时候报如下错误</p>\n<p>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@<br>@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @<br>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@<br>IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!<br>Someone could be eavesdropping on you right now (man-in-the-middle attack)!<br>It is also possible that a host key has just been changed.<br>The fingerprint for the RSA key sent by the remote host is<br>6e:45:f9:a8:af:38:3d:a1:a5:c7:76:1d:02:f8:77:00.<br>Please contact your system administrator.<br>Add correct host key in /home/hostname /.ssh/known_hosts to get rid of this message.<br>Offending RSA key in /var/lib/sss/pubconf/known_hosts:4<br>RSA host key for pong has changed and you have requested strict checking.<br>Host key verification failed.</p>\n<h2 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h2><p>找到<code>~/.ssh/</code>路径下的<code>known_hosts</code>打开，删除对应的<code>ip</code>以及对应信息保存就好</p>\n"},{"title":"iOS中的枚举","date":"2016-05-11T03:02:30.000Z","_content":"\n## 普通的枚举 ##\n\n### 第一种实现方式 ###\n\n```objectivec\ntypedef enum {\n    EnumTypeTop,\n    EnumTypeBottom\n}EnumType\n```\n\n### 第二种实现方式 ###\n\n```objectivec\ntypedef NS_ENUM(NSInteger,EnumType) {\n    EnumTypeTop,\n    EnumTypeBottom\n};\n```\n\n枚举的作用就是增加程序的可读性,将原来使用数值代表的状态转换成自然语言中有相应含义的单词,所以这样写出来的代码更易读懂。编译器会为枚举分配一个独有的编号,从0开始,每个枚举递增1\n\n<!----- more ----->\n\n## 移位枚举 ##\n\n### 实现方式 ###\n\n```objectivec\ntypedef NS_OPTIONS(NSUInteger, EnumType) {\n   EnumTypeNone  = 0,     // 0000 0000   0\n   EnumTypeTop    = 1<<0, // 0000 0001   1\n   EnumTypeBottom = 1<<1, // 0000 0010   2\n   EnumTypeLeft   = 1<<2, // 0000 0100   4\n   EnumTypeRight  = 1<<3, // 0000 1000   8\n   EnumTypeCenter = 1<<4, // 0001 0000   16\n   EnumTypeHeight = 1<<5, // 0010 0000   32\n   EnumTypeWidth  = 1<<6  // 0100 0000   64\n}\n```\n\n上面就是一个移位枚举, 和普通的枚举的区别就是,每个状态的值不是递增的,而是用只有1个二进制位的值是1数字表示的,这么做的好处就是可以对状态值进行\"位或\"运算,从而实现同时使用多个枚举\n\n\n```objectivec\n- (void)testEnum {\n    [self needMutEnum:EnumTypeTop | EnumTypeBottom | EnumTypeLeft | EnumTypeRight | EnumTypeCenter];\n}\n\n- (void)needMutEnum:(EnumType) type {\n    if (type==0) {\n      NSLog(@\"EnumTypeNone\");\n      return;\n    }\n    if (type & EnumTypeTop) {\n        NSLog(@\"EnumTypeTop\");\n    }\n    if (type & EnumTypeBottom) {\n        NSLog(@\"EnumTypeBottom\");\n    }\n    if (type & EnumTypeLeft) {\n        NSLog(@\"EnumTypeLeft\");\n\n    }\n    if (type & EnumTypeRight) {\n        NSLog(@\"EnumTypeRight\");\n\n    }\n    if (type & EnumTypeCenter) {\n        NSLog(@\"EnumTypeCenter\");\n\n    }\n    if (type & EnumTypeHeight) {\n        NSLog(@\"EnumTypeHeight\");\n\n    }\n    if (type & EnumTypeWidth) {\n        NSLog(@\"EnumTypeWidth\");\n    }\n}\n```\n\n输出\n\n```\nEnumTypeTop\nEnumTypeBottom\nEnumTypeLeft\nEnumTypeRight\nEnumTypeCenter\n```\n\n这样就实现了同时使用多个枚举\n\n#### 原因 ####\n\"位或\"和\"位与\"运算\n\"位或\": 0 | 0 = 0 ; 0 | 1 = 1 ; 1 | 1 = 1;\n\"位与\": 0 & 0 = 0 ; 0 & 1 = 0 ; 1 & 1 = 1;\n\n对移位枚举进行\"位或\"运算\n\nEnumTypeTop | EnumTypeBottom | EnumTypeLeft | EnumTypeRight | EnumTypeCenter 转换成二进制就是\n\n0000 0001 | 0000 0010 | 0000 0100 | 0000 1000 | 0010 0000 = 0011 1111  其10进制的值时63\n\n所以\"needMutEnum\"这个方法传入的值 ```type``` 是十进制的63,\n\n当使用的时候又用 ```type``` 的值和枚举做\"位与运算\",63的二进制是 0011 1111  \n\nEnumTypeTop的二进制是 0000 0001 ,\"位与\"运算的结果就是 0000 0001 ,\n\n也就是说传入的 ```type``` 的值转换成二进制,哪个位上是 ```1``` ,对应的那个类型的枚举就被传入了,\n\n但是要注意的是,如果不需要None的状态,就不要把第一个枚举状态设置成 ```0``` ,直接从0000 0001 设置\n","source":"_posts/枚举的实现方式(移位枚举).md","raw":"---\ntitle: iOS中的枚举\ndate: 2016-05-11 11:02:30\ntags: iOS\n---\n\n## 普通的枚举 ##\n\n### 第一种实现方式 ###\n\n```objectivec\ntypedef enum {\n    EnumTypeTop,\n    EnumTypeBottom\n}EnumType\n```\n\n### 第二种实现方式 ###\n\n```objectivec\ntypedef NS_ENUM(NSInteger,EnumType) {\n    EnumTypeTop,\n    EnumTypeBottom\n};\n```\n\n枚举的作用就是增加程序的可读性,将原来使用数值代表的状态转换成自然语言中有相应含义的单词,所以这样写出来的代码更易读懂。编译器会为枚举分配一个独有的编号,从0开始,每个枚举递增1\n\n<!----- more ----->\n\n## 移位枚举 ##\n\n### 实现方式 ###\n\n```objectivec\ntypedef NS_OPTIONS(NSUInteger, EnumType) {\n   EnumTypeNone  = 0,     // 0000 0000   0\n   EnumTypeTop    = 1<<0, // 0000 0001   1\n   EnumTypeBottom = 1<<1, // 0000 0010   2\n   EnumTypeLeft   = 1<<2, // 0000 0100   4\n   EnumTypeRight  = 1<<3, // 0000 1000   8\n   EnumTypeCenter = 1<<4, // 0001 0000   16\n   EnumTypeHeight = 1<<5, // 0010 0000   32\n   EnumTypeWidth  = 1<<6  // 0100 0000   64\n}\n```\n\n上面就是一个移位枚举, 和普通的枚举的区别就是,每个状态的值不是递增的,而是用只有1个二进制位的值是1数字表示的,这么做的好处就是可以对状态值进行\"位或\"运算,从而实现同时使用多个枚举\n\n\n```objectivec\n- (void)testEnum {\n    [self needMutEnum:EnumTypeTop | EnumTypeBottom | EnumTypeLeft | EnumTypeRight | EnumTypeCenter];\n}\n\n- (void)needMutEnum:(EnumType) type {\n    if (type==0) {\n      NSLog(@\"EnumTypeNone\");\n      return;\n    }\n    if (type & EnumTypeTop) {\n        NSLog(@\"EnumTypeTop\");\n    }\n    if (type & EnumTypeBottom) {\n        NSLog(@\"EnumTypeBottom\");\n    }\n    if (type & EnumTypeLeft) {\n        NSLog(@\"EnumTypeLeft\");\n\n    }\n    if (type & EnumTypeRight) {\n        NSLog(@\"EnumTypeRight\");\n\n    }\n    if (type & EnumTypeCenter) {\n        NSLog(@\"EnumTypeCenter\");\n\n    }\n    if (type & EnumTypeHeight) {\n        NSLog(@\"EnumTypeHeight\");\n\n    }\n    if (type & EnumTypeWidth) {\n        NSLog(@\"EnumTypeWidth\");\n    }\n}\n```\n\n输出\n\n```\nEnumTypeTop\nEnumTypeBottom\nEnumTypeLeft\nEnumTypeRight\nEnumTypeCenter\n```\n\n这样就实现了同时使用多个枚举\n\n#### 原因 ####\n\"位或\"和\"位与\"运算\n\"位或\": 0 | 0 = 0 ; 0 | 1 = 1 ; 1 | 1 = 1;\n\"位与\": 0 & 0 = 0 ; 0 & 1 = 0 ; 1 & 1 = 1;\n\n对移位枚举进行\"位或\"运算\n\nEnumTypeTop | EnumTypeBottom | EnumTypeLeft | EnumTypeRight | EnumTypeCenter 转换成二进制就是\n\n0000 0001 | 0000 0010 | 0000 0100 | 0000 1000 | 0010 0000 = 0011 1111  其10进制的值时63\n\n所以\"needMutEnum\"这个方法传入的值 ```type``` 是十进制的63,\n\n当使用的时候又用 ```type``` 的值和枚举做\"位与运算\",63的二进制是 0011 1111  \n\nEnumTypeTop的二进制是 0000 0001 ,\"位与\"运算的结果就是 0000 0001 ,\n\n也就是说传入的 ```type``` 的值转换成二进制,哪个位上是 ```1``` ,对应的那个类型的枚举就被传入了,\n\n但是要注意的是,如果不需要None的状态,就不要把第一个枚举状态设置成 ```0``` ,直接从0000 0001 设置\n","slug":"枚举的实现方式(移位枚举)","published":1,"updated":"2018-06-10T14:07:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9slba5000j08ozvrkakpbk","content":"<h2 id=\"普通的枚举\"><a href=\"#普通的枚举\" class=\"headerlink\" title=\"普通的枚举\"></a>普通的枚举</h2><h3 id=\"第一种实现方式\"><a href=\"#第一种实现方式\" class=\"headerlink\" title=\"第一种实现方式\"></a>第一种实现方式</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">enum</span> &#123;</span><br><span class=\"line\">    EnumTypeTop,</span><br><span class=\"line\">    EnumTypeBottom</span><br><span class=\"line\">&#125;EnumType</span><br></pre></td></tr></table></figure>\n<h3 id=\"第二种实现方式\"><a href=\"#第二种实现方式\" class=\"headerlink\" title=\"第二种实现方式\"></a>第二种实现方式</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSInteger</span>,EnumType) &#123;</span><br><span class=\"line\">    EnumTypeTop,</span><br><span class=\"line\">    EnumTypeBottom</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>枚举的作用就是增加程序的可读性,将原来使用数值代表的状态转换成自然语言中有相应含义的单词,所以这样写出来的代码更易读懂。编译器会为枚举分配一个独有的编号,从0开始,每个枚举递增1</p>\n<a id=\"more\"></a>\n<h2 id=\"移位枚举\"><a href=\"#移位枚举\" class=\"headerlink\" title=\"移位枚举\"></a>移位枚举</h2><h3 id=\"实现方式\"><a href=\"#实现方式\" class=\"headerlink\" title=\"实现方式\"></a>实现方式</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_OPTIONS</span>(<span class=\"built_in\">NSUInteger</span>, EnumType) &#123;</span><br><span class=\"line\">   EnumTypeNone  = <span class=\"number\">0</span>,     <span class=\"comment\">// 0000 0000   0</span></span><br><span class=\"line\">   EnumTypeTop    = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">0</span>, <span class=\"comment\">// 0000 0001   1</span></span><br><span class=\"line\">   EnumTypeBottom = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">1</span>, <span class=\"comment\">// 0000 0010   2</span></span><br><span class=\"line\">   EnumTypeLeft   = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">2</span>, <span class=\"comment\">// 0000 0100   4</span></span><br><span class=\"line\">   EnumTypeRight  = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">3</span>, <span class=\"comment\">// 0000 1000   8</span></span><br><span class=\"line\">   EnumTypeCenter = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">4</span>, <span class=\"comment\">// 0001 0000   16</span></span><br><span class=\"line\">   EnumTypeHeight = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">5</span>, <span class=\"comment\">// 0010 0000   32</span></span><br><span class=\"line\">   EnumTypeWidth  = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">6</span>  <span class=\"comment\">// 0100 0000   64</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面就是一个移位枚举, 和普通的枚举的区别就是,每个状态的值不是递增的,而是用只有1个二进制位的值是1数字表示的,这么做的好处就是可以对状态值进行”位或”运算,从而实现同时使用多个枚举</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)testEnum &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> needMutEnum:EnumTypeTop | EnumTypeBottom | EnumTypeLeft | EnumTypeRight | EnumTypeCenter];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)needMutEnum:(EnumType) type &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type==<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"EnumTypeNone\"</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type &amp; EnumTypeTop) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"EnumTypeTop\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type &amp; EnumTypeBottom) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"EnumTypeBottom\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type &amp; EnumTypeLeft) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"EnumTypeLeft\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type &amp; EnumTypeRight) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"EnumTypeRight\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type &amp; EnumTypeCenter) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"EnumTypeCenter\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type &amp; EnumTypeHeight) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"EnumTypeHeight\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type &amp; EnumTypeWidth) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"EnumTypeWidth\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EnumTypeTop</span><br><span class=\"line\">EnumTypeBottom</span><br><span class=\"line\">EnumTypeLeft</span><br><span class=\"line\">EnumTypeRight</span><br><span class=\"line\">EnumTypeCenter</span><br></pre></td></tr></table></figure>\n<p>这样就实现了同时使用多个枚举</p>\n<h4 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h4><p>“位或”和”位与”运算<br>“位或”: 0 | 0 = 0 ; 0 | 1 = 1 ; 1 | 1 = 1;<br>“位与”: 0 &amp; 0 = 0 ; 0 &amp; 1 = 0 ; 1 &amp; 1 = 1;</p>\n<p>对移位枚举进行”位或”运算</p>\n<p>EnumTypeTop | EnumTypeBottom | EnumTypeLeft | EnumTypeRight | EnumTypeCenter 转换成二进制就是</p>\n<p>0000 0001 | 0000 0010 | 0000 0100 | 0000 1000 | 0010 0000 = 0011 1111  其10进制的值时63</p>\n<p>所以”needMutEnum”这个方法传入的值 <code>type</code> 是十进制的63,</p>\n<p>当使用的时候又用 <code>type</code> 的值和枚举做”位与运算”,63的二进制是 0011 1111  </p>\n<p>EnumTypeTop的二进制是 0000 0001 ,”位与”运算的结果就是 0000 0001 ,</p>\n<p>也就是说传入的 <code>type</code> 的值转换成二进制,哪个位上是 <code>1</code> ,对应的那个类型的枚举就被传入了,</p>\n<p>但是要注意的是,如果不需要None的状态,就不要把第一个枚举状态设置成 <code>0</code> ,直接从0000 0001 设置</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"普通的枚举\"><a href=\"#普通的枚举\" class=\"headerlink\" title=\"普通的枚举\"></a>普通的枚举</h2><h3 id=\"第一种实现方式\"><a href=\"#第一种实现方式\" class=\"headerlink\" title=\"第一种实现方式\"></a>第一种实现方式</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">enum</span> &#123;</span><br><span class=\"line\">    EnumTypeTop,</span><br><span class=\"line\">    EnumTypeBottom</span><br><span class=\"line\">&#125;EnumType</span><br></pre></td></tr></table></figure>\n<h3 id=\"第二种实现方式\"><a href=\"#第二种实现方式\" class=\"headerlink\" title=\"第二种实现方式\"></a>第二种实现方式</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSInteger</span>,EnumType) &#123;</span><br><span class=\"line\">    EnumTypeTop,</span><br><span class=\"line\">    EnumTypeBottom</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>枚举的作用就是增加程序的可读性,将原来使用数值代表的状态转换成自然语言中有相应含义的单词,所以这样写出来的代码更易读懂。编译器会为枚举分配一个独有的编号,从0开始,每个枚举递增1</p>","more":"<h2 id=\"移位枚举\"><a href=\"#移位枚举\" class=\"headerlink\" title=\"移位枚举\"></a>移位枚举</h2><h3 id=\"实现方式\"><a href=\"#实现方式\" class=\"headerlink\" title=\"实现方式\"></a>实现方式</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_OPTIONS</span>(<span class=\"built_in\">NSUInteger</span>, EnumType) &#123;</span><br><span class=\"line\">   EnumTypeNone  = <span class=\"number\">0</span>,     <span class=\"comment\">// 0000 0000   0</span></span><br><span class=\"line\">   EnumTypeTop    = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">0</span>, <span class=\"comment\">// 0000 0001   1</span></span><br><span class=\"line\">   EnumTypeBottom = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">1</span>, <span class=\"comment\">// 0000 0010   2</span></span><br><span class=\"line\">   EnumTypeLeft   = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">2</span>, <span class=\"comment\">// 0000 0100   4</span></span><br><span class=\"line\">   EnumTypeRight  = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">3</span>, <span class=\"comment\">// 0000 1000   8</span></span><br><span class=\"line\">   EnumTypeCenter = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">4</span>, <span class=\"comment\">// 0001 0000   16</span></span><br><span class=\"line\">   EnumTypeHeight = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">5</span>, <span class=\"comment\">// 0010 0000   32</span></span><br><span class=\"line\">   EnumTypeWidth  = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">6</span>  <span class=\"comment\">// 0100 0000   64</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面就是一个移位枚举, 和普通的枚举的区别就是,每个状态的值不是递增的,而是用只有1个二进制位的值是1数字表示的,这么做的好处就是可以对状态值进行”位或”运算,从而实现同时使用多个枚举</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)testEnum &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> needMutEnum:EnumTypeTop | EnumTypeBottom | EnumTypeLeft | EnumTypeRight | EnumTypeCenter];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)needMutEnum:(EnumType) type &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type==<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"EnumTypeNone\"</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type &amp; EnumTypeTop) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"EnumTypeTop\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type &amp; EnumTypeBottom) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"EnumTypeBottom\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type &amp; EnumTypeLeft) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"EnumTypeLeft\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type &amp; EnumTypeRight) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"EnumTypeRight\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type &amp; EnumTypeCenter) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"EnumTypeCenter\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type &amp; EnumTypeHeight) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"EnumTypeHeight\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type &amp; EnumTypeWidth) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"EnumTypeWidth\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EnumTypeTop</span><br><span class=\"line\">EnumTypeBottom</span><br><span class=\"line\">EnumTypeLeft</span><br><span class=\"line\">EnumTypeRight</span><br><span class=\"line\">EnumTypeCenter</span><br></pre></td></tr></table></figure>\n<p>这样就实现了同时使用多个枚举</p>\n<h4 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h4><p>“位或”和”位与”运算<br>“位或”: 0 | 0 = 0 ; 0 | 1 = 1 ; 1 | 1 = 1;<br>“位与”: 0 &amp; 0 = 0 ; 0 &amp; 1 = 0 ; 1 &amp; 1 = 1;</p>\n<p>对移位枚举进行”位或”运算</p>\n<p>EnumTypeTop | EnumTypeBottom | EnumTypeLeft | EnumTypeRight | EnumTypeCenter 转换成二进制就是</p>\n<p>0000 0001 | 0000 0010 | 0000 0100 | 0000 1000 | 0010 0000 = 0011 1111  其10进制的值时63</p>\n<p>所以”needMutEnum”这个方法传入的值 <code>type</code> 是十进制的63,</p>\n<p>当使用的时候又用 <code>type</code> 的值和枚举做”位与运算”,63的二进制是 0011 1111  </p>\n<p>EnumTypeTop的二进制是 0000 0001 ,”位与”运算的结果就是 0000 0001 ,</p>\n<p>也就是说传入的 <code>type</code> 的值转换成二进制,哪个位上是 <code>1</code> ,对应的那个类型的枚举就被传入了,</p>\n<p>但是要注意的是,如果不需要None的状态,就不要把第一个枚举状态设置成 <code>0</code> ,直接从0000 0001 设置</p>"},{"title":"读《iOS与OS X多线程和内存管理》——前言","date":"2017-01-11T03:10:12.000Z","_content":"\n# 前言 #\n\n  都说不会写部落格的程序猿不是好作家，本作家本来想着当一个小小的初级工程师，每天码码界面，终其一生就算了。\n谁知天有不测风云，人有祸福旦夕，那天在工程中多看了一眼别人的代码，顿时觉得自己的知识储备实在是太匮乏了。\n\n那么究竟是什么样的代码，居然有如此神奇的功效，闲话少叙，上代码：\n\n<!----- more ----->\n\n代码一：\n\n```mm\n@interface MyView ()\n\n@property (nonatomic, weak) UILabel *label;\n\n@end\n\n@implementation MyView\n{\nUILabel *label = [[UILabel alloc] init];\nlabel.font = [UIFont systemFontOfSize:14];\nlabel.textColor = [UIColor whiteColor];\nlabel.textAlignment = NSTextAlignmentCenter;\nlabel.text = @\"你好\";\n[self addSubview:label];\n_label = label;\n}\n@end\n```\n\n就是这么一段代码，如果要让楼主写 则是下面这样的\n\n代码二：\n\n```objectivec\n@interface MyView ()\n\n@property (nonatomic, strong) UILabel *label;\n\n@end\n\n@implementation MyView\n{\nself.label = [[UILabel alloc] init];\nself.label.font = [UIFont systemFontOfSize:14];\nself.label.textColor = [UIColor whiteColor];\nself.label.textAlignment = NSTextAlignmentCenter;\nself.label.text = @\"你好\";\n[self addSubview:self.label];\n}\n@end\n```\n\n当然你也可以直接用 ```_label``` 赋值，这里问题的重点不是set方法和成员变量的区别，而是我的属性\n用的是 ```strong``` 修饰而他的是使用 ```weak```修饰。\n\n本着不耻下问，虚心求教的态度我问了一下我同事，得到了这样的解答：\n\n代码一的属性使用的 ```weak``` 修饰，因为在 ```addSubview：``` 的时候 ```self``` 会强引用 ```label``` 对象 ```weak``` 修饰的成员变量 ```_label``` 弱引用着 ```label```对象\n\n代码二的属性使用 ```strong``` 修饰， 在 ```addSubview：``` 的时候 ```self``` 会强引用 ```label```对象 ```strong``` 修饰的成员变量 ```_label``` 也强引用着 ```label``` 对象\n\n第一种代码的好处是在 ```self```移除 ```label```的时候 ```label```对象就释放了。因为 ```label```只有一个 ```self```强引用着\n\n第二种代码在 ```self```移除```label```的时候```label```对象不会释放，因为还有个 ```_label```的变量强引用这 ```label```对象，\n只有在 ```self``` 释放的时候 ```label``` 对象才会释放。\n\n\n本人读书少，仔细一想确实是这么回事，用```weak```修饰，```label```对象只被 ```self```强引用，从view上移除后就可以释放，\n不用等到self释放的时候才释放，创建和释放都很合理(哪里创建哪里释放)。\n\n但是细思极恐，难道我多年来的开发经验是错误的么，用了n年的strong原来是个低效的使用方法。这时候我突然想到了一个面试题，\n那就是你真的了解属性修饰符的用法么？\n\n好吧我承认！我不了解，这就是我看这本书的原因。\n\n注：\n(1).上面的解释不一定是正确的.\n(2).小弟初来乍到要是有啥说的不对的地方希望各位大大不吝赐教。\n(3).要是你们有什么意见和建议，也可以随便吐槽。\n","source":"_posts/读《iOS与OS X多线程和内存管理》——前言.md","raw":"---\ntitle: 读《iOS与OS X多线程和内存管理》——前言\ndate: 2017-01-11 11:10:12\ntags: iOS\n---\n\n# 前言 #\n\n  都说不会写部落格的程序猿不是好作家，本作家本来想着当一个小小的初级工程师，每天码码界面，终其一生就算了。\n谁知天有不测风云，人有祸福旦夕，那天在工程中多看了一眼别人的代码，顿时觉得自己的知识储备实在是太匮乏了。\n\n那么究竟是什么样的代码，居然有如此神奇的功效，闲话少叙，上代码：\n\n<!----- more ----->\n\n代码一：\n\n```mm\n@interface MyView ()\n\n@property (nonatomic, weak) UILabel *label;\n\n@end\n\n@implementation MyView\n{\nUILabel *label = [[UILabel alloc] init];\nlabel.font = [UIFont systemFontOfSize:14];\nlabel.textColor = [UIColor whiteColor];\nlabel.textAlignment = NSTextAlignmentCenter;\nlabel.text = @\"你好\";\n[self addSubview:label];\n_label = label;\n}\n@end\n```\n\n就是这么一段代码，如果要让楼主写 则是下面这样的\n\n代码二：\n\n```objectivec\n@interface MyView ()\n\n@property (nonatomic, strong) UILabel *label;\n\n@end\n\n@implementation MyView\n{\nself.label = [[UILabel alloc] init];\nself.label.font = [UIFont systemFontOfSize:14];\nself.label.textColor = [UIColor whiteColor];\nself.label.textAlignment = NSTextAlignmentCenter;\nself.label.text = @\"你好\";\n[self addSubview:self.label];\n}\n@end\n```\n\n当然你也可以直接用 ```_label``` 赋值，这里问题的重点不是set方法和成员变量的区别，而是我的属性\n用的是 ```strong``` 修饰而他的是使用 ```weak```修饰。\n\n本着不耻下问，虚心求教的态度我问了一下我同事，得到了这样的解答：\n\n代码一的属性使用的 ```weak``` 修饰，因为在 ```addSubview：``` 的时候 ```self``` 会强引用 ```label``` 对象 ```weak``` 修饰的成员变量 ```_label``` 弱引用着 ```label```对象\n\n代码二的属性使用 ```strong``` 修饰， 在 ```addSubview：``` 的时候 ```self``` 会强引用 ```label```对象 ```strong``` 修饰的成员变量 ```_label``` 也强引用着 ```label``` 对象\n\n第一种代码的好处是在 ```self```移除 ```label```的时候 ```label```对象就释放了。因为 ```label```只有一个 ```self```强引用着\n\n第二种代码在 ```self```移除```label```的时候```label```对象不会释放，因为还有个 ```_label```的变量强引用这 ```label```对象，\n只有在 ```self``` 释放的时候 ```label``` 对象才会释放。\n\n\n本人读书少，仔细一想确实是这么回事，用```weak```修饰，```label```对象只被 ```self```强引用，从view上移除后就可以释放，\n不用等到self释放的时候才释放，创建和释放都很合理(哪里创建哪里释放)。\n\n但是细思极恐，难道我多年来的开发经验是错误的么，用了n年的strong原来是个低效的使用方法。这时候我突然想到了一个面试题，\n那就是你真的了解属性修饰符的用法么？\n\n好吧我承认！我不了解，这就是我看这本书的原因。\n\n注：\n(1).上面的解释不一定是正确的.\n(2).小弟初来乍到要是有啥说的不对的地方希望各位大大不吝赐教。\n(3).要是你们有什么意见和建议，也可以随便吐槽。\n","slug":"读《iOS与OS X多线程和内存管理》——前言","published":1,"updated":"2018-09-04T15:05:21.038Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9slba6000l08ozp5m3zuzg","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>  都说不会写部落格的程序猿不是好作家，本作家本来想着当一个小小的初级工程师，每天码码界面，终其一生就算了。<br>谁知天有不测风云，人有祸福旦夕，那天在工程中多看了一眼别人的代码，顿时觉得自己的知识储备实在是太匮乏了。</p>\n<p>那么究竟是什么样的代码，居然有如此神奇的功效，闲话少叙，上代码：</p>\n<a id=\"more\"></a>\n<p>代码一：</p>\n<figure class=\"highlight mm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MyView</span> ()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">weak</span>) <span class=\"built_in\">UILabel</span> *label;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">MyView</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"built_in\">UILabel</span> *label = [[<span class=\"built_in\">UILabel</span> alloc] init];</span><br><span class=\"line\">label.font = [<span class=\"built_in\">UIFont</span> systemFontOfSize:<span class=\"number\">14</span>];</span><br><span class=\"line\">label.textColor = [<span class=\"built_in\">UIColor</span> whiteColor];</span><br><span class=\"line\">label.textAlignment = <span class=\"built_in\">NSTextAlignmentCenter</span>;</span><br><span class=\"line\">label.text = <span class=\"string\">@\"你好\"</span>;</span><br><span class=\"line\">[<span class=\"keyword\">self</span> addSubview:label];</span><br><span class=\"line\">_label = label;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>就是这么一段代码，如果要让楼主写 则是下面这样的</p>\n<p>代码二：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MyView</span> ()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">UILabel</span> *label;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">MyView</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">self</span>.label = [[<span class=\"built_in\">UILabel</span> alloc] init];</span><br><span class=\"line\"><span class=\"keyword\">self</span>.label.font = [<span class=\"built_in\">UIFont</span> systemFontOfSize:<span class=\"number\">14</span>];</span><br><span class=\"line\"><span class=\"keyword\">self</span>.label.textColor = [<span class=\"built_in\">UIColor</span> whiteColor];</span><br><span class=\"line\"><span class=\"keyword\">self</span>.label.textAlignment = <span class=\"built_in\">NSTextAlignmentCenter</span>;</span><br><span class=\"line\"><span class=\"keyword\">self</span>.label.text = <span class=\"string\">@\"你好\"</span>;</span><br><span class=\"line\">[<span class=\"keyword\">self</span> addSubview:<span class=\"keyword\">self</span>.label];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>当然你也可以直接用 <code>_label</code> 赋值，这里问题的重点不是set方法和成员变量的区别，而是我的属性<br>用的是 <code>strong</code> 修饰而他的是使用 <code>weak</code>修饰。</p>\n<p>本着不耻下问，虚心求教的态度我问了一下我同事，得到了这样的解答：</p>\n<p>代码一的属性使用的 <code>weak</code> 修饰，因为在 <code>addSubview：</code> 的时候 <code>self</code> 会强引用 <code>label</code> 对象 <code>weak</code> 修饰的成员变量 <code>_label</code> 弱引用着 <code>label</code>对象</p>\n<p>代码二的属性使用 <code>strong</code> 修饰， 在 <code>addSubview：</code> 的时候 <code>self</code> 会强引用 <code>label</code>对象 <code>strong</code> 修饰的成员变量 <code>_label</code> 也强引用着 <code>label</code> 对象</p>\n<p>第一种代码的好处是在 <code>self</code>移除 <code>label</code>的时候 <code>label</code>对象就释放了。因为 <code>label</code>只有一个 <code>self</code>强引用着</p>\n<p>第二种代码在 <code>self</code>移除<code>label</code>的时候<code>label</code>对象不会释放，因为还有个 <code>_label</code>的变量强引用这 <code>label</code>对象，<br>只有在 <code>self</code> 释放的时候 <code>label</code> 对象才会释放。</p>\n<p>本人读书少，仔细一想确实是这么回事，用<code>weak</code>修饰，<code>label</code>对象只被 <code>self</code>强引用，从view上移除后就可以释放，<br>不用等到self释放的时候才释放，创建和释放都很合理(哪里创建哪里释放)。</p>\n<p>但是细思极恐，难道我多年来的开发经验是错误的么，用了n年的strong原来是个低效的使用方法。这时候我突然想到了一个面试题，<br>那就是你真的了解属性修饰符的用法么？</p>\n<p>好吧我承认！我不了解，这就是我看这本书的原因。</p>\n<p>注：<br>(1).上面的解释不一定是正确的.<br>(2).小弟初来乍到要是有啥说的不对的地方希望各位大大不吝赐教。<br>(3).要是你们有什么意见和建议，也可以随便吐槽。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>  都说不会写部落格的程序猿不是好作家，本作家本来想着当一个小小的初级工程师，每天码码界面，终其一生就算了。<br>谁知天有不测风云，人有祸福旦夕，那天在工程中多看了一眼别人的代码，顿时觉得自己的知识储备实在是太匮乏了。</p>\n<p>那么究竟是什么样的代码，居然有如此神奇的功效，闲话少叙，上代码：</p>","more":"<p>代码一：</p>\n<figure class=\"highlight mm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MyView</span> ()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">weak</span>) <span class=\"built_in\">UILabel</span> *label;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">MyView</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"built_in\">UILabel</span> *label = [[<span class=\"built_in\">UILabel</span> alloc] init];</span><br><span class=\"line\">label.font = [<span class=\"built_in\">UIFont</span> systemFontOfSize:<span class=\"number\">14</span>];</span><br><span class=\"line\">label.textColor = [<span class=\"built_in\">UIColor</span> whiteColor];</span><br><span class=\"line\">label.textAlignment = <span class=\"built_in\">NSTextAlignmentCenter</span>;</span><br><span class=\"line\">label.text = <span class=\"string\">@\"你好\"</span>;</span><br><span class=\"line\">[<span class=\"keyword\">self</span> addSubview:label];</span><br><span class=\"line\">_label = label;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>就是这么一段代码，如果要让楼主写 则是下面这样的</p>\n<p>代码二：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MyView</span> ()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">UILabel</span> *label;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">MyView</span></span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">self</span>.label = [[<span class=\"built_in\">UILabel</span> alloc] init];</span><br><span class=\"line\"><span class=\"keyword\">self</span>.label.font = [<span class=\"built_in\">UIFont</span> systemFontOfSize:<span class=\"number\">14</span>];</span><br><span class=\"line\"><span class=\"keyword\">self</span>.label.textColor = [<span class=\"built_in\">UIColor</span> whiteColor];</span><br><span class=\"line\"><span class=\"keyword\">self</span>.label.textAlignment = <span class=\"built_in\">NSTextAlignmentCenter</span>;</span><br><span class=\"line\"><span class=\"keyword\">self</span>.label.text = <span class=\"string\">@\"你好\"</span>;</span><br><span class=\"line\">[<span class=\"keyword\">self</span> addSubview:<span class=\"keyword\">self</span>.label];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>当然你也可以直接用 <code>_label</code> 赋值，这里问题的重点不是set方法和成员变量的区别，而是我的属性<br>用的是 <code>strong</code> 修饰而他的是使用 <code>weak</code>修饰。</p>\n<p>本着不耻下问，虚心求教的态度我问了一下我同事，得到了这样的解答：</p>\n<p>代码一的属性使用的 <code>weak</code> 修饰，因为在 <code>addSubview：</code> 的时候 <code>self</code> 会强引用 <code>label</code> 对象 <code>weak</code> 修饰的成员变量 <code>_label</code> 弱引用着 <code>label</code>对象</p>\n<p>代码二的属性使用 <code>strong</code> 修饰， 在 <code>addSubview：</code> 的时候 <code>self</code> 会强引用 <code>label</code>对象 <code>strong</code> 修饰的成员变量 <code>_label</code> 也强引用着 <code>label</code> 对象</p>\n<p>第一种代码的好处是在 <code>self</code>移除 <code>label</code>的时候 <code>label</code>对象就释放了。因为 <code>label</code>只有一个 <code>self</code>强引用着</p>\n<p>第二种代码在 <code>self</code>移除<code>label</code>的时候<code>label</code>对象不会释放，因为还有个 <code>_label</code>的变量强引用这 <code>label</code>对象，<br>只有在 <code>self</code> 释放的时候 <code>label</code> 对象才会释放。</p>\n<p>本人读书少，仔细一想确实是这么回事，用<code>weak</code>修饰，<code>label</code>对象只被 <code>self</code>强引用，从view上移除后就可以释放，<br>不用等到self释放的时候才释放，创建和释放都很合理(哪里创建哪里释放)。</p>\n<p>但是细思极恐，难道我多年来的开发经验是错误的么，用了n年的strong原来是个低效的使用方法。这时候我突然想到了一个面试题，<br>那就是你真的了解属性修饰符的用法么？</p>\n<p>好吧我承认！我不了解，这就是我看这本书的原因。</p>\n<p>注：<br>(1).上面的解释不一定是正确的.<br>(2).小弟初来乍到要是有啥说的不对的地方希望各位大大不吝赐教。<br>(3).要是你们有什么意见和建议，也可以随便吐槽。</p>"},{"title":"读《iOS与OS X多线程和内存管理》——引用计数","date":"2017-01-11T03:10:12.000Z","_content":"\n## 1. 什么是自动引用计数(ARC) ##\n\nARC简而言之就是编译器自动进行内存管理，那为什么不叫\"自动内存管理\"，而叫\"自动引用计数\"，当然是因为内存管理是的方法是通过引用计数实现的\n\n要说自动引用计数，首先要说什么是\"引用计数\"\n\n### 1.1引用计数 ###\n\n什么是引用计数，书中举了一个生活中开关房间灯的例子。\n\n简单的描述一下就是，第一个人来的时候要开灯(创建对象)，最后一个人走的时候要关灯(释放对象)，中间来人走人都不需要开关灯。\n那么办公室里的人数就是引用计数。\n\n### 1.2内存管理的思考方式 ###\n\n内存管理的思考方式总结出来就是下面四点  \n\n注：这里还没到ARC所以还是非ARC\n\n1.自己生成的对象，自己所持有 (指通过```alloc/new/copy/mutableCopy```等创建的对象)\neg:\n\n```mm\nid obj = [NSObject new];\n```\n\n2.非自己生成的对象，自己也能持有 (指持有通过类方法创建的对象)\neg:\n\n```mm\nid obj = [NSArray array];\n[obj retain];\n```\n\n3.不再需要自己持有的对象时释放  (释放对象)\neg:\n\n```mm\nid obj = [[NSObject alloc] init];\n[obj release];  \n```\n4.非自己持有的对象无法释放  (多次释放，或未持有释放）\neg:\n\n```mm\nid obj = [[NSObject alloc] init];\n[obj release];\n[obj release];\n```\n\n\n对象的操作与Objective-C方法的对应\n生成并持有对象------ alloc/new/copy/mutableCopy 等\n持有对象----------- retain\n释放对象----------- release\n废弃对象----------- dealloc\n\n\n## 2.alloc/retain/release/dealloc 实现 ##\n\n书中这个节研究的是alloc/retain/release/dealloc的实现。\n\n讲之前先说一个我不知道的常识，那就是Objective-C的框架，底层的是一个叫Cocoa框架其中包含一个Foundation框架\n\n首先Objective-C内存管理的方法是包含在Cocoa框架中的，这里所说的内存管理是的方法alloc/retain/release/dealloc 指的是 NSObject类的alloc类方法,retain实例方法,release实例方法和dealloc实例方法，但是NSObject类的 Foundation``` 框架没有公开过源码，所以这里使用开源软件GNUstep的框架，一个能和Cocoa框架互换的框架，来理解苹果Cocoa框架的实现。\n\n这里我把代码给大家写出来，供大家参考，但书的作者把有些地方的源码在不改变意思的范围进行了修改\n\n### 2.1 alloc 实现 ###\n\nGNUstep的```alloc```实现：\n\n\n```mm\n+(id)alloc\n{\n    return [self allocWithZone:NSDefaultMallocZone()];\n}\n\n+ (id)allocWithZone:(NSZone *)z\n{\n    return NSAllocateObject (self, 0, z);\n}\n\n/* ------- NSAllocateObject ------- */\nstruct obj_layout {\n    NSUInteger retained;\n};\n\ninline id NSAllocateObject (Class aClass, NSUInteger extraBytes, NSZone *zone)\n{\n    int size = 计算容纳对象所需内存大小；\n    id new = NSZoneMalloc(zone,size);\n    memset(new, 0, size);\n    new = (id)&((struct obj_layout *) new)[1];\n}\n\n/* ----- 简化版alloc ----- */\n+ alloc\n{\n    int size = sizeof(struct obj_layout) + 对象大小;\n    struct obj_layout *p = (struct obj_layout *)calloc(1,size);\n    return(id)(p+1);\n}\n```\n\n简化版的是去掉了 ```NSZone``` 之后的代码，```NSZone``` 是为了防止内存碎片化引入的结构，对内存管理没有影响，所以可以忽略。从简化版的代码中可以看出 ```GNUstep``` 申请的对象的内存比需要的大了 ```sizeof(struct obj_layout)```，这个多出来的空间就是用来存放引用计数的\n\n在非ARC即MRC中是可以通过 ```retainCount``` 查看对象的引用计数的。\n\nretainCount的实现:\n\n```mm\n- (NSUInteger)retainCount\n{\n    return NSExtraRefCount(self) + 1;\n}\n\ninline NSUInteger NSExtraRefCount(id anObject)\n{\n    return((struct obj_layout *) anObject)[-1].retained;\n}\n```\n\n### 2.2 retain 实现 ###\n\nGNUstep的 ```retain``` 实现：\n\n```mm\n- (id)retain\n{\n    NSIncrementExtraRefCount(self);\n    return self;\n}\n\ninline void NSIncrementExtraRefCount(id anObject)\n{\n    if(((struct obj_layout *)anObject)[-1].retained == UINT_MAX -1)\n        抛出异常\n    ((struct obj_layout *)anObject)[-1].retained++;\n}\n```\n\n### 2.3 release 实现 ###\nGNUstep的 ```release``` 实现：\n\n```mm\n- (void)release\n{\n    if(NSDecrementExtraRefCountWasZero(self))\n        [self dealloc];\n}\n\nBOOL NSDecrementExtraRefCountWasZero(id anObject)\n{\n    if(((struct obj_layout *)anObject)[-1].retained == 0){\n        return YES;\n    }else {\n        ((struct obj_layout *)anObject)[-1].retained--;\n        return NO;\n    }\n}\n```\n\n### 2.4dealloc 实现 ###\nGNUstep的```dealloc```实现：\n\n```mm\n- (void)dealloc\n{\n    NSDeallocateObject(self);\n}\n\ninline void NSDeallocateObject(id anObject)\n{\n    struct obj_layout *o = &((struct obj_layout *) anObject)[-1];\n    free(o);\n}\n```\n\n可以看到 ```GNUstep``` 实现引用计数的方法是在变量在内存块头部保存的当前对象的引用计数，默认是0，当调用 ```retainCount``` 时会自动+1，这就说明了自己生成的对象，自己所持有。\n\n\n### 2.5 苹果实现 ###\n苹果由于官方未公开源代码，根据运行时调用的代码可以看出苹果实现引用计数和 ```GNUsetp``` 的主要区别就是 ```GNUsetp``` 将引用计数存放在内存块头，而苹果使用的是散列表（键为内存块地址的散列值）\n\n存放在头部管理引用计数的好处：\n- 代码量少\n- 能够统一管理引用计数用内存块和对象用内存块\n\n用散列表(引用计数表)管理引用计数的好处：\n- 对象用内存块的分配无需考虑内存块头部\n- 引用计数表各记录中存有内存块地址，可从各个记录追溯到各对象的内存块\n\n\n### autorelease ###\n所谓 ```autorelease``` 就是自动释放，原理就是若某自动变量超出其作用域，该自动变量将被自动废弃\n\nGNUstep的 ```autorelease``` 实现：\n\n\n```mm\n- (id)autorelease\n{\n    [NSAutoreleasePool addObject:self];\n}\n\n+ (void) addObject:(id)anObj\n{\n    NSAutoreleasePool *pool = 取得当前NSAutoreleasePool对象\n    if(pool != nil) {\n        [pool addObject:anObj];\n    }else {\n        NSLog(@\"NSAutoreleasePool对象非存在状态下调用autorelease\")；\n    }\n}\n```\n\n废弃 ```NSAutoreleasePool``` 方法 ``` drain``` 实现\n\n\n```mm\n- (void)drain\n{\n    [self dealloc];\n}\n\n- (void)dealloc\n{\n    [self emptyPool];\n    [array release];\n}\n\n- (void)emptyPool\n{\n    for(id obj in array) {\n        [obj release];\n    }\n}\n```\n\n查看 ```AutoreleasePool``` 中的内容\n\n```mm\n[NSAutoreleasePool showPools];//此方法只能在iOS中使用\n```\n在运行时系统中调用方法\n\n```mm\n/* 函数声明 */\nextern void _objc_autoreleasePoolPrint();\n\n/* 调试处调用 */\n_objc_autoreleasePoolPrint();\n```\n\n注：\n(1).上面的内容全部是本人读《Objective-C高级编程 iOS与OS X多线程和内存管理》一书觉得重点的部分，如果大家感兴趣可以支持一下正版。\n(2).如果各位看官觉得有什么事小弟说的不对的地方，欢迎指出。\n(3).这篇基本上都是说引用计数的实现的，还没有涉及到前言提出的问题的解答。\n(4).看到这里的都是真爱啊。\n","source":"_posts/读《iOS与OS X多线程和内存管理》——引用计数.md","raw":"---\ntitle: 读《iOS与OS X多线程和内存管理》——引用计数\ndate: 2017-01-11 11:10:12\ntags: iOS\n---\n\n## 1. 什么是自动引用计数(ARC) ##\n\nARC简而言之就是编译器自动进行内存管理，那为什么不叫\"自动内存管理\"，而叫\"自动引用计数\"，当然是因为内存管理是的方法是通过引用计数实现的\n\n要说自动引用计数，首先要说什么是\"引用计数\"\n\n### 1.1引用计数 ###\n\n什么是引用计数，书中举了一个生活中开关房间灯的例子。\n\n简单的描述一下就是，第一个人来的时候要开灯(创建对象)，最后一个人走的时候要关灯(释放对象)，中间来人走人都不需要开关灯。\n那么办公室里的人数就是引用计数。\n\n### 1.2内存管理的思考方式 ###\n\n内存管理的思考方式总结出来就是下面四点  \n\n注：这里还没到ARC所以还是非ARC\n\n1.自己生成的对象，自己所持有 (指通过```alloc/new/copy/mutableCopy```等创建的对象)\neg:\n\n```mm\nid obj = [NSObject new];\n```\n\n2.非自己生成的对象，自己也能持有 (指持有通过类方法创建的对象)\neg:\n\n```mm\nid obj = [NSArray array];\n[obj retain];\n```\n\n3.不再需要自己持有的对象时释放  (释放对象)\neg:\n\n```mm\nid obj = [[NSObject alloc] init];\n[obj release];  \n```\n4.非自己持有的对象无法释放  (多次释放，或未持有释放）\neg:\n\n```mm\nid obj = [[NSObject alloc] init];\n[obj release];\n[obj release];\n```\n\n\n对象的操作与Objective-C方法的对应\n生成并持有对象------ alloc/new/copy/mutableCopy 等\n持有对象----------- retain\n释放对象----------- release\n废弃对象----------- dealloc\n\n\n## 2.alloc/retain/release/dealloc 实现 ##\n\n书中这个节研究的是alloc/retain/release/dealloc的实现。\n\n讲之前先说一个我不知道的常识，那就是Objective-C的框架，底层的是一个叫Cocoa框架其中包含一个Foundation框架\n\n首先Objective-C内存管理的方法是包含在Cocoa框架中的，这里所说的内存管理是的方法alloc/retain/release/dealloc 指的是 NSObject类的alloc类方法,retain实例方法,release实例方法和dealloc实例方法，但是NSObject类的 Foundation``` 框架没有公开过源码，所以这里使用开源软件GNUstep的框架，一个能和Cocoa框架互换的框架，来理解苹果Cocoa框架的实现。\n\n这里我把代码给大家写出来，供大家参考，但书的作者把有些地方的源码在不改变意思的范围进行了修改\n\n### 2.1 alloc 实现 ###\n\nGNUstep的```alloc```实现：\n\n\n```mm\n+(id)alloc\n{\n    return [self allocWithZone:NSDefaultMallocZone()];\n}\n\n+ (id)allocWithZone:(NSZone *)z\n{\n    return NSAllocateObject (self, 0, z);\n}\n\n/* ------- NSAllocateObject ------- */\nstruct obj_layout {\n    NSUInteger retained;\n};\n\ninline id NSAllocateObject (Class aClass, NSUInteger extraBytes, NSZone *zone)\n{\n    int size = 计算容纳对象所需内存大小；\n    id new = NSZoneMalloc(zone,size);\n    memset(new, 0, size);\n    new = (id)&((struct obj_layout *) new)[1];\n}\n\n/* ----- 简化版alloc ----- */\n+ alloc\n{\n    int size = sizeof(struct obj_layout) + 对象大小;\n    struct obj_layout *p = (struct obj_layout *)calloc(1,size);\n    return(id)(p+1);\n}\n```\n\n简化版的是去掉了 ```NSZone``` 之后的代码，```NSZone``` 是为了防止内存碎片化引入的结构，对内存管理没有影响，所以可以忽略。从简化版的代码中可以看出 ```GNUstep``` 申请的对象的内存比需要的大了 ```sizeof(struct obj_layout)```，这个多出来的空间就是用来存放引用计数的\n\n在非ARC即MRC中是可以通过 ```retainCount``` 查看对象的引用计数的。\n\nretainCount的实现:\n\n```mm\n- (NSUInteger)retainCount\n{\n    return NSExtraRefCount(self) + 1;\n}\n\ninline NSUInteger NSExtraRefCount(id anObject)\n{\n    return((struct obj_layout *) anObject)[-1].retained;\n}\n```\n\n### 2.2 retain 实现 ###\n\nGNUstep的 ```retain``` 实现：\n\n```mm\n- (id)retain\n{\n    NSIncrementExtraRefCount(self);\n    return self;\n}\n\ninline void NSIncrementExtraRefCount(id anObject)\n{\n    if(((struct obj_layout *)anObject)[-1].retained == UINT_MAX -1)\n        抛出异常\n    ((struct obj_layout *)anObject)[-1].retained++;\n}\n```\n\n### 2.3 release 实现 ###\nGNUstep的 ```release``` 实现：\n\n```mm\n- (void)release\n{\n    if(NSDecrementExtraRefCountWasZero(self))\n        [self dealloc];\n}\n\nBOOL NSDecrementExtraRefCountWasZero(id anObject)\n{\n    if(((struct obj_layout *)anObject)[-1].retained == 0){\n        return YES;\n    }else {\n        ((struct obj_layout *)anObject)[-1].retained--;\n        return NO;\n    }\n}\n```\n\n### 2.4dealloc 实现 ###\nGNUstep的```dealloc```实现：\n\n```mm\n- (void)dealloc\n{\n    NSDeallocateObject(self);\n}\n\ninline void NSDeallocateObject(id anObject)\n{\n    struct obj_layout *o = &((struct obj_layout *) anObject)[-1];\n    free(o);\n}\n```\n\n可以看到 ```GNUstep``` 实现引用计数的方法是在变量在内存块头部保存的当前对象的引用计数，默认是0，当调用 ```retainCount``` 时会自动+1，这就说明了自己生成的对象，自己所持有。\n\n\n### 2.5 苹果实现 ###\n苹果由于官方未公开源代码，根据运行时调用的代码可以看出苹果实现引用计数和 ```GNUsetp``` 的主要区别就是 ```GNUsetp``` 将引用计数存放在内存块头，而苹果使用的是散列表（键为内存块地址的散列值）\n\n存放在头部管理引用计数的好处：\n- 代码量少\n- 能够统一管理引用计数用内存块和对象用内存块\n\n用散列表(引用计数表)管理引用计数的好处：\n- 对象用内存块的分配无需考虑内存块头部\n- 引用计数表各记录中存有内存块地址，可从各个记录追溯到各对象的内存块\n\n\n### autorelease ###\n所谓 ```autorelease``` 就是自动释放，原理就是若某自动变量超出其作用域，该自动变量将被自动废弃\n\nGNUstep的 ```autorelease``` 实现：\n\n\n```mm\n- (id)autorelease\n{\n    [NSAutoreleasePool addObject:self];\n}\n\n+ (void) addObject:(id)anObj\n{\n    NSAutoreleasePool *pool = 取得当前NSAutoreleasePool对象\n    if(pool != nil) {\n        [pool addObject:anObj];\n    }else {\n        NSLog(@\"NSAutoreleasePool对象非存在状态下调用autorelease\")；\n    }\n}\n```\n\n废弃 ```NSAutoreleasePool``` 方法 ``` drain``` 实现\n\n\n```mm\n- (void)drain\n{\n    [self dealloc];\n}\n\n- (void)dealloc\n{\n    [self emptyPool];\n    [array release];\n}\n\n- (void)emptyPool\n{\n    for(id obj in array) {\n        [obj release];\n    }\n}\n```\n\n查看 ```AutoreleasePool``` 中的内容\n\n```mm\n[NSAutoreleasePool showPools];//此方法只能在iOS中使用\n```\n在运行时系统中调用方法\n\n```mm\n/* 函数声明 */\nextern void _objc_autoreleasePoolPrint();\n\n/* 调试处调用 */\n_objc_autoreleasePoolPrint();\n```\n\n注：\n(1).上面的内容全部是本人读《Objective-C高级编程 iOS与OS X多线程和内存管理》一书觉得重点的部分，如果大家感兴趣可以支持一下正版。\n(2).如果各位看官觉得有什么事小弟说的不对的地方，欢迎指出。\n(3).这篇基本上都是说引用计数的实现的，还没有涉及到前言提出的问题的解答。\n(4).看到这里的都是真爱啊。\n","slug":"读《iOS与OS X多线程和内存管理》——引用计数","published":1,"updated":"2018-09-04T15:05:21.038Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9slba6000o08ozspgcdhlk","content":"<h2 id=\"1-什么是自动引用计数-ARC\"><a href=\"#1-什么是自动引用计数-ARC\" class=\"headerlink\" title=\"1. 什么是自动引用计数(ARC)\"></a>1. 什么是自动引用计数(ARC)</h2><p>ARC简而言之就是编译器自动进行内存管理，那为什么不叫”自动内存管理”，而叫”自动引用计数”，当然是因为内存管理是的方法是通过引用计数实现的</p>\n<p>要说自动引用计数，首先要说什么是”引用计数”</p>\n<h3 id=\"1-1引用计数\"><a href=\"#1-1引用计数\" class=\"headerlink\" title=\"1.1引用计数\"></a>1.1引用计数</h3><p>什么是引用计数，书中举了一个生活中开关房间灯的例子。</p>\n<p>简单的描述一下就是，第一个人来的时候要开灯(创建对象)，最后一个人走的时候要关灯(释放对象)，中间来人走人都不需要开关灯。<br>那么办公室里的人数就是引用计数。</p>\n<h3 id=\"1-2内存管理的思考方式\"><a href=\"#1-2内存管理的思考方式\" class=\"headerlink\" title=\"1.2内存管理的思考方式\"></a>1.2内存管理的思考方式</h3><p>内存管理的思考方式总结出来就是下面四点  </p>\n<p>注：这里还没到ARC所以还是非ARC</p>\n<p>1.自己生成的对象，自己所持有 (指通过<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eg:</span><br><span class=\"line\"></span><br><span class=\"line\">```mm</span><br><span class=\"line\">id obj = [NSObject new];</span><br></pre></td></tr></table></figure></p>\n<p>2.非自己生成的对象，自己也能持有 (指持有通过类方法创建的对象)<br>eg:</p>\n<figure class=\"highlight mm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">id</span> obj = [<span class=\"built_in\">NSArray</span> array];</span><br><span class=\"line\">[obj <span class=\"keyword\">retain</span>];</span><br></pre></td></tr></table></figure>\n<p>3.不再需要自己持有的对象时释放  (释放对象)<br>eg:</p>\n<figure class=\"highlight mm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">id</span> obj = [[<span class=\"built_in\">NSObject</span> alloc] init];</span><br><span class=\"line\">[obj release];</span><br></pre></td></tr></table></figure>\n<p>4.非自己持有的对象无法释放  (多次释放，或未持有释放）<br>eg:</p>\n<figure class=\"highlight mm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">id</span> obj = [[<span class=\"built_in\">NSObject</span> alloc] init];</span><br><span class=\"line\">[obj release];</span><br><span class=\"line\">[obj release];</span><br></pre></td></tr></table></figure>\n<p>对象的操作与Objective-C方法的对应<br>生成并持有对象—— alloc/new/copy/mutableCopy 等<br>持有对象———– retain<br>释放对象———– release<br>废弃对象———– dealloc</p>\n<h2 id=\"2-alloc-retain-release-dealloc-实现\"><a href=\"#2-alloc-retain-release-dealloc-实现\" class=\"headerlink\" title=\"2.alloc/retain/release/dealloc 实现\"></a>2.alloc/retain/release/dealloc 实现</h2><p>书中这个节研究的是alloc/retain/release/dealloc的实现。</p>\n<p>讲之前先说一个我不知道的常识，那就是Objective-C的框架，底层的是一个叫Cocoa框架其中包含一个Foundation框架</p>\n<p>首先Objective-C内存管理的方法是包含在Cocoa框架中的，这里所说的内存管理是的方法alloc/retain/release/dealloc 指的是 NSObject类的alloc类方法,retain实例方法,release实例方法和dealloc实例方法，但是NSObject类的 Foundation<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">这里我把代码给大家写出来，供大家参考，但书的作者把有些地方的源码在不改变意思的范围进行了修改</span><br><span class=\"line\"></span><br><span class=\"line\">### 2.1 alloc 实现 ###</span><br><span class=\"line\"></span><br><span class=\"line\">GNUstep的```alloc```实现：</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">```mm</span><br><span class=\"line\">+(id)alloc</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return [self allocWithZone:NSDefaultMallocZone()];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (id)allocWithZone:(NSZone *)z</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return NSAllocateObject (self, 0, z);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* ------- NSAllocateObject ------- */</span><br><span class=\"line\">struct obj_layout &#123;</span><br><span class=\"line\">    NSUInteger retained;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">inline id NSAllocateObject (Class aClass, NSUInteger extraBytes, NSZone *zone)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int size = 计算容纳对象所需内存大小；</span><br><span class=\"line\">    id new = NSZoneMalloc(zone,size);</span><br><span class=\"line\">    memset(new, 0, size);</span><br><span class=\"line\">    new = (id)&amp;((struct obj_layout *) new)[1];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* ----- 简化版alloc ----- */</span><br><span class=\"line\">+ alloc</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int size = sizeof(struct obj_layout) + 对象大小;</span><br><span class=\"line\">    struct obj_layout *p = (struct obj_layout *)calloc(1,size);</span><br><span class=\"line\">    return(id)(p+1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>简化版的是去掉了 <figure class=\"highlight plain\"><figcaption><span>之后的代码，```NSZone``` 是为了防止内存碎片化引入的结构，对内存管理没有影响，所以可以忽略。从简化版的代码中可以看出 ```GNUstep``` 申请的对象的内存比需要的大了 ```sizeof(struct obj_layout)```，这个多出来的空间就是用来存放引用计数的</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">在非ARC即MRC中是可以通过 ```retainCount``` 查看对象的引用计数的。</span><br><span class=\"line\"></span><br><span class=\"line\">retainCount的实现:</span><br><span class=\"line\"></span><br><span class=\"line\">```mm</span><br><span class=\"line\">- (NSUInteger)retainCount</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return NSExtraRefCount(self) + 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">inline NSUInteger NSExtraRefCount(id anObject)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return((struct obj_layout *) anObject)[-1].retained;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-2-retain-实现\"><a href=\"#2-2-retain-实现\" class=\"headerlink\" title=\"2.2 retain 实现\"></a>2.2 retain 实现</h3><p>GNUstep的 <figure class=\"highlight plain\"><figcaption><span>实现：</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">```mm</span><br><span class=\"line\">- (id)retain</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSIncrementExtraRefCount(self);</span><br><span class=\"line\">    return self;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">inline void NSIncrementExtraRefCount(id anObject)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if(((struct obj_layout *)anObject)[-1].retained == UINT_MAX -1)</span><br><span class=\"line\">        抛出异常</span><br><span class=\"line\">    ((struct obj_layout *)anObject)[-1].retained++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-3-release-实现\"><a href=\"#2-3-release-实现\" class=\"headerlink\" title=\"2.3 release 实现\"></a>2.3 release 实现</h3><p>GNUstep的 <figure class=\"highlight plain\"><figcaption><span>实现：</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">```mm</span><br><span class=\"line\">- (void)release</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if(NSDecrementExtraRefCountWasZero(self))</span><br><span class=\"line\">        [self dealloc];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">BOOL NSDecrementExtraRefCountWasZero(id anObject)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if(((struct obj_layout *)anObject)[-1].retained == 0)&#123;</span><br><span class=\"line\">        return YES;</span><br><span class=\"line\">    &#125;else &#123;</span><br><span class=\"line\">        ((struct obj_layout *)anObject)[-1].retained--;</span><br><span class=\"line\">        return NO;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-4dealloc-实现\"><a href=\"#2-4dealloc-实现\" class=\"headerlink\" title=\"2.4dealloc 实现\"></a>2.4dealloc 实现</h3><p>GNUstep的<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">```mm</span><br><span class=\"line\">- (void)dealloc</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSDeallocateObject(self);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">inline void NSDeallocateObject(id anObject)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    struct obj_layout *o = &amp;((struct obj_layout *) anObject)[-1];</span><br><span class=\"line\">    free(o);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到 <figure class=\"highlight plain\"><figcaption><span>实现引用计数的方法是在变量在内存块头部保存的当前对象的引用计数，默认是0，当调用 ```retainCount``` 时会自动+1，这就说明了自己生成的对象，自己所持有。</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### 2.5 苹果实现 ###</span><br><span class=\"line\">苹果由于官方未公开源代码，根据运行时调用的代码可以看出苹果实现引用计数和 ```GNUsetp``` 的主要区别就是 ```GNUsetp``` 将引用计数存放在内存块头，而苹果使用的是散列表（键为内存块地址的散列值）</span><br><span class=\"line\"></span><br><span class=\"line\">存放在头部管理引用计数的好处：</span><br><span class=\"line\">- 代码量少</span><br><span class=\"line\">- 能够统一管理引用计数用内存块和对象用内存块</span><br><span class=\"line\"></span><br><span class=\"line\">用散列表(引用计数表)管理引用计数的好处：</span><br><span class=\"line\">- 对象用内存块的分配无需考虑内存块头部</span><br><span class=\"line\">- 引用计数表各记录中存有内存块地址，可从各个记录追溯到各对象的内存块</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### autorelease ###</span><br><span class=\"line\">所谓 ```autorelease``` 就是自动释放，原理就是若某自动变量超出其作用域，该自动变量将被自动废弃</span><br><span class=\"line\"></span><br><span class=\"line\">GNUstep的 ```autorelease``` 实现：</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">```mm</span><br><span class=\"line\">- (id)autorelease</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [NSAutoreleasePool addObject:self];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void) addObject:(id)anObj</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSAutoreleasePool *pool = 取得当前NSAutoreleasePool对象</span><br><span class=\"line\">    if(pool != nil) &#123;</span><br><span class=\"line\">        [pool addObject:anObj];</span><br><span class=\"line\">    &#125;else &#123;</span><br><span class=\"line\">        NSLog(@&quot;NSAutoreleasePool对象非存在状态下调用autorelease&quot;)；</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>废弃 <figure class=\"highlight plain\"><figcaption><span>方法 ``` drain``` 实现</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">```mm</span><br><span class=\"line\">- (void)drain</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [self dealloc];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)dealloc</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [self emptyPool];</span><br><span class=\"line\">    [array release];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)emptyPool</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    for(id obj in array) &#123;</span><br><span class=\"line\">        [obj release];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>查看 <figure class=\"highlight plain\"><figcaption><span>中的内容</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">```mm</span><br><span class=\"line\">[NSAutoreleasePool showPools];//此方法只能在iOS中使用</span><br></pre></td></tr></table></figure></p>\n<p>在运行时系统中调用方法</p>\n<figure class=\"highlight mm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 函数声明 */</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">void</span> _objc_autoreleasePoolPrint();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 调试处调用 */</span></span><br><span class=\"line\">_objc_autoreleasePoolPrint();</span><br></pre></td></tr></table></figure>\n<p>注：<br>(1).上面的内容全部是本人读《Objective-C高级编程 iOS与OS X多线程和内存管理》一书觉得重点的部分，如果大家感兴趣可以支持一下正版。<br>(2).如果各位看官觉得有什么事小弟说的不对的地方，欢迎指出。<br>(3).这篇基本上都是说引用计数的实现的，还没有涉及到前言提出的问题的解答。<br>(4).看到这里的都是真爱啊。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-什么是自动引用计数-ARC\"><a href=\"#1-什么是自动引用计数-ARC\" class=\"headerlink\" title=\"1. 什么是自动引用计数(ARC)\"></a>1. 什么是自动引用计数(ARC)</h2><p>ARC简而言之就是编译器自动进行内存管理，那为什么不叫”自动内存管理”，而叫”自动引用计数”，当然是因为内存管理是的方法是通过引用计数实现的</p>\n<p>要说自动引用计数，首先要说什么是”引用计数”</p>\n<h3 id=\"1-1引用计数\"><a href=\"#1-1引用计数\" class=\"headerlink\" title=\"1.1引用计数\"></a>1.1引用计数</h3><p>什么是引用计数，书中举了一个生活中开关房间灯的例子。</p>\n<p>简单的描述一下就是，第一个人来的时候要开灯(创建对象)，最后一个人走的时候要关灯(释放对象)，中间来人走人都不需要开关灯。<br>那么办公室里的人数就是引用计数。</p>\n<h3 id=\"1-2内存管理的思考方式\"><a href=\"#1-2内存管理的思考方式\" class=\"headerlink\" title=\"1.2内存管理的思考方式\"></a>1.2内存管理的思考方式</h3><p>内存管理的思考方式总结出来就是下面四点  </p>\n<p>注：这里还没到ARC所以还是非ARC</p>\n<p>1.自己生成的对象，自己所持有 (指通过<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eg:</span><br><span class=\"line\"></span><br><span class=\"line\">```mm</span><br><span class=\"line\">id obj = [NSObject new];</span><br></pre></td></tr></table></figure></p>\n<p>2.非自己生成的对象，自己也能持有 (指持有通过类方法创建的对象)<br>eg:</p>\n<figure class=\"highlight mm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">id</span> obj = [<span class=\"built_in\">NSArray</span> array];</span><br><span class=\"line\">[obj <span class=\"keyword\">retain</span>];</span><br></pre></td></tr></table></figure>\n<p>3.不再需要自己持有的对象时释放  (释放对象)<br>eg:</p>\n<figure class=\"highlight mm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">id</span> obj = [[<span class=\"built_in\">NSObject</span> alloc] init];</span><br><span class=\"line\">[obj release];</span><br></pre></td></tr></table></figure>\n<p>4.非自己持有的对象无法释放  (多次释放，或未持有释放）<br>eg:</p>\n<figure class=\"highlight mm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">id</span> obj = [[<span class=\"built_in\">NSObject</span> alloc] init];</span><br><span class=\"line\">[obj release];</span><br><span class=\"line\">[obj release];</span><br></pre></td></tr></table></figure>\n<p>对象的操作与Objective-C方法的对应<br>生成并持有对象—— alloc/new/copy/mutableCopy 等<br>持有对象———– retain<br>释放对象———– release<br>废弃对象———– dealloc</p>\n<h2 id=\"2-alloc-retain-release-dealloc-实现\"><a href=\"#2-alloc-retain-release-dealloc-实现\" class=\"headerlink\" title=\"2.alloc/retain/release/dealloc 实现\"></a>2.alloc/retain/release/dealloc 实现</h2><p>书中这个节研究的是alloc/retain/release/dealloc的实现。</p>\n<p>讲之前先说一个我不知道的常识，那就是Objective-C的框架，底层的是一个叫Cocoa框架其中包含一个Foundation框架</p>\n<p>首先Objective-C内存管理的方法是包含在Cocoa框架中的，这里所说的内存管理是的方法alloc/retain/release/dealloc 指的是 NSObject类的alloc类方法,retain实例方法,release实例方法和dealloc实例方法，但是NSObject类的 Foundation<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">这里我把代码给大家写出来，供大家参考，但书的作者把有些地方的源码在不改变意思的范围进行了修改</span><br><span class=\"line\"></span><br><span class=\"line\">### 2.1 alloc 实现 ###</span><br><span class=\"line\"></span><br><span class=\"line\">GNUstep的```alloc```实现：</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">```mm</span><br><span class=\"line\">+(id)alloc</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return [self allocWithZone:NSDefaultMallocZone()];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (id)allocWithZone:(NSZone *)z</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return NSAllocateObject (self, 0, z);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* ------- NSAllocateObject ------- */</span><br><span class=\"line\">struct obj_layout &#123;</span><br><span class=\"line\">    NSUInteger retained;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">inline id NSAllocateObject (Class aClass, NSUInteger extraBytes, NSZone *zone)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int size = 计算容纳对象所需内存大小；</span><br><span class=\"line\">    id new = NSZoneMalloc(zone,size);</span><br><span class=\"line\">    memset(new, 0, size);</span><br><span class=\"line\">    new = (id)&amp;((struct obj_layout *) new)[1];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* ----- 简化版alloc ----- */</span><br><span class=\"line\">+ alloc</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int size = sizeof(struct obj_layout) + 对象大小;</span><br><span class=\"line\">    struct obj_layout *p = (struct obj_layout *)calloc(1,size);</span><br><span class=\"line\">    return(id)(p+1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>简化版的是去掉了 <figure class=\"highlight plain\"><figcaption><span>之后的代码，```NSZone``` 是为了防止内存碎片化引入的结构，对内存管理没有影响，所以可以忽略。从简化版的代码中可以看出 ```GNUstep``` 申请的对象的内存比需要的大了 ```sizeof(struct obj_layout)```，这个多出来的空间就是用来存放引用计数的</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">在非ARC即MRC中是可以通过 ```retainCount``` 查看对象的引用计数的。</span><br><span class=\"line\"></span><br><span class=\"line\">retainCount的实现:</span><br><span class=\"line\"></span><br><span class=\"line\">```mm</span><br><span class=\"line\">- (NSUInteger)retainCount</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return NSExtraRefCount(self) + 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">inline NSUInteger NSExtraRefCount(id anObject)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return((struct obj_layout *) anObject)[-1].retained;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-2-retain-实现\"><a href=\"#2-2-retain-实现\" class=\"headerlink\" title=\"2.2 retain 实现\"></a>2.2 retain 实现</h3><p>GNUstep的 <figure class=\"highlight plain\"><figcaption><span>实现：</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">```mm</span><br><span class=\"line\">- (id)retain</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSIncrementExtraRefCount(self);</span><br><span class=\"line\">    return self;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">inline void NSIncrementExtraRefCount(id anObject)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if(((struct obj_layout *)anObject)[-1].retained == UINT_MAX -1)</span><br><span class=\"line\">        抛出异常</span><br><span class=\"line\">    ((struct obj_layout *)anObject)[-1].retained++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-3-release-实现\"><a href=\"#2-3-release-实现\" class=\"headerlink\" title=\"2.3 release 实现\"></a>2.3 release 实现</h3><p>GNUstep的 <figure class=\"highlight plain\"><figcaption><span>实现：</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">```mm</span><br><span class=\"line\">- (void)release</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if(NSDecrementExtraRefCountWasZero(self))</span><br><span class=\"line\">        [self dealloc];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">BOOL NSDecrementExtraRefCountWasZero(id anObject)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if(((struct obj_layout *)anObject)[-1].retained == 0)&#123;</span><br><span class=\"line\">        return YES;</span><br><span class=\"line\">    &#125;else &#123;</span><br><span class=\"line\">        ((struct obj_layout *)anObject)[-1].retained--;</span><br><span class=\"line\">        return NO;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"2-4dealloc-实现\"><a href=\"#2-4dealloc-实现\" class=\"headerlink\" title=\"2.4dealloc 实现\"></a>2.4dealloc 实现</h3><p>GNUstep的<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">```mm</span><br><span class=\"line\">- (void)dealloc</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSDeallocateObject(self);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">inline void NSDeallocateObject(id anObject)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    struct obj_layout *o = &amp;((struct obj_layout *) anObject)[-1];</span><br><span class=\"line\">    free(o);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到 <figure class=\"highlight plain\"><figcaption><span>实现引用计数的方法是在变量在内存块头部保存的当前对象的引用计数，默认是0，当调用 ```retainCount``` 时会自动+1，这就说明了自己生成的对象，自己所持有。</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### 2.5 苹果实现 ###</span><br><span class=\"line\">苹果由于官方未公开源代码，根据运行时调用的代码可以看出苹果实现引用计数和 ```GNUsetp``` 的主要区别就是 ```GNUsetp``` 将引用计数存放在内存块头，而苹果使用的是散列表（键为内存块地址的散列值）</span><br><span class=\"line\"></span><br><span class=\"line\">存放在头部管理引用计数的好处：</span><br><span class=\"line\">- 代码量少</span><br><span class=\"line\">- 能够统一管理引用计数用内存块和对象用内存块</span><br><span class=\"line\"></span><br><span class=\"line\">用散列表(引用计数表)管理引用计数的好处：</span><br><span class=\"line\">- 对象用内存块的分配无需考虑内存块头部</span><br><span class=\"line\">- 引用计数表各记录中存有内存块地址，可从各个记录追溯到各对象的内存块</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### autorelease ###</span><br><span class=\"line\">所谓 ```autorelease``` 就是自动释放，原理就是若某自动变量超出其作用域，该自动变量将被自动废弃</span><br><span class=\"line\"></span><br><span class=\"line\">GNUstep的 ```autorelease``` 实现：</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">```mm</span><br><span class=\"line\">- (id)autorelease</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [NSAutoreleasePool addObject:self];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void) addObject:(id)anObj</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSAutoreleasePool *pool = 取得当前NSAutoreleasePool对象</span><br><span class=\"line\">    if(pool != nil) &#123;</span><br><span class=\"line\">        [pool addObject:anObj];</span><br><span class=\"line\">    &#125;else &#123;</span><br><span class=\"line\">        NSLog(@&quot;NSAutoreleasePool对象非存在状态下调用autorelease&quot;)；</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>废弃 <figure class=\"highlight plain\"><figcaption><span>方法 ``` drain``` 实现</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">```mm</span><br><span class=\"line\">- (void)drain</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [self dealloc];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)dealloc</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [self emptyPool];</span><br><span class=\"line\">    [array release];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)emptyPool</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    for(id obj in array) &#123;</span><br><span class=\"line\">        [obj release];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>查看 <figure class=\"highlight plain\"><figcaption><span>中的内容</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">```mm</span><br><span class=\"line\">[NSAutoreleasePool showPools];//此方法只能在iOS中使用</span><br></pre></td></tr></table></figure></p>\n<p>在运行时系统中调用方法</p>\n<figure class=\"highlight mm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 函数声明 */</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">void</span> _objc_autoreleasePoolPrint();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 调试处调用 */</span></span><br><span class=\"line\">_objc_autoreleasePoolPrint();</span><br></pre></td></tr></table></figure>\n<p>注：<br>(1).上面的内容全部是本人读《Objective-C高级编程 iOS与OS X多线程和内存管理》一书觉得重点的部分，如果大家感兴趣可以支持一下正版。<br>(2).如果各位看官觉得有什么事小弟说的不对的地方，欢迎指出。<br>(3).这篇基本上都是说引用计数的实现的，还没有涉及到前言提出的问题的解答。<br>(4).看到这里的都是真爱啊。</p>\n"},{"title":"Learn JavaScript","date":"2017-01-11T03:10:12.000Z","_content":"\n## Equality (相等比较符) ##\n\n```Javascript\nvar foo = 42;\nvar bar = 42;\nvar baz = \"42\";\nvar qux = \"life\";\n```\n定义了四个变量在Javascript中 `==`是用来比较两个值但是不会判断类型故 `foo == baz`返回的值是`true`\n\n使用`==`比较的时候编译器会先把类型转换成相同的类型,再去比较\n\n因此在JavaScript 要是比较不同类型的两个值可以使用`===`这样会先判断类型,如果类型不同就会返回`false`\n\n所以推荐使用`===`比较\n\n<!----- more ----->\n\n注意: 1.`NaN`是个特殊的Number,他与所有其他值都不相等,包括它自己\n```JavaScript\nNaN === NaN ; // false\n```\n唯一能判断NaN的方法是通过isNaN()函数:\n```JavaScript\nisNaN(NaN); // true\n```\n\n2.浮点数的比较:\n```JavaScript\n1/3 === (1 - 2 / 3); //false\n```\n这个结果是正确的,出现这个结果这是因为浮点数在运算过程中会产生误差,计算机无法精确的表示无限小数,所以要比较两个浮点数是否相等,只能计算他们之差的绝对值,看是否小于某个阈值:\n\n```JavaScript\nMath.abs(1/3 - (1 - 2 / 3)) < 0.0000001; //true\n```\n\n\n## Types ##\n\n### numbers\n\nJavaScript中只有一种数字类型 – 64-bit float point,类似于Java中的double类型,所以在JavaScript中1和1.0是相同的值\nnumber可以直接做四则运算，规则和数学一致\n\n### 字符串\n\n字符串是以'单引号'或\"双引号\"括起来的文本,如`'abc'` `\"xyz\"`\n\n注意`' '`和`\" \"`并不是字符串的一部分\n\n如果字符串中包含`'` 就使用`\"\"`把文本包起来,如果字符串中包含`\"` 就需要使用转义字符了`\\`\n\n在多行字符串中换行使用的是`\\n` 但是如果行数太多`\\n`需要写多个,不方便,在JavaScript中又增加了一种表示方法(ES6),就是将多行文本用\\`... \\`括起来,就是键盘上tab键上边的那个按键.\n\n#### 模板字符串\n多个字符串可以使用`+`连接起来.字符串也可以是变量如:\n\n```JavaScript\nvar name = '小王吧';\nvar age = '100';\nvar message = '你好,' + name + ',你现在' + age + '岁';\n```\n同样,如果要连接的变量有很多,使用`+`就会很不方便,在JavaScript中增加了一种模板字符串的表示(ES6):\n\n```JavaScript\nvar name = '小王吧';\nvar age = '101';\nvar message = `${name},你今年${age}岁,是不是?`\n```\n注意:新的表示方法使用的是\\` ,就是新的多行文本使用的符号,就是键盘上`tab`按键上边的那个按键,不能使用`\"\"或''`,那样无法转换变量\n\n#### 字符串操作 ####\n获取字符的长度\n\n```JavaScript\nvar name = 'xiao wang ba.';\nalert(name.length); //13\n```\n\n获取指定位置字符,可以把字符串看成是特殊的数组,对字符串进行下标操作,从0索引开始\n\n```JavaScript\nvar name = 'xiao wang ba.';\nname[0]; //'x'\nname[1]; //'i'\nname[4]; //' '\nname[12];//'.'\nname[13];//undefined 超出范围的索引一律返回undefined\n```\n注意:给字符串的索引赋值不会有报错,也不会有任何效果,字符串也不会改变\n\n改变字符串为大写\n\n```JavaScript\nvar name = 'xiao wang ba.';\nname.toUpperCase(); //返回'XIAO WANG BA.'\n```\n\n改变字符串为小写\n\n```JavaScript\nvar name = 'Xiao Wang Ba.';\nname.toLowerCase(); //返回'xiao wang ba.'\n```\n注意:如果字符串是中文,则没效果\n\n返回字符串出现的位置\n\n```JavaScript\nvar name = 'Xiao Wang Ba.';\nname.indexOf('Wang');//返回5\nname.indexOf('wang');//如果没有找到指定的子串,返回-1\n```\n\n获取字符串中的子串\n\n```JavaScript\nvar name = 'xiao wang ba.';\nname.substring(0,4);//从索引0开始到4(不包括4),返回'xiao'\nname.substring(10);//从索引10开始到结束,返回'ba.'\n```\n\n\n### 布尔值\nJavaScript中的布尔值有`true`和`false`两种值,可以直接用`true`或`false`表示,也可以通过布尔运算计算出来\n\n### null和undefined\n`null`表示一个\"空\"的值,同Java中的`null`,Swift中的nil,Python中的None用法类似.\n`undefined`表示\"未定义\".\nJavaScript设计的时候希望用`null`表示一个空的值,用`undefined`表示值未定义,但是大多数情况下我们都应该用`null`.`undefined`仅仅在判断函数参数是否传递的情况下有用\n\n### 数组\n数组是一组按顺序排列的集合,集合的每个值称为元素.JavaScript的数组可以包括任意数据类型.\n创建方法:\n\n```JavaScript\n[1,2,3.14,\"hello\",null,true]; //推荐使用\n```\n另一种创建方法:\n\n```JavaScript\nnew Array(1,2,3);\n```\n\n获取数组的长度\n\n```JavaScript\nvar arr = [1,2,3.14,\"hello\",null,true];\narr.length;//6\n//可以给数组的长度赋值,改变数组的大小\narr.length = 7;//数组改变为[1,2,3.14,\"hello\",null,true,undefined]\narr.length = 4;//数组改变为[1,2,3.14,\"hello\"]\n```\n\n\n数组可以通过索引来访问每个元素的值,也可以改变索引对应元素的值:\n\n```JavaScript\nvar arr = [1,2,3.14,\"hello\",null,true];\narr[0]; //数组第一个元素,值为1\narr[1] = 10;//修改数组第二个元素的值为10\n```\n\n注意:如果通过索引给数组赋值的时候,索引超过了数组长度,数组会被变大\n\n```JavaScript\nvar arr = ['A', 'B', 'C'];\narr[5] = 'F';//arr会变为['A', 'B', 'C', undefined, undefined, 'F'];\n```\n\n获取对应元素的索引\n\n```JavaScript\nvar arr = [10, 20 ,'30', 'xyz'];\narr.indexOf(10);//元素10的索引是0\narr.indexOf(20);//元素20的索引是1\narr.indexOf(30);//元素30的索引是 -1 因为没有找到元素\narr.indexOf('30');//元素'30'的索引是2\n```\n注意：数字`30`和`'30'`是不同的元素\n\n获取数组中的部分元素\n\n```JavaScript\nvar arr =['A','B','C','D','E','F','G'];\narr.slice(0,3);//从索引0开始,到索引3结束,但不包括索引3:['A','B','C']\narr.slice(3);//从索引3开始到结束:['D','E','F','G']\n\n```\n\n注意:`slice()`的起止参数包括开始索引,不包括结束索引\n如果不给`slice()`传递任何参数,它会从头到尾截取所有元素,这个方法可以复制一个`array`\n\n```JavaScript\nvar arr = ['A','B','C','D','E','F','G'];\nvar aCopy = arr.slice();\naCopy; //['A','B','C','D','E','F','G'];\naCopy === arr; //false\nif(aCopy.toString() === arr.toString()) {\n    alert('一样');//数组相同\n}else {\n    alert('不一样');//数组不同\n}\n```\n注意:`JavaScript`比较两个数组是否相同不能直接使用`===` 要比较两个数组是否相同,需要先把数组转换成字符串,然后再比较\n\n在数组末尾添加或删除若干元素,`push()`和`pop()`\n\n```JavaScript\nvar arr = [1 , 2];\narr.push('A','B'); //返回新的长度为4的数组\narr; //[1,2,'A','B']\narr.pop();//pop()返回'B'\narr; // [1,2,'A']\narr.pop();arr.pop();arr.pop(); //连续pop 3次\narr; //[]\narr.pop(); //空数组继续pop不会报错,而是返回undefined\narr;//[]\n```\n\n在数组头部添加或删除若干元素,`unshift()`和`shift()`\n\n```JavaScript\nvar arr =[1,2];\narr.unshift('A','B');//返回新的长度为4的数组\narr;//['A','B',1,2]\narr.shift();//'A'\narr;//['B',1,2]\narr.shift();arr.shift();arr.shift();//连续shift 3次\narr;//[]\narr.shift();//空数组继续shift不会报错,而是返回undefined\narr;//[]\n```\n\n数组排序\n`sort()`可以对当前数组进行排序,它会直接修改当前的数组元素的位置,直接调用时,会按照默认顺序排序\n\n```JavaScript\nvar arr = ['B','C','A'];\narr.sort();\narr;//['A','B','C']\n```\n注意 在函数中可以自定义排序条件\n\n数组反转\n\n`reverse()`可以把数组的元素反转\n\n```JavaScript\nvar arr = ['A','B','C'];\narr.reverse();\narr;//['three','two','one']\n```\n\n数组修改的\"万能方法\",可以从指定索引开始删除若干元素,然后再从该位置添加若干元素\n\n```JavaScript\nvar arr =['Microsoft','Apple','Yahoo','AOL','Excite','Oracle']\narr.splice(2,3,'Google','Facebook');//从索引2开始删除3个元素,然后再添加两个元素,返回删除的元素['Yahoo','AOL','Excite']\narr.splice(2,2);//只删除不添加,返回['Google','Facebook']\narr;//['Microsoft','Apple','Oracle']\narr.splice(2.0,'Google','Facebook');//只添加,不删除,返回[]\narr;//['Microsoft','Apple','Google','Facebook','Oracle']\n```\n把两个数组连接起来,返回一个新的数组\n\n```JavaScript\nvar arr = ['A','B','C'];\nvar added = arr.concat([1,2,3]);\nadded; //['A','B','C',1,2,3]\nARR;//['A','B','C']\n```\n注意 `concat()`方法并没有修改当前数组,而是返回了一个新的数组\n\n而且`concat()`可以接收任意个元素和数组,并把所有数组自动拆开,添加到新的数组中\n\n```JavaScript\nvar arr = ['A','B','C'];\narr.concat(1,2,[3,4]);//['A','B','C',1,2,3,4]\n```\n\n把数组的每个元素都用指定的字符串连接起来,然后返回字符串\n\n```JavaScript\nvar arr = ['A','B','C',1,2,3];\narr.join('-'); //'A-B-C-1-2-3'\n```\n注意如果数组的元素不是字符串,会自动转换成字符串再连接\n\n多维数组,指的是数组中的某个元素又是一个数组\n\n```JavaScript\nvar arr = [[1,2,3],[400,500,600],'-'];\n```\n\n上述`Array`包含3个元素,其中头两个元素本身也是`Array`\n\n\n### 对象\n对象是一组由键-值组成的无序集合:\n\n```JavaScript\nvar person = {\n\tname: 'XiaoWang',\n\ttags: ['js', 'web', 'mobile'],\n\tage: 12,\n\tcity: 'shanghai',\n\thasCar: false,\n\tzipcode: null\n};\n```\n\nJavaScript用一个`{...}` 表示一个对象,键值对以`xxx: xxx`形式申明,用`,`隔开,最后一个键值对不需要加\n\nJavaScript对象的键都是字符串类型,值可以是任意数据类型,每个键都是对象的一个属性,获取属性的方法:\n\n```JavaScript\nperson.name; // 'XiaoWang'\nperson.zipcode; // null\n```\n注:`var person` 是JavaScript的一个变量,`person`是变量名,变量名是大小写英文,数字,`$`和`_`的组合,且不能用数字开头,也不能使用JavaScript中的关键字\n\n\n#### strict模式\n蛋疼的布兰登在设计JavaScript的时候为了赶工期,并没有强制使用`var`声明变量,如果一个变量没有通过`var`声明就被使用,这个变量就会被自动声明为全局变量\n\n```JavaScript\ni = 10; //i就是一个全局变量\n```\n\n如果在不同的JavaScript文件中,你都使用了同样名字的变量,而且都没有用`var`声明,那么你就麻烦了.\n\n因此,为了给布兰登填坑,ECMA在后续的规范中推出了strict模式,在strict模式下运行JavaScript代码不允许使用没有`var`声明的变量,如果有那么就给你报错\n\n启动strict模式的方法很简单,就是在JavaScript代码的第一行写上:\n\n```JavaScript\n'use strict';\n```\n注:如果你用的是老爷机,你的浏览器太老了,他会自以为是的把上面那就话当做一个字符串语句执行,如果这样的话还是换个最新版的浏览器吧\n\n#### Advanced Operaters (高级运算符)\n取余运算 `x = y % 2`\n累加运算 `a = 5`\n\t\t`c = a++`/Users/YaoWanXin/Desktop/app.html resulets : c = 5 and a = 6\n\t\t`c = ++a` resulets : c = 6 and a = 6\n累减运算 `a = 5`\n\t\t`c = a--` resulets : c = 5 and a = 4\n\t\t`c = --a` resulets : c = 4 and a = 4\n","source":"_posts/JavaScript.md","raw":"---\ntitle: Learn JavaScript\ndate: 2017-01-11 11:10:12\ntags: JavaScript\n---\n\n## Equality (相等比较符) ##\n\n```Javascript\nvar foo = 42;\nvar bar = 42;\nvar baz = \"42\";\nvar qux = \"life\";\n```\n定义了四个变量在Javascript中 `==`是用来比较两个值但是不会判断类型故 `foo == baz`返回的值是`true`\n\n使用`==`比较的时候编译器会先把类型转换成相同的类型,再去比较\n\n因此在JavaScript 要是比较不同类型的两个值可以使用`===`这样会先判断类型,如果类型不同就会返回`false`\n\n所以推荐使用`===`比较\n\n<!----- more ----->\n\n注意: 1.`NaN`是个特殊的Number,他与所有其他值都不相等,包括它自己\n```JavaScript\nNaN === NaN ; // false\n```\n唯一能判断NaN的方法是通过isNaN()函数:\n```JavaScript\nisNaN(NaN); // true\n```\n\n2.浮点数的比较:\n```JavaScript\n1/3 === (1 - 2 / 3); //false\n```\n这个结果是正确的,出现这个结果这是因为浮点数在运算过程中会产生误差,计算机无法精确的表示无限小数,所以要比较两个浮点数是否相等,只能计算他们之差的绝对值,看是否小于某个阈值:\n\n```JavaScript\nMath.abs(1/3 - (1 - 2 / 3)) < 0.0000001; //true\n```\n\n\n## Types ##\n\n### numbers\n\nJavaScript中只有一种数字类型 – 64-bit float point,类似于Java中的double类型,所以在JavaScript中1和1.0是相同的值\nnumber可以直接做四则运算，规则和数学一致\n\n### 字符串\n\n字符串是以'单引号'或\"双引号\"括起来的文本,如`'abc'` `\"xyz\"`\n\n注意`' '`和`\" \"`并不是字符串的一部分\n\n如果字符串中包含`'` 就使用`\"\"`把文本包起来,如果字符串中包含`\"` 就需要使用转义字符了`\\`\n\n在多行字符串中换行使用的是`\\n` 但是如果行数太多`\\n`需要写多个,不方便,在JavaScript中又增加了一种表示方法(ES6),就是将多行文本用\\`... \\`括起来,就是键盘上tab键上边的那个按键.\n\n#### 模板字符串\n多个字符串可以使用`+`连接起来.字符串也可以是变量如:\n\n```JavaScript\nvar name = '小王吧';\nvar age = '100';\nvar message = '你好,' + name + ',你现在' + age + '岁';\n```\n同样,如果要连接的变量有很多,使用`+`就会很不方便,在JavaScript中增加了一种模板字符串的表示(ES6):\n\n```JavaScript\nvar name = '小王吧';\nvar age = '101';\nvar message = `${name},你今年${age}岁,是不是?`\n```\n注意:新的表示方法使用的是\\` ,就是新的多行文本使用的符号,就是键盘上`tab`按键上边的那个按键,不能使用`\"\"或''`,那样无法转换变量\n\n#### 字符串操作 ####\n获取字符的长度\n\n```JavaScript\nvar name = 'xiao wang ba.';\nalert(name.length); //13\n```\n\n获取指定位置字符,可以把字符串看成是特殊的数组,对字符串进行下标操作,从0索引开始\n\n```JavaScript\nvar name = 'xiao wang ba.';\nname[0]; //'x'\nname[1]; //'i'\nname[4]; //' '\nname[12];//'.'\nname[13];//undefined 超出范围的索引一律返回undefined\n```\n注意:给字符串的索引赋值不会有报错,也不会有任何效果,字符串也不会改变\n\n改变字符串为大写\n\n```JavaScript\nvar name = 'xiao wang ba.';\nname.toUpperCase(); //返回'XIAO WANG BA.'\n```\n\n改变字符串为小写\n\n```JavaScript\nvar name = 'Xiao Wang Ba.';\nname.toLowerCase(); //返回'xiao wang ba.'\n```\n注意:如果字符串是中文,则没效果\n\n返回字符串出现的位置\n\n```JavaScript\nvar name = 'Xiao Wang Ba.';\nname.indexOf('Wang');//返回5\nname.indexOf('wang');//如果没有找到指定的子串,返回-1\n```\n\n获取字符串中的子串\n\n```JavaScript\nvar name = 'xiao wang ba.';\nname.substring(0,4);//从索引0开始到4(不包括4),返回'xiao'\nname.substring(10);//从索引10开始到结束,返回'ba.'\n```\n\n\n### 布尔值\nJavaScript中的布尔值有`true`和`false`两种值,可以直接用`true`或`false`表示,也可以通过布尔运算计算出来\n\n### null和undefined\n`null`表示一个\"空\"的值,同Java中的`null`,Swift中的nil,Python中的None用法类似.\n`undefined`表示\"未定义\".\nJavaScript设计的时候希望用`null`表示一个空的值,用`undefined`表示值未定义,但是大多数情况下我们都应该用`null`.`undefined`仅仅在判断函数参数是否传递的情况下有用\n\n### 数组\n数组是一组按顺序排列的集合,集合的每个值称为元素.JavaScript的数组可以包括任意数据类型.\n创建方法:\n\n```JavaScript\n[1,2,3.14,\"hello\",null,true]; //推荐使用\n```\n另一种创建方法:\n\n```JavaScript\nnew Array(1,2,3);\n```\n\n获取数组的长度\n\n```JavaScript\nvar arr = [1,2,3.14,\"hello\",null,true];\narr.length;//6\n//可以给数组的长度赋值,改变数组的大小\narr.length = 7;//数组改变为[1,2,3.14,\"hello\",null,true,undefined]\narr.length = 4;//数组改变为[1,2,3.14,\"hello\"]\n```\n\n\n数组可以通过索引来访问每个元素的值,也可以改变索引对应元素的值:\n\n```JavaScript\nvar arr = [1,2,3.14,\"hello\",null,true];\narr[0]; //数组第一个元素,值为1\narr[1] = 10;//修改数组第二个元素的值为10\n```\n\n注意:如果通过索引给数组赋值的时候,索引超过了数组长度,数组会被变大\n\n```JavaScript\nvar arr = ['A', 'B', 'C'];\narr[5] = 'F';//arr会变为['A', 'B', 'C', undefined, undefined, 'F'];\n```\n\n获取对应元素的索引\n\n```JavaScript\nvar arr = [10, 20 ,'30', 'xyz'];\narr.indexOf(10);//元素10的索引是0\narr.indexOf(20);//元素20的索引是1\narr.indexOf(30);//元素30的索引是 -1 因为没有找到元素\narr.indexOf('30');//元素'30'的索引是2\n```\n注意：数字`30`和`'30'`是不同的元素\n\n获取数组中的部分元素\n\n```JavaScript\nvar arr =['A','B','C','D','E','F','G'];\narr.slice(0,3);//从索引0开始,到索引3结束,但不包括索引3:['A','B','C']\narr.slice(3);//从索引3开始到结束:['D','E','F','G']\n\n```\n\n注意:`slice()`的起止参数包括开始索引,不包括结束索引\n如果不给`slice()`传递任何参数,它会从头到尾截取所有元素,这个方法可以复制一个`array`\n\n```JavaScript\nvar arr = ['A','B','C','D','E','F','G'];\nvar aCopy = arr.slice();\naCopy; //['A','B','C','D','E','F','G'];\naCopy === arr; //false\nif(aCopy.toString() === arr.toString()) {\n    alert('一样');//数组相同\n}else {\n    alert('不一样');//数组不同\n}\n```\n注意:`JavaScript`比较两个数组是否相同不能直接使用`===` 要比较两个数组是否相同,需要先把数组转换成字符串,然后再比较\n\n在数组末尾添加或删除若干元素,`push()`和`pop()`\n\n```JavaScript\nvar arr = [1 , 2];\narr.push('A','B'); //返回新的长度为4的数组\narr; //[1,2,'A','B']\narr.pop();//pop()返回'B'\narr; // [1,2,'A']\narr.pop();arr.pop();arr.pop(); //连续pop 3次\narr; //[]\narr.pop(); //空数组继续pop不会报错,而是返回undefined\narr;//[]\n```\n\n在数组头部添加或删除若干元素,`unshift()`和`shift()`\n\n```JavaScript\nvar arr =[1,2];\narr.unshift('A','B');//返回新的长度为4的数组\narr;//['A','B',1,2]\narr.shift();//'A'\narr;//['B',1,2]\narr.shift();arr.shift();arr.shift();//连续shift 3次\narr;//[]\narr.shift();//空数组继续shift不会报错,而是返回undefined\narr;//[]\n```\n\n数组排序\n`sort()`可以对当前数组进行排序,它会直接修改当前的数组元素的位置,直接调用时,会按照默认顺序排序\n\n```JavaScript\nvar arr = ['B','C','A'];\narr.sort();\narr;//['A','B','C']\n```\n注意 在函数中可以自定义排序条件\n\n数组反转\n\n`reverse()`可以把数组的元素反转\n\n```JavaScript\nvar arr = ['A','B','C'];\narr.reverse();\narr;//['three','two','one']\n```\n\n数组修改的\"万能方法\",可以从指定索引开始删除若干元素,然后再从该位置添加若干元素\n\n```JavaScript\nvar arr =['Microsoft','Apple','Yahoo','AOL','Excite','Oracle']\narr.splice(2,3,'Google','Facebook');//从索引2开始删除3个元素,然后再添加两个元素,返回删除的元素['Yahoo','AOL','Excite']\narr.splice(2,2);//只删除不添加,返回['Google','Facebook']\narr;//['Microsoft','Apple','Oracle']\narr.splice(2.0,'Google','Facebook');//只添加,不删除,返回[]\narr;//['Microsoft','Apple','Google','Facebook','Oracle']\n```\n把两个数组连接起来,返回一个新的数组\n\n```JavaScript\nvar arr = ['A','B','C'];\nvar added = arr.concat([1,2,3]);\nadded; //['A','B','C',1,2,3]\nARR;//['A','B','C']\n```\n注意 `concat()`方法并没有修改当前数组,而是返回了一个新的数组\n\n而且`concat()`可以接收任意个元素和数组,并把所有数组自动拆开,添加到新的数组中\n\n```JavaScript\nvar arr = ['A','B','C'];\narr.concat(1,2,[3,4]);//['A','B','C',1,2,3,4]\n```\n\n把数组的每个元素都用指定的字符串连接起来,然后返回字符串\n\n```JavaScript\nvar arr = ['A','B','C',1,2,3];\narr.join('-'); //'A-B-C-1-2-3'\n```\n注意如果数组的元素不是字符串,会自动转换成字符串再连接\n\n多维数组,指的是数组中的某个元素又是一个数组\n\n```JavaScript\nvar arr = [[1,2,3],[400,500,600],'-'];\n```\n\n上述`Array`包含3个元素,其中头两个元素本身也是`Array`\n\n\n### 对象\n对象是一组由键-值组成的无序集合:\n\n```JavaScript\nvar person = {\n\tname: 'XiaoWang',\n\ttags: ['js', 'web', 'mobile'],\n\tage: 12,\n\tcity: 'shanghai',\n\thasCar: false,\n\tzipcode: null\n};\n```\n\nJavaScript用一个`{...}` 表示一个对象,键值对以`xxx: xxx`形式申明,用`,`隔开,最后一个键值对不需要加\n\nJavaScript对象的键都是字符串类型,值可以是任意数据类型,每个键都是对象的一个属性,获取属性的方法:\n\n```JavaScript\nperson.name; // 'XiaoWang'\nperson.zipcode; // null\n```\n注:`var person` 是JavaScript的一个变量,`person`是变量名,变量名是大小写英文,数字,`$`和`_`的组合,且不能用数字开头,也不能使用JavaScript中的关键字\n\n\n#### strict模式\n蛋疼的布兰登在设计JavaScript的时候为了赶工期,并没有强制使用`var`声明变量,如果一个变量没有通过`var`声明就被使用,这个变量就会被自动声明为全局变量\n\n```JavaScript\ni = 10; //i就是一个全局变量\n```\n\n如果在不同的JavaScript文件中,你都使用了同样名字的变量,而且都没有用`var`声明,那么你就麻烦了.\n\n因此,为了给布兰登填坑,ECMA在后续的规范中推出了strict模式,在strict模式下运行JavaScript代码不允许使用没有`var`声明的变量,如果有那么就给你报错\n\n启动strict模式的方法很简单,就是在JavaScript代码的第一行写上:\n\n```JavaScript\n'use strict';\n```\n注:如果你用的是老爷机,你的浏览器太老了,他会自以为是的把上面那就话当做一个字符串语句执行,如果这样的话还是换个最新版的浏览器吧\n\n#### Advanced Operaters (高级运算符)\n取余运算 `x = y % 2`\n累加运算 `a = 5`\n\t\t`c = a++`/Users/YaoWanXin/Desktop/app.html resulets : c = 5 and a = 6\n\t\t`c = ++a` resulets : c = 6 and a = 6\n累减运算 `a = 5`\n\t\t`c = a--` resulets : c = 5 and a = 4\n\t\t`c = --a` resulets : c = 4 and a = 4\n","slug":"JavaScript","published":1,"updated":"2018-06-10T14:07:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9slbad000v08oz8yks7w24","content":"<h2 id=\"Equality-相等比较符\"><a href=\"#Equality-相等比较符\" class=\"headerlink\" title=\"Equality (相等比较符)\"></a>Equality (相等比较符)</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"number\">42</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"number\">42</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> baz = <span class=\"string\">\"42\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> qux = <span class=\"string\">\"life\"</span>;</span><br></pre></td></tr></table></figure>\n<p>定义了四个变量在Javascript中 <code>==</code>是用来比较两个值但是不会判断类型故 <code>foo == baz</code>返回的值是<code>true</code></p>\n<p>使用<code>==</code>比较的时候编译器会先把类型转换成相同的类型,再去比较</p>\n<p>因此在JavaScript 要是比较不同类型的两个值可以使用<code>===</code>这样会先判断类型,如果类型不同就会返回<code>false</code></p>\n<p>所以推荐使用<code>===</code>比较</p>\n<a id=\"more\"></a>\n<p>注意: 1.<code>NaN</code>是个特殊的Number,他与所有其他值都不相等,包括它自己<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">NaN</span> === <span class=\"literal\">NaN</span> ; <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure></p>\n<p>唯一能判断NaN的方法是通过isNaN()函数:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"literal\">NaN</span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure></p>\n<p>2.浮点数的比较:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>/<span class=\"number\">3</span> === (<span class=\"number\">1</span> - <span class=\"number\">2</span> / <span class=\"number\">3</span>); <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure></p>\n<p>这个结果是正确的,出现这个结果这是因为浮点数在运算过程中会产生误差,计算机无法精确的表示无限小数,所以要比较两个浮点数是否相等,只能计算他们之差的绝对值,看是否小于某个阈值:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Math</span>.abs(<span class=\"number\">1</span>/<span class=\"number\">3</span> - (<span class=\"number\">1</span> - <span class=\"number\">2</span> / <span class=\"number\">3</span>)) &lt; <span class=\"number\">0.0000001</span>; <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Types\"><a href=\"#Types\" class=\"headerlink\" title=\"Types\"></a>Types</h2><h3 id=\"numbers\"><a href=\"#numbers\" class=\"headerlink\" title=\"numbers\"></a>numbers</h3><p>JavaScript中只有一种数字类型 – 64-bit float point,类似于Java中的double类型,所以在JavaScript中1和1.0是相同的值<br>number可以直接做四则运算，规则和数学一致</p>\n<h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><p>字符串是以’单引号’或”双引号”括起来的文本,如<code>&#39;abc&#39;</code> <code>&quot;xyz&quot;</code></p>\n<p>注意<code>&#39; &#39;</code>和<code>&quot; &quot;</code>并不是字符串的一部分</p>\n<p>如果字符串中包含<code>&#39;</code> 就使用<code>&quot;&quot;</code>把文本包起来,如果字符串中包含<code>&quot;</code> 就需要使用转义字符了<code>\\</code></p>\n<p>在多行字符串中换行使用的是<code>\\n</code> 但是如果行数太多<code>\\n</code>需要写多个,不方便,在JavaScript中又增加了一种表示方法(ES6),就是将多行文本用`… `括起来,就是键盘上tab键上边的那个按键.</p>\n<h4 id=\"模板字符串\"><a href=\"#模板字符串\" class=\"headerlink\" title=\"模板字符串\"></a>模板字符串</h4><p>多个字符串可以使用<code>+</code>连接起来.字符串也可以是变量如:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'小王吧'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> age = <span class=\"string\">'100'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> message = <span class=\"string\">'你好,'</span> + name + <span class=\"string\">',你现在'</span> + age + <span class=\"string\">'岁'</span>;</span><br></pre></td></tr></table></figure>\n<p>同样,如果要连接的变量有很多,使用<code>+</code>就会很不方便,在JavaScript中增加了一种模板字符串的表示(ES6):</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'小王吧'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> age = <span class=\"string\">'101'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> message = <span class=\"string\">`<span class=\"subst\">$&#123;name&#125;</span>,你今年<span class=\"subst\">$&#123;age&#125;</span>岁,是不是?`</span></span><br></pre></td></tr></table></figure>\n<p>注意:新的表示方法使用的是` ,就是新的多行文本使用的符号,就是键盘上<code>tab</code>按键上边的那个按键,不能使用<code>&quot;&quot;或&#39;&#39;</code>,那样无法转换变量</p>\n<h4 id=\"字符串操作\"><a href=\"#字符串操作\" class=\"headerlink\" title=\"字符串操作\"></a>字符串操作</h4><p>获取字符的长度</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'xiao wang ba.'</span>;</span><br><span class=\"line\">alert(name.length); <span class=\"comment\">//13</span></span><br></pre></td></tr></table></figure>\n<p>获取指定位置字符,可以把字符串看成是特殊的数组,对字符串进行下标操作,从0索引开始</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'xiao wang ba.'</span>;</span><br><span class=\"line\">name[<span class=\"number\">0</span>]; <span class=\"comment\">//'x'</span></span><br><span class=\"line\">name[<span class=\"number\">1</span>]; <span class=\"comment\">//'i'</span></span><br><span class=\"line\">name[<span class=\"number\">4</span>]; <span class=\"comment\">//' '</span></span><br><span class=\"line\">name[<span class=\"number\">12</span>];<span class=\"comment\">//'.'</span></span><br><span class=\"line\">name[<span class=\"number\">13</span>];<span class=\"comment\">//undefined 超出范围的索引一律返回undefined</span></span><br></pre></td></tr></table></figure>\n<p>注意:给字符串的索引赋值不会有报错,也不会有任何效果,字符串也不会改变</p>\n<p>改变字符串为大写</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'xiao wang ba.'</span>;</span><br><span class=\"line\">name.toUpperCase(); <span class=\"comment\">//返回'XIAO WANG BA.'</span></span><br></pre></td></tr></table></figure>\n<p>改变字符串为小写</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'Xiao Wang Ba.'</span>;</span><br><span class=\"line\">name.toLowerCase(); <span class=\"comment\">//返回'xiao wang ba.'</span></span><br></pre></td></tr></table></figure>\n<p>注意:如果字符串是中文,则没效果</p>\n<p>返回字符串出现的位置</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'Xiao Wang Ba.'</span>;</span><br><span class=\"line\">name.indexOf(<span class=\"string\">'Wang'</span>);<span class=\"comment\">//返回5</span></span><br><span class=\"line\">name.indexOf(<span class=\"string\">'wang'</span>);<span class=\"comment\">//如果没有找到指定的子串,返回-1</span></span><br></pre></td></tr></table></figure>\n<p>获取字符串中的子串</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'xiao wang ba.'</span>;</span><br><span class=\"line\">name.substring(<span class=\"number\">0</span>,<span class=\"number\">4</span>);<span class=\"comment\">//从索引0开始到4(不包括4),返回'xiao'</span></span><br><span class=\"line\">name.substring(<span class=\"number\">10</span>);<span class=\"comment\">//从索引10开始到结束,返回'ba.'</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"布尔值\"><a href=\"#布尔值\" class=\"headerlink\" title=\"布尔值\"></a>布尔值</h3><p>JavaScript中的布尔值有<code>true</code>和<code>false</code>两种值,可以直接用<code>true</code>或<code>false</code>表示,也可以通过布尔运算计算出来</p>\n<h3 id=\"null和undefined\"><a href=\"#null和undefined\" class=\"headerlink\" title=\"null和undefined\"></a>null和undefined</h3><p><code>null</code>表示一个”空”的值,同Java中的<code>null</code>,Swift中的nil,Python中的None用法类似.<br><code>undefined</code>表示”未定义”.<br>JavaScript设计的时候希望用<code>null</code>表示一个空的值,用<code>undefined</code>表示值未定义,但是大多数情况下我们都应该用<code>null</code>.<code>undefined</code>仅仅在判断函数参数是否传递的情况下有用</p>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>数组是一组按顺序排列的集合,集合的每个值称为元素.JavaScript的数组可以包括任意数据类型.<br>创建方法:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3.14</span>,<span class=\"string\">\"hello\"</span>,<span class=\"literal\">null</span>,<span class=\"literal\">true</span>]; <span class=\"comment\">//推荐使用</span></span><br></pre></td></tr></table></figure>\n<p>另一种创建方法:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n<p>获取数组的长度</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3.14</span>,<span class=\"string\">\"hello\"</span>,<span class=\"literal\">null</span>,<span class=\"literal\">true</span>];</span><br><span class=\"line\">arr.length;<span class=\"comment\">//6</span></span><br><span class=\"line\"><span class=\"comment\">//可以给数组的长度赋值,改变数组的大小</span></span><br><span class=\"line\">arr.length = <span class=\"number\">7</span>;<span class=\"comment\">//数组改变为[1,2,3.14,\"hello\",null,true,undefined]</span></span><br><span class=\"line\">arr.length = <span class=\"number\">4</span>;<span class=\"comment\">//数组改变为[1,2,3.14,\"hello\"]</span></span><br></pre></td></tr></table></figure>\n<p>数组可以通过索引来访问每个元素的值,也可以改变索引对应元素的值:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3.14</span>,<span class=\"string\">\"hello\"</span>,<span class=\"literal\">null</span>,<span class=\"literal\">true</span>];</span><br><span class=\"line\">arr[<span class=\"number\">0</span>]; <span class=\"comment\">//数组第一个元素,值为1</span></span><br><span class=\"line\">arr[<span class=\"number\">1</span>] = <span class=\"number\">10</span>;<span class=\"comment\">//修改数组第二个元素的值为10</span></span><br></pre></td></tr></table></figure>\n<p>注意:如果通过索引给数组赋值的时候,索引超过了数组长度,数组会被变大</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>];</span><br><span class=\"line\">arr[<span class=\"number\">5</span>] = <span class=\"string\">'F'</span>;<span class=\"comment\">//arr会变为['A', 'B', 'C', undefined, undefined, 'F'];</span></span><br></pre></td></tr></table></figure>\n<p>获取对应元素的索引</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">10</span>, <span class=\"number\">20</span> ,<span class=\"string\">'30'</span>, <span class=\"string\">'xyz'</span>];</span><br><span class=\"line\">arr.indexOf(<span class=\"number\">10</span>);<span class=\"comment\">//元素10的索引是0</span></span><br><span class=\"line\">arr.indexOf(<span class=\"number\">20</span>);<span class=\"comment\">//元素20的索引是1</span></span><br><span class=\"line\">arr.indexOf(<span class=\"number\">30</span>);<span class=\"comment\">//元素30的索引是 -1 因为没有找到元素</span></span><br><span class=\"line\">arr.indexOf(<span class=\"string\">'30'</span>);<span class=\"comment\">//元素'30'的索引是2</span></span><br></pre></td></tr></table></figure>\n<p>注意：数字<code>30</code>和<code>&#39;30&#39;</code>是不同的元素</p>\n<p>获取数组中的部分元素</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr =[<span class=\"string\">'A'</span>,<span class=\"string\">'B'</span>,<span class=\"string\">'C'</span>,<span class=\"string\">'D'</span>,<span class=\"string\">'E'</span>,<span class=\"string\">'F'</span>,<span class=\"string\">'G'</span>];</span><br><span class=\"line\">arr.slice(<span class=\"number\">0</span>,<span class=\"number\">3</span>);<span class=\"comment\">//从索引0开始,到索引3结束,但不包括索引3:['A','B','C']</span></span><br><span class=\"line\">arr.slice(<span class=\"number\">3</span>);<span class=\"comment\">//从索引3开始到结束:['D','E','F','G']</span></span><br></pre></td></tr></table></figure>\n<p>注意:<code>slice()</code>的起止参数包括开始索引,不包括结束索引<br>如果不给<code>slice()</code>传递任何参数,它会从头到尾截取所有元素,这个方法可以复制一个<code>array</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'A'</span>,<span class=\"string\">'B'</span>,<span class=\"string\">'C'</span>,<span class=\"string\">'D'</span>,<span class=\"string\">'E'</span>,<span class=\"string\">'F'</span>,<span class=\"string\">'G'</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> aCopy = arr.slice();</span><br><span class=\"line\">aCopy; <span class=\"comment\">//['A','B','C','D','E','F','G'];</span></span><br><span class=\"line\">aCopy === arr; <span class=\"comment\">//false</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(aCopy.toString() === arr.toString()) &#123;</span><br><span class=\"line\">    alert(<span class=\"string\">'一样'</span>);<span class=\"comment\">//数组相同</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    alert(<span class=\"string\">'不一样'</span>);<span class=\"comment\">//数组不同</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意:<code>JavaScript</code>比较两个数组是否相同不能直接使用<code>===</code> 要比较两个数组是否相同,需要先把数组转换成字符串,然后再比较</p>\n<p>在数组末尾添加或删除若干元素,<code>push()</code>和<code>pop()</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span> , <span class=\"number\">2</span>];</span><br><span class=\"line\">arr.push(<span class=\"string\">'A'</span>,<span class=\"string\">'B'</span>); <span class=\"comment\">//返回新的长度为4的数组</span></span><br><span class=\"line\">arr; <span class=\"comment\">//[1,2,'A','B']</span></span><br><span class=\"line\">arr.pop();<span class=\"comment\">//pop()返回'B'</span></span><br><span class=\"line\">arr; <span class=\"comment\">// [1,2,'A']</span></span><br><span class=\"line\">arr.pop();arr.pop();arr.pop(); <span class=\"comment\">//连续pop 3次</span></span><br><span class=\"line\">arr; <span class=\"comment\">//[]</span></span><br><span class=\"line\">arr.pop(); <span class=\"comment\">//空数组继续pop不会报错,而是返回undefined</span></span><br><span class=\"line\">arr;<span class=\"comment\">//[]</span></span><br></pre></td></tr></table></figure>\n<p>在数组头部添加或删除若干元素,<code>unshift()</code>和<code>shift()</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr =[<span class=\"number\">1</span>,<span class=\"number\">2</span>];</span><br><span class=\"line\">arr.unshift(<span class=\"string\">'A'</span>,<span class=\"string\">'B'</span>);<span class=\"comment\">//返回新的长度为4的数组</span></span><br><span class=\"line\">arr;<span class=\"comment\">//['A','B',1,2]</span></span><br><span class=\"line\">arr.shift();<span class=\"comment\">//'A'</span></span><br><span class=\"line\">arr;<span class=\"comment\">//['B',1,2]</span></span><br><span class=\"line\">arr.shift();arr.shift();arr.shift();<span class=\"comment\">//连续shift 3次</span></span><br><span class=\"line\">arr;<span class=\"comment\">//[]</span></span><br><span class=\"line\">arr.shift();<span class=\"comment\">//空数组继续shift不会报错,而是返回undefined</span></span><br><span class=\"line\">arr;<span class=\"comment\">//[]</span></span><br></pre></td></tr></table></figure>\n<p>数组排序<br><code>sort()</code>可以对当前数组进行排序,它会直接修改当前的数组元素的位置,直接调用时,会按照默认顺序排序</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'B'</span>,<span class=\"string\">'C'</span>,<span class=\"string\">'A'</span>];</span><br><span class=\"line\">arr.sort();</span><br><span class=\"line\">arr;<span class=\"comment\">//['A','B','C']</span></span><br></pre></td></tr></table></figure>\n<p>注意 在函数中可以自定义排序条件</p>\n<p>数组反转</p>\n<p><code>reverse()</code>可以把数组的元素反转</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'A'</span>,<span class=\"string\">'B'</span>,<span class=\"string\">'C'</span>];</span><br><span class=\"line\">arr.reverse();</span><br><span class=\"line\">arr;<span class=\"comment\">//['three','two','one']</span></span><br></pre></td></tr></table></figure>\n<p>数组修改的”万能方法”,可以从指定索引开始删除若干元素,然后再从该位置添加若干元素</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr =[<span class=\"string\">'Microsoft'</span>,<span class=\"string\">'Apple'</span>,<span class=\"string\">'Yahoo'</span>,<span class=\"string\">'AOL'</span>,<span class=\"string\">'Excite'</span>,<span class=\"string\">'Oracle'</span>]</span><br><span class=\"line\">arr.splice(<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"string\">'Google'</span>,<span class=\"string\">'Facebook'</span>);<span class=\"comment\">//从索引2开始删除3个元素,然后再添加两个元素,返回删除的元素['Yahoo','AOL','Excite']</span></span><br><span class=\"line\">arr.splice(<span class=\"number\">2</span>,<span class=\"number\">2</span>);<span class=\"comment\">//只删除不添加,返回['Google','Facebook']</span></span><br><span class=\"line\">arr;<span class=\"comment\">//['Microsoft','Apple','Oracle']</span></span><br><span class=\"line\">arr.splice(<span class=\"number\">2.0</span>,<span class=\"string\">'Google'</span>,<span class=\"string\">'Facebook'</span>);<span class=\"comment\">//只添加,不删除,返回[]</span></span><br><span class=\"line\">arr;<span class=\"comment\">//['Microsoft','Apple','Google','Facebook','Oracle']</span></span><br></pre></td></tr></table></figure>\n<p>把两个数组连接起来,返回一个新的数组</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'A'</span>,<span class=\"string\">'B'</span>,<span class=\"string\">'C'</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> added = arr.concat([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]);</span><br><span class=\"line\">added; <span class=\"comment\">//['A','B','C',1,2,3]</span></span><br><span class=\"line\">ARR;<span class=\"comment\">//['A','B','C']</span></span><br></pre></td></tr></table></figure>\n<p>注意 <code>concat()</code>方法并没有修改当前数组,而是返回了一个新的数组</p>\n<p>而且<code>concat()</code>可以接收任意个元素和数组,并把所有数组自动拆开,添加到新的数组中</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'A'</span>,<span class=\"string\">'B'</span>,<span class=\"string\">'C'</span>];</span><br><span class=\"line\">arr.concat(<span class=\"number\">1</span>,<span class=\"number\">2</span>,[<span class=\"number\">3</span>,<span class=\"number\">4</span>]);<span class=\"comment\">//['A','B','C',1,2,3,4]</span></span><br></pre></td></tr></table></figure>\n<p>把数组的每个元素都用指定的字符串连接起来,然后返回字符串</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'A'</span>,<span class=\"string\">'B'</span>,<span class=\"string\">'C'</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\">arr.join(<span class=\"string\">'-'</span>); <span class=\"comment\">//'A-B-C-1-2-3'</span></span><br></pre></td></tr></table></figure>\n<p>注意如果数组的元素不是字符串,会自动转换成字符串再连接</p>\n<p>多维数组,指的是数组中的某个元素又是一个数组</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>],[<span class=\"number\">400</span>,<span class=\"number\">500</span>,<span class=\"number\">600</span>],<span class=\"string\">'-'</span>];</span><br></pre></td></tr></table></figure>\n<p>上述<code>Array</code>包含3个元素,其中头两个元素本身也是<code>Array</code></p>\n<h3 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h3><p>对象是一组由键-值组成的无序集合:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">\tname: <span class=\"string\">'XiaoWang'</span>,</span><br><span class=\"line\">\ttags: [<span class=\"string\">'js'</span>, <span class=\"string\">'web'</span>, <span class=\"string\">'mobile'</span>],</span><br><span class=\"line\">\tage: <span class=\"number\">12</span>,</span><br><span class=\"line\">\tcity: <span class=\"string\">'shanghai'</span>,</span><br><span class=\"line\">\thasCar: <span class=\"literal\">false</span>,</span><br><span class=\"line\">\tzipcode: <span class=\"literal\">null</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>JavaScript用一个<code>{...}</code> 表示一个对象,键值对以<code>xxx: xxx</code>形式申明,用<code>,</code>隔开,最后一个键值对不需要加</p>\n<p>JavaScript对象的键都是字符串类型,值可以是任意数据类型,每个键都是对象的一个属性,获取属性的方法:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">person.name; <span class=\"comment\">// 'XiaoWang'</span></span><br><span class=\"line\">person.zipcode; <span class=\"comment\">// null</span></span><br></pre></td></tr></table></figure>\n<p>注:<code>var person</code> 是JavaScript的一个变量,<code>person</code>是变量名,变量名是大小写英文,数字,<code>$</code>和<code>_</code>的组合,且不能用数字开头,也不能使用JavaScript中的关键字</p>\n<h4 id=\"strict模式\"><a href=\"#strict模式\" class=\"headerlink\" title=\"strict模式\"></a>strict模式</h4><p>蛋疼的布兰登在设计JavaScript的时候为了赶工期,并没有强制使用<code>var</code>声明变量,如果一个变量没有通过<code>var</code>声明就被使用,这个变量就会被自动声明为全局变量</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i = <span class=\"number\">10</span>; <span class=\"comment\">//i就是一个全局变量</span></span><br></pre></td></tr></table></figure>\n<p>如果在不同的JavaScript文件中,你都使用了同样名字的变量,而且都没有用<code>var</code>声明,那么你就麻烦了.</p>\n<p>因此,为了给布兰登填坑,ECMA在后续的规范中推出了strict模式,在strict模式下运行JavaScript代码不允许使用没有<code>var</code>声明的变量,如果有那么就给你报错</p>\n<p>启动strict模式的方法很简单,就是在JavaScript代码的第一行写上:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">'use strict'</span>;</span><br></pre></td></tr></table></figure>\n<p>注:如果你用的是老爷机,你的浏览器太老了,他会自以为是的把上面那就话当做一个字符串语句执行,如果这样的话还是换个最新版的浏览器吧</p>\n<h4 id=\"Advanced-Operaters-高级运算符\"><a href=\"#Advanced-Operaters-高级运算符\" class=\"headerlink\" title=\"Advanced Operaters (高级运算符)\"></a>Advanced Operaters (高级运算符)</h4><p>取余运算 <code>x = y % 2</code><br>累加运算 <code>a = 5</code><br>        <code>c = a++</code>/Users/YaoWanXin/Desktop/app.html resulets : c = 5 and a = 6<br>        <code>c = ++a</code> resulets : c = 6 and a = 6<br>累减运算 <code>a = 5</code><br>        <code>c = a--</code> resulets : c = 5 and a = 4<br>        <code>c = --a</code> resulets : c = 4 and a = 4</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Equality-相等比较符\"><a href=\"#Equality-相等比较符\" class=\"headerlink\" title=\"Equality (相等比较符)\"></a>Equality (相等比较符)</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"number\">42</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"number\">42</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> baz = <span class=\"string\">\"42\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> qux = <span class=\"string\">\"life\"</span>;</span><br></pre></td></tr></table></figure>\n<p>定义了四个变量在Javascript中 <code>==</code>是用来比较两个值但是不会判断类型故 <code>foo == baz</code>返回的值是<code>true</code></p>\n<p>使用<code>==</code>比较的时候编译器会先把类型转换成相同的类型,再去比较</p>\n<p>因此在JavaScript 要是比较不同类型的两个值可以使用<code>===</code>这样会先判断类型,如果类型不同就会返回<code>false</code></p>\n<p>所以推荐使用<code>===</code>比较</p>","more":"<p>注意: 1.<code>NaN</code>是个特殊的Number,他与所有其他值都不相等,包括它自己<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">NaN</span> === <span class=\"literal\">NaN</span> ; <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure></p>\n<p>唯一能判断NaN的方法是通过isNaN()函数:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"literal\">NaN</span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure></p>\n<p>2.浮点数的比较:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>/<span class=\"number\">3</span> === (<span class=\"number\">1</span> - <span class=\"number\">2</span> / <span class=\"number\">3</span>); <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure></p>\n<p>这个结果是正确的,出现这个结果这是因为浮点数在运算过程中会产生误差,计算机无法精确的表示无限小数,所以要比较两个浮点数是否相等,只能计算他们之差的绝对值,看是否小于某个阈值:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Math</span>.abs(<span class=\"number\">1</span>/<span class=\"number\">3</span> - (<span class=\"number\">1</span> - <span class=\"number\">2</span> / <span class=\"number\">3</span>)) &lt; <span class=\"number\">0.0000001</span>; <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Types\"><a href=\"#Types\" class=\"headerlink\" title=\"Types\"></a>Types</h2><h3 id=\"numbers\"><a href=\"#numbers\" class=\"headerlink\" title=\"numbers\"></a>numbers</h3><p>JavaScript中只有一种数字类型 – 64-bit float point,类似于Java中的double类型,所以在JavaScript中1和1.0是相同的值<br>number可以直接做四则运算，规则和数学一致</p>\n<h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><p>字符串是以’单引号’或”双引号”括起来的文本,如<code>&#39;abc&#39;</code> <code>&quot;xyz&quot;</code></p>\n<p>注意<code>&#39; &#39;</code>和<code>&quot; &quot;</code>并不是字符串的一部分</p>\n<p>如果字符串中包含<code>&#39;</code> 就使用<code>&quot;&quot;</code>把文本包起来,如果字符串中包含<code>&quot;</code> 就需要使用转义字符了<code>\\</code></p>\n<p>在多行字符串中换行使用的是<code>\\n</code> 但是如果行数太多<code>\\n</code>需要写多个,不方便,在JavaScript中又增加了一种表示方法(ES6),就是将多行文本用`… `括起来,就是键盘上tab键上边的那个按键.</p>\n<h4 id=\"模板字符串\"><a href=\"#模板字符串\" class=\"headerlink\" title=\"模板字符串\"></a>模板字符串</h4><p>多个字符串可以使用<code>+</code>连接起来.字符串也可以是变量如:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'小王吧'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> age = <span class=\"string\">'100'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> message = <span class=\"string\">'你好,'</span> + name + <span class=\"string\">',你现在'</span> + age + <span class=\"string\">'岁'</span>;</span><br></pre></td></tr></table></figure>\n<p>同样,如果要连接的变量有很多,使用<code>+</code>就会很不方便,在JavaScript中增加了一种模板字符串的表示(ES6):</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'小王吧'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> age = <span class=\"string\">'101'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> message = <span class=\"string\">`<span class=\"subst\">$&#123;name&#125;</span>,你今年<span class=\"subst\">$&#123;age&#125;</span>岁,是不是?`</span></span><br></pre></td></tr></table></figure>\n<p>注意:新的表示方法使用的是` ,就是新的多行文本使用的符号,就是键盘上<code>tab</code>按键上边的那个按键,不能使用<code>&quot;&quot;或&#39;&#39;</code>,那样无法转换变量</p>\n<h4 id=\"字符串操作\"><a href=\"#字符串操作\" class=\"headerlink\" title=\"字符串操作\"></a>字符串操作</h4><p>获取字符的长度</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'xiao wang ba.'</span>;</span><br><span class=\"line\">alert(name.length); <span class=\"comment\">//13</span></span><br></pre></td></tr></table></figure>\n<p>获取指定位置字符,可以把字符串看成是特殊的数组,对字符串进行下标操作,从0索引开始</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'xiao wang ba.'</span>;</span><br><span class=\"line\">name[<span class=\"number\">0</span>]; <span class=\"comment\">//'x'</span></span><br><span class=\"line\">name[<span class=\"number\">1</span>]; <span class=\"comment\">//'i'</span></span><br><span class=\"line\">name[<span class=\"number\">4</span>]; <span class=\"comment\">//' '</span></span><br><span class=\"line\">name[<span class=\"number\">12</span>];<span class=\"comment\">//'.'</span></span><br><span class=\"line\">name[<span class=\"number\">13</span>];<span class=\"comment\">//undefined 超出范围的索引一律返回undefined</span></span><br></pre></td></tr></table></figure>\n<p>注意:给字符串的索引赋值不会有报错,也不会有任何效果,字符串也不会改变</p>\n<p>改变字符串为大写</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'xiao wang ba.'</span>;</span><br><span class=\"line\">name.toUpperCase(); <span class=\"comment\">//返回'XIAO WANG BA.'</span></span><br></pre></td></tr></table></figure>\n<p>改变字符串为小写</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'Xiao Wang Ba.'</span>;</span><br><span class=\"line\">name.toLowerCase(); <span class=\"comment\">//返回'xiao wang ba.'</span></span><br></pre></td></tr></table></figure>\n<p>注意:如果字符串是中文,则没效果</p>\n<p>返回字符串出现的位置</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'Xiao Wang Ba.'</span>;</span><br><span class=\"line\">name.indexOf(<span class=\"string\">'Wang'</span>);<span class=\"comment\">//返回5</span></span><br><span class=\"line\">name.indexOf(<span class=\"string\">'wang'</span>);<span class=\"comment\">//如果没有找到指定的子串,返回-1</span></span><br></pre></td></tr></table></figure>\n<p>获取字符串中的子串</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'xiao wang ba.'</span>;</span><br><span class=\"line\">name.substring(<span class=\"number\">0</span>,<span class=\"number\">4</span>);<span class=\"comment\">//从索引0开始到4(不包括4),返回'xiao'</span></span><br><span class=\"line\">name.substring(<span class=\"number\">10</span>);<span class=\"comment\">//从索引10开始到结束,返回'ba.'</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"布尔值\"><a href=\"#布尔值\" class=\"headerlink\" title=\"布尔值\"></a>布尔值</h3><p>JavaScript中的布尔值有<code>true</code>和<code>false</code>两种值,可以直接用<code>true</code>或<code>false</code>表示,也可以通过布尔运算计算出来</p>\n<h3 id=\"null和undefined\"><a href=\"#null和undefined\" class=\"headerlink\" title=\"null和undefined\"></a>null和undefined</h3><p><code>null</code>表示一个”空”的值,同Java中的<code>null</code>,Swift中的nil,Python中的None用法类似.<br><code>undefined</code>表示”未定义”.<br>JavaScript设计的时候希望用<code>null</code>表示一个空的值,用<code>undefined</code>表示值未定义,但是大多数情况下我们都应该用<code>null</code>.<code>undefined</code>仅仅在判断函数参数是否传递的情况下有用</p>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>数组是一组按顺序排列的集合,集合的每个值称为元素.JavaScript的数组可以包括任意数据类型.<br>创建方法:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3.14</span>,<span class=\"string\">\"hello\"</span>,<span class=\"literal\">null</span>,<span class=\"literal\">true</span>]; <span class=\"comment\">//推荐使用</span></span><br></pre></td></tr></table></figure>\n<p>另一种创建方法:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n<p>获取数组的长度</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3.14</span>,<span class=\"string\">\"hello\"</span>,<span class=\"literal\">null</span>,<span class=\"literal\">true</span>];</span><br><span class=\"line\">arr.length;<span class=\"comment\">//6</span></span><br><span class=\"line\"><span class=\"comment\">//可以给数组的长度赋值,改变数组的大小</span></span><br><span class=\"line\">arr.length = <span class=\"number\">7</span>;<span class=\"comment\">//数组改变为[1,2,3.14,\"hello\",null,true,undefined]</span></span><br><span class=\"line\">arr.length = <span class=\"number\">4</span>;<span class=\"comment\">//数组改变为[1,2,3.14,\"hello\"]</span></span><br></pre></td></tr></table></figure>\n<p>数组可以通过索引来访问每个元素的值,也可以改变索引对应元素的值:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3.14</span>,<span class=\"string\">\"hello\"</span>,<span class=\"literal\">null</span>,<span class=\"literal\">true</span>];</span><br><span class=\"line\">arr[<span class=\"number\">0</span>]; <span class=\"comment\">//数组第一个元素,值为1</span></span><br><span class=\"line\">arr[<span class=\"number\">1</span>] = <span class=\"number\">10</span>;<span class=\"comment\">//修改数组第二个元素的值为10</span></span><br></pre></td></tr></table></figure>\n<p>注意:如果通过索引给数组赋值的时候,索引超过了数组长度,数组会被变大</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>];</span><br><span class=\"line\">arr[<span class=\"number\">5</span>] = <span class=\"string\">'F'</span>;<span class=\"comment\">//arr会变为['A', 'B', 'C', undefined, undefined, 'F'];</span></span><br></pre></td></tr></table></figure>\n<p>获取对应元素的索引</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">10</span>, <span class=\"number\">20</span> ,<span class=\"string\">'30'</span>, <span class=\"string\">'xyz'</span>];</span><br><span class=\"line\">arr.indexOf(<span class=\"number\">10</span>);<span class=\"comment\">//元素10的索引是0</span></span><br><span class=\"line\">arr.indexOf(<span class=\"number\">20</span>);<span class=\"comment\">//元素20的索引是1</span></span><br><span class=\"line\">arr.indexOf(<span class=\"number\">30</span>);<span class=\"comment\">//元素30的索引是 -1 因为没有找到元素</span></span><br><span class=\"line\">arr.indexOf(<span class=\"string\">'30'</span>);<span class=\"comment\">//元素'30'的索引是2</span></span><br></pre></td></tr></table></figure>\n<p>注意：数字<code>30</code>和<code>&#39;30&#39;</code>是不同的元素</p>\n<p>获取数组中的部分元素</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr =[<span class=\"string\">'A'</span>,<span class=\"string\">'B'</span>,<span class=\"string\">'C'</span>,<span class=\"string\">'D'</span>,<span class=\"string\">'E'</span>,<span class=\"string\">'F'</span>,<span class=\"string\">'G'</span>];</span><br><span class=\"line\">arr.slice(<span class=\"number\">0</span>,<span class=\"number\">3</span>);<span class=\"comment\">//从索引0开始,到索引3结束,但不包括索引3:['A','B','C']</span></span><br><span class=\"line\">arr.slice(<span class=\"number\">3</span>);<span class=\"comment\">//从索引3开始到结束:['D','E','F','G']</span></span><br></pre></td></tr></table></figure>\n<p>注意:<code>slice()</code>的起止参数包括开始索引,不包括结束索引<br>如果不给<code>slice()</code>传递任何参数,它会从头到尾截取所有元素,这个方法可以复制一个<code>array</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'A'</span>,<span class=\"string\">'B'</span>,<span class=\"string\">'C'</span>,<span class=\"string\">'D'</span>,<span class=\"string\">'E'</span>,<span class=\"string\">'F'</span>,<span class=\"string\">'G'</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> aCopy = arr.slice();</span><br><span class=\"line\">aCopy; <span class=\"comment\">//['A','B','C','D','E','F','G'];</span></span><br><span class=\"line\">aCopy === arr; <span class=\"comment\">//false</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(aCopy.toString() === arr.toString()) &#123;</span><br><span class=\"line\">    alert(<span class=\"string\">'一样'</span>);<span class=\"comment\">//数组相同</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    alert(<span class=\"string\">'不一样'</span>);<span class=\"comment\">//数组不同</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意:<code>JavaScript</code>比较两个数组是否相同不能直接使用<code>===</code> 要比较两个数组是否相同,需要先把数组转换成字符串,然后再比较</p>\n<p>在数组末尾添加或删除若干元素,<code>push()</code>和<code>pop()</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span> , <span class=\"number\">2</span>];</span><br><span class=\"line\">arr.push(<span class=\"string\">'A'</span>,<span class=\"string\">'B'</span>); <span class=\"comment\">//返回新的长度为4的数组</span></span><br><span class=\"line\">arr; <span class=\"comment\">//[1,2,'A','B']</span></span><br><span class=\"line\">arr.pop();<span class=\"comment\">//pop()返回'B'</span></span><br><span class=\"line\">arr; <span class=\"comment\">// [1,2,'A']</span></span><br><span class=\"line\">arr.pop();arr.pop();arr.pop(); <span class=\"comment\">//连续pop 3次</span></span><br><span class=\"line\">arr; <span class=\"comment\">//[]</span></span><br><span class=\"line\">arr.pop(); <span class=\"comment\">//空数组继续pop不会报错,而是返回undefined</span></span><br><span class=\"line\">arr;<span class=\"comment\">//[]</span></span><br></pre></td></tr></table></figure>\n<p>在数组头部添加或删除若干元素,<code>unshift()</code>和<code>shift()</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr =[<span class=\"number\">1</span>,<span class=\"number\">2</span>];</span><br><span class=\"line\">arr.unshift(<span class=\"string\">'A'</span>,<span class=\"string\">'B'</span>);<span class=\"comment\">//返回新的长度为4的数组</span></span><br><span class=\"line\">arr;<span class=\"comment\">//['A','B',1,2]</span></span><br><span class=\"line\">arr.shift();<span class=\"comment\">//'A'</span></span><br><span class=\"line\">arr;<span class=\"comment\">//['B',1,2]</span></span><br><span class=\"line\">arr.shift();arr.shift();arr.shift();<span class=\"comment\">//连续shift 3次</span></span><br><span class=\"line\">arr;<span class=\"comment\">//[]</span></span><br><span class=\"line\">arr.shift();<span class=\"comment\">//空数组继续shift不会报错,而是返回undefined</span></span><br><span class=\"line\">arr;<span class=\"comment\">//[]</span></span><br></pre></td></tr></table></figure>\n<p>数组排序<br><code>sort()</code>可以对当前数组进行排序,它会直接修改当前的数组元素的位置,直接调用时,会按照默认顺序排序</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'B'</span>,<span class=\"string\">'C'</span>,<span class=\"string\">'A'</span>];</span><br><span class=\"line\">arr.sort();</span><br><span class=\"line\">arr;<span class=\"comment\">//['A','B','C']</span></span><br></pre></td></tr></table></figure>\n<p>注意 在函数中可以自定义排序条件</p>\n<p>数组反转</p>\n<p><code>reverse()</code>可以把数组的元素反转</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'A'</span>,<span class=\"string\">'B'</span>,<span class=\"string\">'C'</span>];</span><br><span class=\"line\">arr.reverse();</span><br><span class=\"line\">arr;<span class=\"comment\">//['three','two','one']</span></span><br></pre></td></tr></table></figure>\n<p>数组修改的”万能方法”,可以从指定索引开始删除若干元素,然后再从该位置添加若干元素</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr =[<span class=\"string\">'Microsoft'</span>,<span class=\"string\">'Apple'</span>,<span class=\"string\">'Yahoo'</span>,<span class=\"string\">'AOL'</span>,<span class=\"string\">'Excite'</span>,<span class=\"string\">'Oracle'</span>]</span><br><span class=\"line\">arr.splice(<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"string\">'Google'</span>,<span class=\"string\">'Facebook'</span>);<span class=\"comment\">//从索引2开始删除3个元素,然后再添加两个元素,返回删除的元素['Yahoo','AOL','Excite']</span></span><br><span class=\"line\">arr.splice(<span class=\"number\">2</span>,<span class=\"number\">2</span>);<span class=\"comment\">//只删除不添加,返回['Google','Facebook']</span></span><br><span class=\"line\">arr;<span class=\"comment\">//['Microsoft','Apple','Oracle']</span></span><br><span class=\"line\">arr.splice(<span class=\"number\">2.0</span>,<span class=\"string\">'Google'</span>,<span class=\"string\">'Facebook'</span>);<span class=\"comment\">//只添加,不删除,返回[]</span></span><br><span class=\"line\">arr;<span class=\"comment\">//['Microsoft','Apple','Google','Facebook','Oracle']</span></span><br></pre></td></tr></table></figure>\n<p>把两个数组连接起来,返回一个新的数组</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'A'</span>,<span class=\"string\">'B'</span>,<span class=\"string\">'C'</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> added = arr.concat([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]);</span><br><span class=\"line\">added; <span class=\"comment\">//['A','B','C',1,2,3]</span></span><br><span class=\"line\">ARR;<span class=\"comment\">//['A','B','C']</span></span><br></pre></td></tr></table></figure>\n<p>注意 <code>concat()</code>方法并没有修改当前数组,而是返回了一个新的数组</p>\n<p>而且<code>concat()</code>可以接收任意个元素和数组,并把所有数组自动拆开,添加到新的数组中</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'A'</span>,<span class=\"string\">'B'</span>,<span class=\"string\">'C'</span>];</span><br><span class=\"line\">arr.concat(<span class=\"number\">1</span>,<span class=\"number\">2</span>,[<span class=\"number\">3</span>,<span class=\"number\">4</span>]);<span class=\"comment\">//['A','B','C',1,2,3,4]</span></span><br></pre></td></tr></table></figure>\n<p>把数组的每个元素都用指定的字符串连接起来,然后返回字符串</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'A'</span>,<span class=\"string\">'B'</span>,<span class=\"string\">'C'</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\">arr.join(<span class=\"string\">'-'</span>); <span class=\"comment\">//'A-B-C-1-2-3'</span></span><br></pre></td></tr></table></figure>\n<p>注意如果数组的元素不是字符串,会自动转换成字符串再连接</p>\n<p>多维数组,指的是数组中的某个元素又是一个数组</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>],[<span class=\"number\">400</span>,<span class=\"number\">500</span>,<span class=\"number\">600</span>],<span class=\"string\">'-'</span>];</span><br></pre></td></tr></table></figure>\n<p>上述<code>Array</code>包含3个元素,其中头两个元素本身也是<code>Array</code></p>\n<h3 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h3><p>对象是一组由键-值组成的无序集合:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">\tname: <span class=\"string\">'XiaoWang'</span>,</span><br><span class=\"line\">\ttags: [<span class=\"string\">'js'</span>, <span class=\"string\">'web'</span>, <span class=\"string\">'mobile'</span>],</span><br><span class=\"line\">\tage: <span class=\"number\">12</span>,</span><br><span class=\"line\">\tcity: <span class=\"string\">'shanghai'</span>,</span><br><span class=\"line\">\thasCar: <span class=\"literal\">false</span>,</span><br><span class=\"line\">\tzipcode: <span class=\"literal\">null</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>JavaScript用一个<code>{...}</code> 表示一个对象,键值对以<code>xxx: xxx</code>形式申明,用<code>,</code>隔开,最后一个键值对不需要加</p>\n<p>JavaScript对象的键都是字符串类型,值可以是任意数据类型,每个键都是对象的一个属性,获取属性的方法:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">person.name; <span class=\"comment\">// 'XiaoWang'</span></span><br><span class=\"line\">person.zipcode; <span class=\"comment\">// null</span></span><br></pre></td></tr></table></figure>\n<p>注:<code>var person</code> 是JavaScript的一个变量,<code>person</code>是变量名,变量名是大小写英文,数字,<code>$</code>和<code>_</code>的组合,且不能用数字开头,也不能使用JavaScript中的关键字</p>\n<h4 id=\"strict模式\"><a href=\"#strict模式\" class=\"headerlink\" title=\"strict模式\"></a>strict模式</h4><p>蛋疼的布兰登在设计JavaScript的时候为了赶工期,并没有强制使用<code>var</code>声明变量,如果一个变量没有通过<code>var</code>声明就被使用,这个变量就会被自动声明为全局变量</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i = <span class=\"number\">10</span>; <span class=\"comment\">//i就是一个全局变量</span></span><br></pre></td></tr></table></figure>\n<p>如果在不同的JavaScript文件中,你都使用了同样名字的变量,而且都没有用<code>var</code>声明,那么你就麻烦了.</p>\n<p>因此,为了给布兰登填坑,ECMA在后续的规范中推出了strict模式,在strict模式下运行JavaScript代码不允许使用没有<code>var</code>声明的变量,如果有那么就给你报错</p>\n<p>启动strict模式的方法很简单,就是在JavaScript代码的第一行写上:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">'use strict'</span>;</span><br></pre></td></tr></table></figure>\n<p>注:如果你用的是老爷机,你的浏览器太老了,他会自以为是的把上面那就话当做一个字符串语句执行,如果这样的话还是换个最新版的浏览器吧</p>\n<h4 id=\"Advanced-Operaters-高级运算符\"><a href=\"#Advanced-Operaters-高级运算符\" class=\"headerlink\" title=\"Advanced Operaters (高级运算符)\"></a>Advanced Operaters (高级运算符)</h4><p>取余运算 <code>x = y % 2</code><br>累加运算 <code>a = 5</code><br>        <code>c = a++</code>/Users/YaoWanXin/Desktop/app.html resulets : c = 5 and a = 6<br>        <code>c = ++a</code> resulets : c = 6 and a = 6<br>累减运算 <code>a = 5</code><br>        <code>c = a--</code> resulets : c = 5 and a = 4<br>        <code>c = --a</code> resulets : c = 4 and a = 4</p>"},{"title":"OC使用静态库中的类别","date":"2017-04-05T12:02:30.000Z","_content":"\n## OC中使用静态库中的类别的问题 ##\n\nOC的源文件经过 `clang` 编译首先生成中间代码,接着通过优化生成目标代码(目标代码中包括符号表,标示了此代码中的全局符号和静态符号,还标示了导入符号等),连接器会根据符号表分析各个目标代码之间的调用关系,然后将使用到的代码进行连接和重定位,最后生成可执行文件.\n\n在编译Objective-C源文件到目标文件时,编译器并不知道方法的对应实现,只能在运行时才知道,所以编译器只会为类生成连接符号,不会对类中的方法生成连接符号,由于Category方法并不对应一个新类,所以不会生成连接符号,连接器也不会将Category方法合并到原始的类中,最终导致连接器忽略了Category方法,不会将其连接到可执行文件中.\n\n\n> 在OC使用静态库中的类别,需要设置下面5种方法中的一种\n\n\n## Other Linker Flags 设置 ##\n\n* 1. 通过在Other Linder Flags 添加 `-all\\_load` 它会告诉编译器对”所有文档中的所有对象文件,不管里面的符号有没有被用到,全部都载入”,这样会产生比较大的二进制文件\n\n* 2.通过在Other Linder Flags 添加 `-force\\_load 和指定路径` e.g: `-force\\_load $(SRCROOT)/RHAddressBook/libRHAddressBook.a` 这种方法会只载入指定的归档\n\n* 3.通过在Other Linder Flags 添加 `-ObjC` ,这个标识告诉编译器”如果在文档中发现了OC代码,就把文档载入” \n\n* 4.在Xcode里build setting中的 Perform Single-Object PreLink，如果启用这个选项，所有的对象文件都会被合并成一个单文件（这不是真正的链接，所以叫做预链接），这个对象文件（有时被称做主对象文件(master object file)）被添加到文档中。现在如果主对象文件中的任何符号被认为是“在使用”，整个主对象文件都会被认为在使用，这样它里面的OC部分就会被载入了。因为里面的类都被正常符号化了，所以能使从这样的静态库中使用所有的Category\n\n* 5.最后一种解决方法是在只有Category的源文件里添加Fake symbol。如果你想在运行时使用Category，一定要确保你以某种方法在编译时引用了fake symbol，这会使得对象文件以及它里面的OC代码被载入。例如，它可以是一个有空函数体的函数，也可以是一个被访问的全局变量（例如一个全局的int变量，只要它被读或者写了一次就足够了）。和上面其他的解决方法不一样，这种解决方法可以控制哪些category可以在运行时被编译后的代码使用（可以通过使用这个符号，使它们被链接并变得可用；也可以不使用这个符号，这样链接器就会忽略它）","source":"_posts/OC使用静态库中的类别/OC使用静态库中的类别.md","raw":"---\ntitle: OC使用静态库中的类别\ndate: 2017-04-05 20:02:30\ntags: iOS\n---\n\n## OC中使用静态库中的类别的问题 ##\n\nOC的源文件经过 `clang` 编译首先生成中间代码,接着通过优化生成目标代码(目标代码中包括符号表,标示了此代码中的全局符号和静态符号,还标示了导入符号等),连接器会根据符号表分析各个目标代码之间的调用关系,然后将使用到的代码进行连接和重定位,最后生成可执行文件.\n\n在编译Objective-C源文件到目标文件时,编译器并不知道方法的对应实现,只能在运行时才知道,所以编译器只会为类生成连接符号,不会对类中的方法生成连接符号,由于Category方法并不对应一个新类,所以不会生成连接符号,连接器也不会将Category方法合并到原始的类中,最终导致连接器忽略了Category方法,不会将其连接到可执行文件中.\n\n\n> 在OC使用静态库中的类别,需要设置下面5种方法中的一种\n\n\n## Other Linker Flags 设置 ##\n\n* 1. 通过在Other Linder Flags 添加 `-all\\_load` 它会告诉编译器对”所有文档中的所有对象文件,不管里面的符号有没有被用到,全部都载入”,这样会产生比较大的二进制文件\n\n* 2.通过在Other Linder Flags 添加 `-force\\_load 和指定路径` e.g: `-force\\_load $(SRCROOT)/RHAddressBook/libRHAddressBook.a` 这种方法会只载入指定的归档\n\n* 3.通过在Other Linder Flags 添加 `-ObjC` ,这个标识告诉编译器”如果在文档中发现了OC代码,就把文档载入” \n\n* 4.在Xcode里build setting中的 Perform Single-Object PreLink，如果启用这个选项，所有的对象文件都会被合并成一个单文件（这不是真正的链接，所以叫做预链接），这个对象文件（有时被称做主对象文件(master object file)）被添加到文档中。现在如果主对象文件中的任何符号被认为是“在使用”，整个主对象文件都会被认为在使用，这样它里面的OC部分就会被载入了。因为里面的类都被正常符号化了，所以能使从这样的静态库中使用所有的Category\n\n* 5.最后一种解决方法是在只有Category的源文件里添加Fake symbol。如果你想在运行时使用Category，一定要确保你以某种方法在编译时引用了fake symbol，这会使得对象文件以及它里面的OC代码被载入。例如，它可以是一个有空函数体的函数，也可以是一个被访问的全局变量（例如一个全局的int变量，只要它被读或者写了一次就足够了）。和上面其他的解决方法不一样，这种解决方法可以控制哪些category可以在运行时被编译后的代码使用（可以通过使用这个符号，使它们被链接并变得可用；也可以不使用这个符号，这样链接器就会忽略它）","slug":"OC使用静态库中的类别/OC使用静态库中的类别","published":1,"updated":"2018-12-03T14:55:12.063Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9slbal000y08oz93586gk2","content":"<h2 id=\"OC中使用静态库中的类别的问题\"><a href=\"#OC中使用静态库中的类别的问题\" class=\"headerlink\" title=\"OC中使用静态库中的类别的问题\"></a>OC中使用静态库中的类别的问题</h2><p>OC的源文件经过 <code>clang</code> 编译首先生成中间代码,接着通过优化生成目标代码(目标代码中包括符号表,标示了此代码中的全局符号和静态符号,还标示了导入符号等),连接器会根据符号表分析各个目标代码之间的调用关系,然后将使用到的代码进行连接和重定位,最后生成可执行文件.</p>\n<p>在编译Objective-C源文件到目标文件时,编译器并不知道方法的对应实现,只能在运行时才知道,所以编译器只会为类生成连接符号,不会对类中的方法生成连接符号,由于Category方法并不对应一个新类,所以不会生成连接符号,连接器也不会将Category方法合并到原始的类中,最终导致连接器忽略了Category方法,不会将其连接到可执行文件中.</p>\n<blockquote>\n<p>在OC使用静态库中的类别,需要设置下面5种方法中的一种</p>\n</blockquote>\n<h2 id=\"Other-Linker-Flags-设置\"><a href=\"#Other-Linker-Flags-设置\" class=\"headerlink\" title=\"Other Linker Flags 设置\"></a>Other Linker Flags 设置</h2><ul>\n<li><ol>\n<li>通过在Other Linder Flags 添加 <code>-all\\_load</code> 它会告诉编译器对”所有文档中的所有对象文件,不管里面的符号有没有被用到,全部都载入”,这样会产生比较大的二进制文件</li>\n</ol>\n</li>\n<li><p>2.通过在Other Linder Flags 添加 <code>-force\\_load 和指定路径</code> e.g: <code>-force\\_load $(SRCROOT)/RHAddressBook/libRHAddressBook.a</code> 这种方法会只载入指定的归档</p>\n</li>\n<li><p>3.通过在Other Linder Flags 添加 <code>-ObjC</code> ,这个标识告诉编译器”如果在文档中发现了OC代码,就把文档载入” </p>\n</li>\n<li><p>4.在Xcode里build setting中的 Perform Single-Object PreLink，如果启用这个选项，所有的对象文件都会被合并成一个单文件（这不是真正的链接，所以叫做预链接），这个对象文件（有时被称做主对象文件(master object file)）被添加到文档中。现在如果主对象文件中的任何符号被认为是“在使用”，整个主对象文件都会被认为在使用，这样它里面的OC部分就会被载入了。因为里面的类都被正常符号化了，所以能使从这样的静态库中使用所有的Category</p>\n</li>\n<li><p>5.最后一种解决方法是在只有Category的源文件里添加Fake symbol。如果你想在运行时使用Category，一定要确保你以某种方法在编译时引用了fake symbol，这会使得对象文件以及它里面的OC代码被载入。例如，它可以是一个有空函数体的函数，也可以是一个被访问的全局变量（例如一个全局的int变量，只要它被读或者写了一次就足够了）。和上面其他的解决方法不一样，这种解决方法可以控制哪些category可以在运行时被编译后的代码使用（可以通过使用这个符号，使它们被链接并变得可用；也可以不使用这个符号，这样链接器就会忽略它）</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"OC中使用静态库中的类别的问题\"><a href=\"#OC中使用静态库中的类别的问题\" class=\"headerlink\" title=\"OC中使用静态库中的类别的问题\"></a>OC中使用静态库中的类别的问题</h2><p>OC的源文件经过 <code>clang</code> 编译首先生成中间代码,接着通过优化生成目标代码(目标代码中包括符号表,标示了此代码中的全局符号和静态符号,还标示了导入符号等),连接器会根据符号表分析各个目标代码之间的调用关系,然后将使用到的代码进行连接和重定位,最后生成可执行文件.</p>\n<p>在编译Objective-C源文件到目标文件时,编译器并不知道方法的对应实现,只能在运行时才知道,所以编译器只会为类生成连接符号,不会对类中的方法生成连接符号,由于Category方法并不对应一个新类,所以不会生成连接符号,连接器也不会将Category方法合并到原始的类中,最终导致连接器忽略了Category方法,不会将其连接到可执行文件中.</p>\n<blockquote>\n<p>在OC使用静态库中的类别,需要设置下面5种方法中的一种</p>\n</blockquote>\n<h2 id=\"Other-Linker-Flags-设置\"><a href=\"#Other-Linker-Flags-设置\" class=\"headerlink\" title=\"Other Linker Flags 设置\"></a>Other Linker Flags 设置</h2><ul>\n<li><ol>\n<li>通过在Other Linder Flags 添加 <code>-all\\_load</code> 它会告诉编译器对”所有文档中的所有对象文件,不管里面的符号有没有被用到,全部都载入”,这样会产生比较大的二进制文件</li>\n</ol>\n</li>\n<li><p>2.通过在Other Linder Flags 添加 <code>-force\\_load 和指定路径</code> e.g: <code>-force\\_load $(SRCROOT)/RHAddressBook/libRHAddressBook.a</code> 这种方法会只载入指定的归档</p>\n</li>\n<li><p>3.通过在Other Linder Flags 添加 <code>-ObjC</code> ,这个标识告诉编译器”如果在文档中发现了OC代码,就把文档载入” </p>\n</li>\n<li><p>4.在Xcode里build setting中的 Perform Single-Object PreLink，如果启用这个选项，所有的对象文件都会被合并成一个单文件（这不是真正的链接，所以叫做预链接），这个对象文件（有时被称做主对象文件(master object file)）被添加到文档中。现在如果主对象文件中的任何符号被认为是“在使用”，整个主对象文件都会被认为在使用，这样它里面的OC部分就会被载入了。因为里面的类都被正常符号化了，所以能使从这样的静态库中使用所有的Category</p>\n</li>\n<li><p>5.最后一种解决方法是在只有Category的源文件里添加Fake symbol。如果你想在运行时使用Category，一定要确保你以某种方法在编译时引用了fake symbol，这会使得对象文件以及它里面的OC代码被载入。例如，它可以是一个有空函数体的函数，也可以是一个被访问的全局变量（例如一个全局的int变量，只要它被读或者写了一次就足够了）。和上面其他的解决方法不一样，这种解决方法可以控制哪些category可以在运行时被编译后的代码使用（可以通过使用这个符号，使它们被链接并变得可用；也可以不使用这个符号，这样链接器就会忽略它）</p>\n</li>\n</ul>\n"},{"_content":" # WeView 介绍 #\n \n ## WeView 使用的一个简单的demo ##\n \n ![WeView_demo.png](resources/9AF089FB76B2ADB18C4B3E9423098F77.jpg)\n \n > WeView 是一个用来给iOS界面自动布局的工具库\n \n * WeView 2是iOS Auto Layout 的替代品.\n * WeView 2旨在提供一个\"简单\",\"自然\",\"易描述\",\"易维护\"的方法通过UIKit去创建动态适应的界面\n * WeView 2使用直观的描述性方法来布局,如\"alignment\"(对齐),\"margins\"(边距),\"spacing\" (间距).\n * WeView 2构建在iOS现有的大小和布局机制.\n * WeView 2是轻量级的:不超过5k行代码而且没有别的依赖.\n * WeView 2兼容iOS5及以上版本.\n * WeView 2是免费开源的,遵循\" Apache License Version 2.0\"\n * WeView 2是易学的.\n \n# 为什么使用动态布局 #\n\n> 使用动态布局的原因有很多,不管你使用的是iOS Auto Layout还是WeView.动态布局会让界面做到如下几点:\n\n1. 适应不同的屏幕尺寸\n2. 适应方向的改变(eg:横屏和竖屏)\n3. 适应设计的改变(eg:字体大小的改变,添加或移除子view,改变图片大小等)\n4. 适应文本内容的改变\n5. 适应动态内容的改变(eg:下载完成的内容)\n\n# 为什么使用WeView 2 #\n\n> 摘要: iOS Auto Layout 是一种复杂笨拙效率低下的编码方式\n\n* 概念复杂:在使用iOS Auto Layout的时候,你需要考虑\"约束优先级\",\"约束是否完全\",\"约束是否冲突\"(eg:过约束布局),\"最近共同祖先\"等,这些问题也使代码重构变的复杂\n* 缺乏基准:iOS Auto Layout 是基于一个复杂的约束处理系统,任何view的最终位置和大小都会收受到约束系统中的所有约束的影响,这些约束不需要被他们的父view持有,如果不能理解相邻view的层级就不能进行约束\n* 编码复杂:用iOS Auto Layout布局一个按钮水平居中,底部距离父view20pt\n\n## iOS Auto Layout 代码 ##\n\n```\nUIButton *button = ...;\nUIView *superview = ...;\nNSLayoutConstraint *cn = [NSLayoutConstraint constraintWithItem:button\n                                                      attribute:NSLayoutAttributeCenterX\n                                                      relatedBy:NSLayoutRelationEqual\n                                                         toItem:superview\n                                                      attribute:NSLayoutAttributeCenterX\n                                                     multiplier:1.0\n                                                       constant:0.0];\n[superview addConstraint:cn];\ncn = [NSLayoutConstraint constraintWithItem:button\n                                  attribute:NSLayoutAttributeBottom\n                                  relatedBy:NSLayoutRelationEqual\n                                     toItem:superview\n                                  attribute:NSLayoutAttributeBottom\n                                 multiplier:1.0\n                                   constant:-20.0];\n[superview addConstraint:cn];\n```\n\n## 使用Visual Format Language的Auto Layout ##\n\n```\nUIButton *button = ...;\nUIView *superview = ...;\nNSDictionary *variableMap = NSDictionaryOfVariableBindings(label, superview);\nNSLayoutConstraint *cn = [NSLayoutConstraint constraintsWithVisualFormat:@\"V:[button]-12-[superview]\"\n                                                                 options:0\n                                                                 metrics:nil\n                                                                   views:variableMap];\n[superview addConstraint:cn];\ncn = [NSLayoutConstraint constraintsWithVisualFormat:@\"H:[superview]-(<=1)-[button]\"\n                                             options:NSLayoutFormatAlignAllCenterY\n                                             metrics:nil\n                                               views:variableMap];\n[superview addConstraint:cn];\n```\n\n## 使用WeView ##\n\n```\n#import \"WeView.h\"\n\nUIButton *button = ...; \nWeView *panelView = [[WeView alloc] init]; \n[[[[panelView addSubviewWithCustomLayout:button]\n   setHAlign:H_ALIGN_CENTER]\n  setVAlign:V_ALIGN_BOTTOM]\nsetMargin:20];\n```\n\niOS Auto Layout 在xib中比较有优势,而且xib已经在Xcode5中被显著提高,但是在代码编程中自动布局还是很复杂的\n\nWeView 只能被用作代码编程,但可以被设计的简洁明了,利于维护的代码\n\n\n# 指导 1: 概述 #\n\n略\n\n# 指导 2: 安装 #\n\n添加WeView文件夹到工程中就好.\n\nWeView 2只依赖Foundation ,UIKit 和 Quartz Core库而且需要iOS 5及以上版本\n\n## Headers ##\n\n头文件通常只需要导入 ```#import \"WeView.h\" ```\n\n## Classes ##\n\n* ```WeView``` 容器是核心类,他本身只有添加子view和他们布局的方法\n* ```WeView``` 的布局是由WeViewLayout实现的\n* ```UIView + WeView``` 类别为UIView添加了许多布局属性,用来控制view怎么作为子view布局在他的父view上,这些属性存放在一个关联的对象中,且这个对象只有一个\n\n# 指导 3:术语 #\n\n## View Hierarchy (图层) ##\n\n图层是布局作用的上下文,通常我们只需要关系我们布局view的子view和父view\n\n## Superview & Subviews (父view和子view) ##\n\n在布局上下文中,Superview是父view,而他的子view是Subviews(注意:Superview只有一个但是Subviews是可以有多个的),在使用WeView 2布局的时候,通常父view是一个```WeView```,子View可以是任何类型的UIView\n\nWeView 2工作的时候子View不需要引用任何类或实现任何界面\n\n## Widgets vs. Containers (控件和容器) ##\n\nwidgets(控件) :一个界面上可见的元素 eg:button或label等\n\ncontainers(容器) :通常是一些不可见的view,用来组织结构和布局其他view eg:在HTML中DIVs通常被用作容器,在UIKit中,空白view也通常被使用.WeView 2的核心就是```WeView```容器类,通过给容器添加子view作为内容\n\n## Measurement and Arrangement ##\n\nMeasurement :是view的size推测位置的过程\neg:measurement 类似于```[UIView sizeThatFies:]```方法\n\nArrangement :是view的size决定位置的过程\neg:arrangement 类似于```[UIView layoutSubviews]```方法\n\n## Desired Size ##\n\n有时候view想要一个他们想要的大小.eg:一个button想要大小是icon的大小,或label想要大小是文本的大小.这时候的大小就是view的Desired Size\n\n使用Weview 2的时候我们可以完全放心的忽视 intrinsic size(固有大小)\n\n\n## Frame and Bounds ##\n\nUIViews 使用了两套坐标系统.\nframe :UIView的frame是他在他父view的坐标系统中的大小和位置\nbounds :UIView的bounds是他在他自己的坐标系统中的大小和位置\n\n布局子view的时候是在他的父view的坐标系中操作的,所以操作的是子view的frame.\n\n改变一个view的frame会影响他的bounds,反之也是一样的\n\n\n\n\n\n\n ","source":"_posts/WeView 2 使用翻译/WeView 2 使用翻译.md","raw":" # WeView 介绍 #\n \n ## WeView 使用的一个简单的demo ##\n \n ![WeView_demo.png](resources/9AF089FB76B2ADB18C4B3E9423098F77.jpg)\n \n > WeView 是一个用来给iOS界面自动布局的工具库\n \n * WeView 2是iOS Auto Layout 的替代品.\n * WeView 2旨在提供一个\"简单\",\"自然\",\"易描述\",\"易维护\"的方法通过UIKit去创建动态适应的界面\n * WeView 2使用直观的描述性方法来布局,如\"alignment\"(对齐),\"margins\"(边距),\"spacing\" (间距).\n * WeView 2构建在iOS现有的大小和布局机制.\n * WeView 2是轻量级的:不超过5k行代码而且没有别的依赖.\n * WeView 2兼容iOS5及以上版本.\n * WeView 2是免费开源的,遵循\" Apache License Version 2.0\"\n * WeView 2是易学的.\n \n# 为什么使用动态布局 #\n\n> 使用动态布局的原因有很多,不管你使用的是iOS Auto Layout还是WeView.动态布局会让界面做到如下几点:\n\n1. 适应不同的屏幕尺寸\n2. 适应方向的改变(eg:横屏和竖屏)\n3. 适应设计的改变(eg:字体大小的改变,添加或移除子view,改变图片大小等)\n4. 适应文本内容的改变\n5. 适应动态内容的改变(eg:下载完成的内容)\n\n# 为什么使用WeView 2 #\n\n> 摘要: iOS Auto Layout 是一种复杂笨拙效率低下的编码方式\n\n* 概念复杂:在使用iOS Auto Layout的时候,你需要考虑\"约束优先级\",\"约束是否完全\",\"约束是否冲突\"(eg:过约束布局),\"最近共同祖先\"等,这些问题也使代码重构变的复杂\n* 缺乏基准:iOS Auto Layout 是基于一个复杂的约束处理系统,任何view的最终位置和大小都会收受到约束系统中的所有约束的影响,这些约束不需要被他们的父view持有,如果不能理解相邻view的层级就不能进行约束\n* 编码复杂:用iOS Auto Layout布局一个按钮水平居中,底部距离父view20pt\n\n## iOS Auto Layout 代码 ##\n\n```\nUIButton *button = ...;\nUIView *superview = ...;\nNSLayoutConstraint *cn = [NSLayoutConstraint constraintWithItem:button\n                                                      attribute:NSLayoutAttributeCenterX\n                                                      relatedBy:NSLayoutRelationEqual\n                                                         toItem:superview\n                                                      attribute:NSLayoutAttributeCenterX\n                                                     multiplier:1.0\n                                                       constant:0.0];\n[superview addConstraint:cn];\ncn = [NSLayoutConstraint constraintWithItem:button\n                                  attribute:NSLayoutAttributeBottom\n                                  relatedBy:NSLayoutRelationEqual\n                                     toItem:superview\n                                  attribute:NSLayoutAttributeBottom\n                                 multiplier:1.0\n                                   constant:-20.0];\n[superview addConstraint:cn];\n```\n\n## 使用Visual Format Language的Auto Layout ##\n\n```\nUIButton *button = ...;\nUIView *superview = ...;\nNSDictionary *variableMap = NSDictionaryOfVariableBindings(label, superview);\nNSLayoutConstraint *cn = [NSLayoutConstraint constraintsWithVisualFormat:@\"V:[button]-12-[superview]\"\n                                                                 options:0\n                                                                 metrics:nil\n                                                                   views:variableMap];\n[superview addConstraint:cn];\ncn = [NSLayoutConstraint constraintsWithVisualFormat:@\"H:[superview]-(<=1)-[button]\"\n                                             options:NSLayoutFormatAlignAllCenterY\n                                             metrics:nil\n                                               views:variableMap];\n[superview addConstraint:cn];\n```\n\n## 使用WeView ##\n\n```\n#import \"WeView.h\"\n\nUIButton *button = ...; \nWeView *panelView = [[WeView alloc] init]; \n[[[[panelView addSubviewWithCustomLayout:button]\n   setHAlign:H_ALIGN_CENTER]\n  setVAlign:V_ALIGN_BOTTOM]\nsetMargin:20];\n```\n\niOS Auto Layout 在xib中比较有优势,而且xib已经在Xcode5中被显著提高,但是在代码编程中自动布局还是很复杂的\n\nWeView 只能被用作代码编程,但可以被设计的简洁明了,利于维护的代码\n\n\n# 指导 1: 概述 #\n\n略\n\n# 指导 2: 安装 #\n\n添加WeView文件夹到工程中就好.\n\nWeView 2只依赖Foundation ,UIKit 和 Quartz Core库而且需要iOS 5及以上版本\n\n## Headers ##\n\n头文件通常只需要导入 ```#import \"WeView.h\" ```\n\n## Classes ##\n\n* ```WeView``` 容器是核心类,他本身只有添加子view和他们布局的方法\n* ```WeView``` 的布局是由WeViewLayout实现的\n* ```UIView + WeView``` 类别为UIView添加了许多布局属性,用来控制view怎么作为子view布局在他的父view上,这些属性存放在一个关联的对象中,且这个对象只有一个\n\n# 指导 3:术语 #\n\n## View Hierarchy (图层) ##\n\n图层是布局作用的上下文,通常我们只需要关系我们布局view的子view和父view\n\n## Superview & Subviews (父view和子view) ##\n\n在布局上下文中,Superview是父view,而他的子view是Subviews(注意:Superview只有一个但是Subviews是可以有多个的),在使用WeView 2布局的时候,通常父view是一个```WeView```,子View可以是任何类型的UIView\n\nWeView 2工作的时候子View不需要引用任何类或实现任何界面\n\n## Widgets vs. Containers (控件和容器) ##\n\nwidgets(控件) :一个界面上可见的元素 eg:button或label等\n\ncontainers(容器) :通常是一些不可见的view,用来组织结构和布局其他view eg:在HTML中DIVs通常被用作容器,在UIKit中,空白view也通常被使用.WeView 2的核心就是```WeView```容器类,通过给容器添加子view作为内容\n\n## Measurement and Arrangement ##\n\nMeasurement :是view的size推测位置的过程\neg:measurement 类似于```[UIView sizeThatFies:]```方法\n\nArrangement :是view的size决定位置的过程\neg:arrangement 类似于```[UIView layoutSubviews]```方法\n\n## Desired Size ##\n\n有时候view想要一个他们想要的大小.eg:一个button想要大小是icon的大小,或label想要大小是文本的大小.这时候的大小就是view的Desired Size\n\n使用Weview 2的时候我们可以完全放心的忽视 intrinsic size(固有大小)\n\n\n## Frame and Bounds ##\n\nUIViews 使用了两套坐标系统.\nframe :UIView的frame是他在他父view的坐标系统中的大小和位置\nbounds :UIView的bounds是他在他自己的坐标系统中的大小和位置\n\n布局子view的时候是在他的父view的坐标系中操作的,所以操作的是子view的frame.\n\n改变一个view的frame会影响他的bounds,反之也是一样的\n\n\n\n\n\n\n ","slug":"WeView 2 使用翻译/WeView 2 使用翻译","published":1,"date":"2018-12-03T14:55:12.063Z","updated":"2018-12-03T14:55:12.063Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9slbal000z08oz6smzjj3b","content":"<h1 id=\"WeView-介绍\"><a href=\"#WeView-介绍\" class=\"headerlink\" title=\"WeView 介绍\"></a>WeView 介绍</h1><h2 id=\"WeView-使用的一个简单的demo\"><a href=\"#WeView-使用的一个简单的demo\" class=\"headerlink\" title=\"WeView 使用的一个简单的demo\"></a>WeView 使用的一个简单的demo</h2><p> <img src=\"resources/9AF089FB76B2ADB18C4B3E9423098F77.jpg\" alt=\"WeView_demo.png\"></p>\n<blockquote>\n<p>WeView 是一个用来给iOS界面自动布局的工具库</p>\n</blockquote>\n<ul>\n<li>WeView 2是iOS Auto Layout 的替代品.</li>\n<li>WeView 2旨在提供一个”简单”,”自然”,”易描述”,”易维护”的方法通过UIKit去创建动态适应的界面</li>\n<li>WeView 2使用直观的描述性方法来布局,如”alignment”(对齐),”margins”(边距),”spacing” (间距).</li>\n<li>WeView 2构建在iOS现有的大小和布局机制.</li>\n<li>WeView 2是轻量级的:不超过5k行代码而且没有别的依赖.</li>\n<li>WeView 2兼容iOS5及以上版本.</li>\n<li>WeView 2是免费开源的,遵循” Apache License Version 2.0”</li>\n<li>WeView 2是易学的.</li>\n</ul>\n<h1 id=\"为什么使用动态布局\"><a href=\"#为什么使用动态布局\" class=\"headerlink\" title=\"为什么使用动态布局\"></a>为什么使用动态布局</h1><blockquote>\n<p>使用动态布局的原因有很多,不管你使用的是iOS Auto Layout还是WeView.动态布局会让界面做到如下几点:</p>\n</blockquote>\n<ol>\n<li>适应不同的屏幕尺寸</li>\n<li>适应方向的改变(eg:横屏和竖屏)</li>\n<li>适应设计的改变(eg:字体大小的改变,添加或移除子view,改变图片大小等)</li>\n<li>适应文本内容的改变</li>\n<li>适应动态内容的改变(eg:下载完成的内容)</li>\n</ol>\n<h1 id=\"为什么使用WeView-2\"><a href=\"#为什么使用WeView-2\" class=\"headerlink\" title=\"为什么使用WeView 2\"></a>为什么使用WeView 2</h1><blockquote>\n<p>摘要: iOS Auto Layout 是一种复杂笨拙效率低下的编码方式</p>\n</blockquote>\n<ul>\n<li>概念复杂:在使用iOS Auto Layout的时候,你需要考虑”约束优先级”,”约束是否完全”,”约束是否冲突”(eg:过约束布局),”最近共同祖先”等,这些问题也使代码重构变的复杂</li>\n<li>缺乏基准:iOS Auto Layout 是基于一个复杂的约束处理系统,任何view的最终位置和大小都会收受到约束系统中的所有约束的影响,这些约束不需要被他们的父view持有,如果不能理解相邻view的层级就不能进行约束</li>\n<li>编码复杂:用iOS Auto Layout布局一个按钮水平居中,底部距离父view20pt</li>\n</ul>\n<h2 id=\"iOS-Auto-Layout-代码\"><a href=\"#iOS-Auto-Layout-代码\" class=\"headerlink\" title=\"iOS Auto Layout 代码\"></a>iOS Auto Layout 代码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UIButton *button = ...;</span><br><span class=\"line\">UIView *superview = ...;</span><br><span class=\"line\">NSLayoutConstraint *cn = [NSLayoutConstraint constraintWithItem:button</span><br><span class=\"line\">                                                      attribute:NSLayoutAttributeCenterX</span><br><span class=\"line\">                                                      relatedBy:NSLayoutRelationEqual</span><br><span class=\"line\">                                                         toItem:superview</span><br><span class=\"line\">                                                      attribute:NSLayoutAttributeCenterX</span><br><span class=\"line\">                                                     multiplier:1.0</span><br><span class=\"line\">                                                       constant:0.0];</span><br><span class=\"line\">[superview addConstraint:cn];</span><br><span class=\"line\">cn = [NSLayoutConstraint constraintWithItem:button</span><br><span class=\"line\">                                  attribute:NSLayoutAttributeBottom</span><br><span class=\"line\">                                  relatedBy:NSLayoutRelationEqual</span><br><span class=\"line\">                                     toItem:superview</span><br><span class=\"line\">                                  attribute:NSLayoutAttributeBottom</span><br><span class=\"line\">                                 multiplier:1.0</span><br><span class=\"line\">                                   constant:-20.0];</span><br><span class=\"line\">[superview addConstraint:cn];</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用Visual-Format-Language的Auto-Layout\"><a href=\"#使用Visual-Format-Language的Auto-Layout\" class=\"headerlink\" title=\"使用Visual Format Language的Auto Layout\"></a>使用Visual Format Language的Auto Layout</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UIButton *button = ...;</span><br><span class=\"line\">UIView *superview = ...;</span><br><span class=\"line\">NSDictionary *variableMap = NSDictionaryOfVariableBindings(label, superview);</span><br><span class=\"line\">NSLayoutConstraint *cn = [NSLayoutConstraint constraintsWithVisualFormat:@&quot;V:[button]-12-[superview]&quot;</span><br><span class=\"line\">                                                                 options:0</span><br><span class=\"line\">                                                                 metrics:nil</span><br><span class=\"line\">                                                                   views:variableMap];</span><br><span class=\"line\">[superview addConstraint:cn];</span><br><span class=\"line\">cn = [NSLayoutConstraint constraintsWithVisualFormat:@&quot;H:[superview]-(&lt;=1)-[button]&quot;</span><br><span class=\"line\">                                             options:NSLayoutFormatAlignAllCenterY</span><br><span class=\"line\">                                             metrics:nil</span><br><span class=\"line\">                                               views:variableMap];</span><br><span class=\"line\">[superview addConstraint:cn];</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用WeView\"><a href=\"#使用WeView\" class=\"headerlink\" title=\"使用WeView\"></a>使用WeView</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;WeView.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">UIButton *button = ...; </span><br><span class=\"line\">WeView *panelView = [[WeView alloc] init]; </span><br><span class=\"line\">[[[[panelView addSubviewWithCustomLayout:button]</span><br><span class=\"line\">   setHAlign:H_ALIGN_CENTER]</span><br><span class=\"line\">  setVAlign:V_ALIGN_BOTTOM]</span><br><span class=\"line\">setMargin:20];</span><br></pre></td></tr></table></figure>\n<p>iOS Auto Layout 在xib中比较有优势,而且xib已经在Xcode5中被显著提高,但是在代码编程中自动布局还是很复杂的</p>\n<p>WeView 只能被用作代码编程,但可以被设计的简洁明了,利于维护的代码</p>\n<h1 id=\"指导-1-概述\"><a href=\"#指导-1-概述\" class=\"headerlink\" title=\"指导 1: 概述\"></a>指导 1: 概述</h1><p>略</p>\n<h1 id=\"指导-2-安装\"><a href=\"#指导-2-安装\" class=\"headerlink\" title=\"指导 2: 安装\"></a>指导 2: 安装</h1><p>添加WeView文件夹到工程中就好.</p>\n<p>WeView 2只依赖Foundation ,UIKit 和 Quartz Core库而且需要iOS 5及以上版本</p>\n<h2 id=\"Headers\"><a href=\"#Headers\" class=\"headerlink\" title=\"Headers\"></a>Headers</h2><p>头文件通常只需要导入 <code>#import &quot;WeView.h&quot;</code></p>\n<h2 id=\"Classes\"><a href=\"#Classes\" class=\"headerlink\" title=\"Classes\"></a>Classes</h2><ul>\n<li><code>WeView</code> 容器是核心类,他本身只有添加子view和他们布局的方法</li>\n<li><code>WeView</code> 的布局是由WeViewLayout实现的</li>\n<li><code>UIView + WeView</code> 类别为UIView添加了许多布局属性,用来控制view怎么作为子view布局在他的父view上,这些属性存放在一个关联的对象中,且这个对象只有一个</li>\n</ul>\n<h1 id=\"指导-3-术语\"><a href=\"#指导-3-术语\" class=\"headerlink\" title=\"指导 3:术语\"></a>指导 3:术语</h1><h2 id=\"View-Hierarchy-图层\"><a href=\"#View-Hierarchy-图层\" class=\"headerlink\" title=\"View Hierarchy (图层)\"></a>View Hierarchy (图层)</h2><p>图层是布局作用的上下文,通常我们只需要关系我们布局view的子view和父view</p>\n<h2 id=\"Superview-amp-Subviews-父view和子view\"><a href=\"#Superview-amp-Subviews-父view和子view\" class=\"headerlink\" title=\"Superview &amp; Subviews (父view和子view)\"></a>Superview &amp; Subviews (父view和子view)</h2><p>在布局上下文中,Superview是父view,而他的子view是Subviews(注意:Superview只有一个但是Subviews是可以有多个的),在使用WeView 2布局的时候,通常父view是一个<code>WeView</code>,子View可以是任何类型的UIView</p>\n<p>WeView 2工作的时候子View不需要引用任何类或实现任何界面</p>\n<h2 id=\"Widgets-vs-Containers-控件和容器\"><a href=\"#Widgets-vs-Containers-控件和容器\" class=\"headerlink\" title=\"Widgets vs. Containers (控件和容器)\"></a>Widgets vs. Containers (控件和容器)</h2><p>widgets(控件) :一个界面上可见的元素 eg:button或label等</p>\n<p>containers(容器) :通常是一些不可见的view,用来组织结构和布局其他view eg:在HTML中DIVs通常被用作容器,在UIKit中,空白view也通常被使用.WeView 2的核心就是<code>WeView</code>容器类,通过给容器添加子view作为内容</p>\n<h2 id=\"Measurement-and-Arrangement\"><a href=\"#Measurement-and-Arrangement\" class=\"headerlink\" title=\"Measurement and Arrangement\"></a>Measurement and Arrangement</h2><p>Measurement :是view的size推测位置的过程<br>eg:measurement 类似于<code>[UIView sizeThatFies:]</code>方法</p>\n<p>Arrangement :是view的size决定位置的过程<br>eg:arrangement 类似于<code>[UIView layoutSubviews]</code>方法</p>\n<h2 id=\"Desired-Size\"><a href=\"#Desired-Size\" class=\"headerlink\" title=\"Desired Size\"></a>Desired Size</h2><p>有时候view想要一个他们想要的大小.eg:一个button想要大小是icon的大小,或label想要大小是文本的大小.这时候的大小就是view的Desired Size</p>\n<p>使用Weview 2的时候我们可以完全放心的忽视 intrinsic size(固有大小)</p>\n<h2 id=\"Frame-and-Bounds\"><a href=\"#Frame-and-Bounds\" class=\"headerlink\" title=\"Frame and Bounds\"></a>Frame and Bounds</h2><p>UIViews 使用了两套坐标系统.<br>frame :UIView的frame是他在他父view的坐标系统中的大小和位置<br>bounds :UIView的bounds是他在他自己的坐标系统中的大小和位置</p>\n<p>布局子view的时候是在他的父view的坐标系中操作的,所以操作的是子view的frame.</p>\n<p>改变一个view的frame会影响他的bounds,反之也是一样的</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"WeView-介绍\"><a href=\"#WeView-介绍\" class=\"headerlink\" title=\"WeView 介绍\"></a>WeView 介绍</h1><h2 id=\"WeView-使用的一个简单的demo\"><a href=\"#WeView-使用的一个简单的demo\" class=\"headerlink\" title=\"WeView 使用的一个简单的demo\"></a>WeView 使用的一个简单的demo</h2><p> <img src=\"resources/9AF089FB76B2ADB18C4B3E9423098F77.jpg\" alt=\"WeView_demo.png\"></p>\n<blockquote>\n<p>WeView 是一个用来给iOS界面自动布局的工具库</p>\n</blockquote>\n<ul>\n<li>WeView 2是iOS Auto Layout 的替代品.</li>\n<li>WeView 2旨在提供一个”简单”,”自然”,”易描述”,”易维护”的方法通过UIKit去创建动态适应的界面</li>\n<li>WeView 2使用直观的描述性方法来布局,如”alignment”(对齐),”margins”(边距),”spacing” (间距).</li>\n<li>WeView 2构建在iOS现有的大小和布局机制.</li>\n<li>WeView 2是轻量级的:不超过5k行代码而且没有别的依赖.</li>\n<li>WeView 2兼容iOS5及以上版本.</li>\n<li>WeView 2是免费开源的,遵循” Apache License Version 2.0”</li>\n<li>WeView 2是易学的.</li>\n</ul>\n<h1 id=\"为什么使用动态布局\"><a href=\"#为什么使用动态布局\" class=\"headerlink\" title=\"为什么使用动态布局\"></a>为什么使用动态布局</h1><blockquote>\n<p>使用动态布局的原因有很多,不管你使用的是iOS Auto Layout还是WeView.动态布局会让界面做到如下几点:</p>\n</blockquote>\n<ol>\n<li>适应不同的屏幕尺寸</li>\n<li>适应方向的改变(eg:横屏和竖屏)</li>\n<li>适应设计的改变(eg:字体大小的改变,添加或移除子view,改变图片大小等)</li>\n<li>适应文本内容的改变</li>\n<li>适应动态内容的改变(eg:下载完成的内容)</li>\n</ol>\n<h1 id=\"为什么使用WeView-2\"><a href=\"#为什么使用WeView-2\" class=\"headerlink\" title=\"为什么使用WeView 2\"></a>为什么使用WeView 2</h1><blockquote>\n<p>摘要: iOS Auto Layout 是一种复杂笨拙效率低下的编码方式</p>\n</blockquote>\n<ul>\n<li>概念复杂:在使用iOS Auto Layout的时候,你需要考虑”约束优先级”,”约束是否完全”,”约束是否冲突”(eg:过约束布局),”最近共同祖先”等,这些问题也使代码重构变的复杂</li>\n<li>缺乏基准:iOS Auto Layout 是基于一个复杂的约束处理系统,任何view的最终位置和大小都会收受到约束系统中的所有约束的影响,这些约束不需要被他们的父view持有,如果不能理解相邻view的层级就不能进行约束</li>\n<li>编码复杂:用iOS Auto Layout布局一个按钮水平居中,底部距离父view20pt</li>\n</ul>\n<h2 id=\"iOS-Auto-Layout-代码\"><a href=\"#iOS-Auto-Layout-代码\" class=\"headerlink\" title=\"iOS Auto Layout 代码\"></a>iOS Auto Layout 代码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UIButton *button = ...;</span><br><span class=\"line\">UIView *superview = ...;</span><br><span class=\"line\">NSLayoutConstraint *cn = [NSLayoutConstraint constraintWithItem:button</span><br><span class=\"line\">                                                      attribute:NSLayoutAttributeCenterX</span><br><span class=\"line\">                                                      relatedBy:NSLayoutRelationEqual</span><br><span class=\"line\">                                                         toItem:superview</span><br><span class=\"line\">                                                      attribute:NSLayoutAttributeCenterX</span><br><span class=\"line\">                                                     multiplier:1.0</span><br><span class=\"line\">                                                       constant:0.0];</span><br><span class=\"line\">[superview addConstraint:cn];</span><br><span class=\"line\">cn = [NSLayoutConstraint constraintWithItem:button</span><br><span class=\"line\">                                  attribute:NSLayoutAttributeBottom</span><br><span class=\"line\">                                  relatedBy:NSLayoutRelationEqual</span><br><span class=\"line\">                                     toItem:superview</span><br><span class=\"line\">                                  attribute:NSLayoutAttributeBottom</span><br><span class=\"line\">                                 multiplier:1.0</span><br><span class=\"line\">                                   constant:-20.0];</span><br><span class=\"line\">[superview addConstraint:cn];</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用Visual-Format-Language的Auto-Layout\"><a href=\"#使用Visual-Format-Language的Auto-Layout\" class=\"headerlink\" title=\"使用Visual Format Language的Auto Layout\"></a>使用Visual Format Language的Auto Layout</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UIButton *button = ...;</span><br><span class=\"line\">UIView *superview = ...;</span><br><span class=\"line\">NSDictionary *variableMap = NSDictionaryOfVariableBindings(label, superview);</span><br><span class=\"line\">NSLayoutConstraint *cn = [NSLayoutConstraint constraintsWithVisualFormat:@&quot;V:[button]-12-[superview]&quot;</span><br><span class=\"line\">                                                                 options:0</span><br><span class=\"line\">                                                                 metrics:nil</span><br><span class=\"line\">                                                                   views:variableMap];</span><br><span class=\"line\">[superview addConstraint:cn];</span><br><span class=\"line\">cn = [NSLayoutConstraint constraintsWithVisualFormat:@&quot;H:[superview]-(&lt;=1)-[button]&quot;</span><br><span class=\"line\">                                             options:NSLayoutFormatAlignAllCenterY</span><br><span class=\"line\">                                             metrics:nil</span><br><span class=\"line\">                                               views:variableMap];</span><br><span class=\"line\">[superview addConstraint:cn];</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用WeView\"><a href=\"#使用WeView\" class=\"headerlink\" title=\"使用WeView\"></a>使用WeView</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;WeView.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">UIButton *button = ...; </span><br><span class=\"line\">WeView *panelView = [[WeView alloc] init]; </span><br><span class=\"line\">[[[[panelView addSubviewWithCustomLayout:button]</span><br><span class=\"line\">   setHAlign:H_ALIGN_CENTER]</span><br><span class=\"line\">  setVAlign:V_ALIGN_BOTTOM]</span><br><span class=\"line\">setMargin:20];</span><br></pre></td></tr></table></figure>\n<p>iOS Auto Layout 在xib中比较有优势,而且xib已经在Xcode5中被显著提高,但是在代码编程中自动布局还是很复杂的</p>\n<p>WeView 只能被用作代码编程,但可以被设计的简洁明了,利于维护的代码</p>\n<h1 id=\"指导-1-概述\"><a href=\"#指导-1-概述\" class=\"headerlink\" title=\"指导 1: 概述\"></a>指导 1: 概述</h1><p>略</p>\n<h1 id=\"指导-2-安装\"><a href=\"#指导-2-安装\" class=\"headerlink\" title=\"指导 2: 安装\"></a>指导 2: 安装</h1><p>添加WeView文件夹到工程中就好.</p>\n<p>WeView 2只依赖Foundation ,UIKit 和 Quartz Core库而且需要iOS 5及以上版本</p>\n<h2 id=\"Headers\"><a href=\"#Headers\" class=\"headerlink\" title=\"Headers\"></a>Headers</h2><p>头文件通常只需要导入 <code>#import &quot;WeView.h&quot;</code></p>\n<h2 id=\"Classes\"><a href=\"#Classes\" class=\"headerlink\" title=\"Classes\"></a>Classes</h2><ul>\n<li><code>WeView</code> 容器是核心类,他本身只有添加子view和他们布局的方法</li>\n<li><code>WeView</code> 的布局是由WeViewLayout实现的</li>\n<li><code>UIView + WeView</code> 类别为UIView添加了许多布局属性,用来控制view怎么作为子view布局在他的父view上,这些属性存放在一个关联的对象中,且这个对象只有一个</li>\n</ul>\n<h1 id=\"指导-3-术语\"><a href=\"#指导-3-术语\" class=\"headerlink\" title=\"指导 3:术语\"></a>指导 3:术语</h1><h2 id=\"View-Hierarchy-图层\"><a href=\"#View-Hierarchy-图层\" class=\"headerlink\" title=\"View Hierarchy (图层)\"></a>View Hierarchy (图层)</h2><p>图层是布局作用的上下文,通常我们只需要关系我们布局view的子view和父view</p>\n<h2 id=\"Superview-amp-Subviews-父view和子view\"><a href=\"#Superview-amp-Subviews-父view和子view\" class=\"headerlink\" title=\"Superview &amp; Subviews (父view和子view)\"></a>Superview &amp; Subviews (父view和子view)</h2><p>在布局上下文中,Superview是父view,而他的子view是Subviews(注意:Superview只有一个但是Subviews是可以有多个的),在使用WeView 2布局的时候,通常父view是一个<code>WeView</code>,子View可以是任何类型的UIView</p>\n<p>WeView 2工作的时候子View不需要引用任何类或实现任何界面</p>\n<h2 id=\"Widgets-vs-Containers-控件和容器\"><a href=\"#Widgets-vs-Containers-控件和容器\" class=\"headerlink\" title=\"Widgets vs. Containers (控件和容器)\"></a>Widgets vs. Containers (控件和容器)</h2><p>widgets(控件) :一个界面上可见的元素 eg:button或label等</p>\n<p>containers(容器) :通常是一些不可见的view,用来组织结构和布局其他view eg:在HTML中DIVs通常被用作容器,在UIKit中,空白view也通常被使用.WeView 2的核心就是<code>WeView</code>容器类,通过给容器添加子view作为内容</p>\n<h2 id=\"Measurement-and-Arrangement\"><a href=\"#Measurement-and-Arrangement\" class=\"headerlink\" title=\"Measurement and Arrangement\"></a>Measurement and Arrangement</h2><p>Measurement :是view的size推测位置的过程<br>eg:measurement 类似于<code>[UIView sizeThatFies:]</code>方法</p>\n<p>Arrangement :是view的size决定位置的过程<br>eg:arrangement 类似于<code>[UIView layoutSubviews]</code>方法</p>\n<h2 id=\"Desired-Size\"><a href=\"#Desired-Size\" class=\"headerlink\" title=\"Desired Size\"></a>Desired Size</h2><p>有时候view想要一个他们想要的大小.eg:一个button想要大小是icon的大小,或label想要大小是文本的大小.这时候的大小就是view的Desired Size</p>\n<p>使用Weview 2的时候我们可以完全放心的忽视 intrinsic size(固有大小)</p>\n<h2 id=\"Frame-and-Bounds\"><a href=\"#Frame-and-Bounds\" class=\"headerlink\" title=\"Frame and Bounds\"></a>Frame and Bounds</h2><p>UIViews 使用了两套坐标系统.<br>frame :UIView的frame是他在他父view的坐标系统中的大小和位置<br>bounds :UIView的bounds是他在他自己的坐标系统中的大小和位置</p>\n<p>布局子view的时候是在他的父view的坐标系中操作的,所以操作的是子view的frame.</p>\n<p>改变一个view的frame会影响他的bounds,反之也是一样的</p>\n"},{"_content":"## 原因 ##\n\n这是因为Xcode8引进的新的安全机制, Code signing不允许app的bundle里面的文件有未知的文件系统扩展属性\n\n## 解决方法 ##\n在终端中输入 `xattr -lr <path_to_app_bundle>` 可以查看存在未知扩展属性的文件\n\n在终端中输入 `xattr -cr <path_to_app_bundle>` 可以移除所有未知的扩展属性\n\n然后清理Xcode 重新build 工程","source":"_posts/Xcode8 报错resource fork, Finder information, or similar detritus not allowed/Xcode8 报错resource fork, Finder information, or similar detritus not allowed.md","raw":"## 原因 ##\n\n这是因为Xcode8引进的新的安全机制, Code signing不允许app的bundle里面的文件有未知的文件系统扩展属性\n\n## 解决方法 ##\n在终端中输入 `xattr -lr <path_to_app_bundle>` 可以查看存在未知扩展属性的文件\n\n在终端中输入 `xattr -cr <path_to_app_bundle>` 可以移除所有未知的扩展属性\n\n然后清理Xcode 重新build 工程","slug":"Xcode8 报错resource fork, Finder information, or similar detritus not allowed/Xcode8 报错resource fork, Finder information, or similar detritus not allowed","published":1,"date":"2018-12-03T14:55:12.064Z","updated":"2018-12-03T14:55:12.064Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9slbam001108oz0sm3hrbb","content":"<h2 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h2><p>这是因为Xcode8引进的新的安全机制, Code signing不允许app的bundle里面的文件有未知的文件系统扩展属性</p>\n<h2 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h2><p>在终端中输入 <code>xattr -lr &lt;path_to_app_bundle&gt;</code> 可以查看存在未知扩展属性的文件</p>\n<p>在终端中输入 <code>xattr -cr &lt;path_to_app_bundle&gt;</code> 可以移除所有未知的扩展属性</p>\n<p>然后清理Xcode 重新build 工程</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h2><p>这是因为Xcode8引进的新的安全机制, Code signing不允许app的bundle里面的文件有未知的文件系统扩展属性</p>\n<h2 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h2><p>在终端中输入 <code>xattr -lr &lt;path_to_app_bundle&gt;</code> 可以查看存在未知扩展属性的文件</p>\n<p>在终端中输入 <code>xattr -cr &lt;path_to_app_bundle&gt;</code> 可以移除所有未知的扩展属性</p>\n<p>然后清理Xcode 重新build 工程</p>\n"},{"_content":"## NSObject 类的alloc方法执行过程 ##\n\n当一个NSObject类调用了 `alloc` 类方法,其内部的调用顺序是 \n\n1.+alloc\n\n2.+allocWithZone:\n\n3.class_createInstance\n\n4.calloc\n\n## retainCount/retain/release 实例方法的实现 ##\n\n```objectivec\n- retainCount\n__CFDoExternRefOperation\nCFBasicHashGetCountOfKey\n\n- retain\n__CFDoExternRefOperation\nCFBasicHashAddValue\n\n- release\n__CFDoExternRefOperation\nCFBasicHashRemoveValue  //CFBasicHashRemoveValue返回0时 release会调用dealloc\n```\n\n__CFDoExternRefOperation 干的事情就是获取对应对象存放引用计数的hash(散列)表,然后对表调用对应的操作的hash(散列)表操作\n\n\n_objc_autoreleasePoolPrint() 运行此函数,会在控制台打印出AutoreleasePoolPage类使用情况\n\n## ARC ##\n\n同一个程序中按文件为单位可以选择ARC有效/无效\n\n### 设置ARC有效的编译方法 ###\n\n1.使用clang(LLVM编译器)3.0或以上版本\n2.指定编译器属性为\"-fobjc-arc\" 具体步骤\n  在工程文件中选择Build Phases => Compile Sources => 找到对应要修改的类双击 =>在里面输入\"-fobjc-arc\"则当前类开启arc,如果输入\"-fno-objc-arc\"则当前类使用mrc;\n  \n注意:xcode 从4.2之后默认是开启arc的","source":"_posts/内存管理/内存管理.md","raw":"## NSObject 类的alloc方法执行过程 ##\n\n当一个NSObject类调用了 `alloc` 类方法,其内部的调用顺序是 \n\n1.+alloc\n\n2.+allocWithZone:\n\n3.class_createInstance\n\n4.calloc\n\n## retainCount/retain/release 实例方法的实现 ##\n\n```objectivec\n- retainCount\n__CFDoExternRefOperation\nCFBasicHashGetCountOfKey\n\n- retain\n__CFDoExternRefOperation\nCFBasicHashAddValue\n\n- release\n__CFDoExternRefOperation\nCFBasicHashRemoveValue  //CFBasicHashRemoveValue返回0时 release会调用dealloc\n```\n\n__CFDoExternRefOperation 干的事情就是获取对应对象存放引用计数的hash(散列)表,然后对表调用对应的操作的hash(散列)表操作\n\n\n_objc_autoreleasePoolPrint() 运行此函数,会在控制台打印出AutoreleasePoolPage类使用情况\n\n## ARC ##\n\n同一个程序中按文件为单位可以选择ARC有效/无效\n\n### 设置ARC有效的编译方法 ###\n\n1.使用clang(LLVM编译器)3.0或以上版本\n2.指定编译器属性为\"-fobjc-arc\" 具体步骤\n  在工程文件中选择Build Phases => Compile Sources => 找到对应要修改的类双击 =>在里面输入\"-fobjc-arc\"则当前类开启arc,如果输入\"-fno-objc-arc\"则当前类使用mrc;\n  \n注意:xcode 从4.2之后默认是开启arc的","slug":"内存管理/内存管理","published":1,"date":"2018-12-03T14:55:12.064Z","updated":"2018-12-03T14:55:12.064Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9slban001208ozb66tp0ab","content":"<h2 id=\"NSObject-类的alloc方法执行过程\"><a href=\"#NSObject-类的alloc方法执行过程\" class=\"headerlink\" title=\"NSObject 类的alloc方法执行过程\"></a>NSObject 类的alloc方法执行过程</h2><p>当一个NSObject类调用了 <code>alloc</code> 类方法,其内部的调用顺序是 </p>\n<p>1.+alloc</p>\n<p>2.+allocWithZone:</p>\n<p>3.class_createInstance</p>\n<p>4.calloc</p>\n<h2 id=\"retainCount-retain-release-实例方法的实现\"><a href=\"#retainCount-retain-release-实例方法的实现\" class=\"headerlink\" title=\"retainCount/retain/release 实例方法的实现\"></a>retainCount/retain/release 实例方法的实现</h2><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- retainCount</span><br><span class=\"line\">__CFDoExternRefOperation</span><br><span class=\"line\"><span class=\"built_in\">CFBasicHashGetCountOfKey</span></span><br><span class=\"line\"></span><br><span class=\"line\">- <span class=\"keyword\">retain</span></span><br><span class=\"line\">__CFDoExternRefOperation</span><br><span class=\"line\"><span class=\"built_in\">CFBasicHashAddValue</span></span><br><span class=\"line\"></span><br><span class=\"line\">- release</span><br><span class=\"line\">__CFDoExternRefOperation</span><br><span class=\"line\"><span class=\"built_in\">CFBasicHashRemoveValue</span>  <span class=\"comment\">//CFBasicHashRemoveValue返回0时 release会调用dealloc</span></span><br></pre></td></tr></table></figure>\n<p>__CFDoExternRefOperation 干的事情就是获取对应对象存放引用计数的hash(散列)表,然后对表调用对应的操作的hash(散列)表操作</p>\n<p>_objc_autoreleasePoolPrint() 运行此函数,会在控制台打印出AutoreleasePoolPage类使用情况</p>\n<h2 id=\"ARC\"><a href=\"#ARC\" class=\"headerlink\" title=\"ARC\"></a>ARC</h2><p>同一个程序中按文件为单位可以选择ARC有效/无效</p>\n<h3 id=\"设置ARC有效的编译方法\"><a href=\"#设置ARC有效的编译方法\" class=\"headerlink\" title=\"设置ARC有效的编译方法\"></a>设置ARC有效的编译方法</h3><p>1.使用clang(LLVM编译器)3.0或以上版本<br>2.指定编译器属性为”-fobjc-arc” 具体步骤<br>  在工程文件中选择Build Phases =&gt; Compile Sources =&gt; 找到对应要修改的类双击 =&gt;在里面输入”-fobjc-arc”则当前类开启arc,如果输入”-fno-objc-arc”则当前类使用mrc;</p>\n<p>注意:xcode 从4.2之后默认是开启arc的</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"NSObject-类的alloc方法执行过程\"><a href=\"#NSObject-类的alloc方法执行过程\" class=\"headerlink\" title=\"NSObject 类的alloc方法执行过程\"></a>NSObject 类的alloc方法执行过程</h2><p>当一个NSObject类调用了 <code>alloc</code> 类方法,其内部的调用顺序是 </p>\n<p>1.+alloc</p>\n<p>2.+allocWithZone:</p>\n<p>3.class_createInstance</p>\n<p>4.calloc</p>\n<h2 id=\"retainCount-retain-release-实例方法的实现\"><a href=\"#retainCount-retain-release-实例方法的实现\" class=\"headerlink\" title=\"retainCount/retain/release 实例方法的实现\"></a>retainCount/retain/release 实例方法的实现</h2><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- retainCount</span><br><span class=\"line\">__CFDoExternRefOperation</span><br><span class=\"line\"><span class=\"built_in\">CFBasicHashGetCountOfKey</span></span><br><span class=\"line\"></span><br><span class=\"line\">- <span class=\"keyword\">retain</span></span><br><span class=\"line\">__CFDoExternRefOperation</span><br><span class=\"line\"><span class=\"built_in\">CFBasicHashAddValue</span></span><br><span class=\"line\"></span><br><span class=\"line\">- release</span><br><span class=\"line\">__CFDoExternRefOperation</span><br><span class=\"line\"><span class=\"built_in\">CFBasicHashRemoveValue</span>  <span class=\"comment\">//CFBasicHashRemoveValue返回0时 release会调用dealloc</span></span><br></pre></td></tr></table></figure>\n<p>__CFDoExternRefOperation 干的事情就是获取对应对象存放引用计数的hash(散列)表,然后对表调用对应的操作的hash(散列)表操作</p>\n<p>_objc_autoreleasePoolPrint() 运行此函数,会在控制台打印出AutoreleasePoolPage类使用情况</p>\n<h2 id=\"ARC\"><a href=\"#ARC\" class=\"headerlink\" title=\"ARC\"></a>ARC</h2><p>同一个程序中按文件为单位可以选择ARC有效/无效</p>\n<h3 id=\"设置ARC有效的编译方法\"><a href=\"#设置ARC有效的编译方法\" class=\"headerlink\" title=\"设置ARC有效的编译方法\"></a>设置ARC有效的编译方法</h3><p>1.使用clang(LLVM编译器)3.0或以上版本<br>2.指定编译器属性为”-fobjc-arc” 具体步骤<br>  在工程文件中选择Build Phases =&gt; Compile Sources =&gt; 找到对应要修改的类双击 =&gt;在里面输入”-fobjc-arc”则当前类开启arc,如果输入”-fno-objc-arc”则当前类使用mrc;</p>\n<p>注意:xcode 从4.2之后默认是开启arc的</p>\n"},{"_content":"假设有当前情景:A要发送一条消息\"你好\"给B\n\n如果不使用任何加密方法,直接发送,消息一旦被C截获,C就知道了消息的内容\n\n## 对称加密算法 ##\n如果A和B事先约定好了一个规则,比如\"1\"代表\"你\",\"2\"代表\"好\",那么A给B发送消息的时候就可以发送\"12\",B收到消息后通过查看约定的规则知道A发送的消息是\"你好\",如果消息被C截获,C并不知道约定的规则,所以C得到的消息就是\"12\",这对C来说是完全没有意义的,因为C并不知道\"12\"的真正的意义,这就做到了简单的数据加密\n\n上面的过程就是一个简化的\"对称加密算法\"\n\n数据发信方将明文（原始数据）和加密密钥（miyao）一起经过特殊加密算法处理后，使其变成复杂的加密密文发送出去。收信方收到密文后，若想解读原文，则需要使用加密用过的密钥及相同算法的逆算法对密文进行解密，才能使其恢复成可读明文。在对称加密算法中，使用的密钥只有一个，发收信双方都使用这个密钥对数据进行加密和解密，这就要求解密方事先必须知道加密密钥","source":"_posts/加密算法/加密算法.md","raw":"假设有当前情景:A要发送一条消息\"你好\"给B\n\n如果不使用任何加密方法,直接发送,消息一旦被C截获,C就知道了消息的内容\n\n## 对称加密算法 ##\n如果A和B事先约定好了一个规则,比如\"1\"代表\"你\",\"2\"代表\"好\",那么A给B发送消息的时候就可以发送\"12\",B收到消息后通过查看约定的规则知道A发送的消息是\"你好\",如果消息被C截获,C并不知道约定的规则,所以C得到的消息就是\"12\",这对C来说是完全没有意义的,因为C并不知道\"12\"的真正的意义,这就做到了简单的数据加密\n\n上面的过程就是一个简化的\"对称加密算法\"\n\n数据发信方将明文（原始数据）和加密密钥（miyao）一起经过特殊加密算法处理后，使其变成复杂的加密密文发送出去。收信方收到密文后，若想解读原文，则需要使用加密用过的密钥及相同算法的逆算法对密文进行解密，才能使其恢复成可读明文。在对称加密算法中，使用的密钥只有一个，发收信双方都使用这个密钥对数据进行加密和解密，这就要求解密方事先必须知道加密密钥","slug":"加密算法/加密算法","published":1,"date":"2018-12-03T14:55:12.064Z","updated":"2018-12-03T14:55:12.064Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9slban001308oz9cby76bg","content":"<p>假设有当前情景:A要发送一条消息”你好”给B</p>\n<p>如果不使用任何加密方法,直接发送,消息一旦被C截获,C就知道了消息的内容</p>\n<h2 id=\"对称加密算法\"><a href=\"#对称加密算法\" class=\"headerlink\" title=\"对称加密算法\"></a>对称加密算法</h2><p>如果A和B事先约定好了一个规则,比如”1”代表”你”,”2”代表”好”,那么A给B发送消息的时候就可以发送”12”,B收到消息后通过查看约定的规则知道A发送的消息是”你好”,如果消息被C截获,C并不知道约定的规则,所以C得到的消息就是”12”,这对C来说是完全没有意义的,因为C并不知道”12”的真正的意义,这就做到了简单的数据加密</p>\n<p>上面的过程就是一个简化的”对称加密算法”</p>\n<p>数据发信方将明文（原始数据）和加密密钥（miyao）一起经过特殊加密算法处理后，使其变成复杂的加密密文发送出去。收信方收到密文后，若想解读原文，则需要使用加密用过的密钥及相同算法的逆算法对密文进行解密，才能使其恢复成可读明文。在对称加密算法中，使用的密钥只有一个，发收信双方都使用这个密钥对数据进行加密和解密，这就要求解密方事先必须知道加密密钥</p>\n","site":{"data":{}},"excerpt":"","more":"<p>假设有当前情景:A要发送一条消息”你好”给B</p>\n<p>如果不使用任何加密方法,直接发送,消息一旦被C截获,C就知道了消息的内容</p>\n<h2 id=\"对称加密算法\"><a href=\"#对称加密算法\" class=\"headerlink\" title=\"对称加密算法\"></a>对称加密算法</h2><p>如果A和B事先约定好了一个规则,比如”1”代表”你”,”2”代表”好”,那么A给B发送消息的时候就可以发送”12”,B收到消息后通过查看约定的规则知道A发送的消息是”你好”,如果消息被C截获,C并不知道约定的规则,所以C得到的消息就是”12”,这对C来说是完全没有意义的,因为C并不知道”12”的真正的意义,这就做到了简单的数据加密</p>\n<p>上面的过程就是一个简化的”对称加密算法”</p>\n<p>数据发信方将明文（原始数据）和加密密钥（miyao）一起经过特殊加密算法处理后，使其变成复杂的加密密文发送出去。收信方收到密文后，若想解读原文，则需要使用加密用过的密钥及相同算法的逆算法对密文进行解密，才能使其恢复成可读明文。在对称加密算法中，使用的密钥只有一个，发收信双方都使用这个密钥对数据进行加密和解密，这就要求解密方事先必须知道加密密钥</p>\n"},{"_content":"##普通的枚举\n\n###第一种实现方式\n\n```objectivec\ntypedef enum {\n    EnumTypeTop,\n    EnumTypeBottom\n}EnumType\n```\n\n###第二种实现方式\n\n```objectivec\ntypedef NS_ENUM(NSInteger,EnumType) {\n    EnumTypeTop,\n    EnumTypeBottom\n};\n```\n\n枚举的作用就是增加程序的可读性,将原来使用数值代表的状态转换成自然语言中有相应含义的单词,所以这样写出来的代码更易读懂。编译器会为枚举分配一个独有的编号,从0开始,每个枚举递增1\n\n##移位枚举\n\n###实现方式\n\n```objectivec\ntypedef NS_OPTIONS(NSUInteger, EnumType) {\n   EnumTypeNone  = 0,     // 0000 0000   0\n   EnumTypeTop    = 1<<0, // 0000 0001   1\n   EnumTypeBottom = 1<<1, // 0000 0010   2\n   EnumTypeLeft   = 1<<2, // 0000 0100   4\n   EnumTypeRight  = 1<<3, // 0000 1000   8\n   EnumTypeCenter = 1<<4, // 0001 0000   16\n   EnumTypeHeight = 1<<5, // 0010 0000   32\n   EnumTypeWidth  = 1<<6  // 0100 0000   64\n   \n}\n```\n\n上面就是一个移位枚举, 和普通的枚举的区别就是,每个状态的值不是递增的,而是用只有1个二进制位的值是1数字表示的,这么做的好处就是可以对状态值进行\"位或\"运算,从而实现同时使用多个枚举\n\n\n```objectivec\n\n- (void)testEnum {\n    [self needMutEnum:EnumTypeTop | EnumTypeBottom | EnumTypeLeft | EnumTypeRight | EnumTypeCenter];\n} \n\n- (void)needMutEnum:(EnumType) type {\n    if (type==0) {\n      NSLog(@\"EnumTypeNone\");\n      return;\n    }\n    if (type & EnumTypeTop) {\n        NSLog(@\"EnumTypeTop\");\n    }\n    if (type & EnumTypeBottom) {\n        NSLog(@\"EnumTypeBottom\");\n    }\n    if (type & EnumTypeLeft) {\n        NSLog(@\"EnumTypeLeft\");\n\n    }\n    if (type & EnumTypeRight) {\n        NSLog(@\"EnumTypeRight\");\n\n    }\n    if (type & EnumTypeCenter) {\n        NSLog(@\"EnumTypeCenter\");\n\n    }\n    if (type & EnumTypeHeight) {\n        NSLog(@\"EnumTypeHeight\");\n\n    }\n    if (type & EnumTypeWidth) {\n        NSLog(@\"EnumTypeWidth\");\n    }\n}\n```\n\n输出\n\n```\nEnumTypeTop\nEnumTypeBottom\nEnumTypeLeft\nEnumTypeRight\nEnumTypeCenter\n```\n\n这样就实现了同时使用多个枚举\n\n####原因\n\"位或\"和\"位与\"运算\n\"位或\": 0 | 0 = 0 ; 0 | 1 = 1 ; 1 | 1 = 1;\n\"位与\": 0 & 0 = 0 ; 0 & 1 = 0 ; 1 & 1 = 1;\n\n对移位枚举进行\"位或\"运算 \nEnumTypeTop | EnumTypeBottom | EnumTypeLeft | EnumTypeRight | EnumTypeCenter 转换成二进制就是\n\n0000 0001 | 0000 0010 | 0000 0100 | 0000 1000 | 0010 0000 = 0011 1111  其10进制的值时63\n\n所以\"needMutEnum\"这个方法传入的值```type```是十进制的63\n\n使用的时候又用```type```的值和枚举做\"位与运算\"\n\n63的二进制是 0011 1111  EnumTypeTop的二进制是 0000 0001\n\"位与\"运算的结果就是 0000 0001\n\n也就是说传入的```type```的值转换成二进制,那个位上是```1```,对应的那个类型的枚举就被传入了\n\n但是要注意的是,如果不需要None的状态,就不要把第一个枚举状态设置成```0```","source":"_posts/枚举的实现方式(移位枚举)/枚举的实现方式(移位枚举).md","raw":"##普通的枚举\n\n###第一种实现方式\n\n```objectivec\ntypedef enum {\n    EnumTypeTop,\n    EnumTypeBottom\n}EnumType\n```\n\n###第二种实现方式\n\n```objectivec\ntypedef NS_ENUM(NSInteger,EnumType) {\n    EnumTypeTop,\n    EnumTypeBottom\n};\n```\n\n枚举的作用就是增加程序的可读性,将原来使用数值代表的状态转换成自然语言中有相应含义的单词,所以这样写出来的代码更易读懂。编译器会为枚举分配一个独有的编号,从0开始,每个枚举递增1\n\n##移位枚举\n\n###实现方式\n\n```objectivec\ntypedef NS_OPTIONS(NSUInteger, EnumType) {\n   EnumTypeNone  = 0,     // 0000 0000   0\n   EnumTypeTop    = 1<<0, // 0000 0001   1\n   EnumTypeBottom = 1<<1, // 0000 0010   2\n   EnumTypeLeft   = 1<<2, // 0000 0100   4\n   EnumTypeRight  = 1<<3, // 0000 1000   8\n   EnumTypeCenter = 1<<4, // 0001 0000   16\n   EnumTypeHeight = 1<<5, // 0010 0000   32\n   EnumTypeWidth  = 1<<6  // 0100 0000   64\n   \n}\n```\n\n上面就是一个移位枚举, 和普通的枚举的区别就是,每个状态的值不是递增的,而是用只有1个二进制位的值是1数字表示的,这么做的好处就是可以对状态值进行\"位或\"运算,从而实现同时使用多个枚举\n\n\n```objectivec\n\n- (void)testEnum {\n    [self needMutEnum:EnumTypeTop | EnumTypeBottom | EnumTypeLeft | EnumTypeRight | EnumTypeCenter];\n} \n\n- (void)needMutEnum:(EnumType) type {\n    if (type==0) {\n      NSLog(@\"EnumTypeNone\");\n      return;\n    }\n    if (type & EnumTypeTop) {\n        NSLog(@\"EnumTypeTop\");\n    }\n    if (type & EnumTypeBottom) {\n        NSLog(@\"EnumTypeBottom\");\n    }\n    if (type & EnumTypeLeft) {\n        NSLog(@\"EnumTypeLeft\");\n\n    }\n    if (type & EnumTypeRight) {\n        NSLog(@\"EnumTypeRight\");\n\n    }\n    if (type & EnumTypeCenter) {\n        NSLog(@\"EnumTypeCenter\");\n\n    }\n    if (type & EnumTypeHeight) {\n        NSLog(@\"EnumTypeHeight\");\n\n    }\n    if (type & EnumTypeWidth) {\n        NSLog(@\"EnumTypeWidth\");\n    }\n}\n```\n\n输出\n\n```\nEnumTypeTop\nEnumTypeBottom\nEnumTypeLeft\nEnumTypeRight\nEnumTypeCenter\n```\n\n这样就实现了同时使用多个枚举\n\n####原因\n\"位或\"和\"位与\"运算\n\"位或\": 0 | 0 = 0 ; 0 | 1 = 1 ; 1 | 1 = 1;\n\"位与\": 0 & 0 = 0 ; 0 & 1 = 0 ; 1 & 1 = 1;\n\n对移位枚举进行\"位或\"运算 \nEnumTypeTop | EnumTypeBottom | EnumTypeLeft | EnumTypeRight | EnumTypeCenter 转换成二进制就是\n\n0000 0001 | 0000 0010 | 0000 0100 | 0000 1000 | 0010 0000 = 0011 1111  其10进制的值时63\n\n所以\"needMutEnum\"这个方法传入的值```type```是十进制的63\n\n使用的时候又用```type```的值和枚举做\"位与运算\"\n\n63的二进制是 0011 1111  EnumTypeTop的二进制是 0000 0001\n\"位与\"运算的结果就是 0000 0001\n\n也就是说传入的```type```的值转换成二进制,那个位上是```1```,对应的那个类型的枚举就被传入了\n\n但是要注意的是,如果不需要None的状态,就不要把第一个枚举状态设置成```0```","slug":"枚举的实现方式(移位枚举)/枚举的实现方式(移位枚举)","published":1,"date":"2018-12-03T14:55:12.065Z","updated":"2018-12-03T14:55:12.065Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp9slbao001408ozrrz29pzo","content":"<p>##普通的枚举</p>\n<p>###第一种实现方式</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">enum</span> &#123;</span><br><span class=\"line\">    EnumTypeTop,</span><br><span class=\"line\">    EnumTypeBottom</span><br><span class=\"line\">&#125;EnumType</span><br></pre></td></tr></table></figure>\n<p>###第二种实现方式</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSInteger</span>,EnumType) &#123;</span><br><span class=\"line\">    EnumTypeTop,</span><br><span class=\"line\">    EnumTypeBottom</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>枚举的作用就是增加程序的可读性,将原来使用数值代表的状态转换成自然语言中有相应含义的单词,所以这样写出来的代码更易读懂。编译器会为枚举分配一个独有的编号,从0开始,每个枚举递增1</p>\n<p>##移位枚举</p>\n<p>###实现方式</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_OPTIONS</span>(<span class=\"built_in\">NSUInteger</span>, EnumType) &#123;</span><br><span class=\"line\">   EnumTypeNone  = <span class=\"number\">0</span>,     <span class=\"comment\">// 0000 0000   0</span></span><br><span class=\"line\">   EnumTypeTop    = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">0</span>, <span class=\"comment\">// 0000 0001   1</span></span><br><span class=\"line\">   EnumTypeBottom = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">1</span>, <span class=\"comment\">// 0000 0010   2</span></span><br><span class=\"line\">   EnumTypeLeft   = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">2</span>, <span class=\"comment\">// 0000 0100   4</span></span><br><span class=\"line\">   EnumTypeRight  = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">3</span>, <span class=\"comment\">// 0000 1000   8</span></span><br><span class=\"line\">   EnumTypeCenter = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">4</span>, <span class=\"comment\">// 0001 0000   16</span></span><br><span class=\"line\">   EnumTypeHeight = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">5</span>, <span class=\"comment\">// 0010 0000   32</span></span><br><span class=\"line\">   EnumTypeWidth  = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">6</span>  <span class=\"comment\">// 0100 0000   64</span></span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面就是一个移位枚举, 和普通的枚举的区别就是,每个状态的值不是递增的,而是用只有1个二进制位的值是1数字表示的,这么做的好处就是可以对状态值进行”位或”运算,从而实现同时使用多个枚举</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)testEnum &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> needMutEnum:EnumTypeTop | EnumTypeBottom | EnumTypeLeft | EnumTypeRight | EnumTypeCenter];</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)needMutEnum:(EnumType) type &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type==<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"EnumTypeNone\"</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type &amp; EnumTypeTop) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"EnumTypeTop\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type &amp; EnumTypeBottom) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"EnumTypeBottom\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type &amp; EnumTypeLeft) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"EnumTypeLeft\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type &amp; EnumTypeRight) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"EnumTypeRight\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type &amp; EnumTypeCenter) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"EnumTypeCenter\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type &amp; EnumTypeHeight) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"EnumTypeHeight\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type &amp; EnumTypeWidth) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"EnumTypeWidth\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EnumTypeTop</span><br><span class=\"line\">EnumTypeBottom</span><br><span class=\"line\">EnumTypeLeft</span><br><span class=\"line\">EnumTypeRight</span><br><span class=\"line\">EnumTypeCenter</span><br></pre></td></tr></table></figure>\n<p>这样就实现了同时使用多个枚举</p>\n<p>####原因<br>“位或”和”位与”运算<br>“位或”: 0 | 0 = 0 ; 0 | 1 = 1 ; 1 | 1 = 1;<br>“位与”: 0 &amp; 0 = 0 ; 0 &amp; 1 = 0 ; 1 &amp; 1 = 1;</p>\n<p>对移位枚举进行”位或”运算<br>EnumTypeTop | EnumTypeBottom | EnumTypeLeft | EnumTypeRight | EnumTypeCenter 转换成二进制就是</p>\n<p>0000 0001 | 0000 0010 | 0000 0100 | 0000 1000 | 0010 0000 = 0011 1111  其10进制的值时63</p>\n<p>所以”needMutEnum”这个方法传入的值<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">使用的时候又用```type```的值和枚举做&quot;位与运算&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">63的二进制是 0011 1111  EnumTypeTop的二进制是 0000 0001</span><br><span class=\"line\">&quot;位与&quot;运算的结果就是 0000 0001</span><br><span class=\"line\"></span><br><span class=\"line\">也就是说传入的```type```的值转换成二进制,那个位上是```1```,对应的那个类型的枚举就被传入了</span><br><span class=\"line\"></span><br><span class=\"line\">但是要注意的是,如果不需要None的状态,就不要把第一个枚举状态设置成```0</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>##普通的枚举</p>\n<p>###第一种实现方式</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">enum</span> &#123;</span><br><span class=\"line\">    EnumTypeTop,</span><br><span class=\"line\">    EnumTypeBottom</span><br><span class=\"line\">&#125;EnumType</span><br></pre></td></tr></table></figure>\n<p>###第二种实现方式</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSInteger</span>,EnumType) &#123;</span><br><span class=\"line\">    EnumTypeTop,</span><br><span class=\"line\">    EnumTypeBottom</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>枚举的作用就是增加程序的可读性,将原来使用数值代表的状态转换成自然语言中有相应含义的单词,所以这样写出来的代码更易读懂。编译器会为枚举分配一个独有的编号,从0开始,每个枚举递增1</p>\n<p>##移位枚举</p>\n<p>###实现方式</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_OPTIONS</span>(<span class=\"built_in\">NSUInteger</span>, EnumType) &#123;</span><br><span class=\"line\">   EnumTypeNone  = <span class=\"number\">0</span>,     <span class=\"comment\">// 0000 0000   0</span></span><br><span class=\"line\">   EnumTypeTop    = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">0</span>, <span class=\"comment\">// 0000 0001   1</span></span><br><span class=\"line\">   EnumTypeBottom = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">1</span>, <span class=\"comment\">// 0000 0010   2</span></span><br><span class=\"line\">   EnumTypeLeft   = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">2</span>, <span class=\"comment\">// 0000 0100   4</span></span><br><span class=\"line\">   EnumTypeRight  = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">3</span>, <span class=\"comment\">// 0000 1000   8</span></span><br><span class=\"line\">   EnumTypeCenter = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">4</span>, <span class=\"comment\">// 0001 0000   16</span></span><br><span class=\"line\">   EnumTypeHeight = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">5</span>, <span class=\"comment\">// 0010 0000   32</span></span><br><span class=\"line\">   EnumTypeWidth  = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">6</span>  <span class=\"comment\">// 0100 0000   64</span></span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面就是一个移位枚举, 和普通的枚举的区别就是,每个状态的值不是递增的,而是用只有1个二进制位的值是1数字表示的,这么做的好处就是可以对状态值进行”位或”运算,从而实现同时使用多个枚举</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)testEnum &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> needMutEnum:EnumTypeTop | EnumTypeBottom | EnumTypeLeft | EnumTypeRight | EnumTypeCenter];</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)needMutEnum:(EnumType) type &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type==<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"EnumTypeNone\"</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type &amp; EnumTypeTop) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"EnumTypeTop\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type &amp; EnumTypeBottom) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"EnumTypeBottom\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type &amp; EnumTypeLeft) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"EnumTypeLeft\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type &amp; EnumTypeRight) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"EnumTypeRight\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type &amp; EnumTypeCenter) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"EnumTypeCenter\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type &amp; EnumTypeHeight) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"EnumTypeHeight\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type &amp; EnumTypeWidth) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"EnumTypeWidth\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EnumTypeTop</span><br><span class=\"line\">EnumTypeBottom</span><br><span class=\"line\">EnumTypeLeft</span><br><span class=\"line\">EnumTypeRight</span><br><span class=\"line\">EnumTypeCenter</span><br></pre></td></tr></table></figure>\n<p>这样就实现了同时使用多个枚举</p>\n<p>####原因<br>“位或”和”位与”运算<br>“位或”: 0 | 0 = 0 ; 0 | 1 = 1 ; 1 | 1 = 1;<br>“位与”: 0 &amp; 0 = 0 ; 0 &amp; 1 = 0 ; 1 &amp; 1 = 1;</p>\n<p>对移位枚举进行”位或”运算<br>EnumTypeTop | EnumTypeBottom | EnumTypeLeft | EnumTypeRight | EnumTypeCenter 转换成二进制就是</p>\n<p>0000 0001 | 0000 0010 | 0000 0100 | 0000 1000 | 0010 0000 = 0011 1111  其10进制的值时63</p>\n<p>所以”needMutEnum”这个方法传入的值<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">使用的时候又用```type```的值和枚举做&quot;位与运算&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">63的二进制是 0011 1111  EnumTypeTop的二进制是 0000 0001</span><br><span class=\"line\">&quot;位与&quot;运算的结果就是 0000 0001</span><br><span class=\"line\"></span><br><span class=\"line\">也就是说传入的```type```的值转换成二进制,那个位上是```1```,对应的那个类型的枚举就被传入了</span><br><span class=\"line\"></span><br><span class=\"line\">但是要注意的是,如果不需要None的状态,就不要把第一个枚举状态设置成```0</span><br></pre></td></tr></table></figure></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjp9slb9n000208oz8naxbcd1","tag_id":"cjp9slb9r000508ozs6u9wf5j","_id":"cjp9slb9x000a08ozrl060h1j"},{"post_id":"cjp9slb9v000808oz62qqqakg","tag_id":"cjp9slb9r000508ozs6u9wf5j","_id":"cjp9slb9z000c08ozw61ujiq8"},{"post_id":"cjp9slb9t000608ozxrtrtwb1","tag_id":"cjp9slb9r000508ozs6u9wf5j","_id":"cjp9slba0000f08ozffp63t82"},{"post_id":"cjp9slb9u000708ozm9gyo78c","tag_id":"cjp9slba0000e08oz4sl7hsi2","_id":"cjp9slba5000k08ozaxi8xrhe"},{"post_id":"cjp9slba5000j08ozvrkakpbk","tag_id":"cjp9slb9r000508ozs6u9wf5j","_id":"cjp9slba6000n08ozvua8cmaf"},{"post_id":"cjp9slb9x000b08oz37skiw9p","tag_id":"cjp9slba4000i08ozg2cxdqj7","_id":"cjp9slba7000p08oz42n60lmx"},{"post_id":"cjp9slba6000l08ozp5m3zuzg","tag_id":"cjp9slb9r000508ozs6u9wf5j","_id":"cjp9slba7000q08oz1xnqd0uu"},{"post_id":"cjp9slba6000o08ozspgcdhlk","tag_id":"cjp9slb9r000508ozs6u9wf5j","_id":"cjp9slba8000s08ozzmknqpnb"},{"post_id":"cjp9slba0000g08oz8k5chhfy","tag_id":"cjp9slba6000m08ozxsuzseuj","_id":"cjp9slba8000t08oz5tpizuzq"},{"post_id":"cjp9slba4000h08ozhdpyc2nw","tag_id":"cjp9slba8000r08oz8fdy98s2","_id":"cjp9slba8000u08oz5g95ucsl"},{"post_id":"cjp9slbad000v08oz8yks7w24","tag_id":"cjp9slbae000w08ozwh2gr62h","_id":"cjp9slbae000x08ozt1j9hedt"},{"post_id":"cjp9slbal000y08oz93586gk2","tag_id":"cjp9slb9r000508ozs6u9wf5j","_id":"cjp9slbam001008oz052122hb"}],"Tag":[{"name":"iOS","_id":"cjp9slb9r000508ozs6u9wf5j"},{"name":"appium","_id":"cjp9slba0000e08oz4sl7hsi2"},{"name":"Linux","_id":"cjp9slba4000i08ozg2cxdqj7"},{"name":"hello","_id":"cjp9slba6000m08ozxsuzseuj"},{"name":"VPS那些事","_id":"cjp9slba8000r08oz8fdy98s2"},{"name":"JavaScript","_id":"cjp9slbae000w08ozwh2gr62h"}]}}