{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/smackdown/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/smackdown/source/js/Counter.js","path":"js/Counter.js","modified":1,"renderable":1},{"_id":"themes/smackdown/source/js/jquery.lazyload.js","path":"js/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/smackdown/source/js/instagram.js","path":"js/instagram.js","modified":1,"renderable":1},{"_id":"themes/smackdown/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/smackdown/source/js/mobile.js","path":"js/mobile.js","modified":1,"renderable":1},{"_id":"themes/smackdown/source/js/particles.js","path":"js/particles.js","modified":1,"renderable":1},{"_id":"themes/smackdown/source/js/pc.js","path":"js/pc.js","modified":1,"renderable":1},{"_id":"themes/smackdown/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/smackdown/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/smackdown/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/smackdown/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/smackdown/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/smackdown/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/delicious.png","path":"img/delicious.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/coderwall.png","path":"img/coderwall.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/douban.png","path":"img/douban.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/github.png","path":"img/github.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/facebook.png","path":"img/facebook.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/google.png","path":"img/google.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/img-err.png","path":"img/img-err.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/img-loading.png","path":"img/img-loading.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/linkedin.png","path":"img/linkedin.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/mail.png","path":"img/mail.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/pinboard.png","path":"img/pinboard.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/pinterest.png","path":"img/pinterest.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/qq.png","path":"img/qq.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/rss.png","path":"img/rss.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/search.png","path":"img/search.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/twitter.png","path":"img/twitter.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/stackoverflow.png","path":"img/stackoverflow.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/weibo.png","path":"img/weibo.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/zhihu.png","path":"img/zhihu.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/img/wxHeader.jpeg","path":"img/wxHeader.jpeg","modified":1,"renderable":1},{"_id":"themes/smackdown/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/smackdown/source/css/fonts/fontawesome-webfont.svgz","path":"css/fonts/fontawesome-webfont.svgz","modified":1,"renderable":1},{"_id":"themes/smackdown/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/smackdown/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/smackdown/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/smackdown/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/smackdown/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/smackdown/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/smackdown/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/smackdown/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/smackdown/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"79707b76397d0dfaffc8a244ea74ee593f5443c9","modified":1624882540087},{"_id":"themes/smackdown/.gitignore","hash":"eaa3d84cb77d92a21b111fd1e37f53edc1ff9de0","modified":1618219058437},{"_id":"themes/smackdown/READMEzh.md","hash":"f32722cc30aa85927ef2d6e59683e6c221c56ebf","modified":1618219058438},{"_id":"themes/smackdown/_config.yml","hash":"8606922f4391cc7db0c58024cfde223af9bcace7","modified":1618219058438},{"_id":"themes/smackdown/README.md","hash":"3df2f1237738e3a36666f9f88058f2b5833692f4","modified":1618219058438},{"_id":"themes/smackdown/package.json","hash":"ebe2d9263420f16841f55414538485e9b8a01643","modified":1618219058442},{"_id":"source/.MWebMetaData/setting.json","hash":"bdceda6a661945449ae3491a39910b9fa112c406","modified":1618219058416},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1624882540089},{"_id":"source/_posts/Flutter的安装.md","hash":"5d90ce0c705f59a639ae07f0761c9aeebef3a62c","modified":1618219058416},{"_id":"source/_posts/Heroku使用记录.md","hash":"a06aedd640877b751a890727ebca6e5aa539da85","modified":1618219058416},{"_id":"source/_posts/Hexo创建一个blog.md","hash":"22f9fa23735b31f6248c04882713cd6d7aafb1fd","modified":1618219058416},{"_id":"source/_posts/JavaScript.md","hash":"a66c455ae9f883a94d3822dc8ab6c926a338b2ba","modified":1618219058417},{"_id":"source/_posts/Hexo的安装和使用.md","hash":"f1581e185f97147ace7a4ab2bdf5dea6ebb1c93e","modified":1618223228947},{"_id":"source/_posts/Linux执行定时脚本.md","hash":"fb093c20757125f1d642247f6afb669cc7db1f4c","modified":1625047495704},{"_id":"source/_posts/Linux系统使用--Bash基础.md","hash":"84a2230a52b7f0e6b8df338e3ec846fb9a976c8e","modified":1618219058417},{"_id":"source/_posts/Linux系统使用--shell脚本编程.md","hash":"53c54e5718dbf5662e339d9d7a6ec2c64f881287","modified":1618219058417},{"_id":"source/_posts/Linux系统使用--斐讯T1安装Armbian.md","hash":"f96e134fe67f97e26b21e1ce2023106f8e435e70","modified":1618219058417},{"_id":"source/_posts/Linux系统使用--用户权限管理.md","hash":"e7f9dc43cd7463f4237971cee0fa5f9d1771a16c","modified":1618219058417},{"_id":"source/_posts/MAC下安装Python3.md","hash":"ac4668156d011f0331ab2c4d7e86b756eef4418d","modified":1618219058418},{"_id":"source/_posts/MAC使用密钥登录VPS.md","hash":"f2abe8e1005b560c714f85833f8e931d61b62cb1","modified":1618219058418},{"_id":"source/_posts/Mac下打造属于你自己的终端.md","hash":"47f900411d208a5a601927bb0fbbace33f2e760c","modified":1618219058418},{"_id":"source/_posts/Mac软件--Keyboard Maestro.md","hash":"88152d70db59bdf986dd4aed5daf166c7e09c620","modified":1618219058418},{"_id":"source/_posts/OC使用静态库中的类别.md","hash":"c44a62d9ba7e2f365cbc25ba300b6b97d01a5928","modified":1618219058418},{"_id":"source/_posts/Mac软件--mos.md","hash":"34feb5e6e3ecdfe8f85b8c4562c14759321e5510","modified":1618219058418},{"_id":"source/_posts/Python相关--Numpy使用.md","hash":"375f492d63428f80037a595f8091b34768f4f83c","modified":1618219058419},{"_id":"source/_posts/RSA非对称加密.md","hash":"6f3b823d8d42230746b179263f59675c32d7f090","modified":1618219058419},{"_id":"source/_posts/SSH Key.md","hash":"94b9a61eb309c895765a13f14c4d8a5b685ce5d5","modified":1618219058419},{"_id":"source/_posts/UITableViewCell的创建.md","hash":"39e28ac8e2a1a57f989ca9edae7add13a6db9302","modified":1618219058420},{"_id":"source/_posts/Xcode8报错.md","hash":"7586199af04236aac35c4c5a92a50c35946d41fc","modified":1618219058420},{"_id":"source/_posts/anaconda的安装和使用.md","hash":"59972bf1390d275362231111670affed37c5208c","modified":1618226521152},{"_id":"source/_posts/centOS系统命令.md","hash":"55f0c89e60f827f6b1bd12cf62cac866e2c9ca29","modified":1618219058420},{"_id":"source/_posts/hexo部署报错解决.md","hash":"14de6eef2b6e63bea7cfa1332017531599a812d6","modified":1618219058420},{"_id":"source/_posts/iOS中的isEqual：和 “==”.md","hash":"321aa1096bfc85d215f84b5c9a1e0bc4e8349a57","modified":1618219058420},{"_id":"source/_posts/iOS的CF和OC中间的类型转换.md","hash":"cdcbd70821b65c6e3ad68dbd2f0c7f0fba034ff3","modified":1618219058420},{"_id":"source/_posts/rvm管理ruby.md","hash":"8a7f9524b353d2034a2f2c8b77046a57ea4f9b68","modified":1618219058420},{"_id":"source/_posts/ssh连接报错.md","hash":"4cc53ed197026c456aab5125473fdcdeb26964f2","modified":1618219058421},{"_id":"source/_posts/swift-node-4.md","hash":"c96e8005321d31ea365c9b6d425f04c7f3508218","modified":1624883559532},{"_id":"source/_posts/synthesize和dynamic.md","hash":"979836cdff7a9a1a4bf3163b0d869400345d30c0","modified":1618219058421},{"_id":"source/_posts/vim编辑器使用.md","hash":"804bd58d2c74cc25e71e8a78b4fe51b8a96f92e3","modified":1618219058421},{"_id":"source/_posts/使用命令行启动Sublime.md","hash":"baae5e79797122a7411d996689d0811a060c505f","modified":1618219058421},{"_id":"source/_posts/吃黑苹果--Clover美化.md","hash":"234a4376b5250ec240385923178e8a672e534cca","modified":1618219058421},{"_id":"source/_posts/吃黑苹果--声卡驱动.md","hash":"155c735362243f1cb738f4a758b48b3a7d011c4c","modified":1618219058421},{"_id":"source/_posts/我家云搞OMV.md","hash":"e3ef02e8767a54f9dbd7ac6624260d6d4261fdf6","modified":1618219847203},{"_id":"source/_posts/枚举的实现方式(移位枚举).md","hash":"0a426ada12c7b890760c7afead64c6759c642f3c","modified":1618219058422},{"_id":"source/_posts/读《iOS与OS X多线程和内存管理》—— ARC规则.md","hash":"9347caa5c3d79c592df3a7970f43ed7bafb982ef","modified":1618219058422},{"_id":"source/_posts/读《iOS与OS X多线程和内存管理》—— GCD.md","hash":"0d20e87abf572086c4d0789765710ffc4cab4d89","modified":1618219058422},{"_id":"source/_posts/读《iOS与OS X多线程和内存管理》—— 属性.md","hash":"6a0728d6518eb8a9773932b26605743ab857ed1c","modified":1618219058422},{"_id":"source/_posts/读《iOS与OS X多线程和内存管理》—— 自动引用计数.md","hash":"0a3d22d09ffc877edc952dcca743d284bee10099","modified":1618219058422},{"_id":"source/_posts/读《iOS与OS X多线程和内存管理》——前言.md","hash":"19e1026594f26093ceb1523fea29b343fe7453ab","modified":1618219058422},{"_id":"source/_posts/读《iOS与OS X多线程和内存管理》——引用计数(总结).md","hash":"b07cb5b3ee66dd287f9b8d9948b8bcffe590cddb","modified":1618219058423},{"_id":"source/_posts/读《iOS与OS X多线程和内存管理》——引用计数.md","hash":"423be34768d8364062d324e7284bcf8dc0482f0f","modified":1618219058423},{"_id":"themes/smackdown/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1618219058441},{"_id":"themes/smackdown/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1618219058441},{"_id":"themes/smackdown/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1618219058441},{"_id":"themes/smackdown/layout/layout.ejs","hash":"2a03159a20b9b8c65fd1a62c24f5e93ddb0f18c8","modified":1618219058441},{"_id":"themes/smackdown/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1618219058441},{"_id":"themes/smackdown/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1618219058442},{"_id":"themes/smackdown/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1618219058442},{"_id":"themes/smackdown/layout/_partial/after-footer.ejs","hash":"4bf1d05755851ffae61b281d63d273af82f72676","modified":1618219058438},{"_id":"themes/smackdown/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1618219058438},{"_id":"themes/smackdown/layout/_partial/article.ejs","hash":"050bf4301b3b42426b7d1f896951cfb489fe3741","modified":1618219058439},{"_id":"themes/smackdown/layout/_partial/archive-post.ejs","hash":"3bbedf799e1788b3e62494eb6d0f7bd5df985cfc","modified":1618219058438},{"_id":"themes/smackdown/layout/_partial/baidu_tongji.ejs","hash":"b227224a73bfbcb31ebeece59f31723f32ed5b1d","modified":1618219058439},{"_id":"themes/smackdown/layout/_partial/footer.ejs","hash":"c4e0ac111ad70deee307a394dff9e2c2ce543759","modified":1618219058439},{"_id":"themes/smackdown/layout/_partial/google_analytics.ejs","hash":"354f8553dffba0a6bcea8294d5d656ed11315394","modified":1618219058439},{"_id":"themes/smackdown/layout/_partial/head.ejs","hash":"a3a39aa8f03e4a368e7d137cadbc66b25f60dade","modified":1618219058439},{"_id":"themes/smackdown/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1618219058439},{"_id":"themes/smackdown/layout/_partial/left-col.ejs","hash":"70a9951e4e2d30aabba88e75c3fa54b9235ce6a6","modified":1618219058439},{"_id":"themes/smackdown/layout/_partial/mathjax.ejs","hash":"960ee249eb0cfae9746589f3a4c3ece79359cae7","modified":1618219058439},{"_id":"themes/smackdown/layout/_partial/mobile-nav.ejs","hash":"cd0af87ee781ac9c2b0e6a2a05b063d4bd497d9c","modified":1618219058440},{"_id":"themes/smackdown/layout/_partial/search.ejs","hash":"87f9a4f472808398f9c7041642520d4345efac24","modified":1618219058441},{"_id":"themes/smackdown/layout/_widget/Counter.ejs","hash":"e0395ba653817d9b385f69a8733f370e5d60343d","modified":1618219058441},{"_id":"themes/smackdown/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1618219058442},{"_id":"themes/smackdown/source/css/_variables.styl","hash":"5e37a6571caf87149af83ac1cc0cdef99f117350","modified":1618219058444},{"_id":"themes/smackdown/source/css/style.styl","hash":"c6eb98c09466bde2804f122431406141ce1e9015","modified":1618219058446},{"_id":"themes/smackdown/source/js/Counter.js","hash":"6697d5dfba2700c059722b62d856d4c86c73031a","modified":1618219058452},{"_id":"themes/smackdown/source/js/jquery.lazyload.js","hash":"c11a2e7b330d16d06feabd0a8477099adf9d6799","modified":1618219058452},{"_id":"themes/smackdown/source/js/instagram.js","hash":"f19adbcc0dac33536bc6660598059048ec901882","modified":1618219058452},{"_id":"themes/smackdown/source/js/main.js","hash":"5e92a3694111e5ae5aca37c79157218d35f2e63b","modified":1618219058452},{"_id":"themes/smackdown/source/js/mobile.js","hash":"b68cc01d24e80973c48205f551da87f3f3427644","modified":1618219058452},{"_id":"themes/smackdown/source/js/particles.js","hash":"c4286268c2071a624bf3c8565f6328eccecacf30","modified":1618219058453},{"_id":"themes/smackdown/source/js/pc.js","hash":"fdbc039fc9ffa70815b5fc4daaa587ae29693f10","modified":1618219058453},{"_id":"themes/smackdown/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1618219058446},{"_id":"themes/smackdown/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1618219058446},{"_id":"themes/smackdown/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1618219058447},{"_id":"themes/smackdown/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1618219058447},{"_id":"themes/smackdown/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1618219058447},{"_id":"themes/smackdown/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1618219058447},{"_id":"themes/smackdown/source/fancybox/jquery.fancybox.css","hash":"b6aa6692c2e5f8bd74d96827b78570f0c5683c20","modified":1618219058448},{"_id":"themes/smackdown/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1618219058448},{"_id":"themes/smackdown/source/fancybox/jquery.fancybox.js","hash":"a82597493d75ea989ca586e09173cff332efe41e","modified":1618219058448},{"_id":"themes/smackdown/source/img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1618227958892},{"_id":"themes/smackdown/source/img/delicious.png","hash":"9553a5f5189e4a953e04a58a49dbfa74b86b73dd","modified":1618219058449},{"_id":"themes/smackdown/source/img/coderwall.png","hash":"fa84676c4d654e040e51fd34bfcd9f9348cd5331","modified":1618219058449},{"_id":"themes/smackdown/source/img/douban.png","hash":"e2ade003ffadd5826ee66ec23901c2d6e8607e4e","modified":1618219058449},{"_id":"themes/smackdown/source/img/github.png","hash":"b84d03b32fa388dcbf149296ebd16dce6223d48d","modified":1618219058449},{"_id":"themes/smackdown/source/img/facebook.png","hash":"d19ad7a0903daf26817afd8753cd97e0cc714f54","modified":1618219058449},{"_id":"themes/smackdown/source/img/google.png","hash":"61a21fec7346fa3400b747ac9a201cf3d5bc013d","modified":1618219058449},{"_id":"themes/smackdown/source/img/img-err.png","hash":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1618219058449},{"_id":"themes/smackdown/source/img/img-loading.png","hash":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1618219058450},{"_id":"themes/smackdown/source/img/linkedin.png","hash":"e203138fb53c257cb214e97f4e30091b9c568d2c","modified":1618219058450},{"_id":"themes/smackdown/source/img/mail.png","hash":"fca8199cc77fdbd700a45bf56d091c82f4a67fe7","modified":1618219058450},{"_id":"themes/smackdown/source/img/pinboard.png","hash":"0891fbb6d092fa012bf936019923383d84c6aeb0","modified":1618219058450},{"_id":"themes/smackdown/source/img/pinterest.png","hash":"9c72917f8779c083157c6ce7a5d62ed4874f0630","modified":1618219058450},{"_id":"themes/smackdown/source/img/qq.png","hash":"93e6e87ec8cef56573a08c8f8fbb0bb53313354a","modified":1618219058450},{"_id":"themes/smackdown/source/img/rss.png","hash":"430fd47340e75214c081abd05cd7410cf7c71b86","modified":1618219058450},{"_id":"themes/smackdown/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1618219058450},{"_id":"themes/smackdown/source/img/search.png","hash":"1ab76b03297ae2ce61ec59dd9bf8727f1fbbcedd","modified":1618219058451},{"_id":"themes/smackdown/source/img/twitter.png","hash":"14dbb8e62d056525253bc0de13acd1723da7a934","modified":1618219058451},{"_id":"themes/smackdown/source/img/stackoverflow.png","hash":"da5dfe9043055c95e479d49c78cd3b020de608f2","modified":1618219058451},{"_id":"themes/smackdown/source/img/weibo.png","hash":"280dae3fd38086158b4a1b57edb94c06b1a5014b","modified":1618219058451},{"_id":"themes/smackdown/source/img/zhihu.png","hash":"a6d6ef65e9ac82e613a311810391ebb90d9b1c1d","modified":1618219058452},{"_id":"themes/smackdown/source/img/wxHeader.jpeg","hash":"d29298fd69257f0d82fcde7e6115971858ebe23b","modified":1618223737191},{"_id":"themes/smackdown/layout/_partial/post/category.ejs","hash":"d4f0e36f9a2167e91082dbd7d52425a06d2bebbf","modified":1618219058440},{"_id":"themes/smackdown/layout/_partial/post/date.ejs","hash":"c0c988334e857a77ba455a056dfa21809e7e76a5","modified":1618219058440},{"_id":"themes/smackdown/layout/_partial/post/nav.ejs","hash":"1939c94f24ba0f25dd728eef559509ba8647b546","modified":1618219058440},{"_id":"themes/smackdown/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1618219058440},{"_id":"themes/smackdown/layout/_partial/post/share.ejs","hash":"fbfe1306e3092ab8965cddba11db164c5a96ed85","modified":1618219058440},{"_id":"themes/smackdown/layout/_partial/post/tag.ejs","hash":"78612cfc091d7d861a70455a0dc8c3036e460879","modified":1618219058440},{"_id":"themes/smackdown/layout/_partial/post/title.ejs","hash":"efa58f58564d44b819175ad11b10d77347c92891","modified":1618219058440},{"_id":"themes/smackdown/layout/_partial/post/viewCounter.ejs","hash":"07ef10241d92479fd4dafbee361c0bf9664e4452","modified":1618219058441},{"_id":"themes/smackdown/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1618219058444},{"_id":"themes/smackdown/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1618219058444},{"_id":"themes/smackdown/source/css/_partial/archive.styl","hash":"da0a72fb05a6ebfff9b4ba013e35e8a67b047e15","modified":1618219058442},{"_id":"themes/smackdown/source/css/_partial/footer.styl","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1618219058443},{"_id":"themes/smackdown/source/css/_partial/article.styl","hash":"93763dd421409938d901c964d5ca67dc59fb24a2","modified":1618219058442},{"_id":"themes/smackdown/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1618219058443},{"_id":"themes/smackdown/source/css/_partial/highlight.styl","hash":"17a9b4fb6e746dd1f03757e89f5e3eff02b1fba6","modified":1618219058443},{"_id":"themes/smackdown/source/css/_partial/main.styl","hash":"a8d7b2735bab91e5651433880aedb0c900f269b9","modified":1618219058443},{"_id":"themes/smackdown/source/css/_partial/instagram.styl","hash":"4de333144b00c58a5d41d682d83f78794f75d19d","modified":1618219058443},{"_id":"themes/smackdown/source/css/_partial/mobile-slider.styl","hash":"96eee8fb0d3f1108eae9a04682d4bbd0e968be22","modified":1618219058443},{"_id":"themes/smackdown/source/css/_partial/mobile.styl","hash":"dd601ea98944c8fdf0d6776ef5bae4d68e967835","modified":1618219058443},{"_id":"themes/smackdown/source/css/_partial/page.styl","hash":"97371f551ed051780f8632142ea00a705d76c845","modified":1618219058443},{"_id":"themes/smackdown/source/css/_partial/scroll.styl","hash":"a0bd4b253b28f694de59bec217f48f59f92cbaf2","modified":1618219058444},{"_id":"themes/smackdown/source/css/_partial/tagcloud.styl","hash":"84a678fe6b78befb4cf6e7523f8a40313a544fbd","modified":1618219058444},{"_id":"themes/smackdown/source/css/_partial/wheelmenu.styl","hash":"74630c56944e27bef53ef0c0e391611a2eec2ed0","modified":1618219058444},{"_id":"themes/smackdown/source/css/_partial/share.styl","hash":"6ac15a6815b1bbdbea89d3fe933c2821aa80b926","modified":1618219058444},{"_id":"themes/smackdown/source/css/fonts/fontawesome-webfont.eot","hash":"3ce87b82c7a4ffdf65e96765c2ffda10b1a283c6","modified":1618219058445},{"_id":"themes/smackdown/source/css/fonts/fontawesome-webfont.svgz","hash":"4bfdd33ed702e32ae01399fcc2652377f78e7626","modified":1618219058445},{"_id":"themes/smackdown/source/css/fonts/fontawesome-webfont.ttf","hash":"1480b8101b02da9bc4c60341b5e185e63e585064","modified":1618219058446},{"_id":"themes/smackdown/source/css/fonts/fontawesome-webfont.woff","hash":"cafc4ac5761a0a252d33dce4ea3952cf9a38d832","modified":1618219058446},{"_id":"themes/smackdown/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1618219058447},{"_id":"themes/smackdown/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1618219058448},{"_id":"themes/smackdown/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1618219058447},{"_id":"themes/smackdown/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1618219058448},{"_id":"themes/smackdown/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1618219058448},{"_id":"themes/smackdown/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1618219058448},{"_id":"themes/smackdown/source/css/fonts/fontawesome-webfont.svg","hash":"23a6f5b2ff76de9cb3cf1e886194c67647fd868a","modified":1618219058445}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Flutter的安装","date":"2018-11-10T11:26:12.000Z","_content":"\n## 前言 ##\n\n记录一下安装`flutter`的过程，方便以后查询\n\n<!-- more -->\n\n### 安装 ###\n\n下载`flutter`:\n\n终端输入：\n\n```\ngit clone -b beta https://github.com/flutter/flutter.git\n```\n\n添加临时环境变量：\n\n```\nexport PATH=`pwd`/flutter/bin:$PATH\n```\n\n注意：\n`pwd`表示当前路径，后面的`flutter`就是你git下来的文件夹，里面会有一个`bin`文件夹，这里如果git下来的文件夹不叫`flutter`，需要改上面的命令为对应的文件名称，而且要和`pwd`打印出来的路径能连接上\n\n检查依赖：\n\n```\nflutter doctor\n```\n\n这一步可能需要翻墙，解决办法是[添加这两个镜像](https://flutter.io/community/china)\n\n```\n export PUB_HOSTED_URL=https://pub.flutter-io.cn\n export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn\n```\n\n如果`flutter doctor`跑出什么问题，按照提示解决就好\n\n如果是如下错误，需要在`android studio`中添加插件\n\n```\n    ✗ Flutter plugin not installed; this adds Flutter specific functionality.\n    ✗ Dart plugin not installed; this adds Dart specific functionality.\n[!] Connected device\n    ! No devices available\n```\n\n如果需要安装`dart`点同意就好，如果没有其他错误，就表示`flutter`安装成功\n\n","source":"_posts/Flutter的安装.md","raw":"---\ntitle: Flutter的安装\ndate: 2018-11-10 19:26:12\ntags: [Flutter]\n---\n\n## 前言 ##\n\n记录一下安装`flutter`的过程，方便以后查询\n\n<!-- more -->\n\n### 安装 ###\n\n下载`flutter`:\n\n终端输入：\n\n```\ngit clone -b beta https://github.com/flutter/flutter.git\n```\n\n添加临时环境变量：\n\n```\nexport PATH=`pwd`/flutter/bin:$PATH\n```\n\n注意：\n`pwd`表示当前路径，后面的`flutter`就是你git下来的文件夹，里面会有一个`bin`文件夹，这里如果git下来的文件夹不叫`flutter`，需要改上面的命令为对应的文件名称，而且要和`pwd`打印出来的路径能连接上\n\n检查依赖：\n\n```\nflutter doctor\n```\n\n这一步可能需要翻墙，解决办法是[添加这两个镜像](https://flutter.io/community/china)\n\n```\n export PUB_HOSTED_URL=https://pub.flutter-io.cn\n export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn\n```\n\n如果`flutter doctor`跑出什么问题，按照提示解决就好\n\n如果是如下错误，需要在`android studio`中添加插件\n\n```\n    ✗ Flutter plugin not installed; this adds Flutter specific functionality.\n    ✗ Dart plugin not installed; this adds Dart specific functionality.\n[!] Connected device\n    ! No devices available\n```\n\n如果需要安装`dart`点同意就好，如果没有其他错误，就表示`flutter`安装成功\n\n","slug":"Flutter的安装","published":1,"updated":"2021-04-12T09:17:38.416Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqjdx1mu00005emuz730ax9k","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>记录一下安装<code>flutter</code>的过程，方便以后查询</p>\n<a id=\"more\"></a>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>下载<code>flutter</code>:</p>\n<p>终端输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone -b beta https://github.com/flutter/flutter.git</span><br></pre></td></tr></table></figure>\n<p>添加临时环境变量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PATH=`pwd`/flutter/bin:$PATH</span><br></pre></td></tr></table></figure>\n<p>注意：<br><code>pwd</code>表示当前路径，后面的<code>flutter</code>就是你git下来的文件夹，里面会有一个<code>bin</code>文件夹，这里如果git下来的文件夹不叫<code>flutter</code>，需要改上面的命令为对应的文件名称，而且要和<code>pwd</code>打印出来的路径能连接上</p>\n<p>检查依赖：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flutter doctor</span><br></pre></td></tr></table></figure>\n<p>这一步可能需要翻墙，解决办法是<a href=\"https://flutter.io/community/china\" target=\"_blank\" rel=\"noopener\">添加这两个镜像</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PUB_HOSTED_URL=https://pub.flutter-io.cn</span><br><span class=\"line\">export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn</span><br></pre></td></tr></table></figure>\n<p>如果<code>flutter doctor</code>跑出什么问题，按照提示解决就好</p>\n<p>如果是如下错误，需要在<code>android studio</code>中添加插件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    ✗ Flutter plugin not installed; this adds Flutter specific functionality.</span><br><span class=\"line\">    ✗ Dart plugin not installed; this adds Dart specific functionality.</span><br><span class=\"line\">[!] Connected device</span><br><span class=\"line\">    ! No devices available</span><br></pre></td></tr></table></figure>\n<p>如果需要安装<code>dart</code>点同意就好，如果没有其他错误，就表示<code>flutter</code>安装成功</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>记录一下安装<code>flutter</code>的过程，方便以后查询</p>","more":"<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>下载<code>flutter</code>:</p>\n<p>终端输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone -b beta https://github.com/flutter/flutter.git</span><br></pre></td></tr></table></figure>\n<p>添加临时环境变量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PATH=`pwd`/flutter/bin:$PATH</span><br></pre></td></tr></table></figure>\n<p>注意：<br><code>pwd</code>表示当前路径，后面的<code>flutter</code>就是你git下来的文件夹，里面会有一个<code>bin</code>文件夹，这里如果git下来的文件夹不叫<code>flutter</code>，需要改上面的命令为对应的文件名称，而且要和<code>pwd</code>打印出来的路径能连接上</p>\n<p>检查依赖：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flutter doctor</span><br></pre></td></tr></table></figure>\n<p>这一步可能需要翻墙，解决办法是<a href=\"https://flutter.io/community/china\" target=\"_blank\" rel=\"noopener\">添加这两个镜像</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PUB_HOSTED_URL=https://pub.flutter-io.cn</span><br><span class=\"line\">export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn</span><br></pre></td></tr></table></figure>\n<p>如果<code>flutter doctor</code>跑出什么问题，按照提示解决就好</p>\n<p>如果是如下错误，需要在<code>android studio</code>中添加插件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    ✗ Flutter plugin not installed; this adds Flutter specific functionality.</span><br><span class=\"line\">    ✗ Dart plugin not installed; this adds Dart specific functionality.</span><br><span class=\"line\">[!] Connected device</span><br><span class=\"line\">    ! No devices available</span><br></pre></td></tr></table></figure>\n<p>如果需要安装<code>dart</code>点同意就好，如果没有其他错误，就表示<code>flutter</code>安装成功</p>"},{"title":"Learn JavaScript","date":"2017-11-11T13:10:12.000Z","_content":"\n## 前言 ##\n闲来无事看了看`JavaScript`,这里记录部分内容。\n\n<!-- more -->\n\n### Equality (相等比较符) ###\n\n```Javascript\nvar foo = 42;\nvar bar = 42;\nvar baz = \"42\";\nvar qux = \"life\";\n```\n定义了四个变量在Javascript中`==`是用来比较两个值但是不会判断类型故`foo == baz`返回的值是`true`\n\n使用`==`比较的时候编译器会先把类型转换成相同的类型,再去比较\n\n因此在JavaScript 要是比较不同类型的两个值可以使用`===`这样会先判断类型,如果类型不同就会返回`false`\n\n所以推荐使用`===`比较\n\n注意: 1.`NaN`是个特殊的Number,他与所有其他值都不相等,包括它自己\n\n```JavaScript\nNaN === NaN ; // false\n```\n唯一能判断NaN的方法是通过isNaN()函数:\n\n```JavaScript\nisNaN(NaN); // true\n```\n\n2.浮点数的比较:\n\n```JavaScript\n1/3 === (1 - 2 / 3); //false\n```\n这个结果是正确的,出现这个结果这是因为浮点数在运算过程中会产生误差,计算机无法精确的表示无限小数,所以要比较两个浮点数是否相等,只能计算他们之差的绝对值,看是否小于某个阈值:\n\n```JavaScript\nMath.abs(1/3 - (1 - 2 / 3)) < 0.0000001; //true\n```\n\n\n### Types ###\n\n#### numbers ####\n\nJavaScript中只有一种数字类型 – 64-bit float point,类似于Java中的double类型,所以在JavaScript中1和1.0是相同的值\nnumber可以直接做四则运算，规则和数学一致\n\n#### 字符串 ####\n\n字符串是以'单引号'或\"双引号\"括起来的文本,如`'abc'` `\"xyz\"`\n\n注意`' '`和`\" \"`并不是字符串的一部分\n\n如果字符串中包含`'` 就使用`\"\"`把文本包起来,如果字符串中包含`\"` 就需要使用转义字符了`\\`\n\n在多行字符串中换行使用的是`\\n` 但是如果行数太多`\\n`需要写多个,不方便,在JavaScript中又增加了一种表示方法(ES6),就是将多行文本用\\`... \\`括起来,就是键盘上tab键上边的那个按键.\n\n##### 模板字符串 #####\n多个字符串可以使用`+`连接起来.字符串也可以是变量如:\n\n```JavaScript\nvar name = '小王吧';\nvar age = '100';\nvar message = '你好,' + name + ',你现在' + age + '岁';\n```\n同样,如果要连接的变量有很多,使用`+`就会很不方便,在JavaScript中增加了一种模板字符串的表示(ES6):\n\n```JavaScript\nvar name = '小王吧';\nvar age = '101';\nvar message = `${name},你今年${age}岁,是不是?`\n```\n注意:新的表示方法使用的是\\` ,就是新的多行文本使用的符号,就是键盘上`tab`按键上边的那个按键,不能使用`\"\"或''`,那样无法转换变量\n\n##### 字符串操作 #####\n获取字符的长度\n\n```JavaScript\nvar name = 'xiao wang ba.';\nalert(name.length); //13\n```\n\n获取指定位置字符,可以把字符串看成是特殊的数组,对字符串进行下标操作,从0索引开始\n\n```JavaScript\nvar name = 'xiao wang ba.';\nname[0]; //'x'\nname[1]; //'i'\nname[4]; //' '\nname[12];//'.'\nname[13];//undefined 超出范围的索引一律返回undefined\n```\n注意:给字符串的索引赋值不会有报错,也不会有任何效果,字符串也不会改变\n\n改变字符串为大写\n\n```JavaScript\nvar name = 'xiao wang ba.';\nname.toUpperCase(); //返回'XIAO WANG BA.'\n```\n\n改变字符串为小写\n\n```JavaScript\nvar name = 'Xiao Wang Ba.';\nname.toLowerCase(); //返回'xiao wang ba.'\n```\n注意:如果字符串是中文,则没效果\n\n返回字符串出现的位置\n\n```JavaScript\nvar name = 'Xiao Wang Ba.';\nname.indexOf('Wang');//返回5\nname.indexOf('wang');//如果没有找到指定的子串,返回-1\n```\n\n获取字符串中的子串\n\n```JavaScript\nvar name = 'xiao wang ba.';\nname.substring(0,4);//从索引0开始到4(不包括4),返回'xiao'\nname.substring(10);//从索引10开始到结束,返回'ba.'\n```\n\n#### 布尔值 ####\nJavaScript中的布尔值有`true`和`false`两种值,可以直接用`true`或`false`表示,也可以通过布尔运算计算出来\n\n#### null和undefined ####\n`null`表示一个\"空\"的值,同Java中的`null`,Swift中的nil,Python中的None用法类似.\n`undefined`表示\"未定义\".\nJavaScript设计的时候希望用`null`表示一个空的值,用`undefined`表示值未定义,但是大多数情况下我们都应该用`null`.`undefined`仅仅在判断函数参数是否传递的情况下有用\n\n#### 数组 ####\n数组是一组按顺序排列的集合,集合的每个值称为元素.JavaScript的数组可以包括任意数据类型.\n创建方法:\n\n```JavaScript\n[1,2,3.14,\"hello\",null,true]; //推荐使用\n```\n另一种创建方法:\n\n```JavaScript\nnew Array(1,2,3);\n```\n\n获取数组的长度\n\n```JavaScript\nvar arr = [1,2,3.14,\"hello\",null,true];\narr.length;//6\n//可以给数组的长度赋值,改变数组的大小\narr.length = 7;//数组改变为[1,2,3.14,\"hello\",null,true,undefined]\narr.length = 4;//数组改变为[1,2,3.14,\"hello\"]\n```\n\n\n数组可以通过索引来访问每个元素的值,也可以改变索引对应元素的值:\n\n```JavaScript\nvar arr = [1,2,3.14,\"hello\",null,true];\narr[0]; //数组第一个元素,值为1\narr[1] = 10;//修改数组第二个元素的值为10\n```\n\n注意:如果通过索引给数组赋值的时候,索引超过了数组长度,数组会被变大\n\n```JavaScript\nvar arr = ['A', 'B', 'C'];\narr[5] = 'F';//arr会变为['A', 'B', 'C', undefined, undefined, 'F'];\n```\n\n获取对应元素的索引\n\n```JavaScript\nvar arr = [10, 20 ,'30', 'xyz'];\narr.indexOf(10);//元素10的索引是0\narr.indexOf(20);//元素20的索引是1\narr.indexOf(30);//元素30的索引是 -1 因为没有找到元素\narr.indexOf('30');//元素'30'的索引是2\n```\n注意：数字`30`和`'30'`是不同的元素\n\n获取数组中的部分元素\n\n```JavaScript\nvar arr =['A','B','C','D','E','F','G'];\narr.slice(0,3);//从索引0开始,到索引3结束,但不包括索引3:['A','B','C']\narr.slice(3);//从索引3开始到结束:['D','E','F','G']\n\n```\n\n注意:`slice()`的起止参数包括开始索引,不包括结束索引\n如果不给`slice()`传递任何参数,它会从头到尾截取所有元素,这个方法可以复制一个`array`\n\n```JavaScript\nvar arr = ['A','B','C','D','E','F','G'];\nvar aCopy = arr.slice();\naCopy; //['A','B','C','D','E','F','G'];\naCopy === arr; //false\nif(aCopy.toString() === arr.toString()) {\n    alert('一样');//数组相同\n}else {\n    alert('不一样');//数组不同\n}\n```\n注意:`JavaScript`比较两个数组是否相同不能直接使用`===` 要比较两个数组是否相同,需要先把数组转换成字符串,然后再比较\n\n在数组末尾添加或删除若干元素,`push()`和`pop()`\n\n```JavaScript\nvar arr = [1 , 2];\narr.push('A','B'); //返回新的长度为4的数组\narr; //[1,2,'A','B']\narr.pop();//pop()返回'B'\narr; // [1,2,'A']\narr.pop();arr.pop();arr.pop(); //连续pop 3次\narr; //[]\narr.pop(); //空数组继续pop不会报错,而是返回undefined\narr;//[]\n```\n\n在数组头部添加或删除若干元素,`unshift()`和`shift()`\n\n```JavaScript\nvar arr =[1,2];\narr.unshift('A','B');//返回新的长度为4的数组\narr;//['A','B',1,2]\narr.shift();//'A'\narr;//['B',1,2]\narr.shift();arr.shift();arr.shift();//连续shift 3次\narr;//[]\narr.shift();//空数组继续shift不会报错,而是返回undefined\narr;//[]\n```\n\n数组排序\n`sort()`可以对当前数组进行排序,它会直接修改当前的数组元素的位置,直接调用时,会按照默认顺序排序\n\n```JavaScript\nvar arr = ['B','C','A'];\narr.sort();\narr;//['A','B','C']\n```\n注意 在函数中可以自定义排序条件\n\n数组反转\n\n`reverse()`可以把数组的元素反转\n\n```JavaScript\nvar arr = ['A','B','C'];\narr.reverse();\narr;//['three','two','one']\n```\n\n数组修改的\"万能方法\",可以从指定索引开始删除若干元素,然后再从该位置添加若干元素\n\n```JavaScript\nvar arr =['Microsoft','Apple','Yahoo','AOL','Excite','Oracle']\narr.splice(2,3,'Google','Facebook');//从索引2开始删除3个元素,然后再添加两个元素,返回删除的元素['Yahoo','AOL','Excite']\narr.splice(2,2);//只删除不添加,返回['Google','Facebook']\narr;//['Microsoft','Apple','Oracle']\narr.splice(2.0,'Google','Facebook');//只添加,不删除,返回[]\narr;//['Microsoft','Apple','Google','Facebook','Oracle']\n```\n把两个数组连接起来,返回一个新的数组\n\n```JavaScript\nvar arr = ['A','B','C'];\nvar added = arr.concat([1,2,3]);\nadded; //['A','B','C',1,2,3]\nARR;//['A','B','C']\n```\n注意 `concat()`方法并没有修改当前数组,而是返回了一个新的数组\n\n而且`concat()`可以接收任意个元素和数组,并把所有数组自动拆开,添加到新的数组中\n\n```JavaScript\nvar arr = ['A','B','C'];\narr.concat(1,2,[3,4]);//['A','B','C',1,2,3,4]\n```\n\n把数组的每个元素都用指定的字符串连接起来,然后返回字符串\n\n```JavaScript\nvar arr = ['A','B','C',1,2,3];\narr.join('-'); //'A-B-C-1-2-3'\n```\n注意如果数组的元素不是字符串,会自动转换成字符串再连接\n\n多维数组,指的是数组中的某个元素又是一个数组\n\n```JavaScript\nvar arr = [[1,2,3],[400,500,600],'-'];\n```\n\n上述`Array`包含3个元素,其中头两个元素本身也是`Array`\n\n\n#### 对象 ####\n对象是一组由键-值组成的无序集合:\n\n```JavaScript\nvar person = {\n\tname: 'XiaoWang',\n\ttags: ['js', 'web', 'mobile'],\n\tage: 12,\n\tcity: 'shanghai',\n\thasCar: false,\n\tzipcode: null\n};\n```\n\nJavaScript用一个`{...}` 表示一个对象,键值对以`xxx: xxx`形式申明,用`,`隔开,最后一个键值对不需要加\n\nJavaScript对象的键都是字符串类型,值可以是任意数据类型,每个键都是对象的一个属性,获取属性的方法:\n\n```JavaScript\nperson.name; // 'XiaoWang'\nperson.zipcode; // null\n```\n注:`var person` 是JavaScript的一个变量,`person`是变量名,变量名是大小写英文,数字,`$`和`_`的组合,且不能用数字开头,也不能使用JavaScript中的关键字\n\n\n##### strict模式 #####\n蛋疼的布兰登在设计JavaScript的时候为了赶工期,并没有强制使用`var`声明变量,如果一个变量没有通过`var`声明就被使用,这个变量就会被自动声明为全局变量\n\n```JavaScript\ni = 10; //i就是一个全局变量\n```\n\n如果在不同的JavaScript文件中,你都使用了同样名字的变量,而且都没有用`var`声明,那么你就麻烦了.\n\n因此,为了给布兰登填坑,ECMA在后续的规范中推出了strict模式,在strict模式下运行JavaScript代码不允许使用没有`var`声明的变量,如果有那么就给你报错\n\n启动strict模式的方法很简单,就是在JavaScript代码的第一行写上:\n\n```JavaScript\n'use strict';\n```\n注:如果你用的是老爷机,你的浏览器太老了,他会自以为是的把上面那就话当做一个字符串语句执行,如果这样的话还是换个最新版的浏览器吧\n\n##### Advanced Operaters (高级运算符) #####\n取余运算 `x = y % 2`\n累加运算 `a = 5`\n\t\t`c = a++`/Users/YaoWanXin/Desktop/app.html resulets : c = 5 and a = 6\n\t\t`c = ++a` resulets : c = 6 and a = 6\n累减运算 `a = 5`\n\t\t`c = a--` resulets : c = 5 and a = 4\n\t\t`c = --a` resulets : c = 4 and a = 4\n","source":"_posts/JavaScript.md","raw":"---\ntitle: Learn JavaScript\ndate: 2017-11-11 21:10:12\ntags: JavaScript\n---\n\n## 前言 ##\n闲来无事看了看`JavaScript`,这里记录部分内容。\n\n<!-- more -->\n\n### Equality (相等比较符) ###\n\n```Javascript\nvar foo = 42;\nvar bar = 42;\nvar baz = \"42\";\nvar qux = \"life\";\n```\n定义了四个变量在Javascript中`==`是用来比较两个值但是不会判断类型故`foo == baz`返回的值是`true`\n\n使用`==`比较的时候编译器会先把类型转换成相同的类型,再去比较\n\n因此在JavaScript 要是比较不同类型的两个值可以使用`===`这样会先判断类型,如果类型不同就会返回`false`\n\n所以推荐使用`===`比较\n\n注意: 1.`NaN`是个特殊的Number,他与所有其他值都不相等,包括它自己\n\n```JavaScript\nNaN === NaN ; // false\n```\n唯一能判断NaN的方法是通过isNaN()函数:\n\n```JavaScript\nisNaN(NaN); // true\n```\n\n2.浮点数的比较:\n\n```JavaScript\n1/3 === (1 - 2 / 3); //false\n```\n这个结果是正确的,出现这个结果这是因为浮点数在运算过程中会产生误差,计算机无法精确的表示无限小数,所以要比较两个浮点数是否相等,只能计算他们之差的绝对值,看是否小于某个阈值:\n\n```JavaScript\nMath.abs(1/3 - (1 - 2 / 3)) < 0.0000001; //true\n```\n\n\n### Types ###\n\n#### numbers ####\n\nJavaScript中只有一种数字类型 – 64-bit float point,类似于Java中的double类型,所以在JavaScript中1和1.0是相同的值\nnumber可以直接做四则运算，规则和数学一致\n\n#### 字符串 ####\n\n字符串是以'单引号'或\"双引号\"括起来的文本,如`'abc'` `\"xyz\"`\n\n注意`' '`和`\" \"`并不是字符串的一部分\n\n如果字符串中包含`'` 就使用`\"\"`把文本包起来,如果字符串中包含`\"` 就需要使用转义字符了`\\`\n\n在多行字符串中换行使用的是`\\n` 但是如果行数太多`\\n`需要写多个,不方便,在JavaScript中又增加了一种表示方法(ES6),就是将多行文本用\\`... \\`括起来,就是键盘上tab键上边的那个按键.\n\n##### 模板字符串 #####\n多个字符串可以使用`+`连接起来.字符串也可以是变量如:\n\n```JavaScript\nvar name = '小王吧';\nvar age = '100';\nvar message = '你好,' + name + ',你现在' + age + '岁';\n```\n同样,如果要连接的变量有很多,使用`+`就会很不方便,在JavaScript中增加了一种模板字符串的表示(ES6):\n\n```JavaScript\nvar name = '小王吧';\nvar age = '101';\nvar message = `${name},你今年${age}岁,是不是?`\n```\n注意:新的表示方法使用的是\\` ,就是新的多行文本使用的符号,就是键盘上`tab`按键上边的那个按键,不能使用`\"\"或''`,那样无法转换变量\n\n##### 字符串操作 #####\n获取字符的长度\n\n```JavaScript\nvar name = 'xiao wang ba.';\nalert(name.length); //13\n```\n\n获取指定位置字符,可以把字符串看成是特殊的数组,对字符串进行下标操作,从0索引开始\n\n```JavaScript\nvar name = 'xiao wang ba.';\nname[0]; //'x'\nname[1]; //'i'\nname[4]; //' '\nname[12];//'.'\nname[13];//undefined 超出范围的索引一律返回undefined\n```\n注意:给字符串的索引赋值不会有报错,也不会有任何效果,字符串也不会改变\n\n改变字符串为大写\n\n```JavaScript\nvar name = 'xiao wang ba.';\nname.toUpperCase(); //返回'XIAO WANG BA.'\n```\n\n改变字符串为小写\n\n```JavaScript\nvar name = 'Xiao Wang Ba.';\nname.toLowerCase(); //返回'xiao wang ba.'\n```\n注意:如果字符串是中文,则没效果\n\n返回字符串出现的位置\n\n```JavaScript\nvar name = 'Xiao Wang Ba.';\nname.indexOf('Wang');//返回5\nname.indexOf('wang');//如果没有找到指定的子串,返回-1\n```\n\n获取字符串中的子串\n\n```JavaScript\nvar name = 'xiao wang ba.';\nname.substring(0,4);//从索引0开始到4(不包括4),返回'xiao'\nname.substring(10);//从索引10开始到结束,返回'ba.'\n```\n\n#### 布尔值 ####\nJavaScript中的布尔值有`true`和`false`两种值,可以直接用`true`或`false`表示,也可以通过布尔运算计算出来\n\n#### null和undefined ####\n`null`表示一个\"空\"的值,同Java中的`null`,Swift中的nil,Python中的None用法类似.\n`undefined`表示\"未定义\".\nJavaScript设计的时候希望用`null`表示一个空的值,用`undefined`表示值未定义,但是大多数情况下我们都应该用`null`.`undefined`仅仅在判断函数参数是否传递的情况下有用\n\n#### 数组 ####\n数组是一组按顺序排列的集合,集合的每个值称为元素.JavaScript的数组可以包括任意数据类型.\n创建方法:\n\n```JavaScript\n[1,2,3.14,\"hello\",null,true]; //推荐使用\n```\n另一种创建方法:\n\n```JavaScript\nnew Array(1,2,3);\n```\n\n获取数组的长度\n\n```JavaScript\nvar arr = [1,2,3.14,\"hello\",null,true];\narr.length;//6\n//可以给数组的长度赋值,改变数组的大小\narr.length = 7;//数组改变为[1,2,3.14,\"hello\",null,true,undefined]\narr.length = 4;//数组改变为[1,2,3.14,\"hello\"]\n```\n\n\n数组可以通过索引来访问每个元素的值,也可以改变索引对应元素的值:\n\n```JavaScript\nvar arr = [1,2,3.14,\"hello\",null,true];\narr[0]; //数组第一个元素,值为1\narr[1] = 10;//修改数组第二个元素的值为10\n```\n\n注意:如果通过索引给数组赋值的时候,索引超过了数组长度,数组会被变大\n\n```JavaScript\nvar arr = ['A', 'B', 'C'];\narr[5] = 'F';//arr会变为['A', 'B', 'C', undefined, undefined, 'F'];\n```\n\n获取对应元素的索引\n\n```JavaScript\nvar arr = [10, 20 ,'30', 'xyz'];\narr.indexOf(10);//元素10的索引是0\narr.indexOf(20);//元素20的索引是1\narr.indexOf(30);//元素30的索引是 -1 因为没有找到元素\narr.indexOf('30');//元素'30'的索引是2\n```\n注意：数字`30`和`'30'`是不同的元素\n\n获取数组中的部分元素\n\n```JavaScript\nvar arr =['A','B','C','D','E','F','G'];\narr.slice(0,3);//从索引0开始,到索引3结束,但不包括索引3:['A','B','C']\narr.slice(3);//从索引3开始到结束:['D','E','F','G']\n\n```\n\n注意:`slice()`的起止参数包括开始索引,不包括结束索引\n如果不给`slice()`传递任何参数,它会从头到尾截取所有元素,这个方法可以复制一个`array`\n\n```JavaScript\nvar arr = ['A','B','C','D','E','F','G'];\nvar aCopy = arr.slice();\naCopy; //['A','B','C','D','E','F','G'];\naCopy === arr; //false\nif(aCopy.toString() === arr.toString()) {\n    alert('一样');//数组相同\n}else {\n    alert('不一样');//数组不同\n}\n```\n注意:`JavaScript`比较两个数组是否相同不能直接使用`===` 要比较两个数组是否相同,需要先把数组转换成字符串,然后再比较\n\n在数组末尾添加或删除若干元素,`push()`和`pop()`\n\n```JavaScript\nvar arr = [1 , 2];\narr.push('A','B'); //返回新的长度为4的数组\narr; //[1,2,'A','B']\narr.pop();//pop()返回'B'\narr; // [1,2,'A']\narr.pop();arr.pop();arr.pop(); //连续pop 3次\narr; //[]\narr.pop(); //空数组继续pop不会报错,而是返回undefined\narr;//[]\n```\n\n在数组头部添加或删除若干元素,`unshift()`和`shift()`\n\n```JavaScript\nvar arr =[1,2];\narr.unshift('A','B');//返回新的长度为4的数组\narr;//['A','B',1,2]\narr.shift();//'A'\narr;//['B',1,2]\narr.shift();arr.shift();arr.shift();//连续shift 3次\narr;//[]\narr.shift();//空数组继续shift不会报错,而是返回undefined\narr;//[]\n```\n\n数组排序\n`sort()`可以对当前数组进行排序,它会直接修改当前的数组元素的位置,直接调用时,会按照默认顺序排序\n\n```JavaScript\nvar arr = ['B','C','A'];\narr.sort();\narr;//['A','B','C']\n```\n注意 在函数中可以自定义排序条件\n\n数组反转\n\n`reverse()`可以把数组的元素反转\n\n```JavaScript\nvar arr = ['A','B','C'];\narr.reverse();\narr;//['three','two','one']\n```\n\n数组修改的\"万能方法\",可以从指定索引开始删除若干元素,然后再从该位置添加若干元素\n\n```JavaScript\nvar arr =['Microsoft','Apple','Yahoo','AOL','Excite','Oracle']\narr.splice(2,3,'Google','Facebook');//从索引2开始删除3个元素,然后再添加两个元素,返回删除的元素['Yahoo','AOL','Excite']\narr.splice(2,2);//只删除不添加,返回['Google','Facebook']\narr;//['Microsoft','Apple','Oracle']\narr.splice(2.0,'Google','Facebook');//只添加,不删除,返回[]\narr;//['Microsoft','Apple','Google','Facebook','Oracle']\n```\n把两个数组连接起来,返回一个新的数组\n\n```JavaScript\nvar arr = ['A','B','C'];\nvar added = arr.concat([1,2,3]);\nadded; //['A','B','C',1,2,3]\nARR;//['A','B','C']\n```\n注意 `concat()`方法并没有修改当前数组,而是返回了一个新的数组\n\n而且`concat()`可以接收任意个元素和数组,并把所有数组自动拆开,添加到新的数组中\n\n```JavaScript\nvar arr = ['A','B','C'];\narr.concat(1,2,[3,4]);//['A','B','C',1,2,3,4]\n```\n\n把数组的每个元素都用指定的字符串连接起来,然后返回字符串\n\n```JavaScript\nvar arr = ['A','B','C',1,2,3];\narr.join('-'); //'A-B-C-1-2-3'\n```\n注意如果数组的元素不是字符串,会自动转换成字符串再连接\n\n多维数组,指的是数组中的某个元素又是一个数组\n\n```JavaScript\nvar arr = [[1,2,3],[400,500,600],'-'];\n```\n\n上述`Array`包含3个元素,其中头两个元素本身也是`Array`\n\n\n#### 对象 ####\n对象是一组由键-值组成的无序集合:\n\n```JavaScript\nvar person = {\n\tname: 'XiaoWang',\n\ttags: ['js', 'web', 'mobile'],\n\tage: 12,\n\tcity: 'shanghai',\n\thasCar: false,\n\tzipcode: null\n};\n```\n\nJavaScript用一个`{...}` 表示一个对象,键值对以`xxx: xxx`形式申明,用`,`隔开,最后一个键值对不需要加\n\nJavaScript对象的键都是字符串类型,值可以是任意数据类型,每个键都是对象的一个属性,获取属性的方法:\n\n```JavaScript\nperson.name; // 'XiaoWang'\nperson.zipcode; // null\n```\n注:`var person` 是JavaScript的一个变量,`person`是变量名,变量名是大小写英文,数字,`$`和`_`的组合,且不能用数字开头,也不能使用JavaScript中的关键字\n\n\n##### strict模式 #####\n蛋疼的布兰登在设计JavaScript的时候为了赶工期,并没有强制使用`var`声明变量,如果一个变量没有通过`var`声明就被使用,这个变量就会被自动声明为全局变量\n\n```JavaScript\ni = 10; //i就是一个全局变量\n```\n\n如果在不同的JavaScript文件中,你都使用了同样名字的变量,而且都没有用`var`声明,那么你就麻烦了.\n\n因此,为了给布兰登填坑,ECMA在后续的规范中推出了strict模式,在strict模式下运行JavaScript代码不允许使用没有`var`声明的变量,如果有那么就给你报错\n\n启动strict模式的方法很简单,就是在JavaScript代码的第一行写上:\n\n```JavaScript\n'use strict';\n```\n注:如果你用的是老爷机,你的浏览器太老了,他会自以为是的把上面那就话当做一个字符串语句执行,如果这样的话还是换个最新版的浏览器吧\n\n##### Advanced Operaters (高级运算符) #####\n取余运算 `x = y % 2`\n累加运算 `a = 5`\n\t\t`c = a++`/Users/YaoWanXin/Desktop/app.html resulets : c = 5 and a = 6\n\t\t`c = ++a` resulets : c = 6 and a = 6\n累减运算 `a = 5`\n\t\t`c = a--` resulets : c = 5 and a = 4\n\t\t`c = --a` resulets : c = 4 and a = 4\n","slug":"JavaScript","published":1,"updated":"2021-04-12T09:17:38.417Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqjdx1mx00015emuzlio74de","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>闲来无事看了看<code>JavaScript</code>,这里记录部分内容。</p>\n<a id=\"more\"></a>\n<h3 id=\"Equality-相等比较符\"><a href=\"#Equality-相等比较符\" class=\"headerlink\" title=\"Equality (相等比较符)\"></a>Equality (相等比较符)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"number\">42</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"number\">42</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> baz = <span class=\"string\">\"42\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> qux = <span class=\"string\">\"life\"</span>;</span><br></pre></td></tr></table></figure>\n<p>定义了四个变量在Javascript中<code>==</code>是用来比较两个值但是不会判断类型故<code>foo == baz</code>返回的值是<code>true</code></p>\n<p>使用<code>==</code>比较的时候编译器会先把类型转换成相同的类型,再去比较</p>\n<p>因此在JavaScript 要是比较不同类型的两个值可以使用<code>===</code>这样会先判断类型,如果类型不同就会返回<code>false</code></p>\n<p>所以推荐使用<code>===</code>比较</p>\n<p>注意: 1.<code>NaN</code>是个特殊的Number,他与所有其他值都不相等,包括它自己</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">NaN</span> === <span class=\"literal\">NaN</span> ; <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<p>唯一能判断NaN的方法是通过isNaN()函数:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"literal\">NaN</span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>2.浮点数的比较:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>/<span class=\"number\">3</span> === (<span class=\"number\">1</span> - <span class=\"number\">2</span> / <span class=\"number\">3</span>); <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n<p>这个结果是正确的,出现这个结果这是因为浮点数在运算过程中会产生误差,计算机无法精确的表示无限小数,所以要比较两个浮点数是否相等,只能计算他们之差的绝对值,看是否小于某个阈值:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Math</span>.abs(<span class=\"number\">1</span>/<span class=\"number\">3</span> - (<span class=\"number\">1</span> - <span class=\"number\">2</span> / <span class=\"number\">3</span>)) &lt; <span class=\"number\">0.0000001</span>; <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Types\"><a href=\"#Types\" class=\"headerlink\" title=\"Types\"></a>Types</h3><h4 id=\"numbers\"><a href=\"#numbers\" class=\"headerlink\" title=\"numbers\"></a>numbers</h4><p>JavaScript中只有一种数字类型 – 64-bit float point,类似于Java中的double类型,所以在JavaScript中1和1.0是相同的值<br>number可以直接做四则运算，规则和数学一致</p>\n<h4 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h4><p>字符串是以’单引号’或”双引号”括起来的文本,如<code>&#39;abc&#39;</code> <code>&quot;xyz&quot;</code></p>\n<p>注意<code>&#39; &#39;</code>和<code>&quot; &quot;</code>并不是字符串的一部分</p>\n<p>如果字符串中包含<code>&#39;</code> 就使用<code>&quot;&quot;</code>把文本包起来,如果字符串中包含<code>&quot;</code> 就需要使用转义字符了<code>\\</code></p>\n<p>在多行字符串中换行使用的是<code>\\n</code> 但是如果行数太多<code>\\n</code>需要写多个,不方便,在JavaScript中又增加了一种表示方法(ES6),就是将多行文本用`… `括起来,就是键盘上tab键上边的那个按键.</p>\n<h5 id=\"模板字符串\"><a href=\"#模板字符串\" class=\"headerlink\" title=\"模板字符串\"></a>模板字符串</h5><p>多个字符串可以使用<code>+</code>连接起来.字符串也可以是变量如:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'小王吧'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> age = <span class=\"string\">'100'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> message = <span class=\"string\">'你好,'</span> + name + <span class=\"string\">',你现在'</span> + age + <span class=\"string\">'岁'</span>;</span><br></pre></td></tr></table></figure>\n<p>同样,如果要连接的变量有很多,使用<code>+</code>就会很不方便,在JavaScript中增加了一种模板字符串的表示(ES6):</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'小王吧'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> age = <span class=\"string\">'101'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> message = <span class=\"string\">`<span class=\"subst\">$&#123;name&#125;</span>,你今年<span class=\"subst\">$&#123;age&#125;</span>岁,是不是?`</span></span><br></pre></td></tr></table></figure>\n<p>注意:新的表示方法使用的是` ,就是新的多行文本使用的符号,就是键盘上<code>tab</code>按键上边的那个按键,不能使用<code>&quot;&quot;或&#39;&#39;</code>,那样无法转换变量</p>\n<h5 id=\"字符串操作\"><a href=\"#字符串操作\" class=\"headerlink\" title=\"字符串操作\"></a>字符串操作</h5><p>获取字符的长度</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'xiao wang ba.'</span>;</span><br><span class=\"line\">alert(name.length); <span class=\"comment\">//13</span></span><br></pre></td></tr></table></figure>\n<p>获取指定位置字符,可以把字符串看成是特殊的数组,对字符串进行下标操作,从0索引开始</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'xiao wang ba.'</span>;</span><br><span class=\"line\">name[<span class=\"number\">0</span>]; <span class=\"comment\">//'x'</span></span><br><span class=\"line\">name[<span class=\"number\">1</span>]; <span class=\"comment\">//'i'</span></span><br><span class=\"line\">name[<span class=\"number\">4</span>]; <span class=\"comment\">//' '</span></span><br><span class=\"line\">name[<span class=\"number\">12</span>];<span class=\"comment\">//'.'</span></span><br><span class=\"line\">name[<span class=\"number\">13</span>];<span class=\"comment\">//undefined 超出范围的索引一律返回undefined</span></span><br></pre></td></tr></table></figure>\n<p>注意:给字符串的索引赋值不会有报错,也不会有任何效果,字符串也不会改变</p>\n<p>改变字符串为大写</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'xiao wang ba.'</span>;</span><br><span class=\"line\">name.toUpperCase(); <span class=\"comment\">//返回'XIAO WANG BA.'</span></span><br></pre></td></tr></table></figure>\n<p>改变字符串为小写</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'Xiao Wang Ba.'</span>;</span><br><span class=\"line\">name.toLowerCase(); <span class=\"comment\">//返回'xiao wang ba.'</span></span><br></pre></td></tr></table></figure>\n<p>注意:如果字符串是中文,则没效果</p>\n<p>返回字符串出现的位置</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'Xiao Wang Ba.'</span>;</span><br><span class=\"line\">name.indexOf(<span class=\"string\">'Wang'</span>);<span class=\"comment\">//返回5</span></span><br><span class=\"line\">name.indexOf(<span class=\"string\">'wang'</span>);<span class=\"comment\">//如果没有找到指定的子串,返回-1</span></span><br></pre></td></tr></table></figure>\n<p>获取字符串中的子串</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'xiao wang ba.'</span>;</span><br><span class=\"line\">name.substring(<span class=\"number\">0</span>,<span class=\"number\">4</span>);<span class=\"comment\">//从索引0开始到4(不包括4),返回'xiao'</span></span><br><span class=\"line\">name.substring(<span class=\"number\">10</span>);<span class=\"comment\">//从索引10开始到结束,返回'ba.'</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"布尔值\"><a href=\"#布尔值\" class=\"headerlink\" title=\"布尔值\"></a>布尔值</h4><p>JavaScript中的布尔值有<code>true</code>和<code>false</code>两种值,可以直接用<code>true</code>或<code>false</code>表示,也可以通过布尔运算计算出来</p>\n<h4 id=\"null和undefined\"><a href=\"#null和undefined\" class=\"headerlink\" title=\"null和undefined\"></a>null和undefined</h4><p><code>null</code>表示一个”空”的值,同Java中的<code>null</code>,Swift中的nil,Python中的None用法类似.<br><code>undefined</code>表示”未定义”.<br>JavaScript设计的时候希望用<code>null</code>表示一个空的值,用<code>undefined</code>表示值未定义,但是大多数情况下我们都应该用<code>null</code>.<code>undefined</code>仅仅在判断函数参数是否传递的情况下有用</p>\n<h4 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h4><p>数组是一组按顺序排列的集合,集合的每个值称为元素.JavaScript的数组可以包括任意数据类型.<br>创建方法:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3.14</span>,<span class=\"string\">\"hello\"</span>,<span class=\"literal\">null</span>,<span class=\"literal\">true</span>]; <span class=\"comment\">//推荐使用</span></span><br></pre></td></tr></table></figure>\n<p>另一种创建方法:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n<p>获取数组的长度</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3.14</span>,<span class=\"string\">\"hello\"</span>,<span class=\"literal\">null</span>,<span class=\"literal\">true</span>];</span><br><span class=\"line\">arr.length;<span class=\"comment\">//6</span></span><br><span class=\"line\"><span class=\"comment\">//可以给数组的长度赋值,改变数组的大小</span></span><br><span class=\"line\">arr.length = <span class=\"number\">7</span>;<span class=\"comment\">//数组改变为[1,2,3.14,\"hello\",null,true,undefined]</span></span><br><span class=\"line\">arr.length = <span class=\"number\">4</span>;<span class=\"comment\">//数组改变为[1,2,3.14,\"hello\"]</span></span><br></pre></td></tr></table></figure>\n<p>数组可以通过索引来访问每个元素的值,也可以改变索引对应元素的值:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3.14</span>,<span class=\"string\">\"hello\"</span>,<span class=\"literal\">null</span>,<span class=\"literal\">true</span>];</span><br><span class=\"line\">arr[<span class=\"number\">0</span>]; <span class=\"comment\">//数组第一个元素,值为1</span></span><br><span class=\"line\">arr[<span class=\"number\">1</span>] = <span class=\"number\">10</span>;<span class=\"comment\">//修改数组第二个元素的值为10</span></span><br></pre></td></tr></table></figure>\n<p>注意:如果通过索引给数组赋值的时候,索引超过了数组长度,数组会被变大</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>];</span><br><span class=\"line\">arr[<span class=\"number\">5</span>] = <span class=\"string\">'F'</span>;<span class=\"comment\">//arr会变为['A', 'B', 'C', undefined, undefined, 'F'];</span></span><br></pre></td></tr></table></figure>\n<p>获取对应元素的索引</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">10</span>, <span class=\"number\">20</span> ,<span class=\"string\">'30'</span>, <span class=\"string\">'xyz'</span>];</span><br><span class=\"line\">arr.indexOf(<span class=\"number\">10</span>);<span class=\"comment\">//元素10的索引是0</span></span><br><span class=\"line\">arr.indexOf(<span class=\"number\">20</span>);<span class=\"comment\">//元素20的索引是1</span></span><br><span class=\"line\">arr.indexOf(<span class=\"number\">30</span>);<span class=\"comment\">//元素30的索引是 -1 因为没有找到元素</span></span><br><span class=\"line\">arr.indexOf(<span class=\"string\">'30'</span>);<span class=\"comment\">//元素'30'的索引是2</span></span><br></pre></td></tr></table></figure>\n<p>注意：数字<code>30</code>和<code>&#39;30&#39;</code>是不同的元素</p>\n<p>获取数组中的部分元素</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr =[<span class=\"string\">'A'</span>,<span class=\"string\">'B'</span>,<span class=\"string\">'C'</span>,<span class=\"string\">'D'</span>,<span class=\"string\">'E'</span>,<span class=\"string\">'F'</span>,<span class=\"string\">'G'</span>];</span><br><span class=\"line\">arr.slice(<span class=\"number\">0</span>,<span class=\"number\">3</span>);<span class=\"comment\">//从索引0开始,到索引3结束,但不包括索引3:['A','B','C']</span></span><br><span class=\"line\">arr.slice(<span class=\"number\">3</span>);<span class=\"comment\">//从索引3开始到结束:['D','E','F','G']</span></span><br></pre></td></tr></table></figure>\n<p>注意:<code>slice()</code>的起止参数包括开始索引,不包括结束索引<br>如果不给<code>slice()</code>传递任何参数,它会从头到尾截取所有元素,这个方法可以复制一个<code>array</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'A'</span>,<span class=\"string\">'B'</span>,<span class=\"string\">'C'</span>,<span class=\"string\">'D'</span>,<span class=\"string\">'E'</span>,<span class=\"string\">'F'</span>,<span class=\"string\">'G'</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> aCopy = arr.slice();</span><br><span class=\"line\">aCopy; <span class=\"comment\">//['A','B','C','D','E','F','G'];</span></span><br><span class=\"line\">aCopy === arr; <span class=\"comment\">//false</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(aCopy.toString() === arr.toString()) &#123;</span><br><span class=\"line\">    alert(<span class=\"string\">'一样'</span>);<span class=\"comment\">//数组相同</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    alert(<span class=\"string\">'不一样'</span>);<span class=\"comment\">//数组不同</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意:<code>JavaScript</code>比较两个数组是否相同不能直接使用<code>===</code> 要比较两个数组是否相同,需要先把数组转换成字符串,然后再比较</p>\n<p>在数组末尾添加或删除若干元素,<code>push()</code>和<code>pop()</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span> , <span class=\"number\">2</span>];</span><br><span class=\"line\">arr.push(<span class=\"string\">'A'</span>,<span class=\"string\">'B'</span>); <span class=\"comment\">//返回新的长度为4的数组</span></span><br><span class=\"line\">arr; <span class=\"comment\">//[1,2,'A','B']</span></span><br><span class=\"line\">arr.pop();<span class=\"comment\">//pop()返回'B'</span></span><br><span class=\"line\">arr; <span class=\"comment\">// [1,2,'A']</span></span><br><span class=\"line\">arr.pop();arr.pop();arr.pop(); <span class=\"comment\">//连续pop 3次</span></span><br><span class=\"line\">arr; <span class=\"comment\">//[]</span></span><br><span class=\"line\">arr.pop(); <span class=\"comment\">//空数组继续pop不会报错,而是返回undefined</span></span><br><span class=\"line\">arr;<span class=\"comment\">//[]</span></span><br></pre></td></tr></table></figure>\n<p>在数组头部添加或删除若干元素,<code>unshift()</code>和<code>shift()</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr =[<span class=\"number\">1</span>,<span class=\"number\">2</span>];</span><br><span class=\"line\">arr.unshift(<span class=\"string\">'A'</span>,<span class=\"string\">'B'</span>);<span class=\"comment\">//返回新的长度为4的数组</span></span><br><span class=\"line\">arr;<span class=\"comment\">//['A','B',1,2]</span></span><br><span class=\"line\">arr.shift();<span class=\"comment\">//'A'</span></span><br><span class=\"line\">arr;<span class=\"comment\">//['B',1,2]</span></span><br><span class=\"line\">arr.shift();arr.shift();arr.shift();<span class=\"comment\">//连续shift 3次</span></span><br><span class=\"line\">arr;<span class=\"comment\">//[]</span></span><br><span class=\"line\">arr.shift();<span class=\"comment\">//空数组继续shift不会报错,而是返回undefined</span></span><br><span class=\"line\">arr;<span class=\"comment\">//[]</span></span><br></pre></td></tr></table></figure>\n<p>数组排序<br><code>sort()</code>可以对当前数组进行排序,它会直接修改当前的数组元素的位置,直接调用时,会按照默认顺序排序</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'B'</span>,<span class=\"string\">'C'</span>,<span class=\"string\">'A'</span>];</span><br><span class=\"line\">arr.sort();</span><br><span class=\"line\">arr;<span class=\"comment\">//['A','B','C']</span></span><br></pre></td></tr></table></figure>\n<p>注意 在函数中可以自定义排序条件</p>\n<p>数组反转</p>\n<p><code>reverse()</code>可以把数组的元素反转</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'A'</span>,<span class=\"string\">'B'</span>,<span class=\"string\">'C'</span>];</span><br><span class=\"line\">arr.reverse();</span><br><span class=\"line\">arr;<span class=\"comment\">//['three','two','one']</span></span><br></pre></td></tr></table></figure>\n<p>数组修改的”万能方法”,可以从指定索引开始删除若干元素,然后再从该位置添加若干元素</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr =[<span class=\"string\">'Microsoft'</span>,<span class=\"string\">'Apple'</span>,<span class=\"string\">'Yahoo'</span>,<span class=\"string\">'AOL'</span>,<span class=\"string\">'Excite'</span>,<span class=\"string\">'Oracle'</span>]</span><br><span class=\"line\">arr.splice(<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"string\">'Google'</span>,<span class=\"string\">'Facebook'</span>);<span class=\"comment\">//从索引2开始删除3个元素,然后再添加两个元素,返回删除的元素['Yahoo','AOL','Excite']</span></span><br><span class=\"line\">arr.splice(<span class=\"number\">2</span>,<span class=\"number\">2</span>);<span class=\"comment\">//只删除不添加,返回['Google','Facebook']</span></span><br><span class=\"line\">arr;<span class=\"comment\">//['Microsoft','Apple','Oracle']</span></span><br><span class=\"line\">arr.splice(<span class=\"number\">2.0</span>,<span class=\"string\">'Google'</span>,<span class=\"string\">'Facebook'</span>);<span class=\"comment\">//只添加,不删除,返回[]</span></span><br><span class=\"line\">arr;<span class=\"comment\">//['Microsoft','Apple','Google','Facebook','Oracle']</span></span><br></pre></td></tr></table></figure>\n<p>把两个数组连接起来,返回一个新的数组</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'A'</span>,<span class=\"string\">'B'</span>,<span class=\"string\">'C'</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> added = arr.concat([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]);</span><br><span class=\"line\">added; <span class=\"comment\">//['A','B','C',1,2,3]</span></span><br><span class=\"line\">ARR;<span class=\"comment\">//['A','B','C']</span></span><br></pre></td></tr></table></figure>\n<p>注意 <code>concat()</code>方法并没有修改当前数组,而是返回了一个新的数组</p>\n<p>而且<code>concat()</code>可以接收任意个元素和数组,并把所有数组自动拆开,添加到新的数组中</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'A'</span>,<span class=\"string\">'B'</span>,<span class=\"string\">'C'</span>];</span><br><span class=\"line\">arr.concat(<span class=\"number\">1</span>,<span class=\"number\">2</span>,[<span class=\"number\">3</span>,<span class=\"number\">4</span>]);<span class=\"comment\">//['A','B','C',1,2,3,4]</span></span><br></pre></td></tr></table></figure>\n<p>把数组的每个元素都用指定的字符串连接起来,然后返回字符串</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'A'</span>,<span class=\"string\">'B'</span>,<span class=\"string\">'C'</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\">arr.join(<span class=\"string\">'-'</span>); <span class=\"comment\">//'A-B-C-1-2-3'</span></span><br></pre></td></tr></table></figure>\n<p>注意如果数组的元素不是字符串,会自动转换成字符串再连接</p>\n<p>多维数组,指的是数组中的某个元素又是一个数组</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>],[<span class=\"number\">400</span>,<span class=\"number\">500</span>,<span class=\"number\">600</span>],<span class=\"string\">'-'</span>];</span><br></pre></td></tr></table></figure>\n<p>上述<code>Array</code>包含3个元素,其中头两个元素本身也是<code>Array</code></p>\n<h4 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h4><p>对象是一组由键-值组成的无序集合:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">\tname: <span class=\"string\">'XiaoWang'</span>,</span><br><span class=\"line\">\ttags: [<span class=\"string\">'js'</span>, <span class=\"string\">'web'</span>, <span class=\"string\">'mobile'</span>],</span><br><span class=\"line\">\tage: <span class=\"number\">12</span>,</span><br><span class=\"line\">\tcity: <span class=\"string\">'shanghai'</span>,</span><br><span class=\"line\">\thasCar: <span class=\"literal\">false</span>,</span><br><span class=\"line\">\tzipcode: <span class=\"literal\">null</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>JavaScript用一个<code>{...}</code> 表示一个对象,键值对以<code>xxx: xxx</code>形式申明,用<code>,</code>隔开,最后一个键值对不需要加</p>\n<p>JavaScript对象的键都是字符串类型,值可以是任意数据类型,每个键都是对象的一个属性,获取属性的方法:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">person.name; <span class=\"comment\">// 'XiaoWang'</span></span><br><span class=\"line\">person.zipcode; <span class=\"comment\">// null</span></span><br></pre></td></tr></table></figure>\n<p>注:<code>var person</code> 是JavaScript的一个变量,<code>person</code>是变量名,变量名是大小写英文,数字,<code>$</code>和<code>_</code>的组合,且不能用数字开头,也不能使用JavaScript中的关键字</p>\n<h5 id=\"strict模式\"><a href=\"#strict模式\" class=\"headerlink\" title=\"strict模式\"></a>strict模式</h5><p>蛋疼的布兰登在设计JavaScript的时候为了赶工期,并没有强制使用<code>var</code>声明变量,如果一个变量没有通过<code>var</code>声明就被使用,这个变量就会被自动声明为全局变量</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i = <span class=\"number\">10</span>; <span class=\"comment\">//i就是一个全局变量</span></span><br></pre></td></tr></table></figure>\n<p>如果在不同的JavaScript文件中,你都使用了同样名字的变量,而且都没有用<code>var</code>声明,那么你就麻烦了.</p>\n<p>因此,为了给布兰登填坑,ECMA在后续的规范中推出了strict模式,在strict模式下运行JavaScript代码不允许使用没有<code>var</code>声明的变量,如果有那么就给你报错</p>\n<p>启动strict模式的方法很简单,就是在JavaScript代码的第一行写上:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">'use strict'</span>;</span><br></pre></td></tr></table></figure>\n<p>注:如果你用的是老爷机,你的浏览器太老了,他会自以为是的把上面那就话当做一个字符串语句执行,如果这样的话还是换个最新版的浏览器吧</p>\n<h5 id=\"Advanced-Operaters-高级运算符\"><a href=\"#Advanced-Operaters-高级运算符\" class=\"headerlink\" title=\"Advanced Operaters (高级运算符)\"></a>Advanced Operaters (高级运算符)</h5><p>取余运算 <code>x = y % 2</code><br>累加运算 <code>a = 5</code><br>        <code>c = a++</code>/Users/YaoWanXin/Desktop/app.html resulets : c = 5 and a = 6<br>        <code>c = ++a</code> resulets : c = 6 and a = 6<br>累减运算 <code>a = 5</code><br>        <code>c = a--</code> resulets : c = 5 and a = 4<br>        <code>c = --a</code> resulets : c = 4 and a = 4</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>闲来无事看了看<code>JavaScript</code>,这里记录部分内容。</p>","more":"<h3 id=\"Equality-相等比较符\"><a href=\"#Equality-相等比较符\" class=\"headerlink\" title=\"Equality (相等比较符)\"></a>Equality (相等比较符)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"number\">42</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"number\">42</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> baz = <span class=\"string\">\"42\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> qux = <span class=\"string\">\"life\"</span>;</span><br></pre></td></tr></table></figure>\n<p>定义了四个变量在Javascript中<code>==</code>是用来比较两个值但是不会判断类型故<code>foo == baz</code>返回的值是<code>true</code></p>\n<p>使用<code>==</code>比较的时候编译器会先把类型转换成相同的类型,再去比较</p>\n<p>因此在JavaScript 要是比较不同类型的两个值可以使用<code>===</code>这样会先判断类型,如果类型不同就会返回<code>false</code></p>\n<p>所以推荐使用<code>===</code>比较</p>\n<p>注意: 1.<code>NaN</code>是个特殊的Number,他与所有其他值都不相等,包括它自己</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">NaN</span> === <span class=\"literal\">NaN</span> ; <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<p>唯一能判断NaN的方法是通过isNaN()函数:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">isNaN</span>(<span class=\"literal\">NaN</span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>2.浮点数的比较:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>/<span class=\"number\">3</span> === (<span class=\"number\">1</span> - <span class=\"number\">2</span> / <span class=\"number\">3</span>); <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n<p>这个结果是正确的,出现这个结果这是因为浮点数在运算过程中会产生误差,计算机无法精确的表示无限小数,所以要比较两个浮点数是否相等,只能计算他们之差的绝对值,看是否小于某个阈值:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Math</span>.abs(<span class=\"number\">1</span>/<span class=\"number\">3</span> - (<span class=\"number\">1</span> - <span class=\"number\">2</span> / <span class=\"number\">3</span>)) &lt; <span class=\"number\">0.0000001</span>; <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Types\"><a href=\"#Types\" class=\"headerlink\" title=\"Types\"></a>Types</h3><h4 id=\"numbers\"><a href=\"#numbers\" class=\"headerlink\" title=\"numbers\"></a>numbers</h4><p>JavaScript中只有一种数字类型 – 64-bit float point,类似于Java中的double类型,所以在JavaScript中1和1.0是相同的值<br>number可以直接做四则运算，规则和数学一致</p>\n<h4 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h4><p>字符串是以’单引号’或”双引号”括起来的文本,如<code>&#39;abc&#39;</code> <code>&quot;xyz&quot;</code></p>\n<p>注意<code>&#39; &#39;</code>和<code>&quot; &quot;</code>并不是字符串的一部分</p>\n<p>如果字符串中包含<code>&#39;</code> 就使用<code>&quot;&quot;</code>把文本包起来,如果字符串中包含<code>&quot;</code> 就需要使用转义字符了<code>\\</code></p>\n<p>在多行字符串中换行使用的是<code>\\n</code> 但是如果行数太多<code>\\n</code>需要写多个,不方便,在JavaScript中又增加了一种表示方法(ES6),就是将多行文本用`… `括起来,就是键盘上tab键上边的那个按键.</p>\n<h5 id=\"模板字符串\"><a href=\"#模板字符串\" class=\"headerlink\" title=\"模板字符串\"></a>模板字符串</h5><p>多个字符串可以使用<code>+</code>连接起来.字符串也可以是变量如:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'小王吧'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> age = <span class=\"string\">'100'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> message = <span class=\"string\">'你好,'</span> + name + <span class=\"string\">',你现在'</span> + age + <span class=\"string\">'岁'</span>;</span><br></pre></td></tr></table></figure>\n<p>同样,如果要连接的变量有很多,使用<code>+</code>就会很不方便,在JavaScript中增加了一种模板字符串的表示(ES6):</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'小王吧'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> age = <span class=\"string\">'101'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> message = <span class=\"string\">`<span class=\"subst\">$&#123;name&#125;</span>,你今年<span class=\"subst\">$&#123;age&#125;</span>岁,是不是?`</span></span><br></pre></td></tr></table></figure>\n<p>注意:新的表示方法使用的是` ,就是新的多行文本使用的符号,就是键盘上<code>tab</code>按键上边的那个按键,不能使用<code>&quot;&quot;或&#39;&#39;</code>,那样无法转换变量</p>\n<h5 id=\"字符串操作\"><a href=\"#字符串操作\" class=\"headerlink\" title=\"字符串操作\"></a>字符串操作</h5><p>获取字符的长度</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'xiao wang ba.'</span>;</span><br><span class=\"line\">alert(name.length); <span class=\"comment\">//13</span></span><br></pre></td></tr></table></figure>\n<p>获取指定位置字符,可以把字符串看成是特殊的数组,对字符串进行下标操作,从0索引开始</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'xiao wang ba.'</span>;</span><br><span class=\"line\">name[<span class=\"number\">0</span>]; <span class=\"comment\">//'x'</span></span><br><span class=\"line\">name[<span class=\"number\">1</span>]; <span class=\"comment\">//'i'</span></span><br><span class=\"line\">name[<span class=\"number\">4</span>]; <span class=\"comment\">//' '</span></span><br><span class=\"line\">name[<span class=\"number\">12</span>];<span class=\"comment\">//'.'</span></span><br><span class=\"line\">name[<span class=\"number\">13</span>];<span class=\"comment\">//undefined 超出范围的索引一律返回undefined</span></span><br></pre></td></tr></table></figure>\n<p>注意:给字符串的索引赋值不会有报错,也不会有任何效果,字符串也不会改变</p>\n<p>改变字符串为大写</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'xiao wang ba.'</span>;</span><br><span class=\"line\">name.toUpperCase(); <span class=\"comment\">//返回'XIAO WANG BA.'</span></span><br></pre></td></tr></table></figure>\n<p>改变字符串为小写</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'Xiao Wang Ba.'</span>;</span><br><span class=\"line\">name.toLowerCase(); <span class=\"comment\">//返回'xiao wang ba.'</span></span><br></pre></td></tr></table></figure>\n<p>注意:如果字符串是中文,则没效果</p>\n<p>返回字符串出现的位置</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'Xiao Wang Ba.'</span>;</span><br><span class=\"line\">name.indexOf(<span class=\"string\">'Wang'</span>);<span class=\"comment\">//返回5</span></span><br><span class=\"line\">name.indexOf(<span class=\"string\">'wang'</span>);<span class=\"comment\">//如果没有找到指定的子串,返回-1</span></span><br></pre></td></tr></table></figure>\n<p>获取字符串中的子串</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'xiao wang ba.'</span>;</span><br><span class=\"line\">name.substring(<span class=\"number\">0</span>,<span class=\"number\">4</span>);<span class=\"comment\">//从索引0开始到4(不包括4),返回'xiao'</span></span><br><span class=\"line\">name.substring(<span class=\"number\">10</span>);<span class=\"comment\">//从索引10开始到结束,返回'ba.'</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"布尔值\"><a href=\"#布尔值\" class=\"headerlink\" title=\"布尔值\"></a>布尔值</h4><p>JavaScript中的布尔值有<code>true</code>和<code>false</code>两种值,可以直接用<code>true</code>或<code>false</code>表示,也可以通过布尔运算计算出来</p>\n<h4 id=\"null和undefined\"><a href=\"#null和undefined\" class=\"headerlink\" title=\"null和undefined\"></a>null和undefined</h4><p><code>null</code>表示一个”空”的值,同Java中的<code>null</code>,Swift中的nil,Python中的None用法类似.<br><code>undefined</code>表示”未定义”.<br>JavaScript设计的时候希望用<code>null</code>表示一个空的值,用<code>undefined</code>表示值未定义,但是大多数情况下我们都应该用<code>null</code>.<code>undefined</code>仅仅在判断函数参数是否传递的情况下有用</p>\n<h4 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h4><p>数组是一组按顺序排列的集合,集合的每个值称为元素.JavaScript的数组可以包括任意数据类型.<br>创建方法:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3.14</span>,<span class=\"string\">\"hello\"</span>,<span class=\"literal\">null</span>,<span class=\"literal\">true</span>]; <span class=\"comment\">//推荐使用</span></span><br></pre></td></tr></table></figure>\n<p>另一种创建方法:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n<p>获取数组的长度</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3.14</span>,<span class=\"string\">\"hello\"</span>,<span class=\"literal\">null</span>,<span class=\"literal\">true</span>];</span><br><span class=\"line\">arr.length;<span class=\"comment\">//6</span></span><br><span class=\"line\"><span class=\"comment\">//可以给数组的长度赋值,改变数组的大小</span></span><br><span class=\"line\">arr.length = <span class=\"number\">7</span>;<span class=\"comment\">//数组改变为[1,2,3.14,\"hello\",null,true,undefined]</span></span><br><span class=\"line\">arr.length = <span class=\"number\">4</span>;<span class=\"comment\">//数组改变为[1,2,3.14,\"hello\"]</span></span><br></pre></td></tr></table></figure>\n<p>数组可以通过索引来访问每个元素的值,也可以改变索引对应元素的值:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3.14</span>,<span class=\"string\">\"hello\"</span>,<span class=\"literal\">null</span>,<span class=\"literal\">true</span>];</span><br><span class=\"line\">arr[<span class=\"number\">0</span>]; <span class=\"comment\">//数组第一个元素,值为1</span></span><br><span class=\"line\">arr[<span class=\"number\">1</span>] = <span class=\"number\">10</span>;<span class=\"comment\">//修改数组第二个元素的值为10</span></span><br></pre></td></tr></table></figure>\n<p>注意:如果通过索引给数组赋值的时候,索引超过了数组长度,数组会被变大</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>];</span><br><span class=\"line\">arr[<span class=\"number\">5</span>] = <span class=\"string\">'F'</span>;<span class=\"comment\">//arr会变为['A', 'B', 'C', undefined, undefined, 'F'];</span></span><br></pre></td></tr></table></figure>\n<p>获取对应元素的索引</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">10</span>, <span class=\"number\">20</span> ,<span class=\"string\">'30'</span>, <span class=\"string\">'xyz'</span>];</span><br><span class=\"line\">arr.indexOf(<span class=\"number\">10</span>);<span class=\"comment\">//元素10的索引是0</span></span><br><span class=\"line\">arr.indexOf(<span class=\"number\">20</span>);<span class=\"comment\">//元素20的索引是1</span></span><br><span class=\"line\">arr.indexOf(<span class=\"number\">30</span>);<span class=\"comment\">//元素30的索引是 -1 因为没有找到元素</span></span><br><span class=\"line\">arr.indexOf(<span class=\"string\">'30'</span>);<span class=\"comment\">//元素'30'的索引是2</span></span><br></pre></td></tr></table></figure>\n<p>注意：数字<code>30</code>和<code>&#39;30&#39;</code>是不同的元素</p>\n<p>获取数组中的部分元素</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr =[<span class=\"string\">'A'</span>,<span class=\"string\">'B'</span>,<span class=\"string\">'C'</span>,<span class=\"string\">'D'</span>,<span class=\"string\">'E'</span>,<span class=\"string\">'F'</span>,<span class=\"string\">'G'</span>];</span><br><span class=\"line\">arr.slice(<span class=\"number\">0</span>,<span class=\"number\">3</span>);<span class=\"comment\">//从索引0开始,到索引3结束,但不包括索引3:['A','B','C']</span></span><br><span class=\"line\">arr.slice(<span class=\"number\">3</span>);<span class=\"comment\">//从索引3开始到结束:['D','E','F','G']</span></span><br></pre></td></tr></table></figure>\n<p>注意:<code>slice()</code>的起止参数包括开始索引,不包括结束索引<br>如果不给<code>slice()</code>传递任何参数,它会从头到尾截取所有元素,这个方法可以复制一个<code>array</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'A'</span>,<span class=\"string\">'B'</span>,<span class=\"string\">'C'</span>,<span class=\"string\">'D'</span>,<span class=\"string\">'E'</span>,<span class=\"string\">'F'</span>,<span class=\"string\">'G'</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> aCopy = arr.slice();</span><br><span class=\"line\">aCopy; <span class=\"comment\">//['A','B','C','D','E','F','G'];</span></span><br><span class=\"line\">aCopy === arr; <span class=\"comment\">//false</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(aCopy.toString() === arr.toString()) &#123;</span><br><span class=\"line\">    alert(<span class=\"string\">'一样'</span>);<span class=\"comment\">//数组相同</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    alert(<span class=\"string\">'不一样'</span>);<span class=\"comment\">//数组不同</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意:<code>JavaScript</code>比较两个数组是否相同不能直接使用<code>===</code> 要比较两个数组是否相同,需要先把数组转换成字符串,然后再比较</p>\n<p>在数组末尾添加或删除若干元素,<code>push()</code>和<code>pop()</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span> , <span class=\"number\">2</span>];</span><br><span class=\"line\">arr.push(<span class=\"string\">'A'</span>,<span class=\"string\">'B'</span>); <span class=\"comment\">//返回新的长度为4的数组</span></span><br><span class=\"line\">arr; <span class=\"comment\">//[1,2,'A','B']</span></span><br><span class=\"line\">arr.pop();<span class=\"comment\">//pop()返回'B'</span></span><br><span class=\"line\">arr; <span class=\"comment\">// [1,2,'A']</span></span><br><span class=\"line\">arr.pop();arr.pop();arr.pop(); <span class=\"comment\">//连续pop 3次</span></span><br><span class=\"line\">arr; <span class=\"comment\">//[]</span></span><br><span class=\"line\">arr.pop(); <span class=\"comment\">//空数组继续pop不会报错,而是返回undefined</span></span><br><span class=\"line\">arr;<span class=\"comment\">//[]</span></span><br></pre></td></tr></table></figure>\n<p>在数组头部添加或删除若干元素,<code>unshift()</code>和<code>shift()</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr =[<span class=\"number\">1</span>,<span class=\"number\">2</span>];</span><br><span class=\"line\">arr.unshift(<span class=\"string\">'A'</span>,<span class=\"string\">'B'</span>);<span class=\"comment\">//返回新的长度为4的数组</span></span><br><span class=\"line\">arr;<span class=\"comment\">//['A','B',1,2]</span></span><br><span class=\"line\">arr.shift();<span class=\"comment\">//'A'</span></span><br><span class=\"line\">arr;<span class=\"comment\">//['B',1,2]</span></span><br><span class=\"line\">arr.shift();arr.shift();arr.shift();<span class=\"comment\">//连续shift 3次</span></span><br><span class=\"line\">arr;<span class=\"comment\">//[]</span></span><br><span class=\"line\">arr.shift();<span class=\"comment\">//空数组继续shift不会报错,而是返回undefined</span></span><br><span class=\"line\">arr;<span class=\"comment\">//[]</span></span><br></pre></td></tr></table></figure>\n<p>数组排序<br><code>sort()</code>可以对当前数组进行排序,它会直接修改当前的数组元素的位置,直接调用时,会按照默认顺序排序</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'B'</span>,<span class=\"string\">'C'</span>,<span class=\"string\">'A'</span>];</span><br><span class=\"line\">arr.sort();</span><br><span class=\"line\">arr;<span class=\"comment\">//['A','B','C']</span></span><br></pre></td></tr></table></figure>\n<p>注意 在函数中可以自定义排序条件</p>\n<p>数组反转</p>\n<p><code>reverse()</code>可以把数组的元素反转</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'A'</span>,<span class=\"string\">'B'</span>,<span class=\"string\">'C'</span>];</span><br><span class=\"line\">arr.reverse();</span><br><span class=\"line\">arr;<span class=\"comment\">//['three','two','one']</span></span><br></pre></td></tr></table></figure>\n<p>数组修改的”万能方法”,可以从指定索引开始删除若干元素,然后再从该位置添加若干元素</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr =[<span class=\"string\">'Microsoft'</span>,<span class=\"string\">'Apple'</span>,<span class=\"string\">'Yahoo'</span>,<span class=\"string\">'AOL'</span>,<span class=\"string\">'Excite'</span>,<span class=\"string\">'Oracle'</span>]</span><br><span class=\"line\">arr.splice(<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"string\">'Google'</span>,<span class=\"string\">'Facebook'</span>);<span class=\"comment\">//从索引2开始删除3个元素,然后再添加两个元素,返回删除的元素['Yahoo','AOL','Excite']</span></span><br><span class=\"line\">arr.splice(<span class=\"number\">2</span>,<span class=\"number\">2</span>);<span class=\"comment\">//只删除不添加,返回['Google','Facebook']</span></span><br><span class=\"line\">arr;<span class=\"comment\">//['Microsoft','Apple','Oracle']</span></span><br><span class=\"line\">arr.splice(<span class=\"number\">2.0</span>,<span class=\"string\">'Google'</span>,<span class=\"string\">'Facebook'</span>);<span class=\"comment\">//只添加,不删除,返回[]</span></span><br><span class=\"line\">arr;<span class=\"comment\">//['Microsoft','Apple','Google','Facebook','Oracle']</span></span><br></pre></td></tr></table></figure>\n<p>把两个数组连接起来,返回一个新的数组</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'A'</span>,<span class=\"string\">'B'</span>,<span class=\"string\">'C'</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> added = arr.concat([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]);</span><br><span class=\"line\">added; <span class=\"comment\">//['A','B','C',1,2,3]</span></span><br><span class=\"line\">ARR;<span class=\"comment\">//['A','B','C']</span></span><br></pre></td></tr></table></figure>\n<p>注意 <code>concat()</code>方法并没有修改当前数组,而是返回了一个新的数组</p>\n<p>而且<code>concat()</code>可以接收任意个元素和数组,并把所有数组自动拆开,添加到新的数组中</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'A'</span>,<span class=\"string\">'B'</span>,<span class=\"string\">'C'</span>];</span><br><span class=\"line\">arr.concat(<span class=\"number\">1</span>,<span class=\"number\">2</span>,[<span class=\"number\">3</span>,<span class=\"number\">4</span>]);<span class=\"comment\">//['A','B','C',1,2,3,4]</span></span><br></pre></td></tr></table></figure>\n<p>把数组的每个元素都用指定的字符串连接起来,然后返回字符串</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'A'</span>,<span class=\"string\">'B'</span>,<span class=\"string\">'C'</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\">arr.join(<span class=\"string\">'-'</span>); <span class=\"comment\">//'A-B-C-1-2-3'</span></span><br></pre></td></tr></table></figure>\n<p>注意如果数组的元素不是字符串,会自动转换成字符串再连接</p>\n<p>多维数组,指的是数组中的某个元素又是一个数组</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>],[<span class=\"number\">400</span>,<span class=\"number\">500</span>,<span class=\"number\">600</span>],<span class=\"string\">'-'</span>];</span><br></pre></td></tr></table></figure>\n<p>上述<code>Array</code>包含3个元素,其中头两个元素本身也是<code>Array</code></p>\n<h4 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h4><p>对象是一组由键-值组成的无序集合:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">\tname: <span class=\"string\">'XiaoWang'</span>,</span><br><span class=\"line\">\ttags: [<span class=\"string\">'js'</span>, <span class=\"string\">'web'</span>, <span class=\"string\">'mobile'</span>],</span><br><span class=\"line\">\tage: <span class=\"number\">12</span>,</span><br><span class=\"line\">\tcity: <span class=\"string\">'shanghai'</span>,</span><br><span class=\"line\">\thasCar: <span class=\"literal\">false</span>,</span><br><span class=\"line\">\tzipcode: <span class=\"literal\">null</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>JavaScript用一个<code>{...}</code> 表示一个对象,键值对以<code>xxx: xxx</code>形式申明,用<code>,</code>隔开,最后一个键值对不需要加</p>\n<p>JavaScript对象的键都是字符串类型,值可以是任意数据类型,每个键都是对象的一个属性,获取属性的方法:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">person.name; <span class=\"comment\">// 'XiaoWang'</span></span><br><span class=\"line\">person.zipcode; <span class=\"comment\">// null</span></span><br></pre></td></tr></table></figure>\n<p>注:<code>var person</code> 是JavaScript的一个变量,<code>person</code>是变量名,变量名是大小写英文,数字,<code>$</code>和<code>_</code>的组合,且不能用数字开头,也不能使用JavaScript中的关键字</p>\n<h5 id=\"strict模式\"><a href=\"#strict模式\" class=\"headerlink\" title=\"strict模式\"></a>strict模式</h5><p>蛋疼的布兰登在设计JavaScript的时候为了赶工期,并没有强制使用<code>var</code>声明变量,如果一个变量没有通过<code>var</code>声明就被使用,这个变量就会被自动声明为全局变量</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i = <span class=\"number\">10</span>; <span class=\"comment\">//i就是一个全局变量</span></span><br></pre></td></tr></table></figure>\n<p>如果在不同的JavaScript文件中,你都使用了同样名字的变量,而且都没有用<code>var</code>声明,那么你就麻烦了.</p>\n<p>因此,为了给布兰登填坑,ECMA在后续的规范中推出了strict模式,在strict模式下运行JavaScript代码不允许使用没有<code>var</code>声明的变量,如果有那么就给你报错</p>\n<p>启动strict模式的方法很简单,就是在JavaScript代码的第一行写上:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">'use strict'</span>;</span><br></pre></td></tr></table></figure>\n<p>注:如果你用的是老爷机,你的浏览器太老了,他会自以为是的把上面那就话当做一个字符串语句执行,如果这样的话还是换个最新版的浏览器吧</p>\n<h5 id=\"Advanced-Operaters-高级运算符\"><a href=\"#Advanced-Operaters-高级运算符\" class=\"headerlink\" title=\"Advanced Operaters (高级运算符)\"></a>Advanced Operaters (高级运算符)</h5><p>取余运算 <code>x = y % 2</code><br>累加运算 <code>a = 5</code><br>        <code>c = a++</code>/Users/YaoWanXin/Desktop/app.html resulets : c = 5 and a = 6<br>        <code>c = ++a</code> resulets : c = 6 and a = 6<br>累减运算 <code>a = 5</code><br>        <code>c = a--</code> resulets : c = 5 and a = 4<br>        <code>c = --a</code> resulets : c = 4 and a = 4</p>"},{"title":"Hexo的安装和使用","date":"2016-08-02T11:13:00.000Z","_content":"\n\n### 一、hexo的安装\n\n#### 1、安装Node.js\n\nHexo是基于`Node.js`的静态博客框架，所以要安装`Hexo`先要安装`Node.js`。\n\n\nNode.js的安装方法非常简单，从[Node.js官网](https://nodejs.org/en/)下载安装包安装就好\n\n#### 2、安装git\n\nmac下安装了Xcode就会有git\n\n<!-- more -->\n\n\n#### 3、安装Hexo\n\n在终端执行如下命令\n\n```\nsudo npm install -g hexo\n```\n\n等待安装成功\n\n安装完成后使用查看版本命令，看看是否安装成功\n\n```\nhexo -v\n```\n\n如果正常显示版本说明安装成功\n\n#### 注意\n\n如果报如下错误：\n\n```\nError: The module '/Users/***/Desktop/***/node_modules/dtrace-provider/build/Release/DTraceProviderBindings.node'\nwas compiled against a different Node.js version using\nNODE_MODULE_VERSION 48. This version of Node.js requires\nNODE_MODULE_VERSION 67. Please try re-compiling or re-installing\nthe module (for instance, using `npm rebuild` or `npm install`).\n    at Object.Module._extensions..node (internal/modules/cjs/loader.js:751:18)\n    at Module.load (internal/modules/cjs/loader.js:620:32)\n    at tryModuleLoad (internal/modules/cjs/loader.js:560:12)\n    at Function.Module._load (internal/modules/cjs/loader.js:552:3)\n    at Module.require (internal/modules/cjs/loader.js:658:17)\n    \n    ...\n```\n\n执行下面操作：\n\n```\n1. cd hexo 根目录\n2. rm -rvf node_modules\n3. npm install\n\n```\n\n这是因为node_modules的缓存存在版本问题\n\n\n### 二、hexo的使用\n\n#### 创建一个blog库\n\n```\nhexo init blog\n```\n\nblog是文件夹的名称，可以随便起\n\n#### 创建一个blog\n\n```\nhexo new blog_title\n```\n\n这个样就可以创建一个title是blog_title的博客了\n\n这个只是一个默认参数的简写命令\n\n#### 生成静态页面\n\n```\nhexo generate\t\t\n或者：\nhexo g\n```\n\n#### 部署到本地\n\n```\nhexo server\t\t\t\n或者：\nhexo s\n```\n\n部署完可以在浏览器中打开预设的地址查看blog\n\n\n#### 部署到远端\n\n```\nhexo deploy\t\t\t\n或者：\nhexo d\n```\n\n要部署到远端需要配置博客更目录下的`_config.yml`文件中的内容\n\n```\ndeploy:\n  type: git\n  repo: 自己的git地址\n  branch: master\n```\n\n#### 2021更新问题\n\n今天在一台新电脑上部署的时候发现进入的是空白页，在本地测试的时候有如下错误提示\n\n```sh\n(node:9876) Warning: Accessing non-existent property 'lineno' of module exports inside circular dependency\n(Use `node --trace-warnings ...` to show where the warning was created)\n(node:9876) Warning: Accessing non-existent property 'column' of module exports inside circular dependency\n(node:9876) Warning: Accessing non-existent property 'filename' of module exports inside circular dependency\n(node:9876) Warning: Accessing non-existent property 'lineno' of module exports inside circular dependency\n(node:9876) Warning: Accessing non-existent property 'column' of module exports inside circular dependency\n(node:9876) Warning: Accessing non-existent property 'filename' of module exports inside circular dependency\n```\n\n\n\n在`github`上看，部署的`index`文件没有内容,\n\n问题原因： `node.js`版本太高了\n\n解决办法： 降级`node.js`\n\n步骤：\n\n```sh\n//安装node.js版本管理软件 n\nsudo npm install -g n\n\n//查看n 是否安装成功\nn -V\n\n//安装指定版本 node\nsudo n 13.14\n\n```\n\n\n\n\n\n","source":"_posts/Hexo的安装和使用.md","raw":"---\ntitle: Hexo的安装和使用\ndate: 2016-08-02 19:13:00\ntags: [日常,Hexo]\n---\n\n\n### 一、hexo的安装\n\n#### 1、安装Node.js\n\nHexo是基于`Node.js`的静态博客框架，所以要安装`Hexo`先要安装`Node.js`。\n\n\nNode.js的安装方法非常简单，从[Node.js官网](https://nodejs.org/en/)下载安装包安装就好\n\n#### 2、安装git\n\nmac下安装了Xcode就会有git\n\n<!-- more -->\n\n\n#### 3、安装Hexo\n\n在终端执行如下命令\n\n```\nsudo npm install -g hexo\n```\n\n等待安装成功\n\n安装完成后使用查看版本命令，看看是否安装成功\n\n```\nhexo -v\n```\n\n如果正常显示版本说明安装成功\n\n#### 注意\n\n如果报如下错误：\n\n```\nError: The module '/Users/***/Desktop/***/node_modules/dtrace-provider/build/Release/DTraceProviderBindings.node'\nwas compiled against a different Node.js version using\nNODE_MODULE_VERSION 48. This version of Node.js requires\nNODE_MODULE_VERSION 67. Please try re-compiling or re-installing\nthe module (for instance, using `npm rebuild` or `npm install`).\n    at Object.Module._extensions..node (internal/modules/cjs/loader.js:751:18)\n    at Module.load (internal/modules/cjs/loader.js:620:32)\n    at tryModuleLoad (internal/modules/cjs/loader.js:560:12)\n    at Function.Module._load (internal/modules/cjs/loader.js:552:3)\n    at Module.require (internal/modules/cjs/loader.js:658:17)\n    \n    ...\n```\n\n执行下面操作：\n\n```\n1. cd hexo 根目录\n2. rm -rvf node_modules\n3. npm install\n\n```\n\n这是因为node_modules的缓存存在版本问题\n\n\n### 二、hexo的使用\n\n#### 创建一个blog库\n\n```\nhexo init blog\n```\n\nblog是文件夹的名称，可以随便起\n\n#### 创建一个blog\n\n```\nhexo new blog_title\n```\n\n这个样就可以创建一个title是blog_title的博客了\n\n这个只是一个默认参数的简写命令\n\n#### 生成静态页面\n\n```\nhexo generate\t\t\n或者：\nhexo g\n```\n\n#### 部署到本地\n\n```\nhexo server\t\t\t\n或者：\nhexo s\n```\n\n部署完可以在浏览器中打开预设的地址查看blog\n\n\n#### 部署到远端\n\n```\nhexo deploy\t\t\t\n或者：\nhexo d\n```\n\n要部署到远端需要配置博客更目录下的`_config.yml`文件中的内容\n\n```\ndeploy:\n  type: git\n  repo: 自己的git地址\n  branch: master\n```\n\n#### 2021更新问题\n\n今天在一台新电脑上部署的时候发现进入的是空白页，在本地测试的时候有如下错误提示\n\n```sh\n(node:9876) Warning: Accessing non-existent property 'lineno' of module exports inside circular dependency\n(Use `node --trace-warnings ...` to show where the warning was created)\n(node:9876) Warning: Accessing non-existent property 'column' of module exports inside circular dependency\n(node:9876) Warning: Accessing non-existent property 'filename' of module exports inside circular dependency\n(node:9876) Warning: Accessing non-existent property 'lineno' of module exports inside circular dependency\n(node:9876) Warning: Accessing non-existent property 'column' of module exports inside circular dependency\n(node:9876) Warning: Accessing non-existent property 'filename' of module exports inside circular dependency\n```\n\n\n\n在`github`上看，部署的`index`文件没有内容,\n\n问题原因： `node.js`版本太高了\n\n解决办法： 降级`node.js`\n\n步骤：\n\n```sh\n//安装node.js版本管理软件 n\nsudo npm install -g n\n\n//查看n 是否安装成功\nn -V\n\n//安装指定版本 node\nsudo n 13.14\n\n```\n\n\n\n\n\n","slug":"Hexo的安装和使用","published":1,"updated":"2021-04-12T10:27:08.947Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqjdx1n000035emup255xmmy","content":"<h3 id=\"一、hexo的安装\"><a href=\"#一、hexo的安装\" class=\"headerlink\" title=\"一、hexo的安装\"></a>一、hexo的安装</h3><h4 id=\"1、安装Node-js\"><a href=\"#1、安装Node-js\" class=\"headerlink\" title=\"1、安装Node.js\"></a>1、安装Node.js</h4><p>Hexo是基于<code>Node.js</code>的静态博客框架，所以要安装<code>Hexo</code>先要安装<code>Node.js</code>。</p>\n<p>Node.js的安装方法非常简单，从<a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"noopener\">Node.js官网</a>下载安装包安装就好</p>\n<h4 id=\"2、安装git\"><a href=\"#2、安装git\" class=\"headerlink\" title=\"2、安装git\"></a>2、安装git</h4><p>mac下安装了Xcode就会有git</p>\n<a id=\"more\"></a>\n<h4 id=\"3、安装Hexo\"><a href=\"#3、安装Hexo\" class=\"headerlink\" title=\"3、安装Hexo\"></a>3、安装Hexo</h4><p>在终端执行如下命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo npm install -g hexo</span><br></pre></td></tr></table></figure>\n<p>等待安装成功</p>\n<p>安装完成后使用查看版本命令，看看是否安装成功</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo -v</span><br></pre></td></tr></table></figure>\n<p>如果正常显示版本说明安装成功</p>\n<h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><p>如果报如下错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Error: The module &apos;/Users/***/Desktop/***/node_modules/dtrace-provider/build/Release/DTraceProviderBindings.node&apos;</span><br><span class=\"line\">was compiled against a different Node.js version using</span><br><span class=\"line\">NODE_MODULE_VERSION 48. This version of Node.js requires</span><br><span class=\"line\">NODE_MODULE_VERSION 67. Please try re-compiling or re-installing</span><br><span class=\"line\">the module (for instance, using `npm rebuild` or `npm install`).</span><br><span class=\"line\">    at Object.Module._extensions..node (internal/modules/cjs/loader.js:751:18)</span><br><span class=\"line\">    at Module.load (internal/modules/cjs/loader.js:620:32)</span><br><span class=\"line\">    at tryModuleLoad (internal/modules/cjs/loader.js:560:12)</span><br><span class=\"line\">    at Function.Module._load (internal/modules/cjs/loader.js:552:3)</span><br><span class=\"line\">    at Module.require (internal/modules/cjs/loader.js:658:17)</span><br><span class=\"line\">    </span><br><span class=\"line\">    ...</span><br></pre></td></tr></table></figure>\n<p>执行下面操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. cd hexo 根目录</span><br><span class=\"line\">2. rm -rvf node_modules</span><br><span class=\"line\">3. npm install</span><br></pre></td></tr></table></figure>\n<p>这是因为node_modules的缓存存在版本问题</p>\n<h3 id=\"二、hexo的使用\"><a href=\"#二、hexo的使用\" class=\"headerlink\" title=\"二、hexo的使用\"></a>二、hexo的使用</h3><h4 id=\"创建一个blog库\"><a href=\"#创建一个blog库\" class=\"headerlink\" title=\"创建一个blog库\"></a>创建一个blog库</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init blog</span><br></pre></td></tr></table></figure>\n<p>blog是文件夹的名称，可以随便起</p>\n<h4 id=\"创建一个blog\"><a href=\"#创建一个blog\" class=\"headerlink\" title=\"创建一个blog\"></a>创建一个blog</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new blog_title</span><br></pre></td></tr></table></figure>\n<p>这个样就可以创建一个title是blog_title的博客了</p>\n<p>这个只是一个默认参数的简写命令</p>\n<h4 id=\"生成静态页面\"><a href=\"#生成静态页面\" class=\"headerlink\" title=\"生成静态页面\"></a>生成静态页面</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo generate\t\t</span><br><span class=\"line\">或者：</span><br><span class=\"line\">hexo g</span><br></pre></td></tr></table></figure>\n<h4 id=\"部署到本地\"><a href=\"#部署到本地\" class=\"headerlink\" title=\"部署到本地\"></a>部署到本地</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo server\t\t\t</span><br><span class=\"line\">或者：</span><br><span class=\"line\">hexo s</span><br></pre></td></tr></table></figure>\n<p>部署完可以在浏览器中打开预设的地址查看blog</p>\n<h4 id=\"部署到远端\"><a href=\"#部署到远端\" class=\"headerlink\" title=\"部署到远端\"></a>部署到远端</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo deploy\t\t\t</span><br><span class=\"line\">或者：</span><br><span class=\"line\">hexo d</span><br></pre></td></tr></table></figure>\n<p>要部署到远端需要配置博客更目录下的<code>_config.yml</code>文件中的内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: 自己的git地址</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n<h4 id=\"2021更新问题\"><a href=\"#2021更新问题\" class=\"headerlink\" title=\"2021更新问题\"></a>2021更新问题</h4><p>今天在一台新电脑上部署的时候发现进入的是空白页，在本地测试的时候有如下错误提示</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(node:9876) Warning: Accessing non-existent property <span class=\"string\">'lineno'</span> of module exports inside circular dependency</span><br><span class=\"line\">(Use `node --trace-warnings ...` to show <span class=\"built_in\">where</span> the warning was created)</span><br><span class=\"line\">(node:9876) Warning: Accessing non-existent property <span class=\"string\">'column'</span> of module exports inside circular dependency</span><br><span class=\"line\">(node:9876) Warning: Accessing non-existent property <span class=\"string\">'filename'</span> of module exports inside circular dependency</span><br><span class=\"line\">(node:9876) Warning: Accessing non-existent property <span class=\"string\">'lineno'</span> of module exports inside circular dependency</span><br><span class=\"line\">(node:9876) Warning: Accessing non-existent property <span class=\"string\">'column'</span> of module exports inside circular dependency</span><br><span class=\"line\">(node:9876) Warning: Accessing non-existent property <span class=\"string\">'filename'</span> of module exports inside circular dependency</span><br></pre></td></tr></table></figure>\n<p>在<code>github</code>上看，部署的<code>index</code>文件没有内容,</p>\n<p>问题原因： <code>node.js</code>版本太高了</p>\n<p>解决办法： 降级<code>node.js</code></p>\n<p>步骤：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//安装node.js版本管理软件 n</span><br><span class=\"line\">sudo npm install -g n</span><br><span class=\"line\"></span><br><span class=\"line\">//查看n 是否安装成功</span><br><span class=\"line\">n -V</span><br><span class=\"line\"></span><br><span class=\"line\">//安装指定版本 node</span><br><span class=\"line\">sudo n 13.14</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h3 id=\"一、hexo的安装\"><a href=\"#一、hexo的安装\" class=\"headerlink\" title=\"一、hexo的安装\"></a>一、hexo的安装</h3><h4 id=\"1、安装Node-js\"><a href=\"#1、安装Node-js\" class=\"headerlink\" title=\"1、安装Node.js\"></a>1、安装Node.js</h4><p>Hexo是基于<code>Node.js</code>的静态博客框架，所以要安装<code>Hexo</code>先要安装<code>Node.js</code>。</p>\n<p>Node.js的安装方法非常简单，从<a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"noopener\">Node.js官网</a>下载安装包安装就好</p>\n<h4 id=\"2、安装git\"><a href=\"#2、安装git\" class=\"headerlink\" title=\"2、安装git\"></a>2、安装git</h4><p>mac下安装了Xcode就会有git</p>","more":"<h4 id=\"3、安装Hexo\"><a href=\"#3、安装Hexo\" class=\"headerlink\" title=\"3、安装Hexo\"></a>3、安装Hexo</h4><p>在终端执行如下命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo npm install -g hexo</span><br></pre></td></tr></table></figure>\n<p>等待安装成功</p>\n<p>安装完成后使用查看版本命令，看看是否安装成功</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo -v</span><br></pre></td></tr></table></figure>\n<p>如果正常显示版本说明安装成功</p>\n<h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><p>如果报如下错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Error: The module &apos;/Users/***/Desktop/***/node_modules/dtrace-provider/build/Release/DTraceProviderBindings.node&apos;</span><br><span class=\"line\">was compiled against a different Node.js version using</span><br><span class=\"line\">NODE_MODULE_VERSION 48. This version of Node.js requires</span><br><span class=\"line\">NODE_MODULE_VERSION 67. Please try re-compiling or re-installing</span><br><span class=\"line\">the module (for instance, using `npm rebuild` or `npm install`).</span><br><span class=\"line\">    at Object.Module._extensions..node (internal/modules/cjs/loader.js:751:18)</span><br><span class=\"line\">    at Module.load (internal/modules/cjs/loader.js:620:32)</span><br><span class=\"line\">    at tryModuleLoad (internal/modules/cjs/loader.js:560:12)</span><br><span class=\"line\">    at Function.Module._load (internal/modules/cjs/loader.js:552:3)</span><br><span class=\"line\">    at Module.require (internal/modules/cjs/loader.js:658:17)</span><br><span class=\"line\">    </span><br><span class=\"line\">    ...</span><br></pre></td></tr></table></figure>\n<p>执行下面操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. cd hexo 根目录</span><br><span class=\"line\">2. rm -rvf node_modules</span><br><span class=\"line\">3. npm install</span><br></pre></td></tr></table></figure>\n<p>这是因为node_modules的缓存存在版本问题</p>\n<h3 id=\"二、hexo的使用\"><a href=\"#二、hexo的使用\" class=\"headerlink\" title=\"二、hexo的使用\"></a>二、hexo的使用</h3><h4 id=\"创建一个blog库\"><a href=\"#创建一个blog库\" class=\"headerlink\" title=\"创建一个blog库\"></a>创建一个blog库</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init blog</span><br></pre></td></tr></table></figure>\n<p>blog是文件夹的名称，可以随便起</p>\n<h4 id=\"创建一个blog\"><a href=\"#创建一个blog\" class=\"headerlink\" title=\"创建一个blog\"></a>创建一个blog</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new blog_title</span><br></pre></td></tr></table></figure>\n<p>这个样就可以创建一个title是blog_title的博客了</p>\n<p>这个只是一个默认参数的简写命令</p>\n<h4 id=\"生成静态页面\"><a href=\"#生成静态页面\" class=\"headerlink\" title=\"生成静态页面\"></a>生成静态页面</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo generate\t\t</span><br><span class=\"line\">或者：</span><br><span class=\"line\">hexo g</span><br></pre></td></tr></table></figure>\n<h4 id=\"部署到本地\"><a href=\"#部署到本地\" class=\"headerlink\" title=\"部署到本地\"></a>部署到本地</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo server\t\t\t</span><br><span class=\"line\">或者：</span><br><span class=\"line\">hexo s</span><br></pre></td></tr></table></figure>\n<p>部署完可以在浏览器中打开预设的地址查看blog</p>\n<h4 id=\"部署到远端\"><a href=\"#部署到远端\" class=\"headerlink\" title=\"部署到远端\"></a>部署到远端</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo deploy\t\t\t</span><br><span class=\"line\">或者：</span><br><span class=\"line\">hexo d</span><br></pre></td></tr></table></figure>\n<p>要部署到远端需要配置博客更目录下的<code>_config.yml</code>文件中的内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: 自己的git地址</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n<h4 id=\"2021更新问题\"><a href=\"#2021更新问题\" class=\"headerlink\" title=\"2021更新问题\"></a>2021更新问题</h4><p>今天在一台新电脑上部署的时候发现进入的是空白页，在本地测试的时候有如下错误提示</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(node:9876) Warning: Accessing non-existent property <span class=\"string\">'lineno'</span> of module exports inside circular dependency</span><br><span class=\"line\">(Use `node --trace-warnings ...` to show <span class=\"built_in\">where</span> the warning was created)</span><br><span class=\"line\">(node:9876) Warning: Accessing non-existent property <span class=\"string\">'column'</span> of module exports inside circular dependency</span><br><span class=\"line\">(node:9876) Warning: Accessing non-existent property <span class=\"string\">'filename'</span> of module exports inside circular dependency</span><br><span class=\"line\">(node:9876) Warning: Accessing non-existent property <span class=\"string\">'lineno'</span> of module exports inside circular dependency</span><br><span class=\"line\">(node:9876) Warning: Accessing non-existent property <span class=\"string\">'column'</span> of module exports inside circular dependency</span><br><span class=\"line\">(node:9876) Warning: Accessing non-existent property <span class=\"string\">'filename'</span> of module exports inside circular dependency</span><br></pre></td></tr></table></figure>\n<p>在<code>github</code>上看，部署的<code>index</code>文件没有内容,</p>\n<p>问题原因： <code>node.js</code>版本太高了</p>\n<p>解决办法： 降级<code>node.js</code></p>\n<p>步骤：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//安装node.js版本管理软件 n</span><br><span class=\"line\">sudo npm install -g n</span><br><span class=\"line\"></span><br><span class=\"line\">//查看n 是否安装成功</span><br><span class=\"line\">n -V</span><br><span class=\"line\"></span><br><span class=\"line\">//安装指定版本 node</span><br><span class=\"line\">sudo n 13.14</span><br></pre></td></tr></table></figure>"},{"title":"Hexo创建一个blog","date":"2016-08-03T12:38:44.000Z","_content":"\n\n### post布局\n\n当你的Hexo已经搭建完成的时候，你就可以写blog了，最简单的创建一个blog的方法就是调用\n\n```\nhexo new blog_title\n```\n\n执行完成之后，hexo会在根目录的`source`文件夹下创建一个`_post`文件夹，并在里面生成一个`blog_title.md`文件。\n\n<!-- more -->\n\n这个创建blog的完整命令是\n\n```\nhexo new post blog_title\n```\n\n这个就是post布局，当`hexo g 或者 s 或者 d`的时候，会把`_post`文件夹中的文件都生成静态页面\n\n### draft布局\n\n```\nhexo new draft blog_title\n```\n\n当使用`draft`布局创建一个博客的时候，hexo也会在根目录的`source`文件夹下创建一个`_draft`文件夹，并在里面生成一个`blog_title.md`文件，\n\n但是在`hexo g 或者 s 或者 d`的时候，是无法看到你创建的博客的\n\n因为`draft`布局是草稿布局，在`_draft`文件夹中的博客都认为是草稿，不能发布\n\n那当你想看看你的草稿写出来的效果怎么样的时候，你可以使用下面命令将草稿部署到本地\n\n```\nhexo g --draft\nhexo s --draft\n```\n\n如果你的博客已经完成了，你可以使用下面的命令将他发布\n\n```\nhexo publish draft blog_title.md\n```\n\n### page布局\n\n```\nhexo new page \"about\"\n```\n\n当使用`page`布局创建一个博客的时候，hexo会在根目录的`source`文件夹下创建一个`about`文件夹，并在里面生成一个`index.md`文件\n\n当你部署完，你需要使用子路径去访问他\n\neg：\n\n```\nhttp://localhost:4000/about\n```\n\n\n","source":"_posts/Hexo创建一个blog.md","raw":"---\ntitle: Hexo创建一个blog\ndate: 2016-08-03 20:38:44\ntags: [日常,Hexo]\n---\n\n\n### post布局\n\n当你的Hexo已经搭建完成的时候，你就可以写blog了，最简单的创建一个blog的方法就是调用\n\n```\nhexo new blog_title\n```\n\n执行完成之后，hexo会在根目录的`source`文件夹下创建一个`_post`文件夹，并在里面生成一个`blog_title.md`文件。\n\n<!-- more -->\n\n这个创建blog的完整命令是\n\n```\nhexo new post blog_title\n```\n\n这个就是post布局，当`hexo g 或者 s 或者 d`的时候，会把`_post`文件夹中的文件都生成静态页面\n\n### draft布局\n\n```\nhexo new draft blog_title\n```\n\n当使用`draft`布局创建一个博客的时候，hexo也会在根目录的`source`文件夹下创建一个`_draft`文件夹，并在里面生成一个`blog_title.md`文件，\n\n但是在`hexo g 或者 s 或者 d`的时候，是无法看到你创建的博客的\n\n因为`draft`布局是草稿布局，在`_draft`文件夹中的博客都认为是草稿，不能发布\n\n那当你想看看你的草稿写出来的效果怎么样的时候，你可以使用下面命令将草稿部署到本地\n\n```\nhexo g --draft\nhexo s --draft\n```\n\n如果你的博客已经完成了，你可以使用下面的命令将他发布\n\n```\nhexo publish draft blog_title.md\n```\n\n### page布局\n\n```\nhexo new page \"about\"\n```\n\n当使用`page`布局创建一个博客的时候，hexo会在根目录的`source`文件夹下创建一个`about`文件夹，并在里面生成一个`index.md`文件\n\n当你部署完，你需要使用子路径去访问他\n\neg：\n\n```\nhttp://localhost:4000/about\n```\n\n\n","slug":"Hexo创建一个blog","published":1,"updated":"2021-04-12T09:17:38.416Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqjdx1n100045emumn1oy8ji","content":"<h3 id=\"post布局\"><a href=\"#post布局\" class=\"headerlink\" title=\"post布局\"></a>post布局</h3><p>当你的Hexo已经搭建完成的时候，你就可以写blog了，最简单的创建一个blog的方法就是调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new blog_title</span><br></pre></td></tr></table></figure>\n<p>执行完成之后，hexo会在根目录的<code>source</code>文件夹下创建一个<code>_post</code>文件夹，并在里面生成一个<code>blog_title.md</code>文件。</p>\n<a id=\"more\"></a>\n<p>这个创建blog的完整命令是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new post blog_title</span><br></pre></td></tr></table></figure>\n<p>这个就是post布局，当<code>hexo g 或者 s 或者 d</code>的时候，会把<code>_post</code>文件夹中的文件都生成静态页面</p>\n<h3 id=\"draft布局\"><a href=\"#draft布局\" class=\"headerlink\" title=\"draft布局\"></a>draft布局</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new draft blog_title</span><br></pre></td></tr></table></figure>\n<p>当使用<code>draft</code>布局创建一个博客的时候，hexo也会在根目录的<code>source</code>文件夹下创建一个<code>_draft</code>文件夹，并在里面生成一个<code>blog_title.md</code>文件，</p>\n<p>但是在<code>hexo g 或者 s 或者 d</code>的时候，是无法看到你创建的博客的</p>\n<p>因为<code>draft</code>布局是草稿布局，在<code>_draft</code>文件夹中的博客都认为是草稿，不能发布</p>\n<p>那当你想看看你的草稿写出来的效果怎么样的时候，你可以使用下面命令将草稿部署到本地</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g --draft</span><br><span class=\"line\">hexo s --draft</span><br></pre></td></tr></table></figure>\n<p>如果你的博客已经完成了，你可以使用下面的命令将他发布</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo publish draft blog_title.md</span><br></pre></td></tr></table></figure>\n<h3 id=\"page布局\"><a href=\"#page布局\" class=\"headerlink\" title=\"page布局\"></a>page布局</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new page &quot;about&quot;</span><br></pre></td></tr></table></figure>\n<p>当使用<code>page</code>布局创建一个博客的时候，hexo会在根目录的<code>source</code>文件夹下创建一个<code>about</code>文件夹，并在里面生成一个<code>index.md</code>文件</p>\n<p>当你部署完，你需要使用子路径去访问他</p>\n<p>eg：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://localhost:4000/about</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h3 id=\"post布局\"><a href=\"#post布局\" class=\"headerlink\" title=\"post布局\"></a>post布局</h3><p>当你的Hexo已经搭建完成的时候，你就可以写blog了，最简单的创建一个blog的方法就是调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new blog_title</span><br></pre></td></tr></table></figure>\n<p>执行完成之后，hexo会在根目录的<code>source</code>文件夹下创建一个<code>_post</code>文件夹，并在里面生成一个<code>blog_title.md</code>文件。</p>","more":"<p>这个创建blog的完整命令是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new post blog_title</span><br></pre></td></tr></table></figure>\n<p>这个就是post布局，当<code>hexo g 或者 s 或者 d</code>的时候，会把<code>_post</code>文件夹中的文件都生成静态页面</p>\n<h3 id=\"draft布局\"><a href=\"#draft布局\" class=\"headerlink\" title=\"draft布局\"></a>draft布局</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new draft blog_title</span><br></pre></td></tr></table></figure>\n<p>当使用<code>draft</code>布局创建一个博客的时候，hexo也会在根目录的<code>source</code>文件夹下创建一个<code>_draft</code>文件夹，并在里面生成一个<code>blog_title.md</code>文件，</p>\n<p>但是在<code>hexo g 或者 s 或者 d</code>的时候，是无法看到你创建的博客的</p>\n<p>因为<code>draft</code>布局是草稿布局，在<code>_draft</code>文件夹中的博客都认为是草稿，不能发布</p>\n<p>那当你想看看你的草稿写出来的效果怎么样的时候，你可以使用下面命令将草稿部署到本地</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g --draft</span><br><span class=\"line\">hexo s --draft</span><br></pre></td></tr></table></figure>\n<p>如果你的博客已经完成了，你可以使用下面的命令将他发布</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo publish draft blog_title.md</span><br></pre></td></tr></table></figure>\n<h3 id=\"page布局\"><a href=\"#page布局\" class=\"headerlink\" title=\"page布局\"></a>page布局</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new page &quot;about&quot;</span><br></pre></td></tr></table></figure>\n<p>当使用<code>page</code>布局创建一个博客的时候，hexo会在根目录的<code>source</code>文件夹下创建一个<code>about</code>文件夹，并在里面生成一个<code>index.md</code>文件</p>\n<p>当你部署完，你需要使用子路径去访问他</p>\n<p>eg：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://localhost:4000/about</span><br></pre></td></tr></table></figure>"},{"title":"Heroku使用记录","date":"2019-03-17T03:02:30.000Z","_content":"\n\n## 前言 ##\n\n`Heroku`是一个免费的云服务，据说还可以跑`VPN`,但是这不是我这次研究的问题，这次想把`listen1-api`,构建出来的`js`代码部署到上面，当做接口使用\n\n<!-- more -->\n\n### 一 、注册 ###\n\n官网地址 ： [https://www.heroku.com/](https://www.heroku.com/)\n\n注册没有难度，使用国外邮箱，能翻墙就OK\n\n\n### 二、安装工具 ###\n\n这个工具就是一个能在终端部署的工具`heroku-cli`\n\n工具地址： [https://devcenter.heroku.com/articles/heroku-cli](https://devcenter.heroku.com/articles/heroku-cli)\n\n这个工具和`hexo`是一个意思，但是有一个坑的地方就是，你的终端也要可以FQ,不然登录不上去\n\n终端FQ方法以前记录过，这里在贴一下，方便使用\n\n```\nexport http_proxy=socks5://127.0.0.1:1080 # 配置http 代理访问\nexport https_proxy=socks5://127.0.0.1:1080 # 配置https 代理访问\nexport all_proxy=socks5://127.0.0.1:1080 # 配置http和https访问\nunset http_proxy  # 取消http 代理访问\nunset https_proxy # 取消https 代理访问\n```\n\n上面命令中的端口号和地址，需要和`shadowsock`中`socks5`监听的地址和端口号一致,而且这个只是临时使用，要想长期使用，需要加入到`shell`中\n\n卸载命令：\n\n```\nrm -rf /usr/local/heroku /usr/local/lib/heroku /usr/local/bin/heroku ~/.local/share/heroku ~/Library/Caches/heroku\n```\n\n### 三 、使用 ###\n\n#### 查看工具版本 ####\n\n```\nheroku -v\n```\n\n#### 登录 ####\n\n```\nheroku login\n```\n\n#### 创建程序 ####\n\n```\nheroku create app-name\n```\n\n创建完成会有两个地址，一个是访问的网址，一个是代码仓库的地址\n\n我的测试的地址是如下\n\n```\nhttps://nodetestdemo.herokuapp.com/ | https://git.heroku.com/nodetestdemo.git\n```\n\n#### 推送代码 ####\n\n使用`git`把代码推送到上面生成的仓库中\n\n```\ngit init\ngit add .\ngit commit -m \"commit\"\ngit remote add origin https://git.heroku.com/app-name.git\ngit remote -v\ngit push -u origin master\n```\n\n推送完成后，就可以访问上面的地址，查看代码是否部署成功\n\n","source":"_posts/Heroku使用记录.md","raw":"---\ntitle: Heroku使用记录\ndate: 2019-3-17 11:02:30\ntags: Linux\n---\n\n\n## 前言 ##\n\n`Heroku`是一个免费的云服务，据说还可以跑`VPN`,但是这不是我这次研究的问题，这次想把`listen1-api`,构建出来的`js`代码部署到上面，当做接口使用\n\n<!-- more -->\n\n### 一 、注册 ###\n\n官网地址 ： [https://www.heroku.com/](https://www.heroku.com/)\n\n注册没有难度，使用国外邮箱，能翻墙就OK\n\n\n### 二、安装工具 ###\n\n这个工具就是一个能在终端部署的工具`heroku-cli`\n\n工具地址： [https://devcenter.heroku.com/articles/heroku-cli](https://devcenter.heroku.com/articles/heroku-cli)\n\n这个工具和`hexo`是一个意思，但是有一个坑的地方就是，你的终端也要可以FQ,不然登录不上去\n\n终端FQ方法以前记录过，这里在贴一下，方便使用\n\n```\nexport http_proxy=socks5://127.0.0.1:1080 # 配置http 代理访问\nexport https_proxy=socks5://127.0.0.1:1080 # 配置https 代理访问\nexport all_proxy=socks5://127.0.0.1:1080 # 配置http和https访问\nunset http_proxy  # 取消http 代理访问\nunset https_proxy # 取消https 代理访问\n```\n\n上面命令中的端口号和地址，需要和`shadowsock`中`socks5`监听的地址和端口号一致,而且这个只是临时使用，要想长期使用，需要加入到`shell`中\n\n卸载命令：\n\n```\nrm -rf /usr/local/heroku /usr/local/lib/heroku /usr/local/bin/heroku ~/.local/share/heroku ~/Library/Caches/heroku\n```\n\n### 三 、使用 ###\n\n#### 查看工具版本 ####\n\n```\nheroku -v\n```\n\n#### 登录 ####\n\n```\nheroku login\n```\n\n#### 创建程序 ####\n\n```\nheroku create app-name\n```\n\n创建完成会有两个地址，一个是访问的网址，一个是代码仓库的地址\n\n我的测试的地址是如下\n\n```\nhttps://nodetestdemo.herokuapp.com/ | https://git.heroku.com/nodetestdemo.git\n```\n\n#### 推送代码 ####\n\n使用`git`把代码推送到上面生成的仓库中\n\n```\ngit init\ngit add .\ngit commit -m \"commit\"\ngit remote add origin https://git.heroku.com/app-name.git\ngit remote -v\ngit push -u origin master\n```\n\n推送完成后，就可以访问上面的地址，查看代码是否部署成功\n\n","slug":"Heroku使用记录","published":1,"updated":"2021-04-12T09:17:38.416Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqjdx1n200055emuflfn1u40","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p><code>Heroku</code>是一个免费的云服务，据说还可以跑<code>VPN</code>,但是这不是我这次研究的问题，这次想把<code>listen1-api</code>,构建出来的<code>js</code>代码部署到上面，当做接口使用</p>\n<a id=\"more\"></a>\n<h3 id=\"一-、注册\"><a href=\"#一-、注册\" class=\"headerlink\" title=\"一 、注册\"></a>一 、注册</h3><p>官网地址 ： <a href=\"https://www.heroku.com/\" target=\"_blank\" rel=\"noopener\">https://www.heroku.com/</a></p>\n<p>注册没有难度，使用国外邮箱，能翻墙就OK</p>\n<h3 id=\"二、安装工具\"><a href=\"#二、安装工具\" class=\"headerlink\" title=\"二、安装工具\"></a>二、安装工具</h3><p>这个工具就是一个能在终端部署的工具<code>heroku-cli</code></p>\n<p>工具地址： <a href=\"https://devcenter.heroku.com/articles/heroku-cli\" target=\"_blank\" rel=\"noopener\">https://devcenter.heroku.com/articles/heroku-cli</a></p>\n<p>这个工具和<code>hexo</code>是一个意思，但是有一个坑的地方就是，你的终端也要可以FQ,不然登录不上去</p>\n<p>终端FQ方法以前记录过，这里在贴一下，方便使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export http_proxy=socks5://127.0.0.1:1080 # 配置http 代理访问</span><br><span class=\"line\">export https_proxy=socks5://127.0.0.1:1080 # 配置https 代理访问</span><br><span class=\"line\">export all_proxy=socks5://127.0.0.1:1080 # 配置http和https访问</span><br><span class=\"line\">unset http_proxy  # 取消http 代理访问</span><br><span class=\"line\">unset https_proxy # 取消https 代理访问</span><br></pre></td></tr></table></figure>\n<p>上面命令中的端口号和地址，需要和<code>shadowsock</code>中<code>socks5</code>监听的地址和端口号一致,而且这个只是临时使用，要想长期使用，需要加入到<code>shell</code>中</p>\n<p>卸载命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -rf /usr/local/heroku /usr/local/lib/heroku /usr/local/bin/heroku ~/.local/share/heroku ~/Library/Caches/heroku</span><br></pre></td></tr></table></figure>\n<h3 id=\"三-、使用\"><a href=\"#三-、使用\" class=\"headerlink\" title=\"三 、使用\"></a>三 、使用</h3><h4 id=\"查看工具版本\"><a href=\"#查看工具版本\" class=\"headerlink\" title=\"查看工具版本\"></a>查看工具版本</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">heroku -v</span><br></pre></td></tr></table></figure>\n<h4 id=\"登录\"><a href=\"#登录\" class=\"headerlink\" title=\"登录\"></a>登录</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">heroku login</span><br></pre></td></tr></table></figure>\n<h4 id=\"创建程序\"><a href=\"#创建程序\" class=\"headerlink\" title=\"创建程序\"></a>创建程序</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">heroku create app-name</span><br></pre></td></tr></table></figure>\n<p>创建完成会有两个地址，一个是访问的网址，一个是代码仓库的地址</p>\n<p>我的测试的地址是如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://nodetestdemo.herokuapp.com/ | https://git.heroku.com/nodetestdemo.git</span><br></pre></td></tr></table></figure>\n<h4 id=\"推送代码\"><a href=\"#推送代码\" class=\"headerlink\" title=\"推送代码\"></a>推送代码</h4><p>使用<code>git</code>把代码推送到上面生成的仓库中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m &quot;commit&quot;</span><br><span class=\"line\">git remote add origin https://git.heroku.com/app-name.git</span><br><span class=\"line\">git remote -v</span><br><span class=\"line\">git push -u origin master</span><br></pre></td></tr></table></figure>\n<p>推送完成后，就可以访问上面的地址，查看代码是否部署成功</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p><code>Heroku</code>是一个免费的云服务，据说还可以跑<code>VPN</code>,但是这不是我这次研究的问题，这次想把<code>listen1-api</code>,构建出来的<code>js</code>代码部署到上面，当做接口使用</p>","more":"<h3 id=\"一-、注册\"><a href=\"#一-、注册\" class=\"headerlink\" title=\"一 、注册\"></a>一 、注册</h3><p>官网地址 ： <a href=\"https://www.heroku.com/\" target=\"_blank\" rel=\"noopener\">https://www.heroku.com/</a></p>\n<p>注册没有难度，使用国外邮箱，能翻墙就OK</p>\n<h3 id=\"二、安装工具\"><a href=\"#二、安装工具\" class=\"headerlink\" title=\"二、安装工具\"></a>二、安装工具</h3><p>这个工具就是一个能在终端部署的工具<code>heroku-cli</code></p>\n<p>工具地址： <a href=\"https://devcenter.heroku.com/articles/heroku-cli\" target=\"_blank\" rel=\"noopener\">https://devcenter.heroku.com/articles/heroku-cli</a></p>\n<p>这个工具和<code>hexo</code>是一个意思，但是有一个坑的地方就是，你的终端也要可以FQ,不然登录不上去</p>\n<p>终端FQ方法以前记录过，这里在贴一下，方便使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export http_proxy=socks5://127.0.0.1:1080 # 配置http 代理访问</span><br><span class=\"line\">export https_proxy=socks5://127.0.0.1:1080 # 配置https 代理访问</span><br><span class=\"line\">export all_proxy=socks5://127.0.0.1:1080 # 配置http和https访问</span><br><span class=\"line\">unset http_proxy  # 取消http 代理访问</span><br><span class=\"line\">unset https_proxy # 取消https 代理访问</span><br></pre></td></tr></table></figure>\n<p>上面命令中的端口号和地址，需要和<code>shadowsock</code>中<code>socks5</code>监听的地址和端口号一致,而且这个只是临时使用，要想长期使用，需要加入到<code>shell</code>中</p>\n<p>卸载命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -rf /usr/local/heroku /usr/local/lib/heroku /usr/local/bin/heroku ~/.local/share/heroku ~/Library/Caches/heroku</span><br></pre></td></tr></table></figure>\n<h3 id=\"三-、使用\"><a href=\"#三-、使用\" class=\"headerlink\" title=\"三 、使用\"></a>三 、使用</h3><h4 id=\"查看工具版本\"><a href=\"#查看工具版本\" class=\"headerlink\" title=\"查看工具版本\"></a>查看工具版本</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">heroku -v</span><br></pre></td></tr></table></figure>\n<h4 id=\"登录\"><a href=\"#登录\" class=\"headerlink\" title=\"登录\"></a>登录</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">heroku login</span><br></pre></td></tr></table></figure>\n<h4 id=\"创建程序\"><a href=\"#创建程序\" class=\"headerlink\" title=\"创建程序\"></a>创建程序</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">heroku create app-name</span><br></pre></td></tr></table></figure>\n<p>创建完成会有两个地址，一个是访问的网址，一个是代码仓库的地址</p>\n<p>我的测试的地址是如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://nodetestdemo.herokuapp.com/ | https://git.heroku.com/nodetestdemo.git</span><br></pre></td></tr></table></figure>\n<h4 id=\"推送代码\"><a href=\"#推送代码\" class=\"headerlink\" title=\"推送代码\"></a>推送代码</h4><p>使用<code>git</code>把代码推送到上面生成的仓库中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m &quot;commit&quot;</span><br><span class=\"line\">git remote add origin https://git.heroku.com/app-name.git</span><br><span class=\"line\">git remote -v</span><br><span class=\"line\">git push -u origin master</span><br></pre></td></tr></table></figure>\n<p>推送完成后，就可以访问上面的地址，查看代码是否部署成功</p>"},{"title":"Linux执行定时脚本","date":"2018-04-11T03:10:12.000Z","_content":"\n## 前言 ##\n\n新租的的服务器内存有点小，经常在使用一段时间后，就回因为内存不够，导致服务停止，所以写了一个定时启动服务的脚本\n\n\n<!-- more -->\n\n### 定时服务脚本 ###\n\n这个脚本的作用就是找到当前任务中有没有叫`shadowsocks.json`的任务，如果有，就证明服务没挂，那就重启一下，如果没有，就证明服务挂了，那就启动一下\n\n脚本内容如下:\n\n```\n#! /bin/sh\n\nproc_name=\"shadowsocks.json\"\n\nnumber=`ps -ef | grep $proc_name | grep -v grep | wc -l`\n\nif [ $number -eq 0 ];then\n        ssserver -c /etc/shadowsocks.json -d start\nelse\n        ssserver -c /etc/shadowsocks.json -d restart\nfi\n```\n\n使用`vi`编辑完成后保存为`xxx.sh`\n\n\n### 给脚本添加执行权限 ###\n\n```\nchmod 777 xxx.sh\n```\n\n### 添加定时任务 ### \n\n通过`crontab`命令，在固定时间间隔执行指定的系统指令或`shell`脚本\n\n`crontab`其实就是一个定时任务，如果开启的时候，他会按照配置文件中的时间，定时执行指定脚本\n\n`crontab`服务的开启方法：\n\n```\nsudo service crond start     #启动服务\nsudo service crond stop      #关闭服务\nsudo service crond restart   #重启服务\nsudo service crond reload    #重新载入配置\nsudo service crond status    #查看服务状态\n```\n\n`crontab`配置文件的编辑方法：\n\n```\ncrontab -l #查看配置文件内容\n\ncrontab -e #编辑配置文件内容\n```\n\n`crontab`配置文件格式：\n\n```\n# .---------------- minute (0 - 59) \n# |  .------------- hour (0 - 23)\n# |  |  .---------- day of month (1 - 31)\n# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ... \n# |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7)  OR sun,mon,tue,wed,thu,fri,sat \n# |  |  |  |  |\n# *  *  *  *  *  command to be executed\n\n#eg:\n* */4 * * * ~/xxx.sh #表示每四分之一小时执行一次xxx.sh脚本\n```\n\n### MacOS使用相关\n\n* 脚本的`PATH`可能和在终端运行时候有些区别，导致部分命令无法使用，解决办法是在脚本第一行添加`PATH`\n\n  ```shell\n  PATH=/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin\n  ```\n\n* 脚本的运行路径可能和在终端运行有区别，所以脚本中的路径都要使用绝对路径，如果想使用相对路径，需要手动`cd`到相应的路径，或在配置文件中先`cd`到相应路径\n\n  ```shell\n  15 7 * * * cd /home/xxxx/Documents/Scripts && ./email_ip_script.sh\n  ```\n\n* MacOS下的`crontab`对脚本路径有要求，比如：`Documents`目录下的脚本都没法执行，所以需要给`crontab`添加所有文件权限，添加方法，`系统偏好设置`-`安全性与隐私`-`隐私` - `完全磁盘访问权限` ，把`/usr/sbin/cron` 拖入其中\n\n* ```shell\n    # 启动\n    sudo /usr/sbin/cron start\n    # 重启\n    sudo /usr/sbin/cron restart\n    # 停止\n    sudo /usr/sbin/cron stop\n  ```\n\n  \n\n","source":"_posts/Linux执行定时脚本.md","raw":"---\ntitle: Linux执行定时脚本\ndate: 2018-4-11 11:10:12\ntags: [Linux]\n---\n\n## 前言 ##\n\n新租的的服务器内存有点小，经常在使用一段时间后，就回因为内存不够，导致服务停止，所以写了一个定时启动服务的脚本\n\n\n<!-- more -->\n\n### 定时服务脚本 ###\n\n这个脚本的作用就是找到当前任务中有没有叫`shadowsocks.json`的任务，如果有，就证明服务没挂，那就重启一下，如果没有，就证明服务挂了，那就启动一下\n\n脚本内容如下:\n\n```\n#! /bin/sh\n\nproc_name=\"shadowsocks.json\"\n\nnumber=`ps -ef | grep $proc_name | grep -v grep | wc -l`\n\nif [ $number -eq 0 ];then\n        ssserver -c /etc/shadowsocks.json -d start\nelse\n        ssserver -c /etc/shadowsocks.json -d restart\nfi\n```\n\n使用`vi`编辑完成后保存为`xxx.sh`\n\n\n### 给脚本添加执行权限 ###\n\n```\nchmod 777 xxx.sh\n```\n\n### 添加定时任务 ### \n\n通过`crontab`命令，在固定时间间隔执行指定的系统指令或`shell`脚本\n\n`crontab`其实就是一个定时任务，如果开启的时候，他会按照配置文件中的时间，定时执行指定脚本\n\n`crontab`服务的开启方法：\n\n```\nsudo service crond start     #启动服务\nsudo service crond stop      #关闭服务\nsudo service crond restart   #重启服务\nsudo service crond reload    #重新载入配置\nsudo service crond status    #查看服务状态\n```\n\n`crontab`配置文件的编辑方法：\n\n```\ncrontab -l #查看配置文件内容\n\ncrontab -e #编辑配置文件内容\n```\n\n`crontab`配置文件格式：\n\n```\n# .---------------- minute (0 - 59) \n# |  .------------- hour (0 - 23)\n# |  |  .---------- day of month (1 - 31)\n# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ... \n# |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7)  OR sun,mon,tue,wed,thu,fri,sat \n# |  |  |  |  |\n# *  *  *  *  *  command to be executed\n\n#eg:\n* */4 * * * ~/xxx.sh #表示每四分之一小时执行一次xxx.sh脚本\n```\n\n### MacOS使用相关\n\n* 脚本的`PATH`可能和在终端运行时候有些区别，导致部分命令无法使用，解决办法是在脚本第一行添加`PATH`\n\n  ```shell\n  PATH=/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin\n  ```\n\n* 脚本的运行路径可能和在终端运行有区别，所以脚本中的路径都要使用绝对路径，如果想使用相对路径，需要手动`cd`到相应的路径，或在配置文件中先`cd`到相应路径\n\n  ```shell\n  15 7 * * * cd /home/xxxx/Documents/Scripts && ./email_ip_script.sh\n  ```\n\n* MacOS下的`crontab`对脚本路径有要求，比如：`Documents`目录下的脚本都没法执行，所以需要给`crontab`添加所有文件权限，添加方法，`系统偏好设置`-`安全性与隐私`-`隐私` - `完全磁盘访问权限` ，把`/usr/sbin/cron` 拖入其中\n\n* ```shell\n    # 启动\n    sudo /usr/sbin/cron start\n    # 重启\n    sudo /usr/sbin/cron restart\n    # 停止\n    sudo /usr/sbin/cron stop\n  ```\n\n  \n\n","slug":"Linux执行定时脚本","published":1,"updated":"2021-06-30T10:04:55.704Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqjdx1n400085emubjhz5j8t","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>新租的的服务器内存有点小，经常在使用一段时间后，就回因为内存不够，导致服务停止，所以写了一个定时启动服务的脚本</p>\n<a id=\"more\"></a>\n<h3 id=\"定时服务脚本\"><a href=\"#定时服务脚本\" class=\"headerlink\" title=\"定时服务脚本\"></a>定时服务脚本</h3><p>这个脚本的作用就是找到当前任务中有没有叫<code>shadowsocks.json</code>的任务，如果有，就证明服务没挂，那就重启一下，如果没有，就证明服务挂了，那就启动一下</p>\n<p>脚本内容如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#! /bin/sh</span><br><span class=\"line\"></span><br><span class=\"line\">proc_name=&quot;shadowsocks.json&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">number=`ps -ef | grep $proc_name | grep -v grep | wc -l`</span><br><span class=\"line\"></span><br><span class=\"line\">if [ $number -eq 0 ];then</span><br><span class=\"line\">        ssserver -c /etc/shadowsocks.json -d start</span><br><span class=\"line\">else</span><br><span class=\"line\">        ssserver -c /etc/shadowsocks.json -d restart</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n<p>使用<code>vi</code>编辑完成后保存为<code>xxx.sh</code></p>\n<h3 id=\"给脚本添加执行权限\"><a href=\"#给脚本添加执行权限\" class=\"headerlink\" title=\"给脚本添加执行权限\"></a>给脚本添加执行权限</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod 777 xxx.sh</span><br></pre></td></tr></table></figure>\n<h3 id=\"添加定时任务\"><a href=\"#添加定时任务\" class=\"headerlink\" title=\"添加定时任务\"></a>添加定时任务</h3><p>通过<code>crontab</code>命令，在固定时间间隔执行指定的系统指令或<code>shell</code>脚本</p>\n<p><code>crontab</code>其实就是一个定时任务，如果开启的时候，他会按照配置文件中的时间，定时执行指定脚本</p>\n<p><code>crontab</code>服务的开启方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo service crond start     #启动服务</span><br><span class=\"line\">sudo service crond stop      #关闭服务</span><br><span class=\"line\">sudo service crond restart   #重启服务</span><br><span class=\"line\">sudo service crond reload    #重新载入配置</span><br><span class=\"line\">sudo service crond status    #查看服务状态</span><br></pre></td></tr></table></figure>\n<p><code>crontab</code>配置文件的编辑方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">crontab -l #查看配置文件内容</span><br><span class=\"line\"></span><br><span class=\"line\">crontab -e #编辑配置文件内容</span><br></pre></td></tr></table></figure>\n<p><code>crontab</code>配置文件格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># .---------------- minute (0 - 59) </span><br><span class=\"line\"># |  .------------- hour (0 - 23)</span><br><span class=\"line\"># |  |  .---------- day of month (1 - 31)</span><br><span class=\"line\"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ... </span><br><span class=\"line\"># |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7)  OR sun,mon,tue,wed,thu,fri,sat </span><br><span class=\"line\"># |  |  |  |  |</span><br><span class=\"line\"># *  *  *  *  *  command to be executed</span><br><span class=\"line\"></span><br><span class=\"line\">#eg:</span><br><span class=\"line\">* */4 * * * ~/xxx.sh #表示每四分之一小时执行一次xxx.sh脚本</span><br></pre></td></tr></table></figure>\n<h3 id=\"MacOS使用相关\"><a href=\"#MacOS使用相关\" class=\"headerlink\" title=\"MacOS使用相关\"></a>MacOS使用相关</h3><ul>\n<li><p>脚本的<code>PATH</code>可能和在终端运行时候有些区别，导致部分命令无法使用，解决办法是在脚本第一行添加<code>PATH</code></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PATH=/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>脚本的运行路径可能和在终端运行有区别，所以脚本中的路径都要使用绝对路径，如果想使用相对路径，需要手动<code>cd</code>到相应的路径，或在配置文件中先<code>cd</code>到相应路径</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">15 7 * * * cd /home/xxxx/Documents/Scripts &amp;&amp; ./email_ip_script.sh</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>MacOS下的<code>crontab</code>对脚本路径有要求，比如：<code>Documents</code>目录下的脚本都没法执行，所以需要给<code>crontab</code>添加所有文件权限，添加方法，<code>系统偏好设置</code>-<code>安全性与隐私</code>-<code>隐私</code> - <code>完全磁盘访问权限</code> ，把<code>/usr/sbin/cron</code> 拖入其中</p>\n</li>\n<li><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 启动</span></span><br><span class=\"line\">sudo /usr/sbin/cron start</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 重启</span></span><br><span class=\"line\">sudo /usr/sbin/cron restart</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 停止</span></span><br><span class=\"line\">sudo /usr/sbin/cron stop</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>新租的的服务器内存有点小，经常在使用一段时间后，就回因为内存不够，导致服务停止，所以写了一个定时启动服务的脚本</p>","more":"<h3 id=\"定时服务脚本\"><a href=\"#定时服务脚本\" class=\"headerlink\" title=\"定时服务脚本\"></a>定时服务脚本</h3><p>这个脚本的作用就是找到当前任务中有没有叫<code>shadowsocks.json</code>的任务，如果有，就证明服务没挂，那就重启一下，如果没有，就证明服务挂了，那就启动一下</p>\n<p>脚本内容如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#! /bin/sh</span><br><span class=\"line\"></span><br><span class=\"line\">proc_name=&quot;shadowsocks.json&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">number=`ps -ef | grep $proc_name | grep -v grep | wc -l`</span><br><span class=\"line\"></span><br><span class=\"line\">if [ $number -eq 0 ];then</span><br><span class=\"line\">        ssserver -c /etc/shadowsocks.json -d start</span><br><span class=\"line\">else</span><br><span class=\"line\">        ssserver -c /etc/shadowsocks.json -d restart</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n<p>使用<code>vi</code>编辑完成后保存为<code>xxx.sh</code></p>\n<h3 id=\"给脚本添加执行权限\"><a href=\"#给脚本添加执行权限\" class=\"headerlink\" title=\"给脚本添加执行权限\"></a>给脚本添加执行权限</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod 777 xxx.sh</span><br></pre></td></tr></table></figure>\n<h3 id=\"添加定时任务\"><a href=\"#添加定时任务\" class=\"headerlink\" title=\"添加定时任务\"></a>添加定时任务</h3><p>通过<code>crontab</code>命令，在固定时间间隔执行指定的系统指令或<code>shell</code>脚本</p>\n<p><code>crontab</code>其实就是一个定时任务，如果开启的时候，他会按照配置文件中的时间，定时执行指定脚本</p>\n<p><code>crontab</code>服务的开启方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo service crond start     #启动服务</span><br><span class=\"line\">sudo service crond stop      #关闭服务</span><br><span class=\"line\">sudo service crond restart   #重启服务</span><br><span class=\"line\">sudo service crond reload    #重新载入配置</span><br><span class=\"line\">sudo service crond status    #查看服务状态</span><br></pre></td></tr></table></figure>\n<p><code>crontab</code>配置文件的编辑方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">crontab -l #查看配置文件内容</span><br><span class=\"line\"></span><br><span class=\"line\">crontab -e #编辑配置文件内容</span><br></pre></td></tr></table></figure>\n<p><code>crontab</code>配置文件格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># .---------------- minute (0 - 59) </span><br><span class=\"line\"># |  .------------- hour (0 - 23)</span><br><span class=\"line\"># |  |  .---------- day of month (1 - 31)</span><br><span class=\"line\"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ... </span><br><span class=\"line\"># |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7)  OR sun,mon,tue,wed,thu,fri,sat </span><br><span class=\"line\"># |  |  |  |  |</span><br><span class=\"line\"># *  *  *  *  *  command to be executed</span><br><span class=\"line\"></span><br><span class=\"line\">#eg:</span><br><span class=\"line\">* */4 * * * ~/xxx.sh #表示每四分之一小时执行一次xxx.sh脚本</span><br></pre></td></tr></table></figure>\n<h3 id=\"MacOS使用相关\"><a href=\"#MacOS使用相关\" class=\"headerlink\" title=\"MacOS使用相关\"></a>MacOS使用相关</h3><ul>\n<li><p>脚本的<code>PATH</code>可能和在终端运行时候有些区别，导致部分命令无法使用，解决办法是在脚本第一行添加<code>PATH</code></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PATH=/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>脚本的运行路径可能和在终端运行有区别，所以脚本中的路径都要使用绝对路径，如果想使用相对路径，需要手动<code>cd</code>到相应的路径，或在配置文件中先<code>cd</code>到相应路径</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">15 7 * * * cd /home/xxxx/Documents/Scripts &amp;&amp; ./email_ip_script.sh</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>MacOS下的<code>crontab</code>对脚本路径有要求，比如：<code>Documents</code>目录下的脚本都没法执行，所以需要给<code>crontab</code>添加所有文件权限，添加方法，<code>系统偏好设置</code>-<code>安全性与隐私</code>-<code>隐私</code> - <code>完全磁盘访问权限</code> ，把<code>/usr/sbin/cron</code> 拖入其中</p>\n</li>\n<li><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 启动</span></span><br><span class=\"line\">sudo /usr/sbin/cron start</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 重启</span></span><br><span class=\"line\">sudo /usr/sbin/cron restart</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 停止</span></span><br><span class=\"line\">sudo /usr/sbin/cron stop</span><br></pre></td></tr></table></figure>\n</li>\n</ul>"},{"title":"Linux系统使用--Bash基础","date":"2018-04-11T03:10:12.000Z","_content":"\n\n## 前言 ##\n\nlinux的bash使用相关\n\n<!-- more -->\n\n### bash的特性 ###\n\n命令行展开： ~ {}\n命令别名： alias，unalias\n命令历史： history\n文件名通配：glob\n快捷键：Ctrl+a,e,u,k,l\n命名补全： $PATH\n路径补全： Tab\n\n####命令hash####\nbash 会将使用过的命令缓存下来，再次输入命令的时候会先从缓存中去寻找命令，如果没有找到再去$PATH中去自左向右寻找\n\n查看缓存历史命令:\n```\nhash\n-d //删除缓存中的指定命令\n-r //清空缓存\n```\n\n#### 变量 ####\nbash的变量无需事先声明\nbash把所有变量统统视作字符类型\nbash不支持浮点数据，需借助外在工具\n变量名只能包含数字，字母和下划线，且不能以数字开头\n\n\nbash变量类型:\n    一、本地变量: 作用域为当前shell进程\n        变量使用: `${var_name}, 或$var_name, \"\"变量名会替换为其值, ''变量名不会替换为其值`\n        查看变量: `set`\n        撤销变量: `unset name`\n    二、环境变量: 作用域为当前shell进程及其子进程\n        变量赋值:\n            1. export name=value\n            2. name=value\n               export name\n            3. declare -x name=value\n            4. name=value\n               declare -x name  \n        注意: bash内嵌了许多环境变量(通常为全大写字符)，用于定义bash的工作环境。eg: `PATH, HISTFILE, HISTSIZE, HISTFILESIZE, HISTCONTROL, SHELL, HOME, UID, PWD, OLDPWD`\n        查看环境变量:\n        ```\n        export\n        declare -x\n        printenv\n        env\n        ```\n        撤销变量: `unset name`\n        只读变量:\n        1. declare -r name\n        2. readonly name\n        只读变量无法重新赋值，且不支持撤销，存活时间为当前shell进程的生命周期，随shell进程终止而终止\n    三、局部变量: 作用域为函数\n    四、位置参数变量: 当执行脚本的shell进程传递的参数\n    五、特殊变量: shell内置的有特殊功用的变量 eg:`$? 表示命令运行状态0表示成功，1-255表示失败`\n    \n    \n#### 多命令执行 ####\n```\n~]# COMMAND1; COMMAND2; COMMAND3; ...\n```\n\n短路法则:\n```\n~]# COMMAND1 && COMMAND2 //如果命令1失败，则命令2不执行\n\n~]# COMMAND1 || COMMAND2 //如果命令1成功，则命令2不执行\n```\n\n### bash的配置文件 ###\n\n登录类型：\n    交互式登录shell进程：\n        直接通过某终端输入账号和密码后打开的`shell`进程\n        使用`su - USERNAME`或者`su -l USERNAME`执行的登录切换\n    非交互式登录shell进程：\n        使用`su USERNAME`执行登录切换\n        图形界面下打开的终端\n        运行脚本\n        \n1. `profile`类：\n    全局：对所有用户都生效\n    \n        ```\n        /etc/profile\n        /etc.profile.d/*.sh\n        ```\n    \n     用户个人：仅对当前用户有效\n     \n        ```\n        ~/.bash_profile\n        ```\n    \n作用：\n1. 用于定义环境变量\n2. 运行命令或脚本\n\n\n2. bashrc类\n    全局：\n    \n    ```\n    /etc/bashrc \n    ```\n    \n    用户个人：\n    \n    ```\n    ~/.bashrc\n    ```\n    \n作用：\n    1. 定义本地变量\n    2. 定义命令别名\n\n    \n加载顺序：\n\n交互式\n\n```\n/etc/profile --> /etc/profile.d/* --> ~/bash_profile --> ~/.bashrc --> /etc/bashrc\n```\n\n非交互式\n\n```\n~/.bashrc --> /etc/bashrc --> /etc/profile.d/*\n```\n\n让`shell`进程重读配置文件\n\n```\n~]# source /PATH/FROM/CONF_FILE\n~]# . /PATH/FROM/CONF_FILE\n```","source":"_posts/Linux系统使用--Bash基础.md","raw":"---\ntitle: Linux系统使用--Bash基础\ndate: 2018-4-11 11:10:12\ntags: [Linux]\n---\n\n\n## 前言 ##\n\nlinux的bash使用相关\n\n<!-- more -->\n\n### bash的特性 ###\n\n命令行展开： ~ {}\n命令别名： alias，unalias\n命令历史： history\n文件名通配：glob\n快捷键：Ctrl+a,e,u,k,l\n命名补全： $PATH\n路径补全： Tab\n\n####命令hash####\nbash 会将使用过的命令缓存下来，再次输入命令的时候会先从缓存中去寻找命令，如果没有找到再去$PATH中去自左向右寻找\n\n查看缓存历史命令:\n```\nhash\n-d //删除缓存中的指定命令\n-r //清空缓存\n```\n\n#### 变量 ####\nbash的变量无需事先声明\nbash把所有变量统统视作字符类型\nbash不支持浮点数据，需借助外在工具\n变量名只能包含数字，字母和下划线，且不能以数字开头\n\n\nbash变量类型:\n    一、本地变量: 作用域为当前shell进程\n        变量使用: `${var_name}, 或$var_name, \"\"变量名会替换为其值, ''变量名不会替换为其值`\n        查看变量: `set`\n        撤销变量: `unset name`\n    二、环境变量: 作用域为当前shell进程及其子进程\n        变量赋值:\n            1. export name=value\n            2. name=value\n               export name\n            3. declare -x name=value\n            4. name=value\n               declare -x name  \n        注意: bash内嵌了许多环境变量(通常为全大写字符)，用于定义bash的工作环境。eg: `PATH, HISTFILE, HISTSIZE, HISTFILESIZE, HISTCONTROL, SHELL, HOME, UID, PWD, OLDPWD`\n        查看环境变量:\n        ```\n        export\n        declare -x\n        printenv\n        env\n        ```\n        撤销变量: `unset name`\n        只读变量:\n        1. declare -r name\n        2. readonly name\n        只读变量无法重新赋值，且不支持撤销，存活时间为当前shell进程的生命周期，随shell进程终止而终止\n    三、局部变量: 作用域为函数\n    四、位置参数变量: 当执行脚本的shell进程传递的参数\n    五、特殊变量: shell内置的有特殊功用的变量 eg:`$? 表示命令运行状态0表示成功，1-255表示失败`\n    \n    \n#### 多命令执行 ####\n```\n~]# COMMAND1; COMMAND2; COMMAND3; ...\n```\n\n短路法则:\n```\n~]# COMMAND1 && COMMAND2 //如果命令1失败，则命令2不执行\n\n~]# COMMAND1 || COMMAND2 //如果命令1成功，则命令2不执行\n```\n\n### bash的配置文件 ###\n\n登录类型：\n    交互式登录shell进程：\n        直接通过某终端输入账号和密码后打开的`shell`进程\n        使用`su - USERNAME`或者`su -l USERNAME`执行的登录切换\n    非交互式登录shell进程：\n        使用`su USERNAME`执行登录切换\n        图形界面下打开的终端\n        运行脚本\n        \n1. `profile`类：\n    全局：对所有用户都生效\n    \n        ```\n        /etc/profile\n        /etc.profile.d/*.sh\n        ```\n    \n     用户个人：仅对当前用户有效\n     \n        ```\n        ~/.bash_profile\n        ```\n    \n作用：\n1. 用于定义环境变量\n2. 运行命令或脚本\n\n\n2. bashrc类\n    全局：\n    \n    ```\n    /etc/bashrc \n    ```\n    \n    用户个人：\n    \n    ```\n    ~/.bashrc\n    ```\n    \n作用：\n    1. 定义本地变量\n    2. 定义命令别名\n\n    \n加载顺序：\n\n交互式\n\n```\n/etc/profile --> /etc/profile.d/* --> ~/bash_profile --> ~/.bashrc --> /etc/bashrc\n```\n\n非交互式\n\n```\n~/.bashrc --> /etc/bashrc --> /etc/profile.d/*\n```\n\n让`shell`进程重读配置文件\n\n```\n~]# source /PATH/FROM/CONF_FILE\n~]# . /PATH/FROM/CONF_FILE\n```","slug":"Linux系统使用--Bash基础","published":1,"updated":"2021-04-12T09:17:38.417Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqjdx1n500095emu1pjcgt3e","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>linux的bash使用相关</p>\n<a id=\"more\"></a>\n<h3 id=\"bash的特性\"><a href=\"#bash的特性\" class=\"headerlink\" title=\"bash的特性\"></a>bash的特性</h3><p>命令行展开： ~ {}<br>命令别名： alias，unalias<br>命令历史： history<br>文件名通配：glob<br>快捷键：Ctrl+a,e,u,k,l<br>命名补全： $PATH<br>路径补全： Tab</p>\n<p>####命令hash####<br>bash 会将使用过的命令缓存下来，再次输入命令的时候会先从缓存中去寻找命令，如果没有找到再去$PATH中去自左向右寻找</p>\n<p>查看缓存历史命令:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hash</span><br><span class=\"line\">-d //删除缓存中的指定命令</span><br><span class=\"line\">-r //清空缓存</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h4><p>bash的变量无需事先声明<br>bash把所有变量统统视作字符类型<br>bash不支持浮点数据，需借助外在工具<br>变量名只能包含数字，字母和下划线，且不能以数字开头</p>\n<p>bash变量类型:<br>    一、本地变量: 作用域为当前shell进程<br>        变量使用: <code>${var_name}, 或$var_name, &quot;&quot;变量名会替换为其值, &#39;&#39;变量名不会替换为其值</code><br>        查看变量: <code>set</code><br>        撤销变量: <code>unset name</code><br>    二、环境变量: 作用域为当前shell进程及其子进程<br>        变量赋值:</p>\n<pre><code>        1. export name=value\n        2. name=value\n           export name\n        3. declare -x name=value\n        4. name=value\n           declare -x name  \n    注意: bash内嵌了许多环境变量(通常为全大写字符)，用于定义bash的工作环境。eg: `PATH, HISTFILE, HISTSIZE, HISTFILESIZE, HISTCONTROL, SHELL, HOME, UID, PWD, OLDPWD`\n    查看环境变量:\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export</span><br><span class=\"line\">declare -x</span><br><span class=\"line\">printenv</span><br><span class=\"line\">env</span><br></pre></td></tr></table></figure>\n\n    撤销变量: `unset name`\n    只读变量:\n    1. declare -r name\n    2. readonly name\n    只读变量无法重新赋值，且不支持撤销，存活时间为当前shell进程的生命周期，随shell进程终止而终止\n三、局部变量: 作用域为函数\n四、位置参数变量: 当执行脚本的shell进程传递的参数\n五、特殊变量: shell内置的有特殊功用的变量 eg:`$? 表示命令运行状态0表示成功，1-255表示失败`\n</code></pre><h4 id=\"多命令执行\"><a href=\"#多命令执行\" class=\"headerlink\" title=\"多命令执行\"></a>多命令执行</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~]# COMMAND1; COMMAND2; COMMAND3; ...</span><br></pre></td></tr></table></figure>\n<p>短路法则:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~]# COMMAND1 &amp;&amp; COMMAND2 //如果命令1失败，则命令2不执行</span><br><span class=\"line\"></span><br><span class=\"line\">~]# COMMAND1 || COMMAND2 //如果命令1成功，则命令2不执行</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"bash的配置文件\"><a href=\"#bash的配置文件\" class=\"headerlink\" title=\"bash的配置文件\"></a>bash的配置文件</h3><p>登录类型：<br>    交互式登录shell进程：<br>        直接通过某终端输入账号和密码后打开的<code>shell</code>进程<br>        使用<code>su - USERNAME</code>或者<code>su -l USERNAME</code>执行的登录切换<br>    非交互式登录shell进程：<br>        使用<code>su USERNAME</code>执行登录切换<br>        图形界面下打开的终端<br>        运行脚本</p>\n<ol>\n<li><p><code>profile</code>类：<br> 全局：对所有用户都生效</p>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/etc/profile</span><br><span class=\"line\">/etc.profile.d/*.sh</span><br></pre></td></tr></table></figure>\n</code></pre></li>\n</ol>\n<pre><code>用户个人：仅对当前用户有效\n\n   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~/.bash_profile</span><br></pre></td></tr></table></figure>\n</code></pre><p>作用：</p>\n<ol>\n<li>用于定义环境变量</li>\n<li>运行命令或脚本</li>\n</ol>\n<ol start=\"2\">\n<li><p>bashrc类<br> 全局：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/etc/bashrc</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<pre><code>用户个人：\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~/.bashrc</span><br></pre></td></tr></table></figure>\n</code></pre><p>作用：</p>\n<pre><code>1. 定义本地变量\n2. 定义命令别名\n</code></pre><p>加载顺序：</p>\n<p>交互式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/etc/profile --&gt; /etc/profile.d/* --&gt; ~/bash_profile --&gt; ~/.bashrc --&gt; /etc/bashrc</span><br></pre></td></tr></table></figure>\n<p>非交互式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~/.bashrc --&gt; /etc/bashrc --&gt; /etc/profile.d/*</span><br></pre></td></tr></table></figure>\n<p>让<code>shell</code>进程重读配置文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~]# source /PATH/FROM/CONF_FILE</span><br><span class=\"line\">~]# . /PATH/FROM/CONF_FILE</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>linux的bash使用相关</p>","more":"<h3 id=\"bash的特性\"><a href=\"#bash的特性\" class=\"headerlink\" title=\"bash的特性\"></a>bash的特性</h3><p>命令行展开： ~ {}<br>命令别名： alias，unalias<br>命令历史： history<br>文件名通配：glob<br>快捷键：Ctrl+a,e,u,k,l<br>命名补全： $PATH<br>路径补全： Tab</p>\n<p>####命令hash####<br>bash 会将使用过的命令缓存下来，再次输入命令的时候会先从缓存中去寻找命令，如果没有找到再去$PATH中去自左向右寻找</p>\n<p>查看缓存历史命令:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hash</span><br><span class=\"line\">-d //删除缓存中的指定命令</span><br><span class=\"line\">-r //清空缓存</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h4><p>bash的变量无需事先声明<br>bash把所有变量统统视作字符类型<br>bash不支持浮点数据，需借助外在工具<br>变量名只能包含数字，字母和下划线，且不能以数字开头</p>\n<p>bash变量类型:<br>    一、本地变量: 作用域为当前shell进程<br>        变量使用: <code>${var_name}, 或$var_name, &quot;&quot;变量名会替换为其值, &#39;&#39;变量名不会替换为其值</code><br>        查看变量: <code>set</code><br>        撤销变量: <code>unset name</code><br>    二、环境变量: 作用域为当前shell进程及其子进程<br>        变量赋值:</p>\n<pre><code>        1. export name=value\n        2. name=value\n           export name\n        3. declare -x name=value\n        4. name=value\n           declare -x name  \n    注意: bash内嵌了许多环境变量(通常为全大写字符)，用于定义bash的工作环境。eg: `PATH, HISTFILE, HISTSIZE, HISTFILESIZE, HISTCONTROL, SHELL, HOME, UID, PWD, OLDPWD`\n    查看环境变量:\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export</span><br><span class=\"line\">declare -x</span><br><span class=\"line\">printenv</span><br><span class=\"line\">env</span><br></pre></td></tr></table></figure>\n\n    撤销变量: `unset name`\n    只读变量:\n    1. declare -r name\n    2. readonly name\n    只读变量无法重新赋值，且不支持撤销，存活时间为当前shell进程的生命周期，随shell进程终止而终止\n三、局部变量: 作用域为函数\n四、位置参数变量: 当执行脚本的shell进程传递的参数\n五、特殊变量: shell内置的有特殊功用的变量 eg:`$? 表示命令运行状态0表示成功，1-255表示失败`\n</code></pre><h4 id=\"多命令执行\"><a href=\"#多命令执行\" class=\"headerlink\" title=\"多命令执行\"></a>多命令执行</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~]# COMMAND1; COMMAND2; COMMAND3; ...</span><br></pre></td></tr></table></figure>\n<p>短路法则:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~]# COMMAND1 &amp;&amp; COMMAND2 //如果命令1失败，则命令2不执行</span><br><span class=\"line\"></span><br><span class=\"line\">~]# COMMAND1 || COMMAND2 //如果命令1成功，则命令2不执行</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"bash的配置文件\"><a href=\"#bash的配置文件\" class=\"headerlink\" title=\"bash的配置文件\"></a>bash的配置文件</h3><p>登录类型：<br>    交互式登录shell进程：<br>        直接通过某终端输入账号和密码后打开的<code>shell</code>进程<br>        使用<code>su - USERNAME</code>或者<code>su -l USERNAME</code>执行的登录切换<br>    非交互式登录shell进程：<br>        使用<code>su USERNAME</code>执行登录切换<br>        图形界面下打开的终端<br>        运行脚本</p>\n<ol>\n<li><p><code>profile</code>类：<br> 全局：对所有用户都生效</p>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/etc/profile</span><br><span class=\"line\">/etc.profile.d/*.sh</span><br></pre></td></tr></table></figure>\n</code></pre></li>\n</ol>\n<pre><code>用户个人：仅对当前用户有效\n\n   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~/.bash_profile</span><br></pre></td></tr></table></figure>\n</code></pre><p>作用：</p>\n<ol>\n<li>用于定义环境变量</li>\n<li>运行命令或脚本</li>\n</ol>\n<ol start=\"2\">\n<li><p>bashrc类<br> 全局：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/etc/bashrc</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<pre><code>用户个人：\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~/.bashrc</span><br></pre></td></tr></table></figure>\n</code></pre><p>作用：</p>\n<pre><code>1. 定义本地变量\n2. 定义命令别名\n</code></pre><p>加载顺序：</p>\n<p>交互式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/etc/profile --&gt; /etc/profile.d/* --&gt; ~/bash_profile --&gt; ~/.bashrc --&gt; /etc/bashrc</span><br></pre></td></tr></table></figure>\n<p>非交互式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~/.bashrc --&gt; /etc/bashrc --&gt; /etc/profile.d/*</span><br></pre></td></tr></table></figure>\n<p>让<code>shell</code>进程重读配置文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~]# source /PATH/FROM/CONF_FILE</span><br><span class=\"line\">~]# . /PATH/FROM/CONF_FILE</span><br></pre></td></tr></table></figure>"},{"title":"Linux系统使用--shell脚本编程","date":"2018-04-11T03:10:12.000Z","_content":"\n## 前言 ##\n\nlinux的shell脚本编程使用相关\n\n<!-- more -->\n\n### Linux系统使用--shell脚本编程 ###\n\n`shell`脚本编程是利用系统上的命令及编程组件进行编程的过程式编程语言，简单的说`shell`脚本就是命令的堆积，但是需要程序逻辑来判断运行条件是否满足，以避免其运行中发生错误\n\n### shell脚本格式 ###\n\n1. 第一行，顶格给出`shebang(解释器路径)`，用于指明解释执行当前脚本的解释器程序文件\n    常见的解释器路径：\n    ```\n    #!/bin/bash\n    #!/usr/bin/python\n    #!/usr/bin/perl\n    ```\n    \n### shell脚本运行 ###\n\n1. 赋予执行权限，直接运行\n\n    ```\n    chmod +x /PATH/TO/SCRIPT_FILE\n    /PATH/TO/SCRIPT_FILE\n    ```\n\n2. 直接运行解释器，将脚本以命令行参数传递给解释器程序\n\n    ```\n    bash /PATH/TO/SCRIPT_FILE\n    ```","source":"_posts/Linux系统使用--shell脚本编程.md","raw":"---\ntitle: Linux系统使用--shell脚本编程\ndate: 2018-4-11 11:10:12\ntags: [Linux]\n---\n\n## 前言 ##\n\nlinux的shell脚本编程使用相关\n\n<!-- more -->\n\n### Linux系统使用--shell脚本编程 ###\n\n`shell`脚本编程是利用系统上的命令及编程组件进行编程的过程式编程语言，简单的说`shell`脚本就是命令的堆积，但是需要程序逻辑来判断运行条件是否满足，以避免其运行中发生错误\n\n### shell脚本格式 ###\n\n1. 第一行，顶格给出`shebang(解释器路径)`，用于指明解释执行当前脚本的解释器程序文件\n    常见的解释器路径：\n    ```\n    #!/bin/bash\n    #!/usr/bin/python\n    #!/usr/bin/perl\n    ```\n    \n### shell脚本运行 ###\n\n1. 赋予执行权限，直接运行\n\n    ```\n    chmod +x /PATH/TO/SCRIPT_FILE\n    /PATH/TO/SCRIPT_FILE\n    ```\n\n2. 直接运行解释器，将脚本以命令行参数传递给解释器程序\n\n    ```\n    bash /PATH/TO/SCRIPT_FILE\n    ```","slug":"Linux系统使用--shell脚本编程","published":1,"updated":"2021-04-12T09:17:38.417Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqjdx1n6000b5emu5197iwrm","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>linux的shell脚本编程使用相关</p>\n<a id=\"more\"></a>\n<h3 id=\"Linux系统使用–shell脚本编程\"><a href=\"#Linux系统使用–shell脚本编程\" class=\"headerlink\" title=\"Linux系统使用–shell脚本编程\"></a>Linux系统使用–shell脚本编程</h3><p><code>shell</code>脚本编程是利用系统上的命令及编程组件进行编程的过程式编程语言，简单的说<code>shell</code>脚本就是命令的堆积，但是需要程序逻辑来判断运行条件是否满足，以避免其运行中发生错误</p>\n<h3 id=\"shell脚本格式\"><a href=\"#shell脚本格式\" class=\"headerlink\" title=\"shell脚本格式\"></a>shell脚本格式</h3><ol>\n<li>第一行，顶格给出<code>shebang(解释器路径)</code>，用于指明解释执行当前脚本的解释器程序文件<br> 常见的解释器路径： <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">#!/usr/bin/python</span><br><span class=\"line\">#!/usr/bin/perl</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"shell脚本运行\"><a href=\"#shell脚本运行\" class=\"headerlink\" title=\"shell脚本运行\"></a>shell脚本运行</h3><ol>\n<li><p>赋予执行权限，直接运行</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod +x /PATH/TO/SCRIPT_FILE</span><br><span class=\"line\">/PATH/TO/SCRIPT_FILE</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>直接运行解释器，将脚本以命令行参数传递给解释器程序</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bash /PATH/TO/SCRIPT_FILE</span><br></pre></td></tr></table></figure></li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>linux的shell脚本编程使用相关</p>","more":"<h3 id=\"Linux系统使用–shell脚本编程\"><a href=\"#Linux系统使用–shell脚本编程\" class=\"headerlink\" title=\"Linux系统使用–shell脚本编程\"></a>Linux系统使用–shell脚本编程</h3><p><code>shell</code>脚本编程是利用系统上的命令及编程组件进行编程的过程式编程语言，简单的说<code>shell</code>脚本就是命令的堆积，但是需要程序逻辑来判断运行条件是否满足，以避免其运行中发生错误</p>\n<h3 id=\"shell脚本格式\"><a href=\"#shell脚本格式\" class=\"headerlink\" title=\"shell脚本格式\"></a>shell脚本格式</h3><ol>\n<li>第一行，顶格给出<code>shebang(解释器路径)</code>，用于指明解释执行当前脚本的解释器程序文件<br> 常见的解释器路径： <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">#!/usr/bin/python</span><br><span class=\"line\">#!/usr/bin/perl</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"shell脚本运行\"><a href=\"#shell脚本运行\" class=\"headerlink\" title=\"shell脚本运行\"></a>shell脚本运行</h3><ol>\n<li><p>赋予执行权限，直接运行</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod +x /PATH/TO/SCRIPT_FILE</span><br><span class=\"line\">/PATH/TO/SCRIPT_FILE</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>直接运行解释器，将脚本以命令行参数传递给解释器程序</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bash /PATH/TO/SCRIPT_FILE</span><br></pre></td></tr></table></figure></li>\n</ol>"},{"title":"Linux系统使用--斐讯T1安装Armbian","date":"2018-06-14T03:10:12.000Z","_content":"\n## 前言 ##\n\n之前买过一个斐讯T1，用来当电视盒子配置还是够的，但是我没有看电视的需求，后来发现可以安装`Linux`，于是拿来尝试了一下，增加它的可玩性\n\n<!-- more -->\n\n### 准备工作 ###\n\n* U盘一个\n* 斐讯T1\n* 电脑\n\n注意：我在安装的时候使用的使用的一个U盘怎么也无法启动到`Linux`，看网上说是对U盘有要求，解决办法就是换一个U盘，所以在多次安装完成后遇到，无法启动`Linux`时，建议更换U盘，我后来换成了TF卡就没有出现无法启动的问题\n\n还有安装的时候斐讯的系统版本不能是最新版的，最好刷一个降级包\n\n### 下载系统 ###\n\n斐讯T1的`cpu`是Amlogic 晶晨S912，对应的系统被国外的大神制作好上传到`Yandex Disk`,所以下载系统可能需要FQ\n\n[系统下载地址](https://yadi.sk/d/pHxaRAs-tZiei)\n\n进去会有各个版本的文件夹，我使用的是`5.91`,所以进入`5.91`文件中，下载需要的系统。\n\n一个版本会有多个种类的系统文件，区别是`Debian`和`Ubuntu`,还有对应的桌面版还是服务版，下载自己需要的一个就好。\n\n### 写入U盘 ###\n\n下载完系统，就可以把写入U盘了\n\n我使用的软件是`balenaEtcher`, [下载地址](https://www.balena.io/etcher/)，选择对应系统的版本就好（是你电脑的系统）\n\n`balenaEtcher`的使用也很简单，第一项选择上面下载好的`linux`系统，第二项选择你的U盘（写入操作会格式化U盘，注意U盘数据备份），接着点击第三项`Flash`,等待写入成功\n\n### 修改dtb ###\n\n写入完成的U盘会有个叫`BOOT`的盘符，这时我们需要修改里面的`dtb`,斐讯T1使用的`dtb`叫做`meson-gxm-q201.dtb`,我们可以在`Boot/dtb/`文件夹中找到。\n\n使用文本编辑器打开`BOOT`盘符中的`boot.ini`文件，修改里面的`setenv dtb_name`为`\"/dtb/meson-gxm-q201.dtb\"`,修改完该行如下：\n\n```\nsetenv dtb_name \"/dtb/meson-gxm-q201.dtb\"\n```\n\n使用文本编辑器打开`BOOT`盘符中的`uEnv.ini`文件，修改里面的`dtb_name`为`/dtb/meson-gxm-q201.dtb`,修改完该行如下：\n\n```\ndtb_name=/dtb/meson-gxm-q201.dtb\n```\n\n使用文本编辑器打开`BOOT`盘符中`extlinux`文件夹下的`extlinux.conf`文件，修改里面的`FDT`为`/dtb/meson-gxm-q201.dtb`,修改完该行如下：\n\n```\nFDT /dtb/meson-gxm-q201.dtb\n```\n\n### 启动Linux ###\n\n将修改好的U盘插入斐讯T1的usb接口，然后给斐讯通电，斐讯启动会自动进入`Linux`系统，如果没有进入，网上的教程说在安卓的终端输入`reboot update`,斐讯T1会重启，就进入`Linux`系统了，但是我用这个不起作用，所以，我建议，没有启动`Linux`,就更换U盘，或者更换系统试试\n\n### 进入系统 ###\n\n如果启动了`Linux`,等待加载完成，如果加载过程中失败了，则可能是系统问题，建议更换别的版本的`Linux`系统。\n\n如果加载完成了，输入`root`登录超级用户，密码`1234`,登录成功会提示设置新的`root`密码，先输入默认密码`1234`,在输入两次新密码，设定成功。\n\n接下来按照提示，设置新用户名，和密码，已经用户信息。设置完成，就可以用新用户登录了。\n\n如果是有图形界面版本的系统，没有进入桌面，按`ctrl+alt+F7`进入桌面系统\n\n### 设置中文字体 ###\n\n开启中文字体\n```\nsudo vim /etc/locale.gen # 将里面的zh_CN.UTF-8前面的#去掉\n```\n\n更新程序列表\n```\nsudo apt update\n```\n\n更新程序\n```\nsudo apt upgrade\n```\n\n安装字体包（两种字体选一种就好）\n```\nsudo apt install fonts-noto-cjk\n\nsudo apt install ttf-wqy-zenhei \n```\n\n更新字体列表\n```\nsudo fc-cache -v\n```\n\n生成`locale`文件\n```\nsudo locale-gen\n```\n\n重启系统\n\n\n### 远程桌面 ###\n\n安装`x11vnc`\n\n```\nsudo apt install x11vnc\n```\n\n生成vnc密码\n\n```\nsudo x11vnc -storepasswd \n```\n\n启动vnc\n\n```\nx11vnc -auth guess -forever -loop -noxdamage -repeat -rfbauth /home/USERNAME/.vnc/passwd -rfbport 5900 -shared\n```\n\n设置开机自启动\n\n```\n#新建service\nsudo vim /etc/systemd/system/x11vnc.service\n\n#添加如下内容\n[Unit]\nDescription=Start x11vnc at startup.\nAfter=multi-user.target\n \n[Service]\nType=simple\nExecStart=/usr/bin/x11vnc -auth guess -forever -loop -noxdamage -repeat -rfbauth /home/USERNAME/.vnc/passwd -rfbport 5900 -shared\n \n[Install]\nWantedBy=multi-user.target\n```\n\n依次执行下面的命令\n```\nsudo chmod u+x /etc/systemd/system/x11vnc.service\nsudo systemctl daemon-reload\nsudo systemctl enable x11vnc.service\n```","source":"_posts/Linux系统使用--斐讯T1安装Armbian.md","raw":"---\ntitle: Linux系统使用--斐讯T1安装Armbian\ndate: 2018-6-14 11:10:12\ntags: [Linux]\n---\n\n## 前言 ##\n\n之前买过一个斐讯T1，用来当电视盒子配置还是够的，但是我没有看电视的需求，后来发现可以安装`Linux`，于是拿来尝试了一下，增加它的可玩性\n\n<!-- more -->\n\n### 准备工作 ###\n\n* U盘一个\n* 斐讯T1\n* 电脑\n\n注意：我在安装的时候使用的使用的一个U盘怎么也无法启动到`Linux`，看网上说是对U盘有要求，解决办法就是换一个U盘，所以在多次安装完成后遇到，无法启动`Linux`时，建议更换U盘，我后来换成了TF卡就没有出现无法启动的问题\n\n还有安装的时候斐讯的系统版本不能是最新版的，最好刷一个降级包\n\n### 下载系统 ###\n\n斐讯T1的`cpu`是Amlogic 晶晨S912，对应的系统被国外的大神制作好上传到`Yandex Disk`,所以下载系统可能需要FQ\n\n[系统下载地址](https://yadi.sk/d/pHxaRAs-tZiei)\n\n进去会有各个版本的文件夹，我使用的是`5.91`,所以进入`5.91`文件中，下载需要的系统。\n\n一个版本会有多个种类的系统文件，区别是`Debian`和`Ubuntu`,还有对应的桌面版还是服务版，下载自己需要的一个就好。\n\n### 写入U盘 ###\n\n下载完系统，就可以把写入U盘了\n\n我使用的软件是`balenaEtcher`, [下载地址](https://www.balena.io/etcher/)，选择对应系统的版本就好（是你电脑的系统）\n\n`balenaEtcher`的使用也很简单，第一项选择上面下载好的`linux`系统，第二项选择你的U盘（写入操作会格式化U盘，注意U盘数据备份），接着点击第三项`Flash`,等待写入成功\n\n### 修改dtb ###\n\n写入完成的U盘会有个叫`BOOT`的盘符，这时我们需要修改里面的`dtb`,斐讯T1使用的`dtb`叫做`meson-gxm-q201.dtb`,我们可以在`Boot/dtb/`文件夹中找到。\n\n使用文本编辑器打开`BOOT`盘符中的`boot.ini`文件，修改里面的`setenv dtb_name`为`\"/dtb/meson-gxm-q201.dtb\"`,修改完该行如下：\n\n```\nsetenv dtb_name \"/dtb/meson-gxm-q201.dtb\"\n```\n\n使用文本编辑器打开`BOOT`盘符中的`uEnv.ini`文件，修改里面的`dtb_name`为`/dtb/meson-gxm-q201.dtb`,修改完该行如下：\n\n```\ndtb_name=/dtb/meson-gxm-q201.dtb\n```\n\n使用文本编辑器打开`BOOT`盘符中`extlinux`文件夹下的`extlinux.conf`文件，修改里面的`FDT`为`/dtb/meson-gxm-q201.dtb`,修改完该行如下：\n\n```\nFDT /dtb/meson-gxm-q201.dtb\n```\n\n### 启动Linux ###\n\n将修改好的U盘插入斐讯T1的usb接口，然后给斐讯通电，斐讯启动会自动进入`Linux`系统，如果没有进入，网上的教程说在安卓的终端输入`reboot update`,斐讯T1会重启，就进入`Linux`系统了，但是我用这个不起作用，所以，我建议，没有启动`Linux`,就更换U盘，或者更换系统试试\n\n### 进入系统 ###\n\n如果启动了`Linux`,等待加载完成，如果加载过程中失败了，则可能是系统问题，建议更换别的版本的`Linux`系统。\n\n如果加载完成了，输入`root`登录超级用户，密码`1234`,登录成功会提示设置新的`root`密码，先输入默认密码`1234`,在输入两次新密码，设定成功。\n\n接下来按照提示，设置新用户名，和密码，已经用户信息。设置完成，就可以用新用户登录了。\n\n如果是有图形界面版本的系统，没有进入桌面，按`ctrl+alt+F7`进入桌面系统\n\n### 设置中文字体 ###\n\n开启中文字体\n```\nsudo vim /etc/locale.gen # 将里面的zh_CN.UTF-8前面的#去掉\n```\n\n更新程序列表\n```\nsudo apt update\n```\n\n更新程序\n```\nsudo apt upgrade\n```\n\n安装字体包（两种字体选一种就好）\n```\nsudo apt install fonts-noto-cjk\n\nsudo apt install ttf-wqy-zenhei \n```\n\n更新字体列表\n```\nsudo fc-cache -v\n```\n\n生成`locale`文件\n```\nsudo locale-gen\n```\n\n重启系统\n\n\n### 远程桌面 ###\n\n安装`x11vnc`\n\n```\nsudo apt install x11vnc\n```\n\n生成vnc密码\n\n```\nsudo x11vnc -storepasswd \n```\n\n启动vnc\n\n```\nx11vnc -auth guess -forever -loop -noxdamage -repeat -rfbauth /home/USERNAME/.vnc/passwd -rfbport 5900 -shared\n```\n\n设置开机自启动\n\n```\n#新建service\nsudo vim /etc/systemd/system/x11vnc.service\n\n#添加如下内容\n[Unit]\nDescription=Start x11vnc at startup.\nAfter=multi-user.target\n \n[Service]\nType=simple\nExecStart=/usr/bin/x11vnc -auth guess -forever -loop -noxdamage -repeat -rfbauth /home/USERNAME/.vnc/passwd -rfbport 5900 -shared\n \n[Install]\nWantedBy=multi-user.target\n```\n\n依次执行下面的命令\n```\nsudo chmod u+x /etc/systemd/system/x11vnc.service\nsudo systemctl daemon-reload\nsudo systemctl enable x11vnc.service\n```","slug":"Linux系统使用--斐讯T1安装Armbian","published":1,"updated":"2021-04-12T09:17:38.417Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqjdx1n7000d5emuwzdaxz7m","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>之前买过一个斐讯T1，用来当电视盒子配置还是够的，但是我没有看电视的需求，后来发现可以安装<code>Linux</code>，于是拿来尝试了一下，增加它的可玩性</p>\n<a id=\"more\"></a>\n<h3 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h3><ul>\n<li>U盘一个</li>\n<li>斐讯T1</li>\n<li>电脑</li>\n</ul>\n<p>注意：我在安装的时候使用的使用的一个U盘怎么也无法启动到<code>Linux</code>，看网上说是对U盘有要求，解决办法就是换一个U盘，所以在多次安装完成后遇到，无法启动<code>Linux</code>时，建议更换U盘，我后来换成了TF卡就没有出现无法启动的问题</p>\n<p>还有安装的时候斐讯的系统版本不能是最新版的，最好刷一个降级包</p>\n<h3 id=\"下载系统\"><a href=\"#下载系统\" class=\"headerlink\" title=\"下载系统\"></a>下载系统</h3><p>斐讯T1的<code>cpu</code>是Amlogic 晶晨S912，对应的系统被国外的大神制作好上传到<code>Yandex Disk</code>,所以下载系统可能需要FQ</p>\n<p><a href=\"https://yadi.sk/d/pHxaRAs-tZiei\" target=\"_blank\" rel=\"noopener\">系统下载地址</a></p>\n<p>进去会有各个版本的文件夹，我使用的是<code>5.91</code>,所以进入<code>5.91</code>文件中，下载需要的系统。</p>\n<p>一个版本会有多个种类的系统文件，区别是<code>Debian</code>和<code>Ubuntu</code>,还有对应的桌面版还是服务版，下载自己需要的一个就好。</p>\n<h3 id=\"写入U盘\"><a href=\"#写入U盘\" class=\"headerlink\" title=\"写入U盘\"></a>写入U盘</h3><p>下载完系统，就可以把写入U盘了</p>\n<p>我使用的软件是<code>balenaEtcher</code>, <a href=\"https://www.balena.io/etcher/\" target=\"_blank\" rel=\"noopener\">下载地址</a>，选择对应系统的版本就好（是你电脑的系统）</p>\n<p><code>balenaEtcher</code>的使用也很简单，第一项选择上面下载好的<code>linux</code>系统，第二项选择你的U盘（写入操作会格式化U盘，注意U盘数据备份），接着点击第三项<code>Flash</code>,等待写入成功</p>\n<h3 id=\"修改dtb\"><a href=\"#修改dtb\" class=\"headerlink\" title=\"修改dtb\"></a>修改dtb</h3><p>写入完成的U盘会有个叫<code>BOOT</code>的盘符，这时我们需要修改里面的<code>dtb</code>,斐讯T1使用的<code>dtb</code>叫做<code>meson-gxm-q201.dtb</code>,我们可以在<code>Boot/dtb/</code>文件夹中找到。</p>\n<p>使用文本编辑器打开<code>BOOT</code>盘符中的<code>boot.ini</code>文件，修改里面的<code>setenv dtb_name</code>为<code>&quot;/dtb/meson-gxm-q201.dtb&quot;</code>,修改完该行如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setenv dtb_name &quot;/dtb/meson-gxm-q201.dtb&quot;</span><br></pre></td></tr></table></figure>\n<p>使用文本编辑器打开<code>BOOT</code>盘符中的<code>uEnv.ini</code>文件，修改里面的<code>dtb_name</code>为<code>/dtb/meson-gxm-q201.dtb</code>,修改完该行如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dtb_name=/dtb/meson-gxm-q201.dtb</span><br></pre></td></tr></table></figure>\n<p>使用文本编辑器打开<code>BOOT</code>盘符中<code>extlinux</code>文件夹下的<code>extlinux.conf</code>文件，修改里面的<code>FDT</code>为<code>/dtb/meson-gxm-q201.dtb</code>,修改完该行如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FDT /dtb/meson-gxm-q201.dtb</span><br></pre></td></tr></table></figure>\n<h3 id=\"启动Linux\"><a href=\"#启动Linux\" class=\"headerlink\" title=\"启动Linux\"></a>启动Linux</h3><p>将修改好的U盘插入斐讯T1的usb接口，然后给斐讯通电，斐讯启动会自动进入<code>Linux</code>系统，如果没有进入，网上的教程说在安卓的终端输入<code>reboot update</code>,斐讯T1会重启，就进入<code>Linux</code>系统了，但是我用这个不起作用，所以，我建议，没有启动<code>Linux</code>,就更换U盘，或者更换系统试试</p>\n<h3 id=\"进入系统\"><a href=\"#进入系统\" class=\"headerlink\" title=\"进入系统\"></a>进入系统</h3><p>如果启动了<code>Linux</code>,等待加载完成，如果加载过程中失败了，则可能是系统问题，建议更换别的版本的<code>Linux</code>系统。</p>\n<p>如果加载完成了，输入<code>root</code>登录超级用户，密码<code>1234</code>,登录成功会提示设置新的<code>root</code>密码，先输入默认密码<code>1234</code>,在输入两次新密码，设定成功。</p>\n<p>接下来按照提示，设置新用户名，和密码，已经用户信息。设置完成，就可以用新用户登录了。</p>\n<p>如果是有图形界面版本的系统，没有进入桌面，按<code>ctrl+alt+F7</code>进入桌面系统</p>\n<h3 id=\"设置中文字体\"><a href=\"#设置中文字体\" class=\"headerlink\" title=\"设置中文字体\"></a>设置中文字体</h3><p>开启中文字体<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo vim /etc/locale.gen # 将里面的zh_CN.UTF-8前面的#去掉</span><br></pre></td></tr></table></figure></p>\n<p>更新程序列表<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt update</span><br></pre></td></tr></table></figure></p>\n<p>更新程序<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt upgrade</span><br></pre></td></tr></table></figure></p>\n<p>安装字体包（两种字体选一种就好）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install fonts-noto-cjk</span><br><span class=\"line\"></span><br><span class=\"line\">sudo apt install ttf-wqy-zenhei</span><br></pre></td></tr></table></figure></p>\n<p>更新字体列表<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo fc-cache -v</span><br></pre></td></tr></table></figure></p>\n<p>生成<code>locale</code>文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo locale-gen</span><br></pre></td></tr></table></figure></p>\n<p>重启系统</p>\n<h3 id=\"远程桌面\"><a href=\"#远程桌面\" class=\"headerlink\" title=\"远程桌面\"></a>远程桌面</h3><p>安装<code>x11vnc</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install x11vnc</span><br></pre></td></tr></table></figure>\n<p>生成vnc密码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo x11vnc -storepasswd</span><br></pre></td></tr></table></figure>\n<p>启动vnc</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x11vnc -auth guess -forever -loop -noxdamage -repeat -rfbauth /home/USERNAME/.vnc/passwd -rfbport 5900 -shared</span><br></pre></td></tr></table></figure>\n<p>设置开机自启动</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#新建service</span><br><span class=\"line\">sudo vim /etc/systemd/system/x11vnc.service</span><br><span class=\"line\"></span><br><span class=\"line\">#添加如下内容</span><br><span class=\"line\">[Unit]</span><br><span class=\"line\">Description=Start x11vnc at startup.</span><br><span class=\"line\">After=multi-user.target</span><br><span class=\"line\"> </span><br><span class=\"line\">[Service]</span><br><span class=\"line\">Type=simple</span><br><span class=\"line\">ExecStart=/usr/bin/x11vnc -auth guess -forever -loop -noxdamage -repeat -rfbauth /home/USERNAME/.vnc/passwd -rfbport 5900 -shared</span><br><span class=\"line\"> </span><br><span class=\"line\">[Install]</span><br><span class=\"line\">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>\n<p>依次执行下面的命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo chmod u+x /etc/systemd/system/x11vnc.service</span><br><span class=\"line\">sudo systemctl daemon-reload</span><br><span class=\"line\">sudo systemctl enable x11vnc.service</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>之前买过一个斐讯T1，用来当电视盒子配置还是够的，但是我没有看电视的需求，后来发现可以安装<code>Linux</code>，于是拿来尝试了一下，增加它的可玩性</p>","more":"<h3 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h3><ul>\n<li>U盘一个</li>\n<li>斐讯T1</li>\n<li>电脑</li>\n</ul>\n<p>注意：我在安装的时候使用的使用的一个U盘怎么也无法启动到<code>Linux</code>，看网上说是对U盘有要求，解决办法就是换一个U盘，所以在多次安装完成后遇到，无法启动<code>Linux</code>时，建议更换U盘，我后来换成了TF卡就没有出现无法启动的问题</p>\n<p>还有安装的时候斐讯的系统版本不能是最新版的，最好刷一个降级包</p>\n<h3 id=\"下载系统\"><a href=\"#下载系统\" class=\"headerlink\" title=\"下载系统\"></a>下载系统</h3><p>斐讯T1的<code>cpu</code>是Amlogic 晶晨S912，对应的系统被国外的大神制作好上传到<code>Yandex Disk</code>,所以下载系统可能需要FQ</p>\n<p><a href=\"https://yadi.sk/d/pHxaRAs-tZiei\" target=\"_blank\" rel=\"noopener\">系统下载地址</a></p>\n<p>进去会有各个版本的文件夹，我使用的是<code>5.91</code>,所以进入<code>5.91</code>文件中，下载需要的系统。</p>\n<p>一个版本会有多个种类的系统文件，区别是<code>Debian</code>和<code>Ubuntu</code>,还有对应的桌面版还是服务版，下载自己需要的一个就好。</p>\n<h3 id=\"写入U盘\"><a href=\"#写入U盘\" class=\"headerlink\" title=\"写入U盘\"></a>写入U盘</h3><p>下载完系统，就可以把写入U盘了</p>\n<p>我使用的软件是<code>balenaEtcher</code>, <a href=\"https://www.balena.io/etcher/\" target=\"_blank\" rel=\"noopener\">下载地址</a>，选择对应系统的版本就好（是你电脑的系统）</p>\n<p><code>balenaEtcher</code>的使用也很简单，第一项选择上面下载好的<code>linux</code>系统，第二项选择你的U盘（写入操作会格式化U盘，注意U盘数据备份），接着点击第三项<code>Flash</code>,等待写入成功</p>\n<h3 id=\"修改dtb\"><a href=\"#修改dtb\" class=\"headerlink\" title=\"修改dtb\"></a>修改dtb</h3><p>写入完成的U盘会有个叫<code>BOOT</code>的盘符，这时我们需要修改里面的<code>dtb</code>,斐讯T1使用的<code>dtb</code>叫做<code>meson-gxm-q201.dtb</code>,我们可以在<code>Boot/dtb/</code>文件夹中找到。</p>\n<p>使用文本编辑器打开<code>BOOT</code>盘符中的<code>boot.ini</code>文件，修改里面的<code>setenv dtb_name</code>为<code>&quot;/dtb/meson-gxm-q201.dtb&quot;</code>,修改完该行如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setenv dtb_name &quot;/dtb/meson-gxm-q201.dtb&quot;</span><br></pre></td></tr></table></figure>\n<p>使用文本编辑器打开<code>BOOT</code>盘符中的<code>uEnv.ini</code>文件，修改里面的<code>dtb_name</code>为<code>/dtb/meson-gxm-q201.dtb</code>,修改完该行如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dtb_name=/dtb/meson-gxm-q201.dtb</span><br></pre></td></tr></table></figure>\n<p>使用文本编辑器打开<code>BOOT</code>盘符中<code>extlinux</code>文件夹下的<code>extlinux.conf</code>文件，修改里面的<code>FDT</code>为<code>/dtb/meson-gxm-q201.dtb</code>,修改完该行如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FDT /dtb/meson-gxm-q201.dtb</span><br></pre></td></tr></table></figure>\n<h3 id=\"启动Linux\"><a href=\"#启动Linux\" class=\"headerlink\" title=\"启动Linux\"></a>启动Linux</h3><p>将修改好的U盘插入斐讯T1的usb接口，然后给斐讯通电，斐讯启动会自动进入<code>Linux</code>系统，如果没有进入，网上的教程说在安卓的终端输入<code>reboot update</code>,斐讯T1会重启，就进入<code>Linux</code>系统了，但是我用这个不起作用，所以，我建议，没有启动<code>Linux</code>,就更换U盘，或者更换系统试试</p>\n<h3 id=\"进入系统\"><a href=\"#进入系统\" class=\"headerlink\" title=\"进入系统\"></a>进入系统</h3><p>如果启动了<code>Linux</code>,等待加载完成，如果加载过程中失败了，则可能是系统问题，建议更换别的版本的<code>Linux</code>系统。</p>\n<p>如果加载完成了，输入<code>root</code>登录超级用户，密码<code>1234</code>,登录成功会提示设置新的<code>root</code>密码，先输入默认密码<code>1234</code>,在输入两次新密码，设定成功。</p>\n<p>接下来按照提示，设置新用户名，和密码，已经用户信息。设置完成，就可以用新用户登录了。</p>\n<p>如果是有图形界面版本的系统，没有进入桌面，按<code>ctrl+alt+F7</code>进入桌面系统</p>\n<h3 id=\"设置中文字体\"><a href=\"#设置中文字体\" class=\"headerlink\" title=\"设置中文字体\"></a>设置中文字体</h3><p>开启中文字体<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo vim /etc/locale.gen # 将里面的zh_CN.UTF-8前面的#去掉</span><br></pre></td></tr></table></figure></p>\n<p>更新程序列表<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt update</span><br></pre></td></tr></table></figure></p>\n<p>更新程序<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt upgrade</span><br></pre></td></tr></table></figure></p>\n<p>安装字体包（两种字体选一种就好）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install fonts-noto-cjk</span><br><span class=\"line\"></span><br><span class=\"line\">sudo apt install ttf-wqy-zenhei</span><br></pre></td></tr></table></figure></p>\n<p>更新字体列表<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo fc-cache -v</span><br></pre></td></tr></table></figure></p>\n<p>生成<code>locale</code>文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo locale-gen</span><br></pre></td></tr></table></figure></p>\n<p>重启系统</p>\n<h3 id=\"远程桌面\"><a href=\"#远程桌面\" class=\"headerlink\" title=\"远程桌面\"></a>远程桌面</h3><p>安装<code>x11vnc</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install x11vnc</span><br></pre></td></tr></table></figure>\n<p>生成vnc密码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo x11vnc -storepasswd</span><br></pre></td></tr></table></figure>\n<p>启动vnc</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x11vnc -auth guess -forever -loop -noxdamage -repeat -rfbauth /home/USERNAME/.vnc/passwd -rfbport 5900 -shared</span><br></pre></td></tr></table></figure>\n<p>设置开机自启动</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#新建service</span><br><span class=\"line\">sudo vim /etc/systemd/system/x11vnc.service</span><br><span class=\"line\"></span><br><span class=\"line\">#添加如下内容</span><br><span class=\"line\">[Unit]</span><br><span class=\"line\">Description=Start x11vnc at startup.</span><br><span class=\"line\">After=multi-user.target</span><br><span class=\"line\"> </span><br><span class=\"line\">[Service]</span><br><span class=\"line\">Type=simple</span><br><span class=\"line\">ExecStart=/usr/bin/x11vnc -auth guess -forever -loop -noxdamage -repeat -rfbauth /home/USERNAME/.vnc/passwd -rfbport 5900 -shared</span><br><span class=\"line\"> </span><br><span class=\"line\">[Install]</span><br><span class=\"line\">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>\n<p>依次执行下面的命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo chmod u+x /etc/systemd/system/x11vnc.service</span><br><span class=\"line\">sudo systemctl daemon-reload</span><br><span class=\"line\">sudo systemctl enable x11vnc.service</span><br></pre></td></tr></table></figure></p>"},{"title":"MAC下安装Python3","date":"2018-03-24T14:32:17.000Z","_content":"\n## 前言 ##\n`MAC os`本身是自带`Python`的,但是不是`Python3`，这里记录一下安装`Python3`的步骤\n\n<!-- more -->\n\n### 1、安装Xcode ###\n\n步骤：\n\n1）、打开App Store 搜索`Xcode`,点击安装，安装完成后打开\n\n如果是第一次打开`Xcode`需要同意`License Agreement`\n\n\n2）、然后安装`Xcode command line tool`\n\n在终端输入\n\n```\nxcode-select --install\n```\n\n在弹出的窗口中点击`安装`等待完成\n\n### 2、安装HOMEBREW ###\n\nHomeBrew的介绍和安装方法可以在其官网找到 [HomeBrew官网](https://brew.sh/index_zh-cn)\n\n1）、在终端输入：\n\n```\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n```\n\n等待`HomeBrew`安装完成\n\n2）、验证安装结果，在终端输入：\n\n```\nbrew doctor\n```\n\n如果显示`Your system is ready to brew.` 代表`Homebrew`安装成功\n\n\n### 3、安装Python ###\n\n如前言所说其实`MAC os`是自带一个Python的,我们可以使用下面命令查看Python版本\n\n```\npython --version\n```\n\n首先安装Python 终端输入：\n\n```\nbrew install python\n```\n\n完成后Python3就会被安装到`/usr/local/Cellar`目录下\n\n输入`which python3`查看python3的命令路径\n\n\n### 4、修改系统路径 ###\n\n首先查看系统路径，输入：\n\n```\necho $PATH\n```\n\n显示出来的路径就是系统搜索命令的路径\n\n如果里面没有Python3的路径，就需要我们手动添加一下\n\n输入：\n\n```\nsudo emacs /etc/paths\n```\n\n把Python3的路径添加进去\n\n然后按：ctrl+x+c 回复y保存退出\n\n### 5、注意 ###\n\nTensorFlow在Python3.7下目前不支持，而brew的新版本又不支持指定版本Python安装，所以最简单的解决办法是从[Python官网](https://www.python.org/downloads/mac-osx/)下载3.6版本的pkg安装，pkg安装的路径是`/Library/Frameworks/Python.framework/`\n\n\n移除brew安装的Python\n\n```\n#移除所有版本Python\nbrew uninstall --force python \n```","source":"_posts/MAC下安装Python3.md","raw":"---\ntitle: MAC下安装Python3\ndate: 2018-03-24 22:32:17\ntags: Linux\n---\n\n## 前言 ##\n`MAC os`本身是自带`Python`的,但是不是`Python3`，这里记录一下安装`Python3`的步骤\n\n<!-- more -->\n\n### 1、安装Xcode ###\n\n步骤：\n\n1）、打开App Store 搜索`Xcode`,点击安装，安装完成后打开\n\n如果是第一次打开`Xcode`需要同意`License Agreement`\n\n\n2）、然后安装`Xcode command line tool`\n\n在终端输入\n\n```\nxcode-select --install\n```\n\n在弹出的窗口中点击`安装`等待完成\n\n### 2、安装HOMEBREW ###\n\nHomeBrew的介绍和安装方法可以在其官网找到 [HomeBrew官网](https://brew.sh/index_zh-cn)\n\n1）、在终端输入：\n\n```\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n```\n\n等待`HomeBrew`安装完成\n\n2）、验证安装结果，在终端输入：\n\n```\nbrew doctor\n```\n\n如果显示`Your system is ready to brew.` 代表`Homebrew`安装成功\n\n\n### 3、安装Python ###\n\n如前言所说其实`MAC os`是自带一个Python的,我们可以使用下面命令查看Python版本\n\n```\npython --version\n```\n\n首先安装Python 终端输入：\n\n```\nbrew install python\n```\n\n完成后Python3就会被安装到`/usr/local/Cellar`目录下\n\n输入`which python3`查看python3的命令路径\n\n\n### 4、修改系统路径 ###\n\n首先查看系统路径，输入：\n\n```\necho $PATH\n```\n\n显示出来的路径就是系统搜索命令的路径\n\n如果里面没有Python3的路径，就需要我们手动添加一下\n\n输入：\n\n```\nsudo emacs /etc/paths\n```\n\n把Python3的路径添加进去\n\n然后按：ctrl+x+c 回复y保存退出\n\n### 5、注意 ###\n\nTensorFlow在Python3.7下目前不支持，而brew的新版本又不支持指定版本Python安装，所以最简单的解决办法是从[Python官网](https://www.python.org/downloads/mac-osx/)下载3.6版本的pkg安装，pkg安装的路径是`/Library/Frameworks/Python.framework/`\n\n\n移除brew安装的Python\n\n```\n#移除所有版本Python\nbrew uninstall --force python \n```","slug":"MAC下安装Python3","published":1,"updated":"2021-04-12T09:17:38.418Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqjdx1n9000f5emudv0p2p7t","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p><code>MAC os</code>本身是自带<code>Python</code>的,但是不是<code>Python3</code>，这里记录一下安装<code>Python3</code>的步骤</p>\n<a id=\"more\"></a>\n<h3 id=\"1、安装Xcode\"><a href=\"#1、安装Xcode\" class=\"headerlink\" title=\"1、安装Xcode\"></a>1、安装Xcode</h3><p>步骤：</p>\n<p>1）、打开App Store 搜索<code>Xcode</code>,点击安装，安装完成后打开</p>\n<p>如果是第一次打开<code>Xcode</code>需要同意<code>License Agreement</code></p>\n<p>2）、然后安装<code>Xcode command line tool</code></p>\n<p>在终端输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xcode-select --install</span><br></pre></td></tr></table></figure>\n<p>在弹出的窗口中点击<code>安装</code>等待完成</p>\n<h3 id=\"2、安装HOMEBREW\"><a href=\"#2、安装HOMEBREW\" class=\"headerlink\" title=\"2、安装HOMEBREW\"></a>2、安装HOMEBREW</h3><p>HomeBrew的介绍和安装方法可以在其官网找到 <a href=\"https://brew.sh/index_zh-cn\" target=\"_blank\" rel=\"noopener\">HomeBrew官网</a></p>\n<p>1）、在终端输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure>\n<p>等待<code>HomeBrew</code>安装完成</p>\n<p>2）、验证安装结果，在终端输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew doctor</span><br></pre></td></tr></table></figure>\n<p>如果显示<code>Your system is ready to brew.</code> 代表<code>Homebrew</code>安装成功</p>\n<h3 id=\"3、安装Python\"><a href=\"#3、安装Python\" class=\"headerlink\" title=\"3、安装Python\"></a>3、安装Python</h3><p>如前言所说其实<code>MAC os</code>是自带一个Python的,我们可以使用下面命令查看Python版本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python --version</span><br></pre></td></tr></table></figure>\n<p>首先安装Python 终端输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install python</span><br></pre></td></tr></table></figure>\n<p>完成后Python3就会被安装到<code>/usr/local/Cellar</code>目录下</p>\n<p>输入<code>which python3</code>查看python3的命令路径</p>\n<h3 id=\"4、修改系统路径\"><a href=\"#4、修改系统路径\" class=\"headerlink\" title=\"4、修改系统路径\"></a>4、修改系统路径</h3><p>首先查看系统路径，输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo $PATH</span><br></pre></td></tr></table></figure>\n<p>显示出来的路径就是系统搜索命令的路径</p>\n<p>如果里面没有Python3的路径，就需要我们手动添加一下</p>\n<p>输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo emacs /etc/paths</span><br></pre></td></tr></table></figure>\n<p>把Python3的路径添加进去</p>\n<p>然后按：ctrl+x+c 回复y保存退出</p>\n<h3 id=\"5、注意\"><a href=\"#5、注意\" class=\"headerlink\" title=\"5、注意\"></a>5、注意</h3><p>TensorFlow在Python3.7下目前不支持，而brew的新版本又不支持指定版本Python安装，所以最简单的解决办法是从<a href=\"https://www.python.org/downloads/mac-osx/\" target=\"_blank\" rel=\"noopener\">Python官网</a>下载3.6版本的pkg安装，pkg安装的路径是<code>/Library/Frameworks/Python.framework/</code></p>\n<p>移除brew安装的Python</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#移除所有版本Python</span><br><span class=\"line\">brew uninstall --force python</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p><code>MAC os</code>本身是自带<code>Python</code>的,但是不是<code>Python3</code>，这里记录一下安装<code>Python3</code>的步骤</p>","more":"<h3 id=\"1、安装Xcode\"><a href=\"#1、安装Xcode\" class=\"headerlink\" title=\"1、安装Xcode\"></a>1、安装Xcode</h3><p>步骤：</p>\n<p>1）、打开App Store 搜索<code>Xcode</code>,点击安装，安装完成后打开</p>\n<p>如果是第一次打开<code>Xcode</code>需要同意<code>License Agreement</code></p>\n<p>2）、然后安装<code>Xcode command line tool</code></p>\n<p>在终端输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xcode-select --install</span><br></pre></td></tr></table></figure>\n<p>在弹出的窗口中点击<code>安装</code>等待完成</p>\n<h3 id=\"2、安装HOMEBREW\"><a href=\"#2、安装HOMEBREW\" class=\"headerlink\" title=\"2、安装HOMEBREW\"></a>2、安装HOMEBREW</h3><p>HomeBrew的介绍和安装方法可以在其官网找到 <a href=\"https://brew.sh/index_zh-cn\" target=\"_blank\" rel=\"noopener\">HomeBrew官网</a></p>\n<p>1）、在终端输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure>\n<p>等待<code>HomeBrew</code>安装完成</p>\n<p>2）、验证安装结果，在终端输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew doctor</span><br></pre></td></tr></table></figure>\n<p>如果显示<code>Your system is ready to brew.</code> 代表<code>Homebrew</code>安装成功</p>\n<h3 id=\"3、安装Python\"><a href=\"#3、安装Python\" class=\"headerlink\" title=\"3、安装Python\"></a>3、安装Python</h3><p>如前言所说其实<code>MAC os</code>是自带一个Python的,我们可以使用下面命令查看Python版本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python --version</span><br></pre></td></tr></table></figure>\n<p>首先安装Python 终端输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install python</span><br></pre></td></tr></table></figure>\n<p>完成后Python3就会被安装到<code>/usr/local/Cellar</code>目录下</p>\n<p>输入<code>which python3</code>查看python3的命令路径</p>\n<h3 id=\"4、修改系统路径\"><a href=\"#4、修改系统路径\" class=\"headerlink\" title=\"4、修改系统路径\"></a>4、修改系统路径</h3><p>首先查看系统路径，输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo $PATH</span><br></pre></td></tr></table></figure>\n<p>显示出来的路径就是系统搜索命令的路径</p>\n<p>如果里面没有Python3的路径，就需要我们手动添加一下</p>\n<p>输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo emacs /etc/paths</span><br></pre></td></tr></table></figure>\n<p>把Python3的路径添加进去</p>\n<p>然后按：ctrl+x+c 回复y保存退出</p>\n<h3 id=\"5、注意\"><a href=\"#5、注意\" class=\"headerlink\" title=\"5、注意\"></a>5、注意</h3><p>TensorFlow在Python3.7下目前不支持，而brew的新版本又不支持指定版本Python安装，所以最简单的解决办法是从<a href=\"https://www.python.org/downloads/mac-osx/\" target=\"_blank\" rel=\"noopener\">Python官网</a>下载3.6版本的pkg安装，pkg安装的路径是<code>/Library/Frameworks/Python.framework/</code></p>\n<p>移除brew安装的Python</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#移除所有版本Python</span><br><span class=\"line\">brew uninstall --force python</span><br></pre></td></tr></table></figure>"},{"title":"Linux系统使用--用户权限管理","date":"2018-04-11T03:10:12.000Z","_content":"\n## 前言 ##\n\n在`linux/unix`上面执行脚本的时候，通常需要脚本有执行权限，这里记录一下设置权限的方法\n\n<!-- more -->\n\n### chmod 命令 ###\n\n-rw-rw-r-- 权限描述一共十位\n\n\n第一位表示文件类型:-是文件 d是文件夹\n\n第二位到第四位 表示文件拥有者的权限\n\n第五位到第七位 表示同组者的权限\n\n第八位到第十位 表示其他人的权限\n\nr是读权限 w是写权限 x是运行权限\n\n修改权限:\n\n字母法\n\nu文件拥有者 g文件同组者 o其它人\n\n\n```chmod u=rwx 文件名```\n\n```chmod g=w 文件名``` \n\n\n```chmod u=r,g=r,o=r 文件名``` 所有用户都是读权限\n\n```chmod u=,g=,o= 文件名``` 所以用户都没有权限\n\n\n数字法\n\nr---4\nw---2\nx---1\n\n数字的来源就是二进制，三位二进制的各个值\n\n```chmod 137 文件名``` 拥有者是执行权限,同组者是写执行权限,其它人是读写执行权限","source":"_posts/Linux系统使用--用户权限管理.md","raw":"---\ntitle: Linux系统使用--用户权限管理\ndate: 2018-4-11 11:10:12\ntags: [Linux]\n---\n\n## 前言 ##\n\n在`linux/unix`上面执行脚本的时候，通常需要脚本有执行权限，这里记录一下设置权限的方法\n\n<!-- more -->\n\n### chmod 命令 ###\n\n-rw-rw-r-- 权限描述一共十位\n\n\n第一位表示文件类型:-是文件 d是文件夹\n\n第二位到第四位 表示文件拥有者的权限\n\n第五位到第七位 表示同组者的权限\n\n第八位到第十位 表示其他人的权限\n\nr是读权限 w是写权限 x是运行权限\n\n修改权限:\n\n字母法\n\nu文件拥有者 g文件同组者 o其它人\n\n\n```chmod u=rwx 文件名```\n\n```chmod g=w 文件名``` \n\n\n```chmod u=r,g=r,o=r 文件名``` 所有用户都是读权限\n\n```chmod u=,g=,o= 文件名``` 所以用户都没有权限\n\n\n数字法\n\nr---4\nw---2\nx---1\n\n数字的来源就是二进制，三位二进制的各个值\n\n```chmod 137 文件名``` 拥有者是执行权限,同组者是写执行权限,其它人是读写执行权限","slug":"Linux系统使用--用户权限管理","published":1,"updated":"2021-04-12T09:17:38.417Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqjdx1na000g5emuimu2t7nk","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在<code>linux/unix</code>上面执行脚本的时候，通常需要脚本有执行权限，这里记录一下设置权限的方法</p>\n<a id=\"more\"></a>\n<h3 id=\"chmod-命令\"><a href=\"#chmod-命令\" class=\"headerlink\" title=\"chmod 命令\"></a>chmod 命令</h3><p>-rw-rw-r– 权限描述一共十位</p>\n<p>第一位表示文件类型:-是文件 d是文件夹</p>\n<p>第二位到第四位 表示文件拥有者的权限</p>\n<p>第五位到第七位 表示同组者的权限</p>\n<p>第八位到第十位 表示其他人的权限</p>\n<p>r是读权限 w是写权限 x是运行权限</p>\n<p>修改权限:</p>\n<p>字母法</p>\n<p>u文件拥有者 g文件同组者 o其它人</p>\n<p><code>chmod u=rwx 文件名</code></p>\n<p><code>chmod g=w 文件名</code> </p>\n<p><code>chmod u=r,g=r,o=r 文件名</code> 所有用户都是读权限</p>\n<p><code>chmod u=,g=,o= 文件名</code> 所以用户都没有权限</p>\n<p>数字法</p>\n<p>r—4<br>w—2<br>x—1</p>\n<p>数字的来源就是二进制，三位二进制的各个值</p>\n<p><code>chmod 137 文件名</code> 拥有者是执行权限,同组者是写执行权限,其它人是读写执行权限</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在<code>linux/unix</code>上面执行脚本的时候，通常需要脚本有执行权限，这里记录一下设置权限的方法</p>","more":"<h3 id=\"chmod-命令\"><a href=\"#chmod-命令\" class=\"headerlink\" title=\"chmod 命令\"></a>chmod 命令</h3><p>-rw-rw-r– 权限描述一共十位</p>\n<p>第一位表示文件类型:-是文件 d是文件夹</p>\n<p>第二位到第四位 表示文件拥有者的权限</p>\n<p>第五位到第七位 表示同组者的权限</p>\n<p>第八位到第十位 表示其他人的权限</p>\n<p>r是读权限 w是写权限 x是运行权限</p>\n<p>修改权限:</p>\n<p>字母法</p>\n<p>u文件拥有者 g文件同组者 o其它人</p>\n<p><code>chmod u=rwx 文件名</code></p>\n<p><code>chmod g=w 文件名</code> </p>\n<p><code>chmod u=r,g=r,o=r 文件名</code> 所有用户都是读权限</p>\n<p><code>chmod u=,g=,o= 文件名</code> 所以用户都没有权限</p>\n<p>数字法</p>\n<p>r—4<br>w—2<br>x—1</p>\n<p>数字的来源就是二进制，三位二进制的各个值</p>\n<p><code>chmod 137 文件名</code> 拥有者是执行权限,同组者是写执行权限,其它人是读写执行权限</p>"},{"title":"MAC使用密钥登录VPS","date":"2019-02-12T13:30:12.000Z","_content":"\n## 前言 ##\n\n今天登录`VPS`,突然提示如下信息\n\n```\nLast failed login: Tue Feb 12 07:55:56 EST 2019 from 218.92.1.143 on ssh:notty\nThere were 49 failed login attempts since the last successful login.\n```\n\n貌似被别人跑猴子了，所以我就关了密码登录\n\n<!-- more -->\n\n### 使用密钥登录 ###\n\n`MAC`默认是有一个密钥的，没有的话先生成一对\n\n接下运行如下命令：\n\n```\nssh-copy-id root@X.X.X.X\n```\n\n`root`是你VPS的用户名，后面是`IP`\n\n运行完会提示输入`VPS`的密码\n\n如下\n\n```\n/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: \"/Users/xxx/.ssh/id_rsa.pub\"\n/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed\n/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys\nroot@X.X.X.X's password:\n\nNumber of key(s) added:        1\n\nNow try logging into the machine, with:   \"ssh 'root@X.X.X.X'\"\nand check to make sure that only the key(s) you wanted were added.\n```\n\n接下来尝试登录：\n\n```\nssh 'root@X.X.X.X'\n```\n\n没有问题会直接登录成功\n\n### 关闭密码登录 ###\n\n打开`VPS`的`ssh`配置文件\n\n```\nvi /etc/ssh/sshd_config\n```\n\n找到`PasswordAuthentication`改`yes`为`no`,如果没有就手动添加上\n\n然后保存重启`ssh`服务\n\n```\nsystemctl restart sshd.service\n```\n","source":"_posts/MAC使用密钥登录VPS.md","raw":"---\ntitle: MAC使用密钥登录VPS\ndate: 2019-02-12 21:30:12\ntags: [Linux]\n---\n\n## 前言 ##\n\n今天登录`VPS`,突然提示如下信息\n\n```\nLast failed login: Tue Feb 12 07:55:56 EST 2019 from 218.92.1.143 on ssh:notty\nThere were 49 failed login attempts since the last successful login.\n```\n\n貌似被别人跑猴子了，所以我就关了密码登录\n\n<!-- more -->\n\n### 使用密钥登录 ###\n\n`MAC`默认是有一个密钥的，没有的话先生成一对\n\n接下运行如下命令：\n\n```\nssh-copy-id root@X.X.X.X\n```\n\n`root`是你VPS的用户名，后面是`IP`\n\n运行完会提示输入`VPS`的密码\n\n如下\n\n```\n/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: \"/Users/xxx/.ssh/id_rsa.pub\"\n/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed\n/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys\nroot@X.X.X.X's password:\n\nNumber of key(s) added:        1\n\nNow try logging into the machine, with:   \"ssh 'root@X.X.X.X'\"\nand check to make sure that only the key(s) you wanted were added.\n```\n\n接下来尝试登录：\n\n```\nssh 'root@X.X.X.X'\n```\n\n没有问题会直接登录成功\n\n### 关闭密码登录 ###\n\n打开`VPS`的`ssh`配置文件\n\n```\nvi /etc/ssh/sshd_config\n```\n\n找到`PasswordAuthentication`改`yes`为`no`,如果没有就手动添加上\n\n然后保存重启`ssh`服务\n\n```\nsystemctl restart sshd.service\n```\n","slug":"MAC使用密钥登录VPS","published":1,"updated":"2021-04-12T09:17:38.418Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqjdx1nb000i5emukc9e7kzz","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>今天登录<code>VPS</code>,突然提示如下信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Last failed login: Tue Feb 12 07:55:56 EST 2019 from 218.92.1.143 on ssh:notty</span><br><span class=\"line\">There were 49 failed login attempts since the last successful login.</span><br></pre></td></tr></table></figure>\n<p>貌似被别人跑猴子了，所以我就关了密码登录</p>\n<a id=\"more\"></a>\n<h3 id=\"使用密钥登录\"><a href=\"#使用密钥登录\" class=\"headerlink\" title=\"使用密钥登录\"></a>使用密钥登录</h3><p><code>MAC</code>默认是有一个密钥的，没有的话先生成一对</p>\n<p>接下运行如下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-copy-id root@X.X.X.X</span><br></pre></td></tr></table></figure>\n<p><code>root</code>是你VPS的用户名，后面是<code>IP</code></p>\n<p>运行完会提示输入<code>VPS</code>的密码</p>\n<p>如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: &quot;/Users/xxx/.ssh/id_rsa.pub&quot;</span><br><span class=\"line\">/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed</span><br><span class=\"line\">/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys</span><br><span class=\"line\">root@X.X.X.X&apos;s password:</span><br><span class=\"line\"></span><br><span class=\"line\">Number of key(s) added:        1</span><br><span class=\"line\"></span><br><span class=\"line\">Now try logging into the machine, with:   &quot;ssh &apos;root@X.X.X.X&apos;&quot;</span><br><span class=\"line\">and check to make sure that only the key(s) you wanted were added.</span><br></pre></td></tr></table></figure>\n<p>接下来尝试登录：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh &apos;root@X.X.X.X&apos;</span><br></pre></td></tr></table></figure>\n<p>没有问题会直接登录成功</p>\n<h3 id=\"关闭密码登录\"><a href=\"#关闭密码登录\" class=\"headerlink\" title=\"关闭密码登录\"></a>关闭密码登录</h3><p>打开<code>VPS</code>的<code>ssh</code>配置文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure>\n<p>找到<code>PasswordAuthentication</code>改<code>yes</code>为<code>no</code>,如果没有就手动添加上</p>\n<p>然后保存重启<code>ssh</code>服务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl restart sshd.service</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>今天登录<code>VPS</code>,突然提示如下信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Last failed login: Tue Feb 12 07:55:56 EST 2019 from 218.92.1.143 on ssh:notty</span><br><span class=\"line\">There were 49 failed login attempts since the last successful login.</span><br></pre></td></tr></table></figure>\n<p>貌似被别人跑猴子了，所以我就关了密码登录</p>","more":"<h3 id=\"使用密钥登录\"><a href=\"#使用密钥登录\" class=\"headerlink\" title=\"使用密钥登录\"></a>使用密钥登录</h3><p><code>MAC</code>默认是有一个密钥的，没有的话先生成一对</p>\n<p>接下运行如下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-copy-id root@X.X.X.X</span><br></pre></td></tr></table></figure>\n<p><code>root</code>是你VPS的用户名，后面是<code>IP</code></p>\n<p>运行完会提示输入<code>VPS</code>的密码</p>\n<p>如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: &quot;/Users/xxx/.ssh/id_rsa.pub&quot;</span><br><span class=\"line\">/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed</span><br><span class=\"line\">/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys</span><br><span class=\"line\">root@X.X.X.X&apos;s password:</span><br><span class=\"line\"></span><br><span class=\"line\">Number of key(s) added:        1</span><br><span class=\"line\"></span><br><span class=\"line\">Now try logging into the machine, with:   &quot;ssh &apos;root@X.X.X.X&apos;&quot;</span><br><span class=\"line\">and check to make sure that only the key(s) you wanted were added.</span><br></pre></td></tr></table></figure>\n<p>接下来尝试登录：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh &apos;root@X.X.X.X&apos;</span><br></pre></td></tr></table></figure>\n<p>没有问题会直接登录成功</p>\n<h3 id=\"关闭密码登录\"><a href=\"#关闭密码登录\" class=\"headerlink\" title=\"关闭密码登录\"></a>关闭密码登录</h3><p>打开<code>VPS</code>的<code>ssh</code>配置文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure>\n<p>找到<code>PasswordAuthentication</code>改<code>yes</code>为<code>no</code>,如果没有就手动添加上</p>\n<p>然后保存重启<code>ssh</code>服务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl restart sshd.service</span><br></pre></td></tr></table></figure>"},{"title":"Mac下打造属于你自己的终端","date":"2018-03-16T14:46:17.000Z","_content":"\n## item2的自定义样式 ##\n\n让你的终端用上主题\n\n<!-- more -->\n\n### 准备工具 ###\n\n1. item2\n\n\titem2是Mac下超好用的一款终端产品,而且是免费的,你可以[点击这里](http://www.iterm2.com/) 下载到.\n\n2. oh-my-zsh\n\t\n\toh-my-zsh是一个管理自己zsh的工具,可以方便得管理自己的item2样式主题\n\t\n3. Powerline (可选)\n\n\tPowerline是一个字体补丁,不安装有可能出现乱码,但不是所有的主题都需要\n\t\n\t\n### 安装过程 ###\n\n#### 安装oh-my-zsh ####\n\n首先下载item2,从上面的官网点击`download`,然后解压下载下来的解压包,拷贝到应用程序中,item2就安装完成了\n\n接着安装oh-my-zsh,直接在终端输入下面的命令\n\n```\ncurl -L https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh | sh\n```\n\n如果想要卸载oh-my-zsh需要在终端输入下面的命令\n\n```\nuninstall_oh_my_zsh \n```\n\noh-my-zsh安装完成会有如下提示:\n\n```\nPlease look over the ~/.zshrc file to select plugins, themes, and options.\n```\n\n此时你的oh-my-zsh就安装完成了\n\n关掉你的item2然后再重新启动一下看看,样子是不是已经发生变化了\n\n#### 配置oh-my-zsh ####\n\noh-my-zsh安装完成会有一个默认主题的,上面重启之后看到的主题就是默认的主题,下面我们配置一下自定义主题\n\n\n安装完成后在你的用户目录下面(就是通常的```~```下面)会多出来一些和zsh相关的文件夹和文件\n\n`.oh-my-zsh`这个文件夹里面存放着oh-my-zsh的主题文件夹`themes`,配置模板`templates`,字体文件夹`plugins`,日志`log`,库`lib`,工具`tools`等\n\n`.zshrc`这个文件是`oh-my-zsh`的配置文件\n\n好知道了这些就可以更换主题了:\n\n1. 创建一个zsh配置文件到`~`目录\n\n\t使用`cp`命令拷贝`~/.oh-my-zsh/templates/zshrc.zsh-template`这个文件到`~/.zshrc`\n\t\n\t输入:\n\t\n\t```\n\tcp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc\n\t```\n\t\n\t注意: 如果你的`~/.zshrc`存在,最好使用下面命令备份一下\n\t\n\t```\n\tcp ~/.zshrc ~/.zshrc.orig\n\t```\n\t\n2. 设置zsh为默认的shell\n\n\t输入:\n\t\n\t```\n\tchsh -s /bin/zsh\n\t```\n\t\n3. 查看主题\n\n\t到主题文件夹目录中选一个主题\n\t\n\t输入:\n\t\n\t```\n\tcd ~/.oh-my-zsh/themes\n\t```\n\t\n\t查看并选择一个想要设置的主题\n\t\n4. 修改配置文件\n\t\n\t用vim打开oh-my-zsh的配置文件,修改主题名字\n\t\n\t输入:\n\t\n\t```\n\tvim ~/.zshrc\n\t```\n\t\n\t修改`ZSH_THEME=\"xxx\"`一行引号中的内容为想要设置的主题名字,保存退出,重启item2.\n\t\n\t\n\t附录:\n\t\n\t想知道每个主题的样式可以点击这里,[官方对照表](https://github.com/robbyrussell/oh-my-zsh/wiki/themes)\n\t\n\t如果有自己下载的主题也可以放到`~/.oh-my-zsh/themes`中然后按照上面的方法设置\n\t\n\t如果有的主题显示乱码,就需要上面的字体补丁,安装方法\n\t\n\t输入:\n\t\n\t```\n\tpip install powerline-status\n\t```\n\t\n\t如果提示:\n\t\n\t```\n\tzsh: command not found: pip\n\t```\n\t\n\t则先安装pip,输入:\n\t\n\t```\n\tsudo easy_install pip\n\t```\n\n\n\n\n\n\n\n\n\n\n\n\t\n\n\n  ","source":"_posts/Mac下打造属于你自己的终端.md","raw":"---\ntitle: Mac下打造属于你自己的终端\ndate: 2018-03-16 22:46:17\ntags: Linux\n---\n\n## item2的自定义样式 ##\n\n让你的终端用上主题\n\n<!-- more -->\n\n### 准备工具 ###\n\n1. item2\n\n\titem2是Mac下超好用的一款终端产品,而且是免费的,你可以[点击这里](http://www.iterm2.com/) 下载到.\n\n2. oh-my-zsh\n\t\n\toh-my-zsh是一个管理自己zsh的工具,可以方便得管理自己的item2样式主题\n\t\n3. Powerline (可选)\n\n\tPowerline是一个字体补丁,不安装有可能出现乱码,但不是所有的主题都需要\n\t\n\t\n### 安装过程 ###\n\n#### 安装oh-my-zsh ####\n\n首先下载item2,从上面的官网点击`download`,然后解压下载下来的解压包,拷贝到应用程序中,item2就安装完成了\n\n接着安装oh-my-zsh,直接在终端输入下面的命令\n\n```\ncurl -L https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh | sh\n```\n\n如果想要卸载oh-my-zsh需要在终端输入下面的命令\n\n```\nuninstall_oh_my_zsh \n```\n\noh-my-zsh安装完成会有如下提示:\n\n```\nPlease look over the ~/.zshrc file to select plugins, themes, and options.\n```\n\n此时你的oh-my-zsh就安装完成了\n\n关掉你的item2然后再重新启动一下看看,样子是不是已经发生变化了\n\n#### 配置oh-my-zsh ####\n\noh-my-zsh安装完成会有一个默认主题的,上面重启之后看到的主题就是默认的主题,下面我们配置一下自定义主题\n\n\n安装完成后在你的用户目录下面(就是通常的```~```下面)会多出来一些和zsh相关的文件夹和文件\n\n`.oh-my-zsh`这个文件夹里面存放着oh-my-zsh的主题文件夹`themes`,配置模板`templates`,字体文件夹`plugins`,日志`log`,库`lib`,工具`tools`等\n\n`.zshrc`这个文件是`oh-my-zsh`的配置文件\n\n好知道了这些就可以更换主题了:\n\n1. 创建一个zsh配置文件到`~`目录\n\n\t使用`cp`命令拷贝`~/.oh-my-zsh/templates/zshrc.zsh-template`这个文件到`~/.zshrc`\n\t\n\t输入:\n\t\n\t```\n\tcp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc\n\t```\n\t\n\t注意: 如果你的`~/.zshrc`存在,最好使用下面命令备份一下\n\t\n\t```\n\tcp ~/.zshrc ~/.zshrc.orig\n\t```\n\t\n2. 设置zsh为默认的shell\n\n\t输入:\n\t\n\t```\n\tchsh -s /bin/zsh\n\t```\n\t\n3. 查看主题\n\n\t到主题文件夹目录中选一个主题\n\t\n\t输入:\n\t\n\t```\n\tcd ~/.oh-my-zsh/themes\n\t```\n\t\n\t查看并选择一个想要设置的主题\n\t\n4. 修改配置文件\n\t\n\t用vim打开oh-my-zsh的配置文件,修改主题名字\n\t\n\t输入:\n\t\n\t```\n\tvim ~/.zshrc\n\t```\n\t\n\t修改`ZSH_THEME=\"xxx\"`一行引号中的内容为想要设置的主题名字,保存退出,重启item2.\n\t\n\t\n\t附录:\n\t\n\t想知道每个主题的样式可以点击这里,[官方对照表](https://github.com/robbyrussell/oh-my-zsh/wiki/themes)\n\t\n\t如果有自己下载的主题也可以放到`~/.oh-my-zsh/themes`中然后按照上面的方法设置\n\t\n\t如果有的主题显示乱码,就需要上面的字体补丁,安装方法\n\t\n\t输入:\n\t\n\t```\n\tpip install powerline-status\n\t```\n\t\n\t如果提示:\n\t\n\t```\n\tzsh: command not found: pip\n\t```\n\t\n\t则先安装pip,输入:\n\t\n\t```\n\tsudo easy_install pip\n\t```\n\n\n\n\n\n\n\n\n\n\n\n\t\n\n\n  ","slug":"Mac下打造属于你自己的终端","published":1,"updated":"2021-04-12T09:17:38.418Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqjdx1nd000k5emur02dejxt","content":"<h2 id=\"item2的自定义样式\"><a href=\"#item2的自定义样式\" class=\"headerlink\" title=\"item2的自定义样式\"></a>item2的自定义样式</h2><p>让你的终端用上主题</p>\n<a id=\"more\"></a>\n<h3 id=\"准备工具\"><a href=\"#准备工具\" class=\"headerlink\" title=\"准备工具\"></a>准备工具</h3><ol>\n<li><p>item2</p>\n<p> item2是Mac下超好用的一款终端产品,而且是免费的,你可以<a href=\"http://www.iterm2.com/\" target=\"_blank\" rel=\"noopener\">点击这里</a> 下载到.</p>\n</li>\n<li><p>oh-my-zsh</p>\n<p> oh-my-zsh是一个管理自己zsh的工具,可以方便得管理自己的item2样式主题</p>\n</li>\n<li><p>Powerline (可选)</p>\n<p> Powerline是一个字体补丁,不安装有可能出现乱码,但不是所有的主题都需要</p>\n</li>\n</ol>\n<h3 id=\"安装过程\"><a href=\"#安装过程\" class=\"headerlink\" title=\"安装过程\"></a>安装过程</h3><h4 id=\"安装oh-my-zsh\"><a href=\"#安装oh-my-zsh\" class=\"headerlink\" title=\"安装oh-my-zsh\"></a>安装oh-my-zsh</h4><p>首先下载item2,从上面的官网点击<code>download</code>,然后解压下载下来的解压包,拷贝到应用程序中,item2就安装完成了</p>\n<p>接着安装oh-my-zsh,直接在终端输入下面的命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -L https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh | sh</span><br></pre></td></tr></table></figure>\n<p>如果想要卸载oh-my-zsh需要在终端输入下面的命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uninstall_oh_my_zsh</span><br></pre></td></tr></table></figure>\n<p>oh-my-zsh安装完成会有如下提示:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Please look over the ~/.zshrc file to select plugins, themes, and options.</span><br></pre></td></tr></table></figure>\n<p>此时你的oh-my-zsh就安装完成了</p>\n<p>关掉你的item2然后再重新启动一下看看,样子是不是已经发生变化了</p>\n<h4 id=\"配置oh-my-zsh\"><a href=\"#配置oh-my-zsh\" class=\"headerlink\" title=\"配置oh-my-zsh\"></a>配置oh-my-zsh</h4><p>oh-my-zsh安装完成会有一个默认主题的,上面重启之后看到的主题就是默认的主题,下面我们配置一下自定义主题</p>\n<p>安装完成后在你的用户目录下面(就是通常的<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">`.oh-my-zsh`这个文件夹里面存放着oh-my-zsh的主题文件夹`themes`,配置模板`templates`,字体文件夹`plugins`,日志`log`,库`lib`,工具`tools`等</span><br><span class=\"line\"></span><br><span class=\"line\">`.zshrc`这个文件是`oh-my-zsh`的配置文件</span><br><span class=\"line\"></span><br><span class=\"line\">好知道了这些就可以更换主题了:</span><br><span class=\"line\"></span><br><span class=\"line\">1. 创建一个zsh配置文件到`~`目录</span><br><span class=\"line\"></span><br><span class=\"line\">\t使用`cp`命令拷贝`~/.oh-my-zsh/templates/zshrc.zsh-template`这个文件到`~/.zshrc`</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t输入:</span><br></pre></td></tr></table></figure></p>\n<pre><code>cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">注意: 如果你的`~/.zshrc`存在,最好使用下面命令备份一下</span><br></pre></td></tr></table></figure>\n\ncp ~/.zshrc ~/.zshrc.orig\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t</span><br><span class=\"line\">2. 设置zsh为默认的shell</span><br><span class=\"line\"></span><br><span class=\"line\">\t输入:</span><br></pre></td></tr></table></figure>\n\nchsh -s /bin/zsh\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t</span><br><span class=\"line\">3. 查看主题</span><br><span class=\"line\"></span><br><span class=\"line\">\t到主题文件夹目录中选一个主题</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t输入:</span><br></pre></td></tr></table></figure>\n\ncd ~/.oh-my-zsh/themes\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t</span><br><span class=\"line\">\t查看并选择一个想要设置的主题</span><br><span class=\"line\">\t</span><br><span class=\"line\">4. 修改配置文件</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t用vim打开oh-my-zsh的配置文件,修改主题名字</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t输入:</span><br></pre></td></tr></table></figure>\n\nvim ~/.zshrc\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">修改`ZSH_THEME=&quot;xxx&quot;`一行引号中的内容为想要设置的主题名字,保存退出,重启item2.</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">附录:</span><br><span class=\"line\"></span><br><span class=\"line\">想知道每个主题的样式可以点击这里,[官方对照表](https://github.com/robbyrussell/oh-my-zsh/wiki/themes)</span><br><span class=\"line\"></span><br><span class=\"line\">如果有自己下载的主题也可以放到`~/.oh-my-zsh/themes`中然后按照上面的方法设置</span><br><span class=\"line\"></span><br><span class=\"line\">如果有的主题显示乱码,就需要上面的字体补丁,安装方法</span><br><span class=\"line\"></span><br><span class=\"line\">输入:</span><br></pre></td></tr></table></figure>\n\npip install powerline-status\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">如果提示:</span><br></pre></td></tr></table></figure>\n\nzsh: command not found: pip\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">则先安装pip,输入:</span><br></pre></td></tr></table></figure>\n\nsudo easy_install pip\n```\n</code></pre>","site":{"data":{}},"excerpt":"<h2 id=\"item2的自定义样式\"><a href=\"#item2的自定义样式\" class=\"headerlink\" title=\"item2的自定义样式\"></a>item2的自定义样式</h2><p>让你的终端用上主题</p>","more":"<h3 id=\"准备工具\"><a href=\"#准备工具\" class=\"headerlink\" title=\"准备工具\"></a>准备工具</h3><ol>\n<li><p>item2</p>\n<p> item2是Mac下超好用的一款终端产品,而且是免费的,你可以<a href=\"http://www.iterm2.com/\" target=\"_blank\" rel=\"noopener\">点击这里</a> 下载到.</p>\n</li>\n<li><p>oh-my-zsh</p>\n<p> oh-my-zsh是一个管理自己zsh的工具,可以方便得管理自己的item2样式主题</p>\n</li>\n<li><p>Powerline (可选)</p>\n<p> Powerline是一个字体补丁,不安装有可能出现乱码,但不是所有的主题都需要</p>\n</li>\n</ol>\n<h3 id=\"安装过程\"><a href=\"#安装过程\" class=\"headerlink\" title=\"安装过程\"></a>安装过程</h3><h4 id=\"安装oh-my-zsh\"><a href=\"#安装oh-my-zsh\" class=\"headerlink\" title=\"安装oh-my-zsh\"></a>安装oh-my-zsh</h4><p>首先下载item2,从上面的官网点击<code>download</code>,然后解压下载下来的解压包,拷贝到应用程序中,item2就安装完成了</p>\n<p>接着安装oh-my-zsh,直接在终端输入下面的命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -L https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh | sh</span><br></pre></td></tr></table></figure>\n<p>如果想要卸载oh-my-zsh需要在终端输入下面的命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uninstall_oh_my_zsh</span><br></pre></td></tr></table></figure>\n<p>oh-my-zsh安装完成会有如下提示:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Please look over the ~/.zshrc file to select plugins, themes, and options.</span><br></pre></td></tr></table></figure>\n<p>此时你的oh-my-zsh就安装完成了</p>\n<p>关掉你的item2然后再重新启动一下看看,样子是不是已经发生变化了</p>\n<h4 id=\"配置oh-my-zsh\"><a href=\"#配置oh-my-zsh\" class=\"headerlink\" title=\"配置oh-my-zsh\"></a>配置oh-my-zsh</h4><p>oh-my-zsh安装完成会有一个默认主题的,上面重启之后看到的主题就是默认的主题,下面我们配置一下自定义主题</p>\n<p>安装完成后在你的用户目录下面(就是通常的<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">`.oh-my-zsh`这个文件夹里面存放着oh-my-zsh的主题文件夹`themes`,配置模板`templates`,字体文件夹`plugins`,日志`log`,库`lib`,工具`tools`等</span><br><span class=\"line\"></span><br><span class=\"line\">`.zshrc`这个文件是`oh-my-zsh`的配置文件</span><br><span class=\"line\"></span><br><span class=\"line\">好知道了这些就可以更换主题了:</span><br><span class=\"line\"></span><br><span class=\"line\">1. 创建一个zsh配置文件到`~`目录</span><br><span class=\"line\"></span><br><span class=\"line\">\t使用`cp`命令拷贝`~/.oh-my-zsh/templates/zshrc.zsh-template`这个文件到`~/.zshrc`</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t输入:</span><br></pre></td></tr></table></figure></p>\n<pre><code>cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">注意: 如果你的`~/.zshrc`存在,最好使用下面命令备份一下</span><br></pre></td></tr></table></figure>\n\ncp ~/.zshrc ~/.zshrc.orig\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t</span><br><span class=\"line\">2. 设置zsh为默认的shell</span><br><span class=\"line\"></span><br><span class=\"line\">\t输入:</span><br></pre></td></tr></table></figure>\n\nchsh -s /bin/zsh\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t</span><br><span class=\"line\">3. 查看主题</span><br><span class=\"line\"></span><br><span class=\"line\">\t到主题文件夹目录中选一个主题</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t输入:</span><br></pre></td></tr></table></figure>\n\ncd ~/.oh-my-zsh/themes\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t</span><br><span class=\"line\">\t查看并选择一个想要设置的主题</span><br><span class=\"line\">\t</span><br><span class=\"line\">4. 修改配置文件</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t用vim打开oh-my-zsh的配置文件,修改主题名字</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t输入:</span><br></pre></td></tr></table></figure>\n\nvim ~/.zshrc\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">修改`ZSH_THEME=&quot;xxx&quot;`一行引号中的内容为想要设置的主题名字,保存退出,重启item2.</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">附录:</span><br><span class=\"line\"></span><br><span class=\"line\">想知道每个主题的样式可以点击这里,[官方对照表](https://github.com/robbyrussell/oh-my-zsh/wiki/themes)</span><br><span class=\"line\"></span><br><span class=\"line\">如果有自己下载的主题也可以放到`~/.oh-my-zsh/themes`中然后按照上面的方法设置</span><br><span class=\"line\"></span><br><span class=\"line\">如果有的主题显示乱码,就需要上面的字体补丁,安装方法</span><br><span class=\"line\"></span><br><span class=\"line\">输入:</span><br></pre></td></tr></table></figure>\n\npip install powerline-status\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">如果提示:</span><br></pre></td></tr></table></figure>\n\nzsh: command not found: pip\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">则先安装pip,输入:</span><br></pre></td></tr></table></figure>\n\nsudo easy_install pip\n```\n</code></pre>"},{"title":"Mac软件--Keyboard Maestro","date":"2019-06-29T03:02:30.000Z","_content":"\n## 前言 ##\n\n平时不使用电脑的时候，通常是让电脑睡眠，而不是关机，但是当电脑屏幕太大的时候，左上角的小苹果就不是那么容易点到了，每次都要先找到鼠标，然后去左上角让电脑睡眠，这么操作台麻烦了，所以要是睡眠有快捷键，就会方便很多了\n\n<!-- more -->\n\n### 安装 ###\n\n下载好软件安装即可\n\n### 设置 ###\n\n* 打开程序，在`Macros`栏，点击加号添加一个事件\n* 在右边的设置中输入事件名称\n* 点击`New Trigger`,选择`Hot Key Trigger`\n* `Type`中输入需要设置的事件对应的按键\n* 在下面`Will execute the following actions`中选择对应的事件\n\n\n","source":"_posts/Mac软件--Keyboard Maestro.md","raw":"---\ntitle: Mac软件--Keyboard Maestro\ndate: 2019-6-29 11:02:30\ntags: [Mac软件]\n---\n\n## 前言 ##\n\n平时不使用电脑的时候，通常是让电脑睡眠，而不是关机，但是当电脑屏幕太大的时候，左上角的小苹果就不是那么容易点到了，每次都要先找到鼠标，然后去左上角让电脑睡眠，这么操作台麻烦了，所以要是睡眠有快捷键，就会方便很多了\n\n<!-- more -->\n\n### 安装 ###\n\n下载好软件安装即可\n\n### 设置 ###\n\n* 打开程序，在`Macros`栏，点击加号添加一个事件\n* 在右边的设置中输入事件名称\n* 点击`New Trigger`,选择`Hot Key Trigger`\n* `Type`中输入需要设置的事件对应的按键\n* 在下面`Will execute the following actions`中选择对应的事件\n\n\n","slug":"Mac软件--Keyboard Maestro","published":1,"updated":"2021-04-12T09:17:38.418Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqjdx1ne000n5emucw5scefh","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>平时不使用电脑的时候，通常是让电脑睡眠，而不是关机，但是当电脑屏幕太大的时候，左上角的小苹果就不是那么容易点到了，每次都要先找到鼠标，然后去左上角让电脑睡眠，这么操作台麻烦了，所以要是睡眠有快捷键，就会方便很多了</p>\n<a id=\"more\"></a>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>下载好软件安装即可</p>\n<h3 id=\"设置\"><a href=\"#设置\" class=\"headerlink\" title=\"设置\"></a>设置</h3><ul>\n<li>打开程序，在<code>Macros</code>栏，点击加号添加一个事件</li>\n<li>在右边的设置中输入事件名称</li>\n<li>点击<code>New Trigger</code>,选择<code>Hot Key Trigger</code></li>\n<li><code>Type</code>中输入需要设置的事件对应的按键</li>\n<li>在下面<code>Will execute the following actions</code>中选择对应的事件</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>平时不使用电脑的时候，通常是让电脑睡眠，而不是关机，但是当电脑屏幕太大的时候，左上角的小苹果就不是那么容易点到了，每次都要先找到鼠标，然后去左上角让电脑睡眠，这么操作台麻烦了，所以要是睡眠有快捷键，就会方便很多了</p>","more":"<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>下载好软件安装即可</p>\n<h3 id=\"设置\"><a href=\"#设置\" class=\"headerlink\" title=\"设置\"></a>设置</h3><ul>\n<li>打开程序，在<code>Macros</code>栏，点击加号添加一个事件</li>\n<li>在右边的设置中输入事件名称</li>\n<li>点击<code>New Trigger</code>,选择<code>Hot Key Trigger</code></li>\n<li><code>Type</code>中输入需要设置的事件对应的按键</li>\n<li>在下面<code>Will execute the following actions</code>中选择对应的事件</li>\n</ul>"},{"title":"OC使用静态库中的类别","date":"2017-06-05T12:02:30.000Z","_content":"\n## OC中使用静态库中的类别的问题 ##\n\nOC的源文件经过 `clang` 编译首先生成中间代码,接着通过优化生成目标代码(目标代码中包括符号表,标示了此代码中的全局符号和静态符号,还标示了导入符号等),连接器会根据符号表分析各个目标代码之间的调用关系,然后将使用到的代码进行连接和重定位,最后生成可执行文件.\n\n在编译Objective-C源文件到目标文件时,编译器并不知道方法的对应实现,只能在运行时才知道,所以编译器只会为类生成连接符号,不会对类中的方法生成连接符号,由于Category方法并不对应一个新类,所以不会生成连接符号,连接器也不会将Category方法合并到原始的类中,最终导致连接器忽略了Category方法,不会将其连接到可执行文件中.\n\n\n> 在OC使用静态库中的类别,需要设置下面5种方法中的一种\n\n\n## Other Linker Flags 设置 ##\n\n* 1.通过在Other Linder Flags 添加 `-all\\_load` 它会告诉编译器对”所有文档中的所有对象文件,不管里面的符号有没有被用到,全部都载入”,这样会产生比较大的二进制文件\n\n* 2.通过在Other Linder Flags 添加 `-force\\_load 和指定路径` e.g: `-force\\_load $(SRCROOT)/RHAddressBook/libRHAddressBook.a` 这种方法会只载入指定的归档\n\n* 3.通过在Other Linder Flags 添加 `-ObjC` ,这个标识告诉编译器”如果在文档中发现了OC代码,就把文档载入” \n\n* 4.在Xcode里build setting中的 Perform Single-Object PreLink，如果启用这个选项，所有的对象文件都会被合并成一个单文件（这不是真正的链接，所以叫做预链接），这个对象文件（有时被称做主对象文件(master object file)）被添加到文档中。现在如果主对象文件中的任何符号被认为是“在使用”，整个主对象文件都会被认为在使用，这样它里面的OC部分就会被载入了。因为里面的类都被正常符号化了，所以能使从这样的静态库中使用所有的Category\n\n* 5.最后一种解决方法是在只有Category的源文件里添加Fake symbol。如果你想在运行时使用Category，一定要确保你以某种方法在编译时引用了fake symbol，这会使得对象文件以及它里面的OC代码被载入。例如，它可以是一个有空函数体的函数，也可以是一个被访问的全局变量（例如一个全局的int变量，只要它被读或者写了一次就足够了）。和上面其他的解决方法不一样，这种解决方法可以控制哪些category可以在运行时被编译后的代码使用（可以通过使用这个符号，使它们被链接并变得可用；也可以不使用这个符号，这样链接器就会忽略它）\n","source":"_posts/OC使用静态库中的类别.md","raw":"---\ntitle: OC使用静态库中的类别\ndate: 2017-06-05 20:02:30\ntags: iOS\n---\n\n## OC中使用静态库中的类别的问题 ##\n\nOC的源文件经过 `clang` 编译首先生成中间代码,接着通过优化生成目标代码(目标代码中包括符号表,标示了此代码中的全局符号和静态符号,还标示了导入符号等),连接器会根据符号表分析各个目标代码之间的调用关系,然后将使用到的代码进行连接和重定位,最后生成可执行文件.\n\n在编译Objective-C源文件到目标文件时,编译器并不知道方法的对应实现,只能在运行时才知道,所以编译器只会为类生成连接符号,不会对类中的方法生成连接符号,由于Category方法并不对应一个新类,所以不会生成连接符号,连接器也不会将Category方法合并到原始的类中,最终导致连接器忽略了Category方法,不会将其连接到可执行文件中.\n\n\n> 在OC使用静态库中的类别,需要设置下面5种方法中的一种\n\n\n## Other Linker Flags 设置 ##\n\n* 1.通过在Other Linder Flags 添加 `-all\\_load` 它会告诉编译器对”所有文档中的所有对象文件,不管里面的符号有没有被用到,全部都载入”,这样会产生比较大的二进制文件\n\n* 2.通过在Other Linder Flags 添加 `-force\\_load 和指定路径` e.g: `-force\\_load $(SRCROOT)/RHAddressBook/libRHAddressBook.a` 这种方法会只载入指定的归档\n\n* 3.通过在Other Linder Flags 添加 `-ObjC` ,这个标识告诉编译器”如果在文档中发现了OC代码,就把文档载入” \n\n* 4.在Xcode里build setting中的 Perform Single-Object PreLink，如果启用这个选项，所有的对象文件都会被合并成一个单文件（这不是真正的链接，所以叫做预链接），这个对象文件（有时被称做主对象文件(master object file)）被添加到文档中。现在如果主对象文件中的任何符号被认为是“在使用”，整个主对象文件都会被认为在使用，这样它里面的OC部分就会被载入了。因为里面的类都被正常符号化了，所以能使从这样的静态库中使用所有的Category\n\n* 5.最后一种解决方法是在只有Category的源文件里添加Fake symbol。如果你想在运行时使用Category，一定要确保你以某种方法在编译时引用了fake symbol，这会使得对象文件以及它里面的OC代码被载入。例如，它可以是一个有空函数体的函数，也可以是一个被访问的全局变量（例如一个全局的int变量，只要它被读或者写了一次就足够了）。和上面其他的解决方法不一样，这种解决方法可以控制哪些category可以在运行时被编译后的代码使用（可以通过使用这个符号，使它们被链接并变得可用；也可以不使用这个符号，这样链接器就会忽略它）\n","slug":"OC使用静态库中的类别","published":1,"updated":"2021-04-12T09:17:38.418Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqjdx1nf000o5emupdl735va","content":"<h2 id=\"OC中使用静态库中的类别的问题\"><a href=\"#OC中使用静态库中的类别的问题\" class=\"headerlink\" title=\"OC中使用静态库中的类别的问题\"></a>OC中使用静态库中的类别的问题</h2><p>OC的源文件经过 <code>clang</code> 编译首先生成中间代码,接着通过优化生成目标代码(目标代码中包括符号表,标示了此代码中的全局符号和静态符号,还标示了导入符号等),连接器会根据符号表分析各个目标代码之间的调用关系,然后将使用到的代码进行连接和重定位,最后生成可执行文件.</p>\n<p>在编译Objective-C源文件到目标文件时,编译器并不知道方法的对应实现,只能在运行时才知道,所以编译器只会为类生成连接符号,不会对类中的方法生成连接符号,由于Category方法并不对应一个新类,所以不会生成连接符号,连接器也不会将Category方法合并到原始的类中,最终导致连接器忽略了Category方法,不会将其连接到可执行文件中.</p>\n<blockquote>\n<p>在OC使用静态库中的类别,需要设置下面5种方法中的一种</p>\n</blockquote>\n<h2 id=\"Other-Linker-Flags-设置\"><a href=\"#Other-Linker-Flags-设置\" class=\"headerlink\" title=\"Other Linker Flags 设置\"></a>Other Linker Flags 设置</h2><ul>\n<li><p>1.通过在Other Linder Flags 添加 <code>-all\\_load</code> 它会告诉编译器对”所有文档中的所有对象文件,不管里面的符号有没有被用到,全部都载入”,这样会产生比较大的二进制文件</p>\n</li>\n<li><p>2.通过在Other Linder Flags 添加 <code>-force\\_load 和指定路径</code> e.g: <code>-force\\_load $(SRCROOT)/RHAddressBook/libRHAddressBook.a</code> 这种方法会只载入指定的归档</p>\n</li>\n<li><p>3.通过在Other Linder Flags 添加 <code>-ObjC</code> ,这个标识告诉编译器”如果在文档中发现了OC代码,就把文档载入” </p>\n</li>\n<li><p>4.在Xcode里build setting中的 Perform Single-Object PreLink，如果启用这个选项，所有的对象文件都会被合并成一个单文件（这不是真正的链接，所以叫做预链接），这个对象文件（有时被称做主对象文件(master object file)）被添加到文档中。现在如果主对象文件中的任何符号被认为是“在使用”，整个主对象文件都会被认为在使用，这样它里面的OC部分就会被载入了。因为里面的类都被正常符号化了，所以能使从这样的静态库中使用所有的Category</p>\n</li>\n<li><p>5.最后一种解决方法是在只有Category的源文件里添加Fake symbol。如果你想在运行时使用Category，一定要确保你以某种方法在编译时引用了fake symbol，这会使得对象文件以及它里面的OC代码被载入。例如，它可以是一个有空函数体的函数，也可以是一个被访问的全局变量（例如一个全局的int变量，只要它被读或者写了一次就足够了）。和上面其他的解决方法不一样，这种解决方法可以控制哪些category可以在运行时被编译后的代码使用（可以通过使用这个符号，使它们被链接并变得可用；也可以不使用这个符号，这样链接器就会忽略它）</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"OC中使用静态库中的类别的问题\"><a href=\"#OC中使用静态库中的类别的问题\" class=\"headerlink\" title=\"OC中使用静态库中的类别的问题\"></a>OC中使用静态库中的类别的问题</h2><p>OC的源文件经过 <code>clang</code> 编译首先生成中间代码,接着通过优化生成目标代码(目标代码中包括符号表,标示了此代码中的全局符号和静态符号,还标示了导入符号等),连接器会根据符号表分析各个目标代码之间的调用关系,然后将使用到的代码进行连接和重定位,最后生成可执行文件.</p>\n<p>在编译Objective-C源文件到目标文件时,编译器并不知道方法的对应实现,只能在运行时才知道,所以编译器只会为类生成连接符号,不会对类中的方法生成连接符号,由于Category方法并不对应一个新类,所以不会生成连接符号,连接器也不会将Category方法合并到原始的类中,最终导致连接器忽略了Category方法,不会将其连接到可执行文件中.</p>\n<blockquote>\n<p>在OC使用静态库中的类别,需要设置下面5种方法中的一种</p>\n</blockquote>\n<h2 id=\"Other-Linker-Flags-设置\"><a href=\"#Other-Linker-Flags-设置\" class=\"headerlink\" title=\"Other Linker Flags 设置\"></a>Other Linker Flags 设置</h2><ul>\n<li><p>1.通过在Other Linder Flags 添加 <code>-all\\_load</code> 它会告诉编译器对”所有文档中的所有对象文件,不管里面的符号有没有被用到,全部都载入”,这样会产生比较大的二进制文件</p>\n</li>\n<li><p>2.通过在Other Linder Flags 添加 <code>-force\\_load 和指定路径</code> e.g: <code>-force\\_load $(SRCROOT)/RHAddressBook/libRHAddressBook.a</code> 这种方法会只载入指定的归档</p>\n</li>\n<li><p>3.通过在Other Linder Flags 添加 <code>-ObjC</code> ,这个标识告诉编译器”如果在文档中发现了OC代码,就把文档载入” </p>\n</li>\n<li><p>4.在Xcode里build setting中的 Perform Single-Object PreLink，如果启用这个选项，所有的对象文件都会被合并成一个单文件（这不是真正的链接，所以叫做预链接），这个对象文件（有时被称做主对象文件(master object file)）被添加到文档中。现在如果主对象文件中的任何符号被认为是“在使用”，整个主对象文件都会被认为在使用，这样它里面的OC部分就会被载入了。因为里面的类都被正常符号化了，所以能使从这样的静态库中使用所有的Category</p>\n</li>\n<li><p>5.最后一种解决方法是在只有Category的源文件里添加Fake symbol。如果你想在运行时使用Category，一定要确保你以某种方法在编译时引用了fake symbol，这会使得对象文件以及它里面的OC代码被载入。例如，它可以是一个有空函数体的函数，也可以是一个被访问的全局变量（例如一个全局的int变量，只要它被读或者写了一次就足够了）。和上面其他的解决方法不一样，这种解决方法可以控制哪些category可以在运行时被编译后的代码使用（可以通过使用这个符号，使它们被链接并变得可用；也可以不使用这个符号，这样链接器就会忽略它）</p>\n</li>\n</ul>\n"},{"title":"Mac软件--mos","date":"2019-06-30T03:02:30.000Z","_content":"\n## 前言 ##\n\nMac黑苹果使用鼠标的时候，鼠标滚轮不是特别灵敏，经常向下滚动的时候，会出现页面向上的问题，使用这个`mos`软件可以完美解决这个问题\n\n<!-- more -->\n\n### 安装方法 ###\n\n#### 软件源码地址 ####\n\n[mos地址](https://github.com/Caldis/Mos)\n\n#### 安装 ####\n\n```\nbrew cask install mos\n```\n\n命令会自动安装软件到`/Applications/Mos.app`\n\n#### 更新 ####\n\n```\nbrew update\nbrew cask reinstall mos\n```\n\n更新后重新启动应用即可","source":"_posts/Mac软件--mos.md","raw":"---\ntitle: Mac软件--mos\ndate: 2019-6-30 11:02:30\ntags: [Mac软件]\n---\n\n## 前言 ##\n\nMac黑苹果使用鼠标的时候，鼠标滚轮不是特别灵敏，经常向下滚动的时候，会出现页面向上的问题，使用这个`mos`软件可以完美解决这个问题\n\n<!-- more -->\n\n### 安装方法 ###\n\n#### 软件源码地址 ####\n\n[mos地址](https://github.com/Caldis/Mos)\n\n#### 安装 ####\n\n```\nbrew cask install mos\n```\n\n命令会自动安装软件到`/Applications/Mos.app`\n\n#### 更新 ####\n\n```\nbrew update\nbrew cask reinstall mos\n```\n\n更新后重新启动应用即可","slug":"Mac软件--mos","published":1,"updated":"2021-04-12T09:17:38.418Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqjdx1ng000q5emubpry3rhp","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Mac黑苹果使用鼠标的时候，鼠标滚轮不是特别灵敏，经常向下滚动的时候，会出现页面向上的问题，使用这个<code>mos</code>软件可以完美解决这个问题</p>\n<a id=\"more\"></a>\n<h3 id=\"安装方法\"><a href=\"#安装方法\" class=\"headerlink\" title=\"安装方法\"></a>安装方法</h3><h4 id=\"软件源码地址\"><a href=\"#软件源码地址\" class=\"headerlink\" title=\"软件源码地址\"></a>软件源码地址</h4><p><a href=\"https://github.com/Caldis/Mos\" target=\"_blank\" rel=\"noopener\">mos地址</a></p>\n<h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew cask install mos</span><br></pre></td></tr></table></figure>\n<p>命令会自动安装软件到<code>/Applications/Mos.app</code></p>\n<h4 id=\"更新\"><a href=\"#更新\" class=\"headerlink\" title=\"更新\"></a>更新</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew update</span><br><span class=\"line\">brew cask reinstall mos</span><br></pre></td></tr></table></figure>\n<p>更新后重新启动应用即可</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Mac黑苹果使用鼠标的时候，鼠标滚轮不是特别灵敏，经常向下滚动的时候，会出现页面向上的问题，使用这个<code>mos</code>软件可以完美解决这个问题</p>","more":"<h3 id=\"安装方法\"><a href=\"#安装方法\" class=\"headerlink\" title=\"安装方法\"></a>安装方法</h3><h4 id=\"软件源码地址\"><a href=\"#软件源码地址\" class=\"headerlink\" title=\"软件源码地址\"></a>软件源码地址</h4><p><a href=\"https://github.com/Caldis/Mos\" target=\"_blank\" rel=\"noopener\">mos地址</a></p>\n<h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew cask install mos</span><br></pre></td></tr></table></figure>\n<p>命令会自动安装软件到<code>/Applications/Mos.app</code></p>\n<h4 id=\"更新\"><a href=\"#更新\" class=\"headerlink\" title=\"更新\"></a>更新</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew update</span><br><span class=\"line\">brew cask reinstall mos</span><br></pre></td></tr></table></figure>\n<p>更新后重新启动应用即可</p>"},{"title":"Python相关--Numpy使用","date":"2019-03-01T12:10:12.000Z","_content":"\n## 前言 ##\n\nNumPy(Numerical Python) 是 Python 语言的一个扩展程序库，支持大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。\n\n<!-- more -->\n\n### numpy 方法 ###\n\n创建矩阵\n\n```\nnp.array([1,2,3],[2,3,4])\n\nnp.array([2,3,4],dtype=np.int) //同时指定类型\n\nnp.zeros((3,4)) //生成3行4列全部为0的矩阵\n\nnp.ones((3,4),dtype=np.int) //生成3行4列全部为1的矩阵\n\nnp.empty((3,4)) //生成3行4列为空的矩阵，里面的值全部都是接近0的值\n\nnp.arange(10,20,2) //生成一个从10到20，步长为2的矩阵，不包括20\n\nnp.arange(12).reshape((3,4)) //生成一个从0到11的3行4列的矩阵\n\nnp.linspace(1,10,20) //生成一个从1到10，一共20段的矩阵，起始值是1结束值是10\n\nnp.random.random((2,4)) //生成一个随机的2行4列矩阵\n```\n\n查看数组维度\n\n```\narray.ndim\n```\n\n查看数组的形状\n\n```\narray.shape\n```\n\n查看数组的元素\n\n```\narray.size\n```\n\n### numpy的运算 ###\n\n```\na=np.array([10,20,30,40]) //[10 20 30 40]\nb=np.arange(4) //[0 1 2 3]\n\nc=a+b //[10 21 32 43]\nc=a-b //[10 19 28 37]\nc=a*b //[0 20 60 120]\nc=b**4 //表示b的4次方\n\nc=10*np.sin(a) //对a的每个元素求sin再乘以10\nc=b<3 //[True True True False] 每个元素是否小于3\n\n/******/\na=np.array([[1,1],[0,1]])\nb=np.arange(4).reshape((2,2))\n\nc=a*b //元素逐个相乘 [[0 1] [0 3]]\nc=np.dot(a,b) //矩阵的乘法 [[2 4] [2 3]]\nc=a.dot(b) //矩阵乘法的另一种表示\n\n/******/\na=np.random.random((2,4))\nnp.sum(a,axis=1) //不加axis=1表示所有元素求和，axis=1表示维度,1是以行求和，0是以列求和\nnp.min(a,axis=0) //求最小值 同上\nnp.max(a,axis=1) //求最大值 同上\n\n/******/\na=np.arange(2,14).reshape((3,4))\nb=np.argmin(a) //获取最小值的索引\nc=np.argmax(a) //获取最大值的索引\nd=np.mean(a) //获取平均值\ne=np.average(a) //另一种平均值算法\nf=np.median(a) //中位数\ng=np.cumsum(a) //累加，第一个值是第一个元素的值。第二个值是前两个元素相加的值\nh=np.diff(a) //相邻的差\ni=np.sort(a) //从小到大排序，每行排每行的\nj=np.transpose(a) //矩阵反向，行变成列，列变成行\nj=a.T //也是矩阵的反向\nk=np.clip(a,5,9) //小于5的数变成5，大于9的数变成9\n```\n","source":"_posts/Python相关--Numpy使用.md","raw":"---\ntitle: Python相关--Numpy使用\ndate: 2019-3-1 20:10:12\ntags: [Python]\n---\n\n## 前言 ##\n\nNumPy(Numerical Python) 是 Python 语言的一个扩展程序库，支持大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。\n\n<!-- more -->\n\n### numpy 方法 ###\n\n创建矩阵\n\n```\nnp.array([1,2,3],[2,3,4])\n\nnp.array([2,3,4],dtype=np.int) //同时指定类型\n\nnp.zeros((3,4)) //生成3行4列全部为0的矩阵\n\nnp.ones((3,4),dtype=np.int) //生成3行4列全部为1的矩阵\n\nnp.empty((3,4)) //生成3行4列为空的矩阵，里面的值全部都是接近0的值\n\nnp.arange(10,20,2) //生成一个从10到20，步长为2的矩阵，不包括20\n\nnp.arange(12).reshape((3,4)) //生成一个从0到11的3行4列的矩阵\n\nnp.linspace(1,10,20) //生成一个从1到10，一共20段的矩阵，起始值是1结束值是10\n\nnp.random.random((2,4)) //生成一个随机的2行4列矩阵\n```\n\n查看数组维度\n\n```\narray.ndim\n```\n\n查看数组的形状\n\n```\narray.shape\n```\n\n查看数组的元素\n\n```\narray.size\n```\n\n### numpy的运算 ###\n\n```\na=np.array([10,20,30,40]) //[10 20 30 40]\nb=np.arange(4) //[0 1 2 3]\n\nc=a+b //[10 21 32 43]\nc=a-b //[10 19 28 37]\nc=a*b //[0 20 60 120]\nc=b**4 //表示b的4次方\n\nc=10*np.sin(a) //对a的每个元素求sin再乘以10\nc=b<3 //[True True True False] 每个元素是否小于3\n\n/******/\na=np.array([[1,1],[0,1]])\nb=np.arange(4).reshape((2,2))\n\nc=a*b //元素逐个相乘 [[0 1] [0 3]]\nc=np.dot(a,b) //矩阵的乘法 [[2 4] [2 3]]\nc=a.dot(b) //矩阵乘法的另一种表示\n\n/******/\na=np.random.random((2,4))\nnp.sum(a,axis=1) //不加axis=1表示所有元素求和，axis=1表示维度,1是以行求和，0是以列求和\nnp.min(a,axis=0) //求最小值 同上\nnp.max(a,axis=1) //求最大值 同上\n\n/******/\na=np.arange(2,14).reshape((3,4))\nb=np.argmin(a) //获取最小值的索引\nc=np.argmax(a) //获取最大值的索引\nd=np.mean(a) //获取平均值\ne=np.average(a) //另一种平均值算法\nf=np.median(a) //中位数\ng=np.cumsum(a) //累加，第一个值是第一个元素的值。第二个值是前两个元素相加的值\nh=np.diff(a) //相邻的差\ni=np.sort(a) //从小到大排序，每行排每行的\nj=np.transpose(a) //矩阵反向，行变成列，列变成行\nj=a.T //也是矩阵的反向\nk=np.clip(a,5,9) //小于5的数变成5，大于9的数变成9\n```\n","slug":"Python相关--Numpy使用","published":1,"updated":"2021-04-12T09:17:38.419Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqjdx1nh000s5emumgz5icyy","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>NumPy(Numerical Python) 是 Python 语言的一个扩展程序库，支持大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。</p>\n<a id=\"more\"></a>\n<h3 id=\"numpy-方法\"><a href=\"#numpy-方法\" class=\"headerlink\" title=\"numpy 方法\"></a>numpy 方法</h3><p>创建矩阵</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">np.array([1,2,3],[2,3,4])</span><br><span class=\"line\"></span><br><span class=\"line\">np.array([2,3,4],dtype=np.int) //同时指定类型</span><br><span class=\"line\"></span><br><span class=\"line\">np.zeros((3,4)) //生成3行4列全部为0的矩阵</span><br><span class=\"line\"></span><br><span class=\"line\">np.ones((3,4),dtype=np.int) //生成3行4列全部为1的矩阵</span><br><span class=\"line\"></span><br><span class=\"line\">np.empty((3,4)) //生成3行4列为空的矩阵，里面的值全部都是接近0的值</span><br><span class=\"line\"></span><br><span class=\"line\">np.arange(10,20,2) //生成一个从10到20，步长为2的矩阵，不包括20</span><br><span class=\"line\"></span><br><span class=\"line\">np.arange(12).reshape((3,4)) //生成一个从0到11的3行4列的矩阵</span><br><span class=\"line\"></span><br><span class=\"line\">np.linspace(1,10,20) //生成一个从1到10，一共20段的矩阵，起始值是1结束值是10</span><br><span class=\"line\"></span><br><span class=\"line\">np.random.random((2,4)) //生成一个随机的2行4列矩阵</span><br></pre></td></tr></table></figure>\n<p>查看数组维度</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">array.ndim</span><br></pre></td></tr></table></figure>\n<p>查看数组的形状</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">array.shape</span><br></pre></td></tr></table></figure>\n<p>查看数组的元素</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">array.size</span><br></pre></td></tr></table></figure>\n<h3 id=\"numpy的运算\"><a href=\"#numpy的运算\" class=\"headerlink\" title=\"numpy的运算\"></a>numpy的运算</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a=np.array([10,20,30,40]) //[10 20 30 40]</span><br><span class=\"line\">b=np.arange(4) //[0 1 2 3]</span><br><span class=\"line\"></span><br><span class=\"line\">c=a+b //[10 21 32 43]</span><br><span class=\"line\">c=a-b //[10 19 28 37]</span><br><span class=\"line\">c=a*b //[0 20 60 120]</span><br><span class=\"line\">c=b**4 //表示b的4次方</span><br><span class=\"line\"></span><br><span class=\"line\">c=10*np.sin(a) //对a的每个元素求sin再乘以10</span><br><span class=\"line\">c=b&lt;3 //[True True True False] 每个元素是否小于3</span><br><span class=\"line\"></span><br><span class=\"line\">/******/</span><br><span class=\"line\">a=np.array([[1,1],[0,1]])</span><br><span class=\"line\">b=np.arange(4).reshape((2,2))</span><br><span class=\"line\"></span><br><span class=\"line\">c=a*b //元素逐个相乘 [[0 1] [0 3]]</span><br><span class=\"line\">c=np.dot(a,b) //矩阵的乘法 [[2 4] [2 3]]</span><br><span class=\"line\">c=a.dot(b) //矩阵乘法的另一种表示</span><br><span class=\"line\"></span><br><span class=\"line\">/******/</span><br><span class=\"line\">a=np.random.random((2,4))</span><br><span class=\"line\">np.sum(a,axis=1) //不加axis=1表示所有元素求和，axis=1表示维度,1是以行求和，0是以列求和</span><br><span class=\"line\">np.min(a,axis=0) //求最小值 同上</span><br><span class=\"line\">np.max(a,axis=1) //求最大值 同上</span><br><span class=\"line\"></span><br><span class=\"line\">/******/</span><br><span class=\"line\">a=np.arange(2,14).reshape((3,4))</span><br><span class=\"line\">b=np.argmin(a) //获取最小值的索引</span><br><span class=\"line\">c=np.argmax(a) //获取最大值的索引</span><br><span class=\"line\">d=np.mean(a) //获取平均值</span><br><span class=\"line\">e=np.average(a) //另一种平均值算法</span><br><span class=\"line\">f=np.median(a) //中位数</span><br><span class=\"line\">g=np.cumsum(a) //累加，第一个值是第一个元素的值。第二个值是前两个元素相加的值</span><br><span class=\"line\">h=np.diff(a) //相邻的差</span><br><span class=\"line\">i=np.sort(a) //从小到大排序，每行排每行的</span><br><span class=\"line\">j=np.transpose(a) //矩阵反向，行变成列，列变成行</span><br><span class=\"line\">j=a.T //也是矩阵的反向</span><br><span class=\"line\">k=np.clip(a,5,9) //小于5的数变成5，大于9的数变成9</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>NumPy(Numerical Python) 是 Python 语言的一个扩展程序库，支持大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。</p>","more":"<h3 id=\"numpy-方法\"><a href=\"#numpy-方法\" class=\"headerlink\" title=\"numpy 方法\"></a>numpy 方法</h3><p>创建矩阵</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">np.array([1,2,3],[2,3,4])</span><br><span class=\"line\"></span><br><span class=\"line\">np.array([2,3,4],dtype=np.int) //同时指定类型</span><br><span class=\"line\"></span><br><span class=\"line\">np.zeros((3,4)) //生成3行4列全部为0的矩阵</span><br><span class=\"line\"></span><br><span class=\"line\">np.ones((3,4),dtype=np.int) //生成3行4列全部为1的矩阵</span><br><span class=\"line\"></span><br><span class=\"line\">np.empty((3,4)) //生成3行4列为空的矩阵，里面的值全部都是接近0的值</span><br><span class=\"line\"></span><br><span class=\"line\">np.arange(10,20,2) //生成一个从10到20，步长为2的矩阵，不包括20</span><br><span class=\"line\"></span><br><span class=\"line\">np.arange(12).reshape((3,4)) //生成一个从0到11的3行4列的矩阵</span><br><span class=\"line\"></span><br><span class=\"line\">np.linspace(1,10,20) //生成一个从1到10，一共20段的矩阵，起始值是1结束值是10</span><br><span class=\"line\"></span><br><span class=\"line\">np.random.random((2,4)) //生成一个随机的2行4列矩阵</span><br></pre></td></tr></table></figure>\n<p>查看数组维度</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">array.ndim</span><br></pre></td></tr></table></figure>\n<p>查看数组的形状</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">array.shape</span><br></pre></td></tr></table></figure>\n<p>查看数组的元素</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">array.size</span><br></pre></td></tr></table></figure>\n<h3 id=\"numpy的运算\"><a href=\"#numpy的运算\" class=\"headerlink\" title=\"numpy的运算\"></a>numpy的运算</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a=np.array([10,20,30,40]) //[10 20 30 40]</span><br><span class=\"line\">b=np.arange(4) //[0 1 2 3]</span><br><span class=\"line\"></span><br><span class=\"line\">c=a+b //[10 21 32 43]</span><br><span class=\"line\">c=a-b //[10 19 28 37]</span><br><span class=\"line\">c=a*b //[0 20 60 120]</span><br><span class=\"line\">c=b**4 //表示b的4次方</span><br><span class=\"line\"></span><br><span class=\"line\">c=10*np.sin(a) //对a的每个元素求sin再乘以10</span><br><span class=\"line\">c=b&lt;3 //[True True True False] 每个元素是否小于3</span><br><span class=\"line\"></span><br><span class=\"line\">/******/</span><br><span class=\"line\">a=np.array([[1,1],[0,1]])</span><br><span class=\"line\">b=np.arange(4).reshape((2,2))</span><br><span class=\"line\"></span><br><span class=\"line\">c=a*b //元素逐个相乘 [[0 1] [0 3]]</span><br><span class=\"line\">c=np.dot(a,b) //矩阵的乘法 [[2 4] [2 3]]</span><br><span class=\"line\">c=a.dot(b) //矩阵乘法的另一种表示</span><br><span class=\"line\"></span><br><span class=\"line\">/******/</span><br><span class=\"line\">a=np.random.random((2,4))</span><br><span class=\"line\">np.sum(a,axis=1) //不加axis=1表示所有元素求和，axis=1表示维度,1是以行求和，0是以列求和</span><br><span class=\"line\">np.min(a,axis=0) //求最小值 同上</span><br><span class=\"line\">np.max(a,axis=1) //求最大值 同上</span><br><span class=\"line\"></span><br><span class=\"line\">/******/</span><br><span class=\"line\">a=np.arange(2,14).reshape((3,4))</span><br><span class=\"line\">b=np.argmin(a) //获取最小值的索引</span><br><span class=\"line\">c=np.argmax(a) //获取最大值的索引</span><br><span class=\"line\">d=np.mean(a) //获取平均值</span><br><span class=\"line\">e=np.average(a) //另一种平均值算法</span><br><span class=\"line\">f=np.median(a) //中位数</span><br><span class=\"line\">g=np.cumsum(a) //累加，第一个值是第一个元素的值。第二个值是前两个元素相加的值</span><br><span class=\"line\">h=np.diff(a) //相邻的差</span><br><span class=\"line\">i=np.sort(a) //从小到大排序，每行排每行的</span><br><span class=\"line\">j=np.transpose(a) //矩阵反向，行变成列，列变成行</span><br><span class=\"line\">j=a.T //也是矩阵的反向</span><br><span class=\"line\">k=np.clip(a,5,9) //小于5的数变成5，大于9的数变成9</span><br></pre></td></tr></table></figure>"},{"title":"RAS 加密算法原理","date":"2018-05-02T13:45:12.000Z","_content":"\n## 前言 ##\n\n网上看了一下李永乐老师讲的非对称加密的原理，挺有意思的，记录一下\n\n<!-- more -->\n\n\n### 非对称加密 ###\n\n#### 传递信息的非对称加密过程：####\n\n1. A想要把信息m发送给B\n\n2. B生成两个有相关性的数字，e（公钥）和d（私钥）\n\n3. B把公钥e以公开的形式传给A\n\n4. A通过公钥的某一种算法得到密文C\n\n5. A把密文C传给B\n\n6. B通过私钥d解密密文C，得到信息m\n\n\n### RSA加密算法 ###\n\nRSA就是一种非对称加密的算法\n\n\n#### RSA加密过程：####\n\n1. 首页B找出两个质数p，q\n2. n = p*q\n3. 带入欧拉函数 Φ（n）= （p-1）*（q-1）\n4. 找出公钥e ，e需要满足两个条件（1）1<e<Φ（n）(2) e 和 Φ（n）互质\n5. 找出私钥d ，d需要满足e*d/Φ（n）余数是1\n6. 加密算法：m的e次幂除以n求余数C\n7. 解密算法：C的d次方除以n求余数m\n\n\n### 安全性 ###\n\nA在传播信息的时候传播了n，e，c\n\n解密需要n，d，c\n\n如果想知道私钥d，由上面可知，需要知道Φ（n）\n\nΦ（n）需要知道p，q\n\np，q需要知道n，因为n=p*q\n\n求p，q的过程叫分解质因数\n\n但是大数的质因数特别难分解，所以RSA加密算法安全，当然如果可以做到大数质因数分解那么就。。。\n\n\neg：量子计算机\n\n","source":"_posts/RSA非对称加密.md","raw":"---\ntitle: RAS 加密算法原理\ndate: 2018-05-02 21:45:12\ntags: [Linux]\n---\n\n## 前言 ##\n\n网上看了一下李永乐老师讲的非对称加密的原理，挺有意思的，记录一下\n\n<!-- more -->\n\n\n### 非对称加密 ###\n\n#### 传递信息的非对称加密过程：####\n\n1. A想要把信息m发送给B\n\n2. B生成两个有相关性的数字，e（公钥）和d（私钥）\n\n3. B把公钥e以公开的形式传给A\n\n4. A通过公钥的某一种算法得到密文C\n\n5. A把密文C传给B\n\n6. B通过私钥d解密密文C，得到信息m\n\n\n### RSA加密算法 ###\n\nRSA就是一种非对称加密的算法\n\n\n#### RSA加密过程：####\n\n1. 首页B找出两个质数p，q\n2. n = p*q\n3. 带入欧拉函数 Φ（n）= （p-1）*（q-1）\n4. 找出公钥e ，e需要满足两个条件（1）1<e<Φ（n）(2) e 和 Φ（n）互质\n5. 找出私钥d ，d需要满足e*d/Φ（n）余数是1\n6. 加密算法：m的e次幂除以n求余数C\n7. 解密算法：C的d次方除以n求余数m\n\n\n### 安全性 ###\n\nA在传播信息的时候传播了n，e，c\n\n解密需要n，d，c\n\n如果想知道私钥d，由上面可知，需要知道Φ（n）\n\nΦ（n）需要知道p，q\n\np，q需要知道n，因为n=p*q\n\n求p，q的过程叫分解质因数\n\n但是大数的质因数特别难分解，所以RSA加密算法安全，当然如果可以做到大数质因数分解那么就。。。\n\n\neg：量子计算机\n\n","slug":"RSA非对称加密","published":1,"updated":"2021-04-12T09:17:38.419Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqjdx1ni000u5emu30434meq","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>网上看了一下李永乐老师讲的非对称加密的原理，挺有意思的，记录一下</p>\n<a id=\"more\"></a>\n<h3 id=\"非对称加密\"><a href=\"#非对称加密\" class=\"headerlink\" title=\"非对称加密\"></a>非对称加密</h3><h4 id=\"传递信息的非对称加密过程：\"><a href=\"#传递信息的非对称加密过程：\" class=\"headerlink\" title=\"传递信息的非对称加密过程：\"></a>传递信息的非对称加密过程：</h4><ol>\n<li><p>A想要把信息m发送给B</p>\n</li>\n<li><p>B生成两个有相关性的数字，e（公钥）和d（私钥）</p>\n</li>\n<li><p>B把公钥e以公开的形式传给A</p>\n</li>\n<li><p>A通过公钥的某一种算法得到密文C</p>\n</li>\n<li><p>A把密文C传给B</p>\n</li>\n<li><p>B通过私钥d解密密文C，得到信息m</p>\n</li>\n</ol>\n<h3 id=\"RSA加密算法\"><a href=\"#RSA加密算法\" class=\"headerlink\" title=\"RSA加密算法\"></a>RSA加密算法</h3><p>RSA就是一种非对称加密的算法</p>\n<h4 id=\"RSA加密过程：\"><a href=\"#RSA加密过程：\" class=\"headerlink\" title=\"RSA加密过程：\"></a>RSA加密过程：</h4><ol>\n<li>首页B找出两个质数p，q</li>\n<li>n = p*q</li>\n<li>带入欧拉函数 Φ（n）= （p-1）*（q-1）</li>\n<li>找出公钥e ，e需要满足两个条件（1）1&lt;e&lt;Φ（n）(2) e 和 Φ（n）互质</li>\n<li>找出私钥d ，d需要满足e*d/Φ（n）余数是1</li>\n<li>加密算法：m的e次幂除以n求余数C</li>\n<li>解密算法：C的d次方除以n求余数m</li>\n</ol>\n<h3 id=\"安全性\"><a href=\"#安全性\" class=\"headerlink\" title=\"安全性\"></a>安全性</h3><p>A在传播信息的时候传播了n，e，c</p>\n<p>解密需要n，d，c</p>\n<p>如果想知道私钥d，由上面可知，需要知道Φ（n）</p>\n<p>Φ（n）需要知道p，q</p>\n<p>p，q需要知道n，因为n=p*q</p>\n<p>求p，q的过程叫分解质因数</p>\n<p>但是大数的质因数特别难分解，所以RSA加密算法安全，当然如果可以做到大数质因数分解那么就。。。</p>\n<p>eg：量子计算机</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>网上看了一下李永乐老师讲的非对称加密的原理，挺有意思的，记录一下</p>","more":"<h3 id=\"非对称加密\"><a href=\"#非对称加密\" class=\"headerlink\" title=\"非对称加密\"></a>非对称加密</h3><h4 id=\"传递信息的非对称加密过程：\"><a href=\"#传递信息的非对称加密过程：\" class=\"headerlink\" title=\"传递信息的非对称加密过程：\"></a>传递信息的非对称加密过程：</h4><ol>\n<li><p>A想要把信息m发送给B</p>\n</li>\n<li><p>B生成两个有相关性的数字，e（公钥）和d（私钥）</p>\n</li>\n<li><p>B把公钥e以公开的形式传给A</p>\n</li>\n<li><p>A通过公钥的某一种算法得到密文C</p>\n</li>\n<li><p>A把密文C传给B</p>\n</li>\n<li><p>B通过私钥d解密密文C，得到信息m</p>\n</li>\n</ol>\n<h3 id=\"RSA加密算法\"><a href=\"#RSA加密算法\" class=\"headerlink\" title=\"RSA加密算法\"></a>RSA加密算法</h3><p>RSA就是一种非对称加密的算法</p>\n<h4 id=\"RSA加密过程：\"><a href=\"#RSA加密过程：\" class=\"headerlink\" title=\"RSA加密过程：\"></a>RSA加密过程：</h4><ol>\n<li>首页B找出两个质数p，q</li>\n<li>n = p*q</li>\n<li>带入欧拉函数 Φ（n）= （p-1）*（q-1）</li>\n<li>找出公钥e ，e需要满足两个条件（1）1&lt;e&lt;Φ（n）(2) e 和 Φ（n）互质</li>\n<li>找出私钥d ，d需要满足e*d/Φ（n）余数是1</li>\n<li>加密算法：m的e次幂除以n求余数C</li>\n<li>解密算法：C的d次方除以n求余数m</li>\n</ol>\n<h3 id=\"安全性\"><a href=\"#安全性\" class=\"headerlink\" title=\"安全性\"></a>安全性</h3><p>A在传播信息的时候传播了n，e，c</p>\n<p>解密需要n，d，c</p>\n<p>如果想知道私钥d，由上面可知，需要知道Φ（n）</p>\n<p>Φ（n）需要知道p，q</p>\n<p>p，q需要知道n，因为n=p*q</p>\n<p>求p，q的过程叫分解质因数</p>\n<p>但是大数的质因数特别难分解，所以RSA加密算法安全，当然如果可以做到大数质因数分解那么就。。。</p>\n<p>eg：量子计算机</p>"},{"title":"SSH Key","date":"2018-06-01T07:41:23.000Z","_content":"\n## 前言 ##\n记录SSH的使用\n\n<!-- more -->\n\n### SSH Key 的生成 ###\n\n1.  一个`ssh key `是由两个文件组成,一个是私钥名字默认是`id_rsa`,另一个就是公钥默认名字是`id_rsa.pub`,两个是配套使用的\n\n2.  Mac系统默认秘钥的存放路径是`~/.ssh`\n\n3.  如果在存放路径中有公钥和私钥就不需要生成,可以直接使用,如果没有就需要使用下面命令生成一个\n4. \n```\nssh-keygen -t rsa -C \"your_email@example.com\"\n```\n\n4. 敲完回车首先会让你填写一个文件名,就是生成的ssh文件的文件名,不填写默认会是`id_rsa`和`id_rsa.pub`或`id_dsa`和`id_dsa.pub`\n\n    注意:这里的文件如果输入了文件名,生成的公钥和私钥文件存放的位置是当前命令的位置\n\n5.  输入完文件名回车后会让你输出密码和确认密码,可以为空,但是如果输出了,每次使用ssh的时候都会让你输入密码\n\n6. 输入完密码生成一个ssh key文件就大功告成了\n\n7. 最后会给你一个`randomart image`这个东西是用来方便比对key是否一样的,以为人们对不图片比对不字符串的接受更容易\n\n### SSH Key 的参数 ###\n\n` -t xxx `xxx可以是`rsa` `rsa1` 或`dsa`,这个是几种不同的加密算法\n\n`-C \"your_email@example.com\"`生成的时候添加一个注释\n\n`-f ~/.ssh/id_rsa_soho` 指定保存文件名和位置\n\n其他参数暂时用不到,就不介绍了\n\n\n### 多个SSH Key 同时使用 ###\n\n如果需要使用多ssh文件给不同的服务器时,就要使用配置文件了\n\n1.  在`~/.ssh`目录创建一个名字为d`config`的文本文件\n\n2. 里面写如下内容\n\n```\n# 配置github.com\nHost github.com\n# 这个是真实的域名地址                 \n    HostName github.com\n# 这是id_rsa的路径   \n    IdentityFile ~/.ssh/id_rsa_github\n# 配置登录时用什么权限认证--可设为publickey,password,publickey,keyboard-interactive等\n    PreferredAuthentications publickey\n# 配置使用用户名\n    User username1\n\n# 配置git.oschina.net \nHost git.oschina.net \n    HostName git.oschina.net\n    IdentityFile ~/.ssh/id_rsa_oschina\n    PreferredAuthentications publickey\n    User username2\n```\n\n每个`ssh`文件单独配置一个`Host`，`Host`可以随便起，只要配置好`HostName`和`IdentityFile`两个属性即可\n\n注意：如果 `Host mygithub`这样定义的话，命令如下，\ngit的命令应该写成:`git clone git@mygithub:123.git`\n\n3. 测试配置是否成功,使用如下命令:\n\n```\nssh -T git@github.com\n```\n 　　　　　　　　　　\n\n\n附录:\n\nMac下开启/关闭 显示隐藏文件的方法\n\n```\n显示：defaults write com.apple.finder AppleShowAllFiles -bool true\n隐藏：defaults write com.apple.finder AppleShowAllFiles -bool false \n```\n","source":"_posts/SSH Key.md","raw":"---\ntitle: SSH Key\ndate: 2018-06-01 15:41:23\ntags: [Linux]\n---\n\n## 前言 ##\n记录SSH的使用\n\n<!-- more -->\n\n### SSH Key 的生成 ###\n\n1.  一个`ssh key `是由两个文件组成,一个是私钥名字默认是`id_rsa`,另一个就是公钥默认名字是`id_rsa.pub`,两个是配套使用的\n\n2.  Mac系统默认秘钥的存放路径是`~/.ssh`\n\n3.  如果在存放路径中有公钥和私钥就不需要生成,可以直接使用,如果没有就需要使用下面命令生成一个\n4. \n```\nssh-keygen -t rsa -C \"your_email@example.com\"\n```\n\n4. 敲完回车首先会让你填写一个文件名,就是生成的ssh文件的文件名,不填写默认会是`id_rsa`和`id_rsa.pub`或`id_dsa`和`id_dsa.pub`\n\n    注意:这里的文件如果输入了文件名,生成的公钥和私钥文件存放的位置是当前命令的位置\n\n5.  输入完文件名回车后会让你输出密码和确认密码,可以为空,但是如果输出了,每次使用ssh的时候都会让你输入密码\n\n6. 输入完密码生成一个ssh key文件就大功告成了\n\n7. 最后会给你一个`randomart image`这个东西是用来方便比对key是否一样的,以为人们对不图片比对不字符串的接受更容易\n\n### SSH Key 的参数 ###\n\n` -t xxx `xxx可以是`rsa` `rsa1` 或`dsa`,这个是几种不同的加密算法\n\n`-C \"your_email@example.com\"`生成的时候添加一个注释\n\n`-f ~/.ssh/id_rsa_soho` 指定保存文件名和位置\n\n其他参数暂时用不到,就不介绍了\n\n\n### 多个SSH Key 同时使用 ###\n\n如果需要使用多ssh文件给不同的服务器时,就要使用配置文件了\n\n1.  在`~/.ssh`目录创建一个名字为d`config`的文本文件\n\n2. 里面写如下内容\n\n```\n# 配置github.com\nHost github.com\n# 这个是真实的域名地址                 \n    HostName github.com\n# 这是id_rsa的路径   \n    IdentityFile ~/.ssh/id_rsa_github\n# 配置登录时用什么权限认证--可设为publickey,password,publickey,keyboard-interactive等\n    PreferredAuthentications publickey\n# 配置使用用户名\n    User username1\n\n# 配置git.oschina.net \nHost git.oschina.net \n    HostName git.oschina.net\n    IdentityFile ~/.ssh/id_rsa_oschina\n    PreferredAuthentications publickey\n    User username2\n```\n\n每个`ssh`文件单独配置一个`Host`，`Host`可以随便起，只要配置好`HostName`和`IdentityFile`两个属性即可\n\n注意：如果 `Host mygithub`这样定义的话，命令如下，\ngit的命令应该写成:`git clone git@mygithub:123.git`\n\n3. 测试配置是否成功,使用如下命令:\n\n```\nssh -T git@github.com\n```\n 　　　　　　　　　　\n\n\n附录:\n\nMac下开启/关闭 显示隐藏文件的方法\n\n```\n显示：defaults write com.apple.finder AppleShowAllFiles -bool true\n隐藏：defaults write com.apple.finder AppleShowAllFiles -bool false \n```\n","slug":"SSH Key","published":1,"updated":"2021-04-12T09:17:38.419Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqjdx1nj000x5emu95jppavp","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>记录SSH的使用</p>\n<a id=\"more\"></a>\n<h3 id=\"SSH-Key-的生成\"><a href=\"#SSH-Key-的生成\" class=\"headerlink\" title=\"SSH Key 的生成\"></a>SSH Key 的生成</h3><ol>\n<li><p>一个<code>ssh key</code>是由两个文件组成,一个是私钥名字默认是<code>id_rsa</code>,另一个就是公钥默认名字是<code>id_rsa.pub</code>,两个是配套使用的</p>\n</li>\n<li><p>Mac系统默认秘钥的存放路径是<code>~/.ssh</code></p>\n</li>\n<li><p>如果在存放路径中有公钥和私钥就不需要生成,可以直接使用,如果没有就需要使用下面命令生成一个</p>\n</li>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>敲完回车首先会让你填写一个文件名,就是生成的ssh文件的文件名,不填写默认会是<code>id_rsa</code>和<code>id_rsa.pub</code>或<code>id_dsa</code>和<code>id_dsa.pub</code></p>\n<p> 注意:这里的文件如果输入了文件名,生成的公钥和私钥文件存放的位置是当前命令的位置</p>\n</li>\n<li><p>输入完文件名回车后会让你输出密码和确认密码,可以为空,但是如果输出了,每次使用ssh的时候都会让你输入密码</p>\n</li>\n<li><p>输入完密码生成一个ssh key文件就大功告成了</p>\n</li>\n<li><p>最后会给你一个<code>randomart image</code>这个东西是用来方便比对key是否一样的,以为人们对不图片比对不字符串的接受更容易</p>\n</li>\n</ol>\n<h3 id=\"SSH-Key-的参数\"><a href=\"#SSH-Key-的参数\" class=\"headerlink\" title=\"SSH Key 的参数\"></a>SSH Key 的参数</h3><p><code>-t xxx</code>xxx可以是<code>rsa</code> <code>rsa1</code> 或<code>dsa</code>,这个是几种不同的加密算法</p>\n<p><code>-C &quot;your_email@example.com&quot;</code>生成的时候添加一个注释</p>\n<p><code>-f ~/.ssh/id_rsa_soho</code> 指定保存文件名和位置</p>\n<p>其他参数暂时用不到,就不介绍了</p>\n<h3 id=\"多个SSH-Key-同时使用\"><a href=\"#多个SSH-Key-同时使用\" class=\"headerlink\" title=\"多个SSH Key 同时使用\"></a>多个SSH Key 同时使用</h3><p>如果需要使用多ssh文件给不同的服务器时,就要使用配置文件了</p>\n<ol>\n<li><p>在<code>~/.ssh</code>目录创建一个名字为d<code>config</code>的文本文件</p>\n</li>\n<li><p>里面写如下内容</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 配置github.com</span><br><span class=\"line\">Host github.com</span><br><span class=\"line\"># 这个是真实的域名地址                 </span><br><span class=\"line\">    HostName github.com</span><br><span class=\"line\"># 这是id_rsa的路径   </span><br><span class=\"line\">    IdentityFile ~/.ssh/id_rsa_github</span><br><span class=\"line\"># 配置登录时用什么权限认证--可设为publickey,password,publickey,keyboard-interactive等</span><br><span class=\"line\">    PreferredAuthentications publickey</span><br><span class=\"line\"># 配置使用用户名</span><br><span class=\"line\">    User username1</span><br><span class=\"line\"></span><br><span class=\"line\"># 配置git.oschina.net </span><br><span class=\"line\">Host git.oschina.net </span><br><span class=\"line\">    HostName git.oschina.net</span><br><span class=\"line\">    IdentityFile ~/.ssh/id_rsa_oschina</span><br><span class=\"line\">    PreferredAuthentications publickey</span><br><span class=\"line\">    User username2</span><br></pre></td></tr></table></figure>\n<p>每个<code>ssh</code>文件单独配置一个<code>Host</code>，<code>Host</code>可以随便起，只要配置好<code>HostName</code>和<code>IdentityFile</code>两个属性即可</p>\n<p>注意：如果 <code>Host mygithub</code>这样定义的话，命令如下，<br>git的命令应该写成:<code>git clone git@mygithub:123.git</code></p>\n<ol start=\"3\">\n<li>测试配置是否成功,使用如下命令:</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -T git@github.com</span><br></pre></td></tr></table></figure>\n<p> 　　　　　　　　　　</p>\n<p>附录:</p>\n<p>Mac下开启/关闭 显示隐藏文件的方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">显示：defaults write com.apple.finder AppleShowAllFiles -bool true</span><br><span class=\"line\">隐藏：defaults write com.apple.finder AppleShowAllFiles -bool false</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>记录SSH的使用</p>","more":"<h3 id=\"SSH-Key-的生成\"><a href=\"#SSH-Key-的生成\" class=\"headerlink\" title=\"SSH Key 的生成\"></a>SSH Key 的生成</h3><ol>\n<li><p>一个<code>ssh key</code>是由两个文件组成,一个是私钥名字默认是<code>id_rsa</code>,另一个就是公钥默认名字是<code>id_rsa.pub</code>,两个是配套使用的</p>\n</li>\n<li><p>Mac系统默认秘钥的存放路径是<code>~/.ssh</code></p>\n</li>\n<li><p>如果在存放路径中有公钥和私钥就不需要生成,可以直接使用,如果没有就需要使用下面命令生成一个</p>\n</li>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>敲完回车首先会让你填写一个文件名,就是生成的ssh文件的文件名,不填写默认会是<code>id_rsa</code>和<code>id_rsa.pub</code>或<code>id_dsa</code>和<code>id_dsa.pub</code></p>\n<p> 注意:这里的文件如果输入了文件名,生成的公钥和私钥文件存放的位置是当前命令的位置</p>\n</li>\n<li><p>输入完文件名回车后会让你输出密码和确认密码,可以为空,但是如果输出了,每次使用ssh的时候都会让你输入密码</p>\n</li>\n<li><p>输入完密码生成一个ssh key文件就大功告成了</p>\n</li>\n<li><p>最后会给你一个<code>randomart image</code>这个东西是用来方便比对key是否一样的,以为人们对不图片比对不字符串的接受更容易</p>\n</li>\n</ol>\n<h3 id=\"SSH-Key-的参数\"><a href=\"#SSH-Key-的参数\" class=\"headerlink\" title=\"SSH Key 的参数\"></a>SSH Key 的参数</h3><p><code>-t xxx</code>xxx可以是<code>rsa</code> <code>rsa1</code> 或<code>dsa</code>,这个是几种不同的加密算法</p>\n<p><code>-C &quot;your_email@example.com&quot;</code>生成的时候添加一个注释</p>\n<p><code>-f ~/.ssh/id_rsa_soho</code> 指定保存文件名和位置</p>\n<p>其他参数暂时用不到,就不介绍了</p>\n<h3 id=\"多个SSH-Key-同时使用\"><a href=\"#多个SSH-Key-同时使用\" class=\"headerlink\" title=\"多个SSH Key 同时使用\"></a>多个SSH Key 同时使用</h3><p>如果需要使用多ssh文件给不同的服务器时,就要使用配置文件了</p>\n<ol>\n<li><p>在<code>~/.ssh</code>目录创建一个名字为d<code>config</code>的文本文件</p>\n</li>\n<li><p>里面写如下内容</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 配置github.com</span><br><span class=\"line\">Host github.com</span><br><span class=\"line\"># 这个是真实的域名地址                 </span><br><span class=\"line\">    HostName github.com</span><br><span class=\"line\"># 这是id_rsa的路径   </span><br><span class=\"line\">    IdentityFile ~/.ssh/id_rsa_github</span><br><span class=\"line\"># 配置登录时用什么权限认证--可设为publickey,password,publickey,keyboard-interactive等</span><br><span class=\"line\">    PreferredAuthentications publickey</span><br><span class=\"line\"># 配置使用用户名</span><br><span class=\"line\">    User username1</span><br><span class=\"line\"></span><br><span class=\"line\"># 配置git.oschina.net </span><br><span class=\"line\">Host git.oschina.net </span><br><span class=\"line\">    HostName git.oschina.net</span><br><span class=\"line\">    IdentityFile ~/.ssh/id_rsa_oschina</span><br><span class=\"line\">    PreferredAuthentications publickey</span><br><span class=\"line\">    User username2</span><br></pre></td></tr></table></figure>\n<p>每个<code>ssh</code>文件单独配置一个<code>Host</code>，<code>Host</code>可以随便起，只要配置好<code>HostName</code>和<code>IdentityFile</code>两个属性即可</p>\n<p>注意：如果 <code>Host mygithub</code>这样定义的话，命令如下，<br>git的命令应该写成:<code>git clone git@mygithub:123.git</code></p>\n<ol start=\"3\">\n<li>测试配置是否成功,使用如下命令:</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -T git@github.com</span><br></pre></td></tr></table></figure>\n<p> 　　　　　　　　　　</p>\n<p>附录:</p>\n<p>Mac下开启/关闭 显示隐藏文件的方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">显示：defaults write com.apple.finder AppleShowAllFiles -bool true</span><br><span class=\"line\">隐藏：defaults write com.apple.finder AppleShowAllFiles -bool false</span><br></pre></td></tr></table></figure>"},{"title":"UITableViewCell的创建","date":"2018-10-20T11:58:55.000Z","_content":"\n## 前言 ##\n`cell`的创建通常有两种方法，平时使用的时候没有注意，这里记录一下\n\n<!-- more -->\n\n### UITableViewCell的创建 ###\n\n我们都知道iOS中`tableview`的`cell`在创建的时候会用到重用机制，简单的说，就是把每个`cell`绑定一个标识，然后当`cell`在屏幕中显示的时候，系统首先会去缓冲池中取对应标志的`cell`，如果没有那就创建一个`cell`，如果有就直接拿出来使用，当`cell`滚动出屏幕的时候，系统会把`cell`放回缓冲池中，这样，缓冲池中最多也就一两个对象，而系统也不需要每次显示都创建对象。\n\n\n```\n- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {\n    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@\"identiffier\"];\n    if (!cell) {\n        cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:@\"identiffier\"];\n    }\n    \n    return cell;\n}\n```\n\n这个是一个默认的`tablecell`的创建，可以看到\n\n```\nUITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@\"identiffier\"];\n\n```\n先是去缓冲池去取`cell`，如果没有再去创建\n\n所以这个写法必须要加上下面的if判断，如果不加，而且缓冲池中没有cell，那么程序就会因为返回一个nil崩溃\n\n\n```\n- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {\n    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@\"identiffier\" forIndexPath:indexPath];\n    \n    return cell;\n}\n```\n\n在iOS6之后，又有了这种创建`cell`的方法，这种方法不需要写`if`，也就是说，如果缓冲池中没有，系统会自动的去创建一个`cell`，但是如果只是这么写还是不够的，系统还是会崩溃，因为你你要告诉tableview用什么标识创建一个什么`cell`\n\n简单的说，你还要在tableview创建的时候写上下面的方法\n\n```\n[tableView registerClass:[UITableViewCell class] forCellReuseIdentifier:@\"identiffier\"];\n```\n\n这样tableview就知道，在缓冲池中没有cell的时候，需要用什么类创建一个什么标识的cell\n\n### 总结 ###\n\n`tableviewcell`的重用有两种方法\n\n```\nUITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@\"identiffier\"];\n```\n\n这种方法不需要注册cell，但如果缓冲池没有需要手动创建\n\n```\nUITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@\"identiffier\" forIndexPath:indexPath];\n\n```\n这种方法需要注册`cell`，但是不需要手动创建了\n","source":"_posts/UITableViewCell的创建.md","raw":"---\ntitle: UITableViewCell的创建\ndate: 2018-10-20 19:58:55\ntags: [iOS]\n---\n\n## 前言 ##\n`cell`的创建通常有两种方法，平时使用的时候没有注意，这里记录一下\n\n<!-- more -->\n\n### UITableViewCell的创建 ###\n\n我们都知道iOS中`tableview`的`cell`在创建的时候会用到重用机制，简单的说，就是把每个`cell`绑定一个标识，然后当`cell`在屏幕中显示的时候，系统首先会去缓冲池中取对应标志的`cell`，如果没有那就创建一个`cell`，如果有就直接拿出来使用，当`cell`滚动出屏幕的时候，系统会把`cell`放回缓冲池中，这样，缓冲池中最多也就一两个对象，而系统也不需要每次显示都创建对象。\n\n\n```\n- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {\n    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@\"identiffier\"];\n    if (!cell) {\n        cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:@\"identiffier\"];\n    }\n    \n    return cell;\n}\n```\n\n这个是一个默认的`tablecell`的创建，可以看到\n\n```\nUITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@\"identiffier\"];\n\n```\n先是去缓冲池去取`cell`，如果没有再去创建\n\n所以这个写法必须要加上下面的if判断，如果不加，而且缓冲池中没有cell，那么程序就会因为返回一个nil崩溃\n\n\n```\n- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {\n    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@\"identiffier\" forIndexPath:indexPath];\n    \n    return cell;\n}\n```\n\n在iOS6之后，又有了这种创建`cell`的方法，这种方法不需要写`if`，也就是说，如果缓冲池中没有，系统会自动的去创建一个`cell`，但是如果只是这么写还是不够的，系统还是会崩溃，因为你你要告诉tableview用什么标识创建一个什么`cell`\n\n简单的说，你还要在tableview创建的时候写上下面的方法\n\n```\n[tableView registerClass:[UITableViewCell class] forCellReuseIdentifier:@\"identiffier\"];\n```\n\n这样tableview就知道，在缓冲池中没有cell的时候，需要用什么类创建一个什么标识的cell\n\n### 总结 ###\n\n`tableviewcell`的重用有两种方法\n\n```\nUITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@\"identiffier\"];\n```\n\n这种方法不需要注册cell，但如果缓冲池没有需要手动创建\n\n```\nUITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@\"identiffier\" forIndexPath:indexPath];\n\n```\n这种方法需要注册`cell`，但是不需要手动创建了\n","slug":"UITableViewCell的创建","published":1,"updated":"2021-04-12T09:17:38.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqjdx1nk000z5emux4mszq3j","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p><code>cell</code>的创建通常有两种方法，平时使用的时候没有注意，这里记录一下</p>\n<a id=\"more\"></a>\n<h3 id=\"UITableViewCell的创建\"><a href=\"#UITableViewCell的创建\" class=\"headerlink\" title=\"UITableViewCell的创建\"></a>UITableViewCell的创建</h3><p>我们都知道iOS中<code>tableview</code>的<code>cell</code>在创建的时候会用到重用机制，简单的说，就是把每个<code>cell</code>绑定一个标识，然后当<code>cell</code>在屏幕中显示的时候，系统首先会去缓冲池中取对应标志的<code>cell</code>，如果没有那就创建一个<code>cell</code>，如果有就直接拿出来使用，当<code>cell</code>滚动出屏幕的时候，系统会把<code>cell</code>放回缓冲池中，这样，缓冲池中最多也就一两个对象，而系统也不需要每次显示都创建对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</span><br><span class=\"line\">    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;identiffier&quot;];</span><br><span class=\"line\">    if (!cell) &#123;</span><br><span class=\"line\">        cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:@&quot;identiffier&quot;];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return cell;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个是一个默认的<code>tablecell</code>的创建，可以看到</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;identiffier&quot;];</span><br></pre></td></tr></table></figure>\n<p>先是去缓冲池去取<code>cell</code>，如果没有再去创建</p>\n<p>所以这个写法必须要加上下面的if判断，如果不加，而且缓冲池中没有cell，那么程序就会因为返回一个nil崩溃</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</span><br><span class=\"line\">    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;identiffier&quot; forIndexPath:indexPath];</span><br><span class=\"line\">    </span><br><span class=\"line\">    return cell;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在iOS6之后，又有了这种创建<code>cell</code>的方法，这种方法不需要写<code>if</code>，也就是说，如果缓冲池中没有，系统会自动的去创建一个<code>cell</code>，但是如果只是这么写还是不够的，系统还是会崩溃，因为你你要告诉tableview用什么标识创建一个什么<code>cell</code></p>\n<p>简单的说，你还要在tableview创建的时候写上下面的方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[tableView registerClass:[UITableViewCell class] forCellReuseIdentifier:@&quot;identiffier&quot;];</span><br></pre></td></tr></table></figure>\n<p>这样tableview就知道，在缓冲池中没有cell的时候，需要用什么类创建一个什么标识的cell</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><code>tableviewcell</code>的重用有两种方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;identiffier&quot;];</span><br></pre></td></tr></table></figure>\n<p>这种方法不需要注册cell，但如果缓冲池没有需要手动创建</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;identiffier&quot; forIndexPath:indexPath];</span><br></pre></td></tr></table></figure>\n<p>这种方法需要注册<code>cell</code>，但是不需要手动创建了</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p><code>cell</code>的创建通常有两种方法，平时使用的时候没有注意，这里记录一下</p>","more":"<h3 id=\"UITableViewCell的创建\"><a href=\"#UITableViewCell的创建\" class=\"headerlink\" title=\"UITableViewCell的创建\"></a>UITableViewCell的创建</h3><p>我们都知道iOS中<code>tableview</code>的<code>cell</code>在创建的时候会用到重用机制，简单的说，就是把每个<code>cell</code>绑定一个标识，然后当<code>cell</code>在屏幕中显示的时候，系统首先会去缓冲池中取对应标志的<code>cell</code>，如果没有那就创建一个<code>cell</code>，如果有就直接拿出来使用，当<code>cell</code>滚动出屏幕的时候，系统会把<code>cell</code>放回缓冲池中，这样，缓冲池中最多也就一两个对象，而系统也不需要每次显示都创建对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</span><br><span class=\"line\">    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;identiffier&quot;];</span><br><span class=\"line\">    if (!cell) &#123;</span><br><span class=\"line\">        cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:@&quot;identiffier&quot;];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return cell;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个是一个默认的<code>tablecell</code>的创建，可以看到</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;identiffier&quot;];</span><br></pre></td></tr></table></figure>\n<p>先是去缓冲池去取<code>cell</code>，如果没有再去创建</p>\n<p>所以这个写法必须要加上下面的if判断，如果不加，而且缓冲池中没有cell，那么程序就会因为返回一个nil崩溃</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</span><br><span class=\"line\">    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;identiffier&quot; forIndexPath:indexPath];</span><br><span class=\"line\">    </span><br><span class=\"line\">    return cell;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在iOS6之后，又有了这种创建<code>cell</code>的方法，这种方法不需要写<code>if</code>，也就是说，如果缓冲池中没有，系统会自动的去创建一个<code>cell</code>，但是如果只是这么写还是不够的，系统还是会崩溃，因为你你要告诉tableview用什么标识创建一个什么<code>cell</code></p>\n<p>简单的说，你还要在tableview创建的时候写上下面的方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[tableView registerClass:[UITableViewCell class] forCellReuseIdentifier:@&quot;identiffier&quot;];</span><br></pre></td></tr></table></figure>\n<p>这样tableview就知道，在缓冲池中没有cell的时候，需要用什么类创建一个什么标识的cell</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><code>tableviewcell</code>的重用有两种方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;identiffier&quot;];</span><br></pre></td></tr></table></figure>\n<p>这种方法不需要注册cell，但如果缓冲池没有需要手动创建</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;identiffier&quot; forIndexPath:indexPath];</span><br></pre></td></tr></table></figure>\n<p>这种方法需要注册<code>cell</code>，但是不需要手动创建了</p>"},{"title":"Xcode8 报错resource fork, Finder information, or similar detritus not allowed","date":"2017-03-31T03:02:30.000Z","_content":"\nXcode8 报错resource fork, Finder information, or similar detritus not allowed\n\n## 原因 ##\n\n这是因为Xcode8引进的新的安全机制, Code signing不允许app的bundle里面的文件有未知的文件系统扩展属性\n\n<!-- more -->\n\n## 解决方法 ##\n在终端中输入`xattr -lr <path_to_app_bundle>`可以查看存在未知扩展属性的文件\n\n在终端中输入`xattr -cr <path_to_app_bundle>`可以移除所有未知的扩展属性\n\n然后清理Xcode 重新build 工程\n","source":"_posts/Xcode8报错.md","raw":"---\ntitle: Xcode8 报错resource fork, Finder information, or similar detritus not allowed\ndate: 2017-03-31 11:02:30\ntags: [iOS]\n---\n\nXcode8 报错resource fork, Finder information, or similar detritus not allowed\n\n## 原因 ##\n\n这是因为Xcode8引进的新的安全机制, Code signing不允许app的bundle里面的文件有未知的文件系统扩展属性\n\n<!-- more -->\n\n## 解决方法 ##\n在终端中输入`xattr -lr <path_to_app_bundle>`可以查看存在未知扩展属性的文件\n\n在终端中输入`xattr -cr <path_to_app_bundle>`可以移除所有未知的扩展属性\n\n然后清理Xcode 重新build 工程\n","slug":"Xcode8报错","published":1,"updated":"2021-04-12T09:17:38.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqjdx1nm00125emu356bx8ar","content":"<p>Xcode8 报错resource fork, Finder information, or similar detritus not allowed</p>\n<h2 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h2><p>这是因为Xcode8引进的新的安全机制, Code signing不允许app的bundle里面的文件有未知的文件系统扩展属性</p>\n<a id=\"more\"></a>\n<h2 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h2><p>在终端中输入<code>xattr -lr &lt;path_to_app_bundle&gt;</code>可以查看存在未知扩展属性的文件</p>\n<p>在终端中输入<code>xattr -cr &lt;path_to_app_bundle&gt;</code>可以移除所有未知的扩展属性</p>\n<p>然后清理Xcode 重新build 工程</p>\n","site":{"data":{}},"excerpt":"<p>Xcode8 报错resource fork, Finder information, or similar detritus not allowed</p>\n<h2 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h2><p>这是因为Xcode8引进的新的安全机制, Code signing不允许app的bundle里面的文件有未知的文件系统扩展属性</p>","more":"<h2 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h2><p>在终端中输入<code>xattr -lr &lt;path_to_app_bundle&gt;</code>可以查看存在未知扩展属性的文件</p>\n<p>在终端中输入<code>xattr -cr &lt;path_to_app_bundle&gt;</code>可以移除所有未知的扩展属性</p>\n<p>然后清理Xcode 重新build 工程</p>"},{"title":"centOS Linux系统命令--VPS那些事","date":"2016-12-11T03:02:30.000Z","_content":"\n## 升级系统 ##\n\n```\nyum update -y\n```\n\n## 安装wget ##\nwget是一个从网络上自动下载文件的自由工具，支持通过HTTP、HTTPS、FTP三个最常见的TCP/IP协议下载，并可以使用HTTP代理。wget名称的由来是“World Wide Web”与“get”的结合\n\n```\nyum -y install wget\n```\n\n## 查看当前内核版本 ##\n```\nuname -r\n```\n\n<!----- more ----->\n\n## 修改内核 ##\n```\nrpm -ivh http://gongju.wn789.com/neihei/kernel-firmware-2.6.32-504.3.3.el6.noarch.rpm\n```\n\n```\nrpm -ivh http://gongju.wn789.com/neihei/kernel-2.6.32-504.3.3.el6.x86_64.rpm --force\n```\n\n## 查看内核 ##\n```\nrpm -qa | grep kernel\n```\n\n## 安装锐速破解版 ##\n```\nwget -N --no-check-certificate https://github.com/91yun/serverspeeder/raw/master/serverspeeder.sh && bash serverspeeder.sh\n```\n\n## 锐速卸载 ##\n```\nchattr -i /serverspeeder/etc/apx* && /serverspeeder/bin/serverSpeeder.sh uninstall -f\n```\n\n## 查看锐速状态 ##\n```\nservice serverSpeeder status\n```\n\n## 锐速相关 ##\n```\n service serverSpeeder start | stop | restart\n```\n\n## 搭建shadowsocks ##\n\n1. 安装\n\n安装pip\n\n```\nyum install python-setuptools && easy_install pip\n```\n\n安装shadowsocks\n\n```\npip install shadowsocks\n```\n\n2. 配置\n\n创建一个文件在`/etc/shadowsocks.json`\n\n```\ncd /etc\n\nvi shadowsocks.json\n```\n\n在json文件中写入如下信息\n\n```\n{\n        \"server\":\"x.x.x.x\",            #服务器IP地址\n        \"server_port\":8388,                 #服务监听端口\n        \"local_port\":1080,                  #本地连接端口\n        \"password\":\"barfoo\",               #加密传输使用到的密码\n        \"timeout\":600,                      #连接超时时间\n        \"method\":\"aes-256-cfb\"            #加密算法\n}\n```\n\n3. 启动、停止\n\n```\nssserver -c /etc/shadowsocks.json -d start | stop\n```\n\n4. 配置定时任务\n\n在vps的内存比较小的时候，shadowsocks容易被系统给kill掉，这时，我们就要有个定时任务去查看shadowsocks的服务状态\n\n首先，创建一个查看服务脚本\n\n```\n#! /bin/sh\n\nproc_name=\"shadowsocks.json\"\n\nnumber=`ps -ef | grep $proc_name | grep -v grep | wc -l`\n\nif [ $number -eq 0 ];then\n        ssserver -c /etc/shadowsocks.json -d start\nelse\n        ssserver -c /etc/shadowsocks.json -d restart\nfi\n```\n\n给脚本添加运行权限\n\n```\nchmod 777 xxxx.sh\n```\n\n将脚本加入定时任务中\n\n```\ncrontab -e  //打开定时任务配置\n```\n\n加入上面的脚本\n\n```\n*/1 * * * * ./xxx.sh  //注意脚本路径\n\n```\n\n启动定时任务\n\n```\nservice crond start\n```\n\n5.mac终端使用ss\n\n在终端中输入如下命令：\n\n```\nexport http_proxy=socks5://127.0.0.1:1080 # 配置http 代理访问\nexport https_proxy=socks5://127.0.0.1:1080 # 配置https 代理访问\nexport all_proxy=socks5://127.0.0.1:1080 # 配置http和https访问\nunset http_proxy  # 取消http 代理访问\nunset https_proxy # 取消https 代理访问\n```\n\n这样设置只能在当前启动的终端中有效，如果需要每次都走代理，则需要在`shell`文件中添加上述设置。\n\n上面命令中的端口号和地址，需要和`shadowsock`中`socks5`监听的地址和端口号一致\n\n\n## 安装使用Apache ##\n\n在Linux中Apache的名字叫`httpd`\n\n查看服务器版本\n\n```\napachectl -v    \n```\n\n安装Apache\n\n```\nyum install httpd\n```\n\n打开Apache\n\n```\n/etc/init.d/httpd start\n或者\nhttpd -k start | stop | restart\n```\n\nApache的配置文件路径\n\n```\n/etc/httpd/conf/httpd.conf\n```\n\n## 安装Mysql ##\n\n```\nyum list installed | grep mysql#查看是否已经安装\nyum install mysql-server#安装服务端\nyum install mysql-devel#这个应该是组件，不知道有什么用\nyum install mysql#安装客户端\n\nservice mysqld start#启动\nservice mysqld stop#停止\nservice mysqld restart#重启\nmysqladmin -u root password 123456#设置密码\nmysql -u root -p #登录\n```\n","source":"_posts/centOS系统命令.md","raw":"---\ntitle: centOS Linux系统命令--VPS那些事\ndate: 2016-12-11 11:02:30\ntags: Linux\n---\n\n## 升级系统 ##\n\n```\nyum update -y\n```\n\n## 安装wget ##\nwget是一个从网络上自动下载文件的自由工具，支持通过HTTP、HTTPS、FTP三个最常见的TCP/IP协议下载，并可以使用HTTP代理。wget名称的由来是“World Wide Web”与“get”的结合\n\n```\nyum -y install wget\n```\n\n## 查看当前内核版本 ##\n```\nuname -r\n```\n\n<!----- more ----->\n\n## 修改内核 ##\n```\nrpm -ivh http://gongju.wn789.com/neihei/kernel-firmware-2.6.32-504.3.3.el6.noarch.rpm\n```\n\n```\nrpm -ivh http://gongju.wn789.com/neihei/kernel-2.6.32-504.3.3.el6.x86_64.rpm --force\n```\n\n## 查看内核 ##\n```\nrpm -qa | grep kernel\n```\n\n## 安装锐速破解版 ##\n```\nwget -N --no-check-certificate https://github.com/91yun/serverspeeder/raw/master/serverspeeder.sh && bash serverspeeder.sh\n```\n\n## 锐速卸载 ##\n```\nchattr -i /serverspeeder/etc/apx* && /serverspeeder/bin/serverSpeeder.sh uninstall -f\n```\n\n## 查看锐速状态 ##\n```\nservice serverSpeeder status\n```\n\n## 锐速相关 ##\n```\n service serverSpeeder start | stop | restart\n```\n\n## 搭建shadowsocks ##\n\n1. 安装\n\n安装pip\n\n```\nyum install python-setuptools && easy_install pip\n```\n\n安装shadowsocks\n\n```\npip install shadowsocks\n```\n\n2. 配置\n\n创建一个文件在`/etc/shadowsocks.json`\n\n```\ncd /etc\n\nvi shadowsocks.json\n```\n\n在json文件中写入如下信息\n\n```\n{\n        \"server\":\"x.x.x.x\",            #服务器IP地址\n        \"server_port\":8388,                 #服务监听端口\n        \"local_port\":1080,                  #本地连接端口\n        \"password\":\"barfoo\",               #加密传输使用到的密码\n        \"timeout\":600,                      #连接超时时间\n        \"method\":\"aes-256-cfb\"            #加密算法\n}\n```\n\n3. 启动、停止\n\n```\nssserver -c /etc/shadowsocks.json -d start | stop\n```\n\n4. 配置定时任务\n\n在vps的内存比较小的时候，shadowsocks容易被系统给kill掉，这时，我们就要有个定时任务去查看shadowsocks的服务状态\n\n首先，创建一个查看服务脚本\n\n```\n#! /bin/sh\n\nproc_name=\"shadowsocks.json\"\n\nnumber=`ps -ef | grep $proc_name | grep -v grep | wc -l`\n\nif [ $number -eq 0 ];then\n        ssserver -c /etc/shadowsocks.json -d start\nelse\n        ssserver -c /etc/shadowsocks.json -d restart\nfi\n```\n\n给脚本添加运行权限\n\n```\nchmod 777 xxxx.sh\n```\n\n将脚本加入定时任务中\n\n```\ncrontab -e  //打开定时任务配置\n```\n\n加入上面的脚本\n\n```\n*/1 * * * * ./xxx.sh  //注意脚本路径\n\n```\n\n启动定时任务\n\n```\nservice crond start\n```\n\n5.mac终端使用ss\n\n在终端中输入如下命令：\n\n```\nexport http_proxy=socks5://127.0.0.1:1080 # 配置http 代理访问\nexport https_proxy=socks5://127.0.0.1:1080 # 配置https 代理访问\nexport all_proxy=socks5://127.0.0.1:1080 # 配置http和https访问\nunset http_proxy  # 取消http 代理访问\nunset https_proxy # 取消https 代理访问\n```\n\n这样设置只能在当前启动的终端中有效，如果需要每次都走代理，则需要在`shell`文件中添加上述设置。\n\n上面命令中的端口号和地址，需要和`shadowsock`中`socks5`监听的地址和端口号一致\n\n\n## 安装使用Apache ##\n\n在Linux中Apache的名字叫`httpd`\n\n查看服务器版本\n\n```\napachectl -v    \n```\n\n安装Apache\n\n```\nyum install httpd\n```\n\n打开Apache\n\n```\n/etc/init.d/httpd start\n或者\nhttpd -k start | stop | restart\n```\n\nApache的配置文件路径\n\n```\n/etc/httpd/conf/httpd.conf\n```\n\n## 安装Mysql ##\n\n```\nyum list installed | grep mysql#查看是否已经安装\nyum install mysql-server#安装服务端\nyum install mysql-devel#这个应该是组件，不知道有什么用\nyum install mysql#安装客户端\n\nservice mysqld start#启动\nservice mysqld stop#停止\nservice mysqld restart#重启\nmysqladmin -u root password 123456#设置密码\nmysql -u root -p #登录\n```\n","slug":"centOS系统命令","published":1,"updated":"2021-04-12T09:17:38.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqjdx1nn00145emuonudlgqp","content":"<h2 id=\"升级系统\"><a href=\"#升级系统\" class=\"headerlink\" title=\"升级系统\"></a>升级系统</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum update -y</span><br></pre></td></tr></table></figure>\n<h2 id=\"安装wget\"><a href=\"#安装wget\" class=\"headerlink\" title=\"安装wget\"></a>安装wget</h2><p>wget是一个从网络上自动下载文件的自由工具，支持通过HTTP、HTTPS、FTP三个最常见的TCP/IP协议下载，并可以使用HTTP代理。wget名称的由来是“World Wide Web”与“get”的结合</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum -y install wget</span><br></pre></td></tr></table></figure>\n<h2 id=\"查看当前内核版本\"><a href=\"#查看当前内核版本\" class=\"headerlink\" title=\"查看当前内核版本\"></a>查看当前内核版本</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uname -r</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h2 id=\"修改内核\"><a href=\"#修改内核\" class=\"headerlink\" title=\"修改内核\"></a>修改内核</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpm -ivh http://gongju.wn789.com/neihei/kernel-firmware-2.6.32-504.3.3.el6.noarch.rpm</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpm -ivh http://gongju.wn789.com/neihei/kernel-2.6.32-504.3.3.el6.x86_64.rpm --force</span><br></pre></td></tr></table></figure>\n<h2 id=\"查看内核\"><a href=\"#查看内核\" class=\"headerlink\" title=\"查看内核\"></a>查看内核</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpm -qa | grep kernel</span><br></pre></td></tr></table></figure>\n<h2 id=\"安装锐速破解版\"><a href=\"#安装锐速破解版\" class=\"headerlink\" title=\"安装锐速破解版\"></a>安装锐速破解版</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget -N --no-check-certificate https://github.com/91yun/serverspeeder/raw/master/serverspeeder.sh &amp;&amp; bash serverspeeder.sh</span><br></pre></td></tr></table></figure>\n<h2 id=\"锐速卸载\"><a href=\"#锐速卸载\" class=\"headerlink\" title=\"锐速卸载\"></a>锐速卸载</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chattr -i /serverspeeder/etc/apx* &amp;&amp; /serverspeeder/bin/serverSpeeder.sh uninstall -f</span><br></pre></td></tr></table></figure>\n<h2 id=\"查看锐速状态\"><a href=\"#查看锐速状态\" class=\"headerlink\" title=\"查看锐速状态\"></a>查看锐速状态</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service serverSpeeder status</span><br></pre></td></tr></table></figure>\n<h2 id=\"锐速相关\"><a href=\"#锐速相关\" class=\"headerlink\" title=\"锐速相关\"></a>锐速相关</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service serverSpeeder start | stop | restart</span><br></pre></td></tr></table></figure>\n<h2 id=\"搭建shadowsocks\"><a href=\"#搭建shadowsocks\" class=\"headerlink\" title=\"搭建shadowsocks\"></a>搭建shadowsocks</h2><ol>\n<li>安装</li>\n</ol>\n<p>安装pip</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install python-setuptools &amp;&amp; easy_install pip</span><br></pre></td></tr></table></figure>\n<p>安装shadowsocks</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install shadowsocks</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>配置</li>\n</ol>\n<p>创建一个文件在<code>/etc/shadowsocks.json</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /etc</span><br><span class=\"line\"></span><br><span class=\"line\">vi shadowsocks.json</span><br></pre></td></tr></table></figure>\n<p>在json文件中写入如下信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">        &quot;server&quot;:&quot;x.x.x.x&quot;,            #服务器IP地址</span><br><span class=\"line\">        &quot;server_port&quot;:8388,                 #服务监听端口</span><br><span class=\"line\">        &quot;local_port&quot;:1080,                  #本地连接端口</span><br><span class=\"line\">        &quot;password&quot;:&quot;barfoo&quot;,               #加密传输使用到的密码</span><br><span class=\"line\">        &quot;timeout&quot;:600,                      #连接超时时间</span><br><span class=\"line\">        &quot;method&quot;:&quot;aes-256-cfb&quot;            #加密算法</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>启动、停止</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssserver -c /etc/shadowsocks.json -d start | stop</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>配置定时任务</li>\n</ol>\n<p>在vps的内存比较小的时候，shadowsocks容易被系统给kill掉，这时，我们就要有个定时任务去查看shadowsocks的服务状态</p>\n<p>首先，创建一个查看服务脚本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#! /bin/sh</span><br><span class=\"line\"></span><br><span class=\"line\">proc_name=&quot;shadowsocks.json&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">number=`ps -ef | grep $proc_name | grep -v grep | wc -l`</span><br><span class=\"line\"></span><br><span class=\"line\">if [ $number -eq 0 ];then</span><br><span class=\"line\">        ssserver -c /etc/shadowsocks.json -d start</span><br><span class=\"line\">else</span><br><span class=\"line\">        ssserver -c /etc/shadowsocks.json -d restart</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n<p>给脚本添加运行权限</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod 777 xxxx.sh</span><br></pre></td></tr></table></figure>\n<p>将脚本加入定时任务中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">crontab -e  //打开定时任务配置</span><br></pre></td></tr></table></figure>\n<p>加入上面的脚本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*/1 * * * * ./xxx.sh  //注意脚本路径</span><br></pre></td></tr></table></figure>\n<p>启动定时任务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service crond start</span><br></pre></td></tr></table></figure>\n<p>5.mac终端使用ss</p>\n<p>在终端中输入如下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export http_proxy=socks5://127.0.0.1:1080 # 配置http 代理访问</span><br><span class=\"line\">export https_proxy=socks5://127.0.0.1:1080 # 配置https 代理访问</span><br><span class=\"line\">export all_proxy=socks5://127.0.0.1:1080 # 配置http和https访问</span><br><span class=\"line\">unset http_proxy  # 取消http 代理访问</span><br><span class=\"line\">unset https_proxy # 取消https 代理访问</span><br></pre></td></tr></table></figure>\n<p>这样设置只能在当前启动的终端中有效，如果需要每次都走代理，则需要在<code>shell</code>文件中添加上述设置。</p>\n<p>上面命令中的端口号和地址，需要和<code>shadowsock</code>中<code>socks5</code>监听的地址和端口号一致</p>\n<h2 id=\"安装使用Apache\"><a href=\"#安装使用Apache\" class=\"headerlink\" title=\"安装使用Apache\"></a>安装使用Apache</h2><p>在Linux中Apache的名字叫<code>httpd</code></p>\n<p>查看服务器版本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apachectl -v</span><br></pre></td></tr></table></figure>\n<p>安装Apache</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install httpd</span><br></pre></td></tr></table></figure>\n<p>打开Apache</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/etc/init.d/httpd start</span><br><span class=\"line\">或者</span><br><span class=\"line\">httpd -k start | stop | restart</span><br></pre></td></tr></table></figure>\n<p>Apache的配置文件路径</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/etc/httpd/conf/httpd.conf</span><br></pre></td></tr></table></figure>\n<h2 id=\"安装Mysql\"><a href=\"#安装Mysql\" class=\"headerlink\" title=\"安装Mysql\"></a>安装Mysql</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum list installed | grep mysql#查看是否已经安装</span><br><span class=\"line\">yum install mysql-server#安装服务端</span><br><span class=\"line\">yum install mysql-devel#这个应该是组件，不知道有什么用</span><br><span class=\"line\">yum install mysql#安装客户端</span><br><span class=\"line\"></span><br><span class=\"line\">service mysqld start#启动</span><br><span class=\"line\">service mysqld stop#停止</span><br><span class=\"line\">service mysqld restart#重启</span><br><span class=\"line\">mysqladmin -u root password 123456#设置密码</span><br><span class=\"line\">mysql -u root -p #登录</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"升级系统\"><a href=\"#升级系统\" class=\"headerlink\" title=\"升级系统\"></a>升级系统</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum update -y</span><br></pre></td></tr></table></figure>\n<h2 id=\"安装wget\"><a href=\"#安装wget\" class=\"headerlink\" title=\"安装wget\"></a>安装wget</h2><p>wget是一个从网络上自动下载文件的自由工具，支持通过HTTP、HTTPS、FTP三个最常见的TCP/IP协议下载，并可以使用HTTP代理。wget名称的由来是“World Wide Web”与“get”的结合</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum -y install wget</span><br></pre></td></tr></table></figure>\n<h2 id=\"查看当前内核版本\"><a href=\"#查看当前内核版本\" class=\"headerlink\" title=\"查看当前内核版本\"></a>查看当前内核版本</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uname -r</span><br></pre></td></tr></table></figure>","more":"<h2 id=\"修改内核\"><a href=\"#修改内核\" class=\"headerlink\" title=\"修改内核\"></a>修改内核</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpm -ivh http://gongju.wn789.com/neihei/kernel-firmware-2.6.32-504.3.3.el6.noarch.rpm</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpm -ivh http://gongju.wn789.com/neihei/kernel-2.6.32-504.3.3.el6.x86_64.rpm --force</span><br></pre></td></tr></table></figure>\n<h2 id=\"查看内核\"><a href=\"#查看内核\" class=\"headerlink\" title=\"查看内核\"></a>查看内核</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rpm -qa | grep kernel</span><br></pre></td></tr></table></figure>\n<h2 id=\"安装锐速破解版\"><a href=\"#安装锐速破解版\" class=\"headerlink\" title=\"安装锐速破解版\"></a>安装锐速破解版</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget -N --no-check-certificate https://github.com/91yun/serverspeeder/raw/master/serverspeeder.sh &amp;&amp; bash serverspeeder.sh</span><br></pre></td></tr></table></figure>\n<h2 id=\"锐速卸载\"><a href=\"#锐速卸载\" class=\"headerlink\" title=\"锐速卸载\"></a>锐速卸载</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chattr -i /serverspeeder/etc/apx* &amp;&amp; /serverspeeder/bin/serverSpeeder.sh uninstall -f</span><br></pre></td></tr></table></figure>\n<h2 id=\"查看锐速状态\"><a href=\"#查看锐速状态\" class=\"headerlink\" title=\"查看锐速状态\"></a>查看锐速状态</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service serverSpeeder status</span><br></pre></td></tr></table></figure>\n<h2 id=\"锐速相关\"><a href=\"#锐速相关\" class=\"headerlink\" title=\"锐速相关\"></a>锐速相关</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service serverSpeeder start | stop | restart</span><br></pre></td></tr></table></figure>\n<h2 id=\"搭建shadowsocks\"><a href=\"#搭建shadowsocks\" class=\"headerlink\" title=\"搭建shadowsocks\"></a>搭建shadowsocks</h2><ol>\n<li>安装</li>\n</ol>\n<p>安装pip</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install python-setuptools &amp;&amp; easy_install pip</span><br></pre></td></tr></table></figure>\n<p>安装shadowsocks</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install shadowsocks</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>配置</li>\n</ol>\n<p>创建一个文件在<code>/etc/shadowsocks.json</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /etc</span><br><span class=\"line\"></span><br><span class=\"line\">vi shadowsocks.json</span><br></pre></td></tr></table></figure>\n<p>在json文件中写入如下信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">        &quot;server&quot;:&quot;x.x.x.x&quot;,            #服务器IP地址</span><br><span class=\"line\">        &quot;server_port&quot;:8388,                 #服务监听端口</span><br><span class=\"line\">        &quot;local_port&quot;:1080,                  #本地连接端口</span><br><span class=\"line\">        &quot;password&quot;:&quot;barfoo&quot;,               #加密传输使用到的密码</span><br><span class=\"line\">        &quot;timeout&quot;:600,                      #连接超时时间</span><br><span class=\"line\">        &quot;method&quot;:&quot;aes-256-cfb&quot;            #加密算法</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>启动、停止</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssserver -c /etc/shadowsocks.json -d start | stop</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>配置定时任务</li>\n</ol>\n<p>在vps的内存比较小的时候，shadowsocks容易被系统给kill掉，这时，我们就要有个定时任务去查看shadowsocks的服务状态</p>\n<p>首先，创建一个查看服务脚本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#! /bin/sh</span><br><span class=\"line\"></span><br><span class=\"line\">proc_name=&quot;shadowsocks.json&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">number=`ps -ef | grep $proc_name | grep -v grep | wc -l`</span><br><span class=\"line\"></span><br><span class=\"line\">if [ $number -eq 0 ];then</span><br><span class=\"line\">        ssserver -c /etc/shadowsocks.json -d start</span><br><span class=\"line\">else</span><br><span class=\"line\">        ssserver -c /etc/shadowsocks.json -d restart</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n<p>给脚本添加运行权限</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod 777 xxxx.sh</span><br></pre></td></tr></table></figure>\n<p>将脚本加入定时任务中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">crontab -e  //打开定时任务配置</span><br></pre></td></tr></table></figure>\n<p>加入上面的脚本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*/1 * * * * ./xxx.sh  //注意脚本路径</span><br></pre></td></tr></table></figure>\n<p>启动定时任务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service crond start</span><br></pre></td></tr></table></figure>\n<p>5.mac终端使用ss</p>\n<p>在终端中输入如下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export http_proxy=socks5://127.0.0.1:1080 # 配置http 代理访问</span><br><span class=\"line\">export https_proxy=socks5://127.0.0.1:1080 # 配置https 代理访问</span><br><span class=\"line\">export all_proxy=socks5://127.0.0.1:1080 # 配置http和https访问</span><br><span class=\"line\">unset http_proxy  # 取消http 代理访问</span><br><span class=\"line\">unset https_proxy # 取消https 代理访问</span><br></pre></td></tr></table></figure>\n<p>这样设置只能在当前启动的终端中有效，如果需要每次都走代理，则需要在<code>shell</code>文件中添加上述设置。</p>\n<p>上面命令中的端口号和地址，需要和<code>shadowsock</code>中<code>socks5</code>监听的地址和端口号一致</p>\n<h2 id=\"安装使用Apache\"><a href=\"#安装使用Apache\" class=\"headerlink\" title=\"安装使用Apache\"></a>安装使用Apache</h2><p>在Linux中Apache的名字叫<code>httpd</code></p>\n<p>查看服务器版本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apachectl -v</span><br></pre></td></tr></table></figure>\n<p>安装Apache</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install httpd</span><br></pre></td></tr></table></figure>\n<p>打开Apache</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/etc/init.d/httpd start</span><br><span class=\"line\">或者</span><br><span class=\"line\">httpd -k start | stop | restart</span><br></pre></td></tr></table></figure>\n<p>Apache的配置文件路径</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/etc/httpd/conf/httpd.conf</span><br></pre></td></tr></table></figure>\n<h2 id=\"安装Mysql\"><a href=\"#安装Mysql\" class=\"headerlink\" title=\"安装Mysql\"></a>安装Mysql</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum list installed | grep mysql#查看是否已经安装</span><br><span class=\"line\">yum install mysql-server#安装服务端</span><br><span class=\"line\">yum install mysql-devel#这个应该是组件，不知道有什么用</span><br><span class=\"line\">yum install mysql#安装客户端</span><br><span class=\"line\"></span><br><span class=\"line\">service mysqld start#启动</span><br><span class=\"line\">service mysqld stop#停止</span><br><span class=\"line\">service mysqld restart#重启</span><br><span class=\"line\">mysqladmin -u root password 123456#设置密码</span><br><span class=\"line\">mysql -u root -p #登录</span><br></pre></td></tr></table></figure>"},{"title":"anaconda的安装和使用","date":"2021-04-12T10:43:57.000Z","_content":"\n## 前言 ##\n\n最近在搭建一个`python`工程的环境的时候，发现需要使用一些指定版本的软件环境，所以就想到了使用`Anaconda`\n\n<!-- more -->\n\n### 简介 ###\n\n> `Anaconda`指的是一个开源的[Python](https://baike.baidu.com/item/Python)发行版本，其包含了[conda](https://baike.baidu.com/item/conda/4500060)、Python等180多个科学包及其依赖项。 [1] 因为包含了大量的科学包，Anaconda 的下载文件比较大（约 531 MB），如果只需要某些包，或者需要节省带宽或[存储空间](https://baike.baidu.com/item/存储空间/10657950)，也可以使用**Miniconda**这个较小的发行版（仅包含conda和 Python）。\n\n### 安装 ###\n\n`Anaconda`有两种安装方式，都可以从[官网下载](https://www.anaconda.com/products/individual#Downloads)\n\n#### 图形界面 ####\n\n双击下载好的`pkg` ,然后无脑下一步就好\n\n#### 命令行 ####\n\n下载好命令行安装包，其实就是一个`sh`脚本,然后运行安装\n\n```\nbash ~/Downloads/xxx.sh\n```\n\n### 使用 ###\n\n安装完没有任何反应，在终端敲`conda --version` 也显示找不到`conda`命令\n\n这时候需要在终端启动一下\n\n```shell\n//如果安装的时候，选的是为所有人安装，则运行此命令\nsource /opt/anaconda3/bin/activate\n\n//如果安装的时候，选的是自己的账号，则运行此命令，可以用 echo $USER 查看username\nsource /Users/my_username/opt/anaconda3/bin/activate\n\n//初始化一下命令行 zsh 使用：\nconda init zsh\n//bash shell 使用\nconda init\n\n//查看是否设置成功\nconda list\n\n```\n\n#### 环境管理 ####\n\n##### 创建新环境 #####\n\n```sh\nconda create --name <env_name> <package_names>\n\n//eg:\nconda create -n python python=3.8\n\n```\n\n##### 切换环境 #####\n\n```sh\nsource activate <env_name>\n\n//eg:\nsource activate python\n\n```\n\n##### 查看环境 #####\n\n```sh\nconda info --envs\n//or\nconda info -e\n//or\nconda info --envs\n```\n\n##### 退出环境 #####\n\n```\nsource deactivate\n```\n\n##### 删除环境 #####\n\n```\nconda remove --name <env_name> --all\n```\n\n\n\n\n\n","source":"_posts/anaconda的安装和使用.md","raw":"---\ntitle: anaconda的安装和使用\ndate: 2021-04-12 18:43:57\ntags:\n---\n\n## 前言 ##\n\n最近在搭建一个`python`工程的环境的时候，发现需要使用一些指定版本的软件环境，所以就想到了使用`Anaconda`\n\n<!-- more -->\n\n### 简介 ###\n\n> `Anaconda`指的是一个开源的[Python](https://baike.baidu.com/item/Python)发行版本，其包含了[conda](https://baike.baidu.com/item/conda/4500060)、Python等180多个科学包及其依赖项。 [1] 因为包含了大量的科学包，Anaconda 的下载文件比较大（约 531 MB），如果只需要某些包，或者需要节省带宽或[存储空间](https://baike.baidu.com/item/存储空间/10657950)，也可以使用**Miniconda**这个较小的发行版（仅包含conda和 Python）。\n\n### 安装 ###\n\n`Anaconda`有两种安装方式，都可以从[官网下载](https://www.anaconda.com/products/individual#Downloads)\n\n#### 图形界面 ####\n\n双击下载好的`pkg` ,然后无脑下一步就好\n\n#### 命令行 ####\n\n下载好命令行安装包，其实就是一个`sh`脚本,然后运行安装\n\n```\nbash ~/Downloads/xxx.sh\n```\n\n### 使用 ###\n\n安装完没有任何反应，在终端敲`conda --version` 也显示找不到`conda`命令\n\n这时候需要在终端启动一下\n\n```shell\n//如果安装的时候，选的是为所有人安装，则运行此命令\nsource /opt/anaconda3/bin/activate\n\n//如果安装的时候，选的是自己的账号，则运行此命令，可以用 echo $USER 查看username\nsource /Users/my_username/opt/anaconda3/bin/activate\n\n//初始化一下命令行 zsh 使用：\nconda init zsh\n//bash shell 使用\nconda init\n\n//查看是否设置成功\nconda list\n\n```\n\n#### 环境管理 ####\n\n##### 创建新环境 #####\n\n```sh\nconda create --name <env_name> <package_names>\n\n//eg:\nconda create -n python python=3.8\n\n```\n\n##### 切换环境 #####\n\n```sh\nsource activate <env_name>\n\n//eg:\nsource activate python\n\n```\n\n##### 查看环境 #####\n\n```sh\nconda info --envs\n//or\nconda info -e\n//or\nconda info --envs\n```\n\n##### 退出环境 #####\n\n```\nsource deactivate\n```\n\n##### 删除环境 #####\n\n```\nconda remove --name <env_name> --all\n```\n\n\n\n\n\n","slug":"anaconda的安装和使用","published":1,"updated":"2021-04-12T11:22:01.152Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqjdx1no00175emu952nutwk","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>最近在搭建一个<code>python</code>工程的环境的时候，发现需要使用一些指定版本的软件环境，所以就想到了使用<code>Anaconda</code></p>\n<a id=\"more\"></a>\n<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><blockquote>\n<p><code>Anaconda</code>指的是一个开源的<a href=\"https://baike.baidu.com/item/Python\" target=\"_blank\" rel=\"noopener\">Python</a>发行版本，其包含了<a href=\"https://baike.baidu.com/item/conda/4500060\" target=\"_blank\" rel=\"noopener\">conda</a>、Python等180多个科学包及其依赖项。 [1] 因为包含了大量的科学包，Anaconda 的下载文件比较大（约 531 MB），如果只需要某些包，或者需要节省带宽或<a href=\"https://baike.baidu.com/item/存储空间/10657950\" target=\"_blank\" rel=\"noopener\">存储空间</a>，也可以使用<strong>Miniconda</strong>这个较小的发行版（仅包含conda和 Python）。</p>\n</blockquote>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p><code>Anaconda</code>有两种安装方式，都可以从<a href=\"https://www.anaconda.com/products/individual#Downloads\" target=\"_blank\" rel=\"noopener\">官网下载</a></p>\n<h4 id=\"图形界面\"><a href=\"#图形界面\" class=\"headerlink\" title=\"图形界面\"></a>图形界面</h4><p>双击下载好的<code>pkg</code> ,然后无脑下一步就好</p>\n<h4 id=\"命令行\"><a href=\"#命令行\" class=\"headerlink\" title=\"命令行\"></a>命令行</h4><p>下载好命令行安装包，其实就是一个<code>sh</code>脚本,然后运行安装</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bash ~/Downloads/xxx.sh</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>安装完没有任何反应，在终端敲<code>conda --version</code> 也显示找不到<code>conda</code>命令</p>\n<p>这时候需要在终端启动一下</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//如果安装的时候，选的是为所有人安装，则运行此命令</span><br><span class=\"line\">source /opt/anaconda3/bin/activate</span><br><span class=\"line\"></span><br><span class=\"line\">//如果安装的时候，选的是自己的账号，则运行此命令，可以用 echo $USER 查看username</span><br><span class=\"line\">source /Users/my_username/opt/anaconda3/bin/activate</span><br><span class=\"line\"></span><br><span class=\"line\">//初始化一下命令行 zsh 使用：</span><br><span class=\"line\">conda init zsh</span><br><span class=\"line\">//bash shell 使用</span><br><span class=\"line\">conda init</span><br><span class=\"line\"></span><br><span class=\"line\">//查看是否设置成功</span><br><span class=\"line\">conda list</span><br></pre></td></tr></table></figure>\n<h4 id=\"环境管理\"><a href=\"#环境管理\" class=\"headerlink\" title=\"环境管理\"></a>环境管理</h4><h5 id=\"创建新环境\"><a href=\"#创建新环境\" class=\"headerlink\" title=\"创建新环境\"></a>创建新环境</h5><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda create --name &lt;env_name&gt; &lt;package_names&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">//eg:</span><br><span class=\"line\">conda create -n python python=3.8</span><br></pre></td></tr></table></figure>\n<h5 id=\"切换环境\"><a href=\"#切换环境\" class=\"headerlink\" title=\"切换环境\"></a>切换环境</h5><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">source</span> activate &lt;env_name&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">//eg:</span><br><span class=\"line\"><span class=\"built_in\">source</span> activate python</span><br></pre></td></tr></table></figure>\n<h5 id=\"查看环境\"><a href=\"#查看环境\" class=\"headerlink\" title=\"查看环境\"></a>查看环境</h5><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda info --envs</span><br><span class=\"line\">//or</span><br><span class=\"line\">conda info -e</span><br><span class=\"line\">//or</span><br><span class=\"line\">conda info --envs</span><br></pre></td></tr></table></figure>\n<h5 id=\"退出环境\"><a href=\"#退出环境\" class=\"headerlink\" title=\"退出环境\"></a>退出环境</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source deactivate</span><br></pre></td></tr></table></figure>\n<h5 id=\"删除环境\"><a href=\"#删除环境\" class=\"headerlink\" title=\"删除环境\"></a>删除环境</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda remove --name &lt;env_name&gt; --all</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>最近在搭建一个<code>python</code>工程的环境的时候，发现需要使用一些指定版本的软件环境，所以就想到了使用<code>Anaconda</code></p>","more":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><blockquote>\n<p><code>Anaconda</code>指的是一个开源的<a href=\"https://baike.baidu.com/item/Python\" target=\"_blank\" rel=\"noopener\">Python</a>发行版本，其包含了<a href=\"https://baike.baidu.com/item/conda/4500060\" target=\"_blank\" rel=\"noopener\">conda</a>、Python等180多个科学包及其依赖项。 [1] 因为包含了大量的科学包，Anaconda 的下载文件比较大（约 531 MB），如果只需要某些包，或者需要节省带宽或<a href=\"https://baike.baidu.com/item/存储空间/10657950\" target=\"_blank\" rel=\"noopener\">存储空间</a>，也可以使用<strong>Miniconda</strong>这个较小的发行版（仅包含conda和 Python）。</p>\n</blockquote>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p><code>Anaconda</code>有两种安装方式，都可以从<a href=\"https://www.anaconda.com/products/individual#Downloads\" target=\"_blank\" rel=\"noopener\">官网下载</a></p>\n<h4 id=\"图形界面\"><a href=\"#图形界面\" class=\"headerlink\" title=\"图形界面\"></a>图形界面</h4><p>双击下载好的<code>pkg</code> ,然后无脑下一步就好</p>\n<h4 id=\"命令行\"><a href=\"#命令行\" class=\"headerlink\" title=\"命令行\"></a>命令行</h4><p>下载好命令行安装包，其实就是一个<code>sh</code>脚本,然后运行安装</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bash ~/Downloads/xxx.sh</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>安装完没有任何反应，在终端敲<code>conda --version</code> 也显示找不到<code>conda</code>命令</p>\n<p>这时候需要在终端启动一下</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//如果安装的时候，选的是为所有人安装，则运行此命令</span><br><span class=\"line\">source /opt/anaconda3/bin/activate</span><br><span class=\"line\"></span><br><span class=\"line\">//如果安装的时候，选的是自己的账号，则运行此命令，可以用 echo $USER 查看username</span><br><span class=\"line\">source /Users/my_username/opt/anaconda3/bin/activate</span><br><span class=\"line\"></span><br><span class=\"line\">//初始化一下命令行 zsh 使用：</span><br><span class=\"line\">conda init zsh</span><br><span class=\"line\">//bash shell 使用</span><br><span class=\"line\">conda init</span><br><span class=\"line\"></span><br><span class=\"line\">//查看是否设置成功</span><br><span class=\"line\">conda list</span><br></pre></td></tr></table></figure>\n<h4 id=\"环境管理\"><a href=\"#环境管理\" class=\"headerlink\" title=\"环境管理\"></a>环境管理</h4><h5 id=\"创建新环境\"><a href=\"#创建新环境\" class=\"headerlink\" title=\"创建新环境\"></a>创建新环境</h5><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda create --name &lt;env_name&gt; &lt;package_names&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">//eg:</span><br><span class=\"line\">conda create -n python python=3.8</span><br></pre></td></tr></table></figure>\n<h5 id=\"切换环境\"><a href=\"#切换环境\" class=\"headerlink\" title=\"切换环境\"></a>切换环境</h5><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">source</span> activate &lt;env_name&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">//eg:</span><br><span class=\"line\"><span class=\"built_in\">source</span> activate python</span><br></pre></td></tr></table></figure>\n<h5 id=\"查看环境\"><a href=\"#查看环境\" class=\"headerlink\" title=\"查看环境\"></a>查看环境</h5><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda info --envs</span><br><span class=\"line\">//or</span><br><span class=\"line\">conda info -e</span><br><span class=\"line\">//or</span><br><span class=\"line\">conda info --envs</span><br></pre></td></tr></table></figure>\n<h5 id=\"退出环境\"><a href=\"#退出环境\" class=\"headerlink\" title=\"退出环境\"></a>退出环境</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source deactivate</span><br></pre></td></tr></table></figure>\n<h5 id=\"删除环境\"><a href=\"#删除环境\" class=\"headerlink\" title=\"删除环境\"></a>删除环境</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda remove --name &lt;env_name&gt; --all</span><br></pre></td></tr></table></figure>"},{"title":"hexo部署报错解决","date":"2017-12-06T15:21:15.000Z","_content":"\n## 前言 ##\n\n由于换了一个电脑搭建`hexo`,在部署的时候报错了，这里记录一下解决办法：\n\n删除`.deploy_git`\n\n<!-- more -->\n\n### 报错操作 ###\n\n从`git`拉下代码，在新搭建的`hexo`环境中`hexo d`部署的时候报一下错误\n\n```\n~/Desktop/myBlog (master ✘)✖✹✭ ᐅ hexo d\nINFO  Deploying: git\nINFO  Clearing .deploy_git folder...\nINFO  Copying files from public folder...\nfatal: in unpopulated submodule '.deploy_git'\nFATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html\nError: fatal: in unpopulated submodule '.deploy_git'\n\n    at ChildProcess.<anonymous> (/Users/xxx/Desktop/myBlog/node_modules/hexo-util/lib/spawn.js:37:17)\n    at ChildProcess.emit (events.js:182:13)\n    at maybeClose (internal/child_process.js:978:16)\n    at Socket.stream.socket.on (internal/child_process.js:395:11)\n    at Socket.emit (events.js:182:13)\n    at Pipe._handle.close (net.js:616:12)\n```\n\n### 解决办法 ###\n\n解决办法很简单，把博客目录下的`.deploy_git`删除重新构建部署就好，命令如下\n\n```\nrm -rf .deploy_git\nhexo g\nhexo d\n```\n\n看来以后要把这个文件夹添加到`.gitignore`文件中试试\n","source":"_posts/hexo部署报错解决.md","raw":"---\ntitle: hexo部署报错解决\ndate: 2017-12-06 23:21:15\ntags: [日常]\n---\n\n## 前言 ##\n\n由于换了一个电脑搭建`hexo`,在部署的时候报错了，这里记录一下解决办法：\n\n删除`.deploy_git`\n\n<!-- more -->\n\n### 报错操作 ###\n\n从`git`拉下代码，在新搭建的`hexo`环境中`hexo d`部署的时候报一下错误\n\n```\n~/Desktop/myBlog (master ✘)✖✹✭ ᐅ hexo d\nINFO  Deploying: git\nINFO  Clearing .deploy_git folder...\nINFO  Copying files from public folder...\nfatal: in unpopulated submodule '.deploy_git'\nFATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html\nError: fatal: in unpopulated submodule '.deploy_git'\n\n    at ChildProcess.<anonymous> (/Users/xxx/Desktop/myBlog/node_modules/hexo-util/lib/spawn.js:37:17)\n    at ChildProcess.emit (events.js:182:13)\n    at maybeClose (internal/child_process.js:978:16)\n    at Socket.stream.socket.on (internal/child_process.js:395:11)\n    at Socket.emit (events.js:182:13)\n    at Pipe._handle.close (net.js:616:12)\n```\n\n### 解决办法 ###\n\n解决办法很简单，把博客目录下的`.deploy_git`删除重新构建部署就好，命令如下\n\n```\nrm -rf .deploy_git\nhexo g\nhexo d\n```\n\n看来以后要把这个文件夹添加到`.gitignore`文件中试试\n","slug":"hexo部署报错解决","published":1,"updated":"2021-04-12T09:17:38.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqjdx1np00195emu4f0o0bzt","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>由于换了一个电脑搭建<code>hexo</code>,在部署的时候报错了，这里记录一下解决办法：</p>\n<p>删除<code>.deploy_git</code></p>\n<a id=\"more\"></a>\n<h3 id=\"报错操作\"><a href=\"#报错操作\" class=\"headerlink\" title=\"报错操作\"></a>报错操作</h3><p>从<code>git</code>拉下代码，在新搭建的<code>hexo</code>环境中<code>hexo d</code>部署的时候报一下错误</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~/Desktop/myBlog (master ✘)✖✹✭ ᐅ hexo d</span><br><span class=\"line\">INFO  Deploying: git</span><br><span class=\"line\">INFO  Clearing .deploy_git folder...</span><br><span class=\"line\">INFO  Copying files from public folder...</span><br><span class=\"line\">fatal: in unpopulated submodule &apos;.deploy_git&apos;</span><br><span class=\"line\">FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</span><br><span class=\"line\">Error: fatal: in unpopulated submodule &apos;.deploy_git&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">    at ChildProcess.&lt;anonymous&gt; (/Users/xxx/Desktop/myBlog/node_modules/hexo-util/lib/spawn.js:37:17)</span><br><span class=\"line\">    at ChildProcess.emit (events.js:182:13)</span><br><span class=\"line\">    at maybeClose (internal/child_process.js:978:16)</span><br><span class=\"line\">    at Socket.stream.socket.on (internal/child_process.js:395:11)</span><br><span class=\"line\">    at Socket.emit (events.js:182:13)</span><br><span class=\"line\">    at Pipe._handle.close (net.js:616:12)</span><br></pre></td></tr></table></figure>\n<h3 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h3><p>解决办法很简单，把博客目录下的<code>.deploy_git</code>删除重新构建部署就好，命令如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -rf .deploy_git</span><br><span class=\"line\">hexo g</span><br><span class=\"line\">hexo d</span><br></pre></td></tr></table></figure>\n<p>看来以后要把这个文件夹添加到<code>.gitignore</code>文件中试试</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>由于换了一个电脑搭建<code>hexo</code>,在部署的时候报错了，这里记录一下解决办法：</p>\n<p>删除<code>.deploy_git</code></p>","more":"<h3 id=\"报错操作\"><a href=\"#报错操作\" class=\"headerlink\" title=\"报错操作\"></a>报错操作</h3><p>从<code>git</code>拉下代码，在新搭建的<code>hexo</code>环境中<code>hexo d</code>部署的时候报一下错误</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~/Desktop/myBlog (master ✘)✖✹✭ ᐅ hexo d</span><br><span class=\"line\">INFO  Deploying: git</span><br><span class=\"line\">INFO  Clearing .deploy_git folder...</span><br><span class=\"line\">INFO  Copying files from public folder...</span><br><span class=\"line\">fatal: in unpopulated submodule &apos;.deploy_git&apos;</span><br><span class=\"line\">FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</span><br><span class=\"line\">Error: fatal: in unpopulated submodule &apos;.deploy_git&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">    at ChildProcess.&lt;anonymous&gt; (/Users/xxx/Desktop/myBlog/node_modules/hexo-util/lib/spawn.js:37:17)</span><br><span class=\"line\">    at ChildProcess.emit (events.js:182:13)</span><br><span class=\"line\">    at maybeClose (internal/child_process.js:978:16)</span><br><span class=\"line\">    at Socket.stream.socket.on (internal/child_process.js:395:11)</span><br><span class=\"line\">    at Socket.emit (events.js:182:13)</span><br><span class=\"line\">    at Pipe._handle.close (net.js:616:12)</span><br></pre></td></tr></table></figure>\n<h3 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h3><p>解决办法很简单，把博客目录下的<code>.deploy_git</code>删除重新构建部署就好，命令如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -rf .deploy_git</span><br><span class=\"line\">hexo g</span><br><span class=\"line\">hexo d</span><br></pre></td></tr></table></figure>\n<p>看来以后要把这个文件夹添加到<code>.gitignore</code>文件中试试</p>"},{"title":"iOS的CF和OC中间的类型转换","date":"2017-01-11T03:10:12.000Z","_content":"\n# iOS的CF和OC中间的类型转换 #\n\n## Toll-Free bridged ##\n\n`Toll-Free bridged`  是Core Foundation和Foundation之间交换使用数据类型的技术.即同一数据类型既可作为Core Foundation函数的参数,也可以作为接收者向其发送Objective-C消息.\n\n说的简单点,就是OC中的有些类型,通过`Toll-Free bridged` 既可以当做Core Foundation的类型使用(CFxxxx),又可以当做Foundation的类型使用(NSxxxx).\n\n\n<!----- more ----->\n\n\n## Toll-Free bridged原理 ##\n\n每一个能够bridge的ObjC类，都是一个类簇（class cluster）。类簇是一个公开的抽象类，但其核心功能的是在不同的私有子类中实现的，公开类只暴露一致的接口和实现一些辅助的创建方法。而与该ObjC类相对应的Core Foundation类的内存结构，正好与类簇的其中一个私有子类相同。\n\n举个例子，NSString是一个类簇，一个公开的抽象类，但每次创建一个NSString的实例时，实际上我们会获得其中一个私有子类的实例。而NSString的其中一个私有子类实现既为NSCFString，其内存的结构与CFString是相同的，CFString的isa指针就指向NSCFString类，即CFString对象就是一个NSCFString类的实例。\n所以，当NSString的实现刚好是NSCFString的时候，他们两者之间的转换是相当容易而直接的，他们就是同一个类的实例。\n\n当NSString的实现不是NSCFString的时候（比如我们自己subclass了NSString），我们调用CF函数，就需要先检查对象的具体实现。如果发现其不是NSCFString，我们不会调用CF函数的实现来获得结果，而是通过给对象发送与函数功能相对应的ObjC消息（调用相对应的NSString的接口）来获得其结果。\n\n例如CFStringGetLength函数，当收到一个作为参数传递进来的对象时，会先确认该对象到底是不是NSCFString实现。如果是的话，就会直接调用CFStringGetLength函数的实现来获得字符串的长度；如果不是的话，会给对象发送length消息（调用NSString的length接口），来得到字符串的长度。\n\n## Toll-Free bridged的内存管理 ##\n\n在ARC中编译器不知道如何处理这个同时拥有ObjC和CFTypeRef指向的对象,所以你必须为编译器提供额外的信息：将类型显示转换为互换类型；同时可能需明确对象的声明周期。 因此我们需要使用 `__bridge`, `__bridge_retained`, `__bridge_transfer` 修饰符告诉编译器该如何去做。\n\n### __bridge ###\n\n```objectivec\n//objc to cf\n NSString *str = @\"hello\";\n CFStringRef cfStr = (__bridge CFStringRef)str;\n CFRelease(cfStr);//这里不需要release\n```\n编译器会继续负责nsStr的内存管理的事情，不会在bridge的时候retain对象，所以也不需要开发者在CF 一端释放。需要注意的是，当nsStr被释放的时候（比如出了作用域），意味着cfStr指向的对象被释放了，这时如果继续使用cfStr将会引起程序崩溃。\n\n```objectivec\n//cf to objc\n CFStringRef cfStr = CFStringCreateWithCString(kCFAllpacatorDefaule,\"hello\",kCFStringEncodingUTF8);\n NSString *str = (__bridge NSString *)(cfStr);\n CFRelease(cfStr);//这里需要release\n```\n\n bridge的时候编译器不会做任何内存管理的事情，bridge之后，编译器会负责ObjC一端的内存管理的事情。同时，开发者需要负责管理CF 一端的内存管理的事情，需要在bridge之后，负责release对象。\n\n### __bridge_retained ###\n接着上面的例子，Foundation类型对应的Core Foundation类型时，为了防止str被释放，引起我们使用cfStr的时候程序崩溃，可以使用__bridge_retained修饰符。这意味着，在bridge的时候，编译器会retain对象，而由开发者在CF一端负责release。这样，就算str在objc一端被释放，只要开发者不手动去释放cfStr，其指向的对象就不会被真的销毁。但同时，开发者也必须保证和负责对象的释放。\n\n```objectivec\n//objc to cf\n NSString *str = @\"hello\";\n CFStringRef cfStr = (__bridge_retained CFStringRef)str;\n CFRelease(cfStr);//这里不需要release\n```\n\n### __bridge_transfer ###\n当Core Foundation类型转化为Foundation类型时，如果使用__bridge修饰符在cf转objc的时候非常的麻烦，我们既需要一个CFTypeRef的变量，还需要在bridge之后负责释放。这时我们可以使用__bridge_transfer，意味着在bridge的时候，编译器转移了对象的所有权，开发者不再需要负责对象的释放。\n\n```objectivec\n//cf to objc\n CFStringRef cfStr = CFStringCreateWithCString(kCFAllpacatorDefaule,\"hello\",kCFStringEncodingUTF8);\n NSString *str = (__bridge NSString *)(cfStr);\n CFRelease(cfStr);//这里需要release\n```\n\n## 总结 ##\n\n  * `__bridge` :编译器在bridge的时候不要做任何事情\n  * `__bridge_retained` :（ObjC转CF的时候使用）编译器在bridge的时候retain对象，开发者需要在CF一端负责释放对象\n  * `__bridge_transfer` :（CF转ObjC的时候使用）编译器转移CF对象的所有权，开发者不再需要在CF一端负责释放对象\n","source":"_posts/iOS的CF和OC中间的类型转换.md","raw":"---\ntitle: iOS的CF和OC中间的类型转换\ndate: 2017-01-11 11:10:12\ntags: iOS\n---\n\n# iOS的CF和OC中间的类型转换 #\n\n## Toll-Free bridged ##\n\n`Toll-Free bridged`  是Core Foundation和Foundation之间交换使用数据类型的技术.即同一数据类型既可作为Core Foundation函数的参数,也可以作为接收者向其发送Objective-C消息.\n\n说的简单点,就是OC中的有些类型,通过`Toll-Free bridged` 既可以当做Core Foundation的类型使用(CFxxxx),又可以当做Foundation的类型使用(NSxxxx).\n\n\n<!----- more ----->\n\n\n## Toll-Free bridged原理 ##\n\n每一个能够bridge的ObjC类，都是一个类簇（class cluster）。类簇是一个公开的抽象类，但其核心功能的是在不同的私有子类中实现的，公开类只暴露一致的接口和实现一些辅助的创建方法。而与该ObjC类相对应的Core Foundation类的内存结构，正好与类簇的其中一个私有子类相同。\n\n举个例子，NSString是一个类簇，一个公开的抽象类，但每次创建一个NSString的实例时，实际上我们会获得其中一个私有子类的实例。而NSString的其中一个私有子类实现既为NSCFString，其内存的结构与CFString是相同的，CFString的isa指针就指向NSCFString类，即CFString对象就是一个NSCFString类的实例。\n所以，当NSString的实现刚好是NSCFString的时候，他们两者之间的转换是相当容易而直接的，他们就是同一个类的实例。\n\n当NSString的实现不是NSCFString的时候（比如我们自己subclass了NSString），我们调用CF函数，就需要先检查对象的具体实现。如果发现其不是NSCFString，我们不会调用CF函数的实现来获得结果，而是通过给对象发送与函数功能相对应的ObjC消息（调用相对应的NSString的接口）来获得其结果。\n\n例如CFStringGetLength函数，当收到一个作为参数传递进来的对象时，会先确认该对象到底是不是NSCFString实现。如果是的话，就会直接调用CFStringGetLength函数的实现来获得字符串的长度；如果不是的话，会给对象发送length消息（调用NSString的length接口），来得到字符串的长度。\n\n## Toll-Free bridged的内存管理 ##\n\n在ARC中编译器不知道如何处理这个同时拥有ObjC和CFTypeRef指向的对象,所以你必须为编译器提供额外的信息：将类型显示转换为互换类型；同时可能需明确对象的声明周期。 因此我们需要使用 `__bridge`, `__bridge_retained`, `__bridge_transfer` 修饰符告诉编译器该如何去做。\n\n### __bridge ###\n\n```objectivec\n//objc to cf\n NSString *str = @\"hello\";\n CFStringRef cfStr = (__bridge CFStringRef)str;\n CFRelease(cfStr);//这里不需要release\n```\n编译器会继续负责nsStr的内存管理的事情，不会在bridge的时候retain对象，所以也不需要开发者在CF 一端释放。需要注意的是，当nsStr被释放的时候（比如出了作用域），意味着cfStr指向的对象被释放了，这时如果继续使用cfStr将会引起程序崩溃。\n\n```objectivec\n//cf to objc\n CFStringRef cfStr = CFStringCreateWithCString(kCFAllpacatorDefaule,\"hello\",kCFStringEncodingUTF8);\n NSString *str = (__bridge NSString *)(cfStr);\n CFRelease(cfStr);//这里需要release\n```\n\n bridge的时候编译器不会做任何内存管理的事情，bridge之后，编译器会负责ObjC一端的内存管理的事情。同时，开发者需要负责管理CF 一端的内存管理的事情，需要在bridge之后，负责release对象。\n\n### __bridge_retained ###\n接着上面的例子，Foundation类型对应的Core Foundation类型时，为了防止str被释放，引起我们使用cfStr的时候程序崩溃，可以使用__bridge_retained修饰符。这意味着，在bridge的时候，编译器会retain对象，而由开发者在CF一端负责release。这样，就算str在objc一端被释放，只要开发者不手动去释放cfStr，其指向的对象就不会被真的销毁。但同时，开发者也必须保证和负责对象的释放。\n\n```objectivec\n//objc to cf\n NSString *str = @\"hello\";\n CFStringRef cfStr = (__bridge_retained CFStringRef)str;\n CFRelease(cfStr);//这里不需要release\n```\n\n### __bridge_transfer ###\n当Core Foundation类型转化为Foundation类型时，如果使用__bridge修饰符在cf转objc的时候非常的麻烦，我们既需要一个CFTypeRef的变量，还需要在bridge之后负责释放。这时我们可以使用__bridge_transfer，意味着在bridge的时候，编译器转移了对象的所有权，开发者不再需要负责对象的释放。\n\n```objectivec\n//cf to objc\n CFStringRef cfStr = CFStringCreateWithCString(kCFAllpacatorDefaule,\"hello\",kCFStringEncodingUTF8);\n NSString *str = (__bridge NSString *)(cfStr);\n CFRelease(cfStr);//这里需要release\n```\n\n## 总结 ##\n\n  * `__bridge` :编译器在bridge的时候不要做任何事情\n  * `__bridge_retained` :（ObjC转CF的时候使用）编译器在bridge的时候retain对象，开发者需要在CF一端负责释放对象\n  * `__bridge_transfer` :（CF转ObjC的时候使用）编译器转移CF对象的所有权，开发者不再需要在CF一端负责释放对象\n","slug":"iOS的CF和OC中间的类型转换","published":1,"updated":"2021-04-12T09:17:38.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqjdx1nt001c5emuq1uy2ara","content":"<h1 id=\"iOS的CF和OC中间的类型转换\"><a href=\"#iOS的CF和OC中间的类型转换\" class=\"headerlink\" title=\"iOS的CF和OC中间的类型转换\"></a>iOS的CF和OC中间的类型转换</h1><h2 id=\"Toll-Free-bridged\"><a href=\"#Toll-Free-bridged\" class=\"headerlink\" title=\"Toll-Free bridged\"></a>Toll-Free bridged</h2><p><code>Toll-Free bridged</code>  是Core Foundation和Foundation之间交换使用数据类型的技术.即同一数据类型既可作为Core Foundation函数的参数,也可以作为接收者向其发送Objective-C消息.</p>\n<p>说的简单点,就是OC中的有些类型,通过<code>Toll-Free bridged</code> 既可以当做Core Foundation的类型使用(CFxxxx),又可以当做Foundation的类型使用(NSxxxx).</p>\n<a id=\"more\"></a>\n<h2 id=\"Toll-Free-bridged原理\"><a href=\"#Toll-Free-bridged原理\" class=\"headerlink\" title=\"Toll-Free bridged原理\"></a>Toll-Free bridged原理</h2><p>每一个能够bridge的ObjC类，都是一个类簇（class cluster）。类簇是一个公开的抽象类，但其核心功能的是在不同的私有子类中实现的，公开类只暴露一致的接口和实现一些辅助的创建方法。而与该ObjC类相对应的Core Foundation类的内存结构，正好与类簇的其中一个私有子类相同。</p>\n<p>举个例子，NSString是一个类簇，一个公开的抽象类，但每次创建一个NSString的实例时，实际上我们会获得其中一个私有子类的实例。而NSString的其中一个私有子类实现既为NSCFString，其内存的结构与CFString是相同的，CFString的isa指针就指向NSCFString类，即CFString对象就是一个NSCFString类的实例。<br>所以，当NSString的实现刚好是NSCFString的时候，他们两者之间的转换是相当容易而直接的，他们就是同一个类的实例。</p>\n<p>当NSString的实现不是NSCFString的时候（比如我们自己subclass了NSString），我们调用CF函数，就需要先检查对象的具体实现。如果发现其不是NSCFString，我们不会调用CF函数的实现来获得结果，而是通过给对象发送与函数功能相对应的ObjC消息（调用相对应的NSString的接口）来获得其结果。</p>\n<p>例如CFStringGetLength函数，当收到一个作为参数传递进来的对象时，会先确认该对象到底是不是NSCFString实现。如果是的话，就会直接调用CFStringGetLength函数的实现来获得字符串的长度；如果不是的话，会给对象发送length消息（调用NSString的length接口），来得到字符串的长度。</p>\n<h2 id=\"Toll-Free-bridged的内存管理\"><a href=\"#Toll-Free-bridged的内存管理\" class=\"headerlink\" title=\"Toll-Free bridged的内存管理\"></a>Toll-Free bridged的内存管理</h2><p>在ARC中编译器不知道如何处理这个同时拥有ObjC和CFTypeRef指向的对象,所以你必须为编译器提供额外的信息：将类型显示转换为互换类型；同时可能需明确对象的声明周期。 因此我们需要使用 <code>__bridge</code>, <code>__bridge_retained</code>, <code>__bridge_transfer</code> 修饰符告诉编译器该如何去做。</p>\n<h3 id=\"bridge\"><a href=\"#bridge\" class=\"headerlink\" title=\"__bridge\"></a>__bridge</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//objc to cf</span></span><br><span class=\"line\"> <span class=\"built_in\">NSString</span> *str = <span class=\"string\">@\"hello\"</span>;</span><br><span class=\"line\"> <span class=\"built_in\">CFStringRef</span> cfStr = (__bridge <span class=\"built_in\">CFStringRef</span>)str;</span><br><span class=\"line\"> <span class=\"built_in\">CFRelease</span>(cfStr);<span class=\"comment\">//这里不需要release</span></span><br></pre></td></tr></table></figure>\n<p>编译器会继续负责nsStr的内存管理的事情，不会在bridge的时候retain对象，所以也不需要开发者在CF 一端释放。需要注意的是，当nsStr被释放的时候（比如出了作用域），意味着cfStr指向的对象被释放了，这时如果继续使用cfStr将会引起程序崩溃。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//cf to objc</span></span><br><span class=\"line\"> <span class=\"built_in\">CFStringRef</span> cfStr = <span class=\"built_in\">CFStringCreateWithCString</span>(kCFAllpacatorDefaule,<span class=\"string\">\"hello\"</span>,kCFStringEncodingUTF8);</span><br><span class=\"line\"> <span class=\"built_in\">NSString</span> *str = (__bridge <span class=\"built_in\">NSString</span> *)(cfStr);</span><br><span class=\"line\"> <span class=\"built_in\">CFRelease</span>(cfStr);<span class=\"comment\">//这里需要release</span></span><br></pre></td></tr></table></figure>\n<p> bridge的时候编译器不会做任何内存管理的事情，bridge之后，编译器会负责ObjC一端的内存管理的事情。同时，开发者需要负责管理CF 一端的内存管理的事情，需要在bridge之后，负责release对象。</p>\n<h3 id=\"bridge-retained\"><a href=\"#bridge-retained\" class=\"headerlink\" title=\"__bridge_retained\"></a>__bridge_retained</h3><p>接着上面的例子，Foundation类型对应的Core Foundation类型时，为了防止str被释放，引起我们使用cfStr的时候程序崩溃，可以使用__bridge_retained修饰符。这意味着，在bridge的时候，编译器会retain对象，而由开发者在CF一端负责release。这样，就算str在objc一端被释放，只要开发者不手动去释放cfStr，其指向的对象就不会被真的销毁。但同时，开发者也必须保证和负责对象的释放。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//objc to cf</span></span><br><span class=\"line\"> <span class=\"built_in\">NSString</span> *str = <span class=\"string\">@\"hello\"</span>;</span><br><span class=\"line\"> <span class=\"built_in\">CFStringRef</span> cfStr = (__bridge_retained <span class=\"built_in\">CFStringRef</span>)str;</span><br><span class=\"line\"> <span class=\"built_in\">CFRelease</span>(cfStr);<span class=\"comment\">//这里不需要release</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"bridge-transfer\"><a href=\"#bridge-transfer\" class=\"headerlink\" title=\"__bridge_transfer\"></a>__bridge_transfer</h3><p>当Core Foundation类型转化为Foundation类型时，如果使用<strong>bridge修饰符在cf转objc的时候非常的麻烦，我们既需要一个CFTypeRef的变量，还需要在bridge之后负责释放。这时我们可以使用</strong>bridge_transfer，意味着在bridge的时候，编译器转移了对象的所有权，开发者不再需要负责对象的释放。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//cf to objc</span></span><br><span class=\"line\"> <span class=\"built_in\">CFStringRef</span> cfStr = <span class=\"built_in\">CFStringCreateWithCString</span>(kCFAllpacatorDefaule,<span class=\"string\">\"hello\"</span>,kCFStringEncodingUTF8);</span><br><span class=\"line\"> <span class=\"built_in\">NSString</span> *str = (__bridge <span class=\"built_in\">NSString</span> *)(cfStr);</span><br><span class=\"line\"> <span class=\"built_in\">CFRelease</span>(cfStr);<span class=\"comment\">//这里需要release</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li><code>__bridge</code> :编译器在bridge的时候不要做任何事情</li>\n<li><code>__bridge_retained</code> :（ObjC转CF的时候使用）编译器在bridge的时候retain对象，开发者需要在CF一端负责释放对象</li>\n<li><code>__bridge_transfer</code> :（CF转ObjC的时候使用）编译器转移CF对象的所有权，开发者不再需要在CF一端负责释放对象</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"iOS的CF和OC中间的类型转换\"><a href=\"#iOS的CF和OC中间的类型转换\" class=\"headerlink\" title=\"iOS的CF和OC中间的类型转换\"></a>iOS的CF和OC中间的类型转换</h1><h2 id=\"Toll-Free-bridged\"><a href=\"#Toll-Free-bridged\" class=\"headerlink\" title=\"Toll-Free bridged\"></a>Toll-Free bridged</h2><p><code>Toll-Free bridged</code>  是Core Foundation和Foundation之间交换使用数据类型的技术.即同一数据类型既可作为Core Foundation函数的参数,也可以作为接收者向其发送Objective-C消息.</p>\n<p>说的简单点,就是OC中的有些类型,通过<code>Toll-Free bridged</code> 既可以当做Core Foundation的类型使用(CFxxxx),又可以当做Foundation的类型使用(NSxxxx).</p>","more":"<h2 id=\"Toll-Free-bridged原理\"><a href=\"#Toll-Free-bridged原理\" class=\"headerlink\" title=\"Toll-Free bridged原理\"></a>Toll-Free bridged原理</h2><p>每一个能够bridge的ObjC类，都是一个类簇（class cluster）。类簇是一个公开的抽象类，但其核心功能的是在不同的私有子类中实现的，公开类只暴露一致的接口和实现一些辅助的创建方法。而与该ObjC类相对应的Core Foundation类的内存结构，正好与类簇的其中一个私有子类相同。</p>\n<p>举个例子，NSString是一个类簇，一个公开的抽象类，但每次创建一个NSString的实例时，实际上我们会获得其中一个私有子类的实例。而NSString的其中一个私有子类实现既为NSCFString，其内存的结构与CFString是相同的，CFString的isa指针就指向NSCFString类，即CFString对象就是一个NSCFString类的实例。<br>所以，当NSString的实现刚好是NSCFString的时候，他们两者之间的转换是相当容易而直接的，他们就是同一个类的实例。</p>\n<p>当NSString的实现不是NSCFString的时候（比如我们自己subclass了NSString），我们调用CF函数，就需要先检查对象的具体实现。如果发现其不是NSCFString，我们不会调用CF函数的实现来获得结果，而是通过给对象发送与函数功能相对应的ObjC消息（调用相对应的NSString的接口）来获得其结果。</p>\n<p>例如CFStringGetLength函数，当收到一个作为参数传递进来的对象时，会先确认该对象到底是不是NSCFString实现。如果是的话，就会直接调用CFStringGetLength函数的实现来获得字符串的长度；如果不是的话，会给对象发送length消息（调用NSString的length接口），来得到字符串的长度。</p>\n<h2 id=\"Toll-Free-bridged的内存管理\"><a href=\"#Toll-Free-bridged的内存管理\" class=\"headerlink\" title=\"Toll-Free bridged的内存管理\"></a>Toll-Free bridged的内存管理</h2><p>在ARC中编译器不知道如何处理这个同时拥有ObjC和CFTypeRef指向的对象,所以你必须为编译器提供额外的信息：将类型显示转换为互换类型；同时可能需明确对象的声明周期。 因此我们需要使用 <code>__bridge</code>, <code>__bridge_retained</code>, <code>__bridge_transfer</code> 修饰符告诉编译器该如何去做。</p>\n<h3 id=\"bridge\"><a href=\"#bridge\" class=\"headerlink\" title=\"__bridge\"></a>__bridge</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//objc to cf</span></span><br><span class=\"line\"> <span class=\"built_in\">NSString</span> *str = <span class=\"string\">@\"hello\"</span>;</span><br><span class=\"line\"> <span class=\"built_in\">CFStringRef</span> cfStr = (__bridge <span class=\"built_in\">CFStringRef</span>)str;</span><br><span class=\"line\"> <span class=\"built_in\">CFRelease</span>(cfStr);<span class=\"comment\">//这里不需要release</span></span><br></pre></td></tr></table></figure>\n<p>编译器会继续负责nsStr的内存管理的事情，不会在bridge的时候retain对象，所以也不需要开发者在CF 一端释放。需要注意的是，当nsStr被释放的时候（比如出了作用域），意味着cfStr指向的对象被释放了，这时如果继续使用cfStr将会引起程序崩溃。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//cf to objc</span></span><br><span class=\"line\"> <span class=\"built_in\">CFStringRef</span> cfStr = <span class=\"built_in\">CFStringCreateWithCString</span>(kCFAllpacatorDefaule,<span class=\"string\">\"hello\"</span>,kCFStringEncodingUTF8);</span><br><span class=\"line\"> <span class=\"built_in\">NSString</span> *str = (__bridge <span class=\"built_in\">NSString</span> *)(cfStr);</span><br><span class=\"line\"> <span class=\"built_in\">CFRelease</span>(cfStr);<span class=\"comment\">//这里需要release</span></span><br></pre></td></tr></table></figure>\n<p> bridge的时候编译器不会做任何内存管理的事情，bridge之后，编译器会负责ObjC一端的内存管理的事情。同时，开发者需要负责管理CF 一端的内存管理的事情，需要在bridge之后，负责release对象。</p>\n<h3 id=\"bridge-retained\"><a href=\"#bridge-retained\" class=\"headerlink\" title=\"__bridge_retained\"></a>__bridge_retained</h3><p>接着上面的例子，Foundation类型对应的Core Foundation类型时，为了防止str被释放，引起我们使用cfStr的时候程序崩溃，可以使用__bridge_retained修饰符。这意味着，在bridge的时候，编译器会retain对象，而由开发者在CF一端负责release。这样，就算str在objc一端被释放，只要开发者不手动去释放cfStr，其指向的对象就不会被真的销毁。但同时，开发者也必须保证和负责对象的释放。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//objc to cf</span></span><br><span class=\"line\"> <span class=\"built_in\">NSString</span> *str = <span class=\"string\">@\"hello\"</span>;</span><br><span class=\"line\"> <span class=\"built_in\">CFStringRef</span> cfStr = (__bridge_retained <span class=\"built_in\">CFStringRef</span>)str;</span><br><span class=\"line\"> <span class=\"built_in\">CFRelease</span>(cfStr);<span class=\"comment\">//这里不需要release</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"bridge-transfer\"><a href=\"#bridge-transfer\" class=\"headerlink\" title=\"__bridge_transfer\"></a>__bridge_transfer</h3><p>当Core Foundation类型转化为Foundation类型时，如果使用<strong>bridge修饰符在cf转objc的时候非常的麻烦，我们既需要一个CFTypeRef的变量，还需要在bridge之后负责释放。这时我们可以使用</strong>bridge_transfer，意味着在bridge的时候，编译器转移了对象的所有权，开发者不再需要负责对象的释放。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//cf to objc</span></span><br><span class=\"line\"> <span class=\"built_in\">CFStringRef</span> cfStr = <span class=\"built_in\">CFStringCreateWithCString</span>(kCFAllpacatorDefaule,<span class=\"string\">\"hello\"</span>,kCFStringEncodingUTF8);</span><br><span class=\"line\"> <span class=\"built_in\">NSString</span> *str = (__bridge <span class=\"built_in\">NSString</span> *)(cfStr);</span><br><span class=\"line\"> <span class=\"built_in\">CFRelease</span>(cfStr);<span class=\"comment\">//这里需要release</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li><code>__bridge</code> :编译器在bridge的时候不要做任何事情</li>\n<li><code>__bridge_retained</code> :（ObjC转CF的时候使用）编译器在bridge的时候retain对象，开发者需要在CF一端负责释放对象</li>\n<li><code>__bridge_transfer</code> :（CF转ObjC的时候使用）编译器转移CF对象的所有权，开发者不再需要在CF一端负责释放对象</li>\n</ul>"},{"title":"ssh连接报错","date":"2016-12-11T03:02:30.000Z","_content":"\n## 使用ssh连接远程服务器 ##\n\n在使用VPS的时候由于更换了数据中心，导致远程服务`ip`地址改变，使用`ssh`连接的时候报如下错误\n\n\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\nIT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\nSomeone could be eavesdropping on you right now (man-in-the-middle attack)!\nIt is also possible that a host key has just been changed.\nThe fingerprint for the RSA key sent by the remote host is\n6e:45:f9:a8:af:38:3d:a1:a5:c7:76:1d:02:f8:77:00.\nPlease contact your system administrator.\nAdd correct host key in /home/hostname /.ssh/known_hosts to get rid of this message.\nOffending RSA key in /var/lib/sss/pubconf/known_hosts:4\nRSA host key for pong has changed and you have requested strict checking.\nHost key verification failed.\n\n\n## 解决办法 ##\n\n找到`~/.ssh/`路径下的`known_hosts`打开，删除对应的`ip`以及对应信息保存就好\n","source":"_posts/ssh连接报错.md","raw":"---\ntitle: ssh连接报错\ndate: 2016-12-11 11:02:30\ntags: VPS那些事\n---\n\n## 使用ssh连接远程服务器 ##\n\n在使用VPS的时候由于更换了数据中心，导致远程服务`ip`地址改变，使用`ssh`连接的时候报如下错误\n\n\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\nIT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!\nSomeone could be eavesdropping on you right now (man-in-the-middle attack)!\nIt is also possible that a host key has just been changed.\nThe fingerprint for the RSA key sent by the remote host is\n6e:45:f9:a8:af:38:3d:a1:a5:c7:76:1d:02:f8:77:00.\nPlease contact your system administrator.\nAdd correct host key in /home/hostname /.ssh/known_hosts to get rid of this message.\nOffending RSA key in /var/lib/sss/pubconf/known_hosts:4\nRSA host key for pong has changed and you have requested strict checking.\nHost key verification failed.\n\n\n## 解决办法 ##\n\n找到`~/.ssh/`路径下的`known_hosts`打开，删除对应的`ip`以及对应信息保存就好\n","slug":"ssh连接报错","published":1,"updated":"2021-04-12T09:17:38.421Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqjdx1nu001e5emu6ydjx9sq","content":"<h2 id=\"使用ssh连接远程服务器\"><a href=\"#使用ssh连接远程服务器\" class=\"headerlink\" title=\"使用ssh连接远程服务器\"></a>使用ssh连接远程服务器</h2><p>在使用VPS的时候由于更换了数据中心，导致远程服务<code>ip</code>地址改变，使用<code>ssh</code>连接的时候报如下错误</p>\n<p>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@<br>@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @<br>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@<br>IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!<br>Someone could be eavesdropping on you right now (man-in-the-middle attack)!<br>It is also possible that a host key has just been changed.<br>The fingerprint for the RSA key sent by the remote host is<br>6e:45:f9:a8:af:38:3d:a1:a5:c7:76:1d:02:f8:77:00.<br>Please contact your system administrator.<br>Add correct host key in /home/hostname /.ssh/known_hosts to get rid of this message.<br>Offending RSA key in /var/lib/sss/pubconf/known_hosts:4<br>RSA host key for pong has changed and you have requested strict checking.<br>Host key verification failed.</p>\n<h2 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h2><p>找到<code>~/.ssh/</code>路径下的<code>known_hosts</code>打开，删除对应的<code>ip</code>以及对应信息保存就好</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"使用ssh连接远程服务器\"><a href=\"#使用ssh连接远程服务器\" class=\"headerlink\" title=\"使用ssh连接远程服务器\"></a>使用ssh连接远程服务器</h2><p>在使用VPS的时候由于更换了数据中心，导致远程服务<code>ip</code>地址改变，使用<code>ssh</code>连接的时候报如下错误</p>\n<p>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@<br>@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @<br>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@<br>IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!<br>Someone could be eavesdropping on you right now (man-in-the-middle attack)!<br>It is also possible that a host key has just been changed.<br>The fingerprint for the RSA key sent by the remote host is<br>6e:45:f9:a8:af:38:3d:a1:a5:c7:76:1d:02:f8:77:00.<br>Please contact your system administrator.<br>Add correct host key in /home/hostname /.ssh/known_hosts to get rid of this message.<br>Offending RSA key in /var/lib/sss/pubconf/known_hosts:4<br>RSA host key for pong has changed and you have requested strict checking.<br>Host key verification failed.</p>\n<h2 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h2><p>找到<code>~/.ssh/</code>路径下的<code>known_hosts</code>打开，删除对应的<code>ip</code>以及对应信息保存就好</p>\n"},{"title":"iOS中的isEqual：和 “==”","date":"2017-06-13T15:32:00.000Z","_content":"\n\n## 前言 ##\n\n在iOS开发中常常要比较两个值是否一样，通常的做法有两种，就是用`isEqual：`或者使用`==`\n\n<!-- more -->\n\n### \"==\" 比较\n\n如果用`==`比较的是两基本类型，则比较的是两个两个基本类型的值，如果比较的是两个对象类型，则比较的是对象的地址\n\n\n这时如果有两个`string`：\n\n```\n    NSString *str1 = @\"hello\";\n    NSString *str2 = [NSString stringWithFormat:@\"hello\"];\n```\n\n这两个string的内容明显是一样的，但是地址却不一样，如果使用`==`比较就会返回`NO`\n\n这样就用到我们的`isEqual：`\n\n注：isEqualToString：会在下面说\n\n### isEqual：比较\n\n\n使用`isEqual：`是想要比较对象的值，而不是地址，注意这里是想要\n\n使用`isEqual：`比较上面两个字符串，会返回`YES`\n\n但是这不代表所有的对象使用都会去自动比较对象的值，比如比较两个自己定义的对象的时候，默认情况下他其实还是比较的两个对象的地址\n\n之所以比较字符串会比较两个值，是因为`NSString`的`isEqual：` 已经被重写了,注意这里是重写因为`isEqual：`是`NSObject`的方法\n\n同时还增加了一个`isEqualToString：`方法，这里是增加，因为这是`NSString`自己的方法\n\n同样的还有还多，比如`NSDate`,`NSArray`,`NSDictionary`,`NSSet`,甚至是`UIColor`\n\n所以当我们想要比较自己定义的对象的值的时候，我们也要重写自己的`isEqual：`\n\n重写的时候其实你可以说任何一个比较的对象都是一样的，换句话说只要你觉得符合你的业务逻辑，你就可以说他是一样\n\n### 重写isEqual：\n\n\n```\n- (BOOL)isEqual:(id)other {  \n \tif (other == self)   \n \t\treturn YES;  \n \tif (!other || ![other isKindOfClass:[self class]])  \n \t\treturn NO;  \n \t\treturn [self isEqualToWidget:other];  \n}  \n\n\n- (BOOL)isEqualToWidget:(MyWidget *)aWidget {  \n \tif (self == aWidget)  \n \t\treturn YES;  \n \tif (![(id)[self name] isEqual:[aWidget name]])  \n \t\treturn NO;  \n \tif (![[self data] isEqualToData:[aWidget data]])  \n \t\treturn NO;  \n \t\treturn YES;  \n}\n```\n\n其实上面的方法可以随意返回，只要你觉得需要\n","source":"_posts/iOS中的isEqual：和 “==”.md","raw":"---\ntitle: iOS中的isEqual：和 “==”\ndate: 2017-06-13 23:32:00\ntags: [iOS]\n---\n\n\n## 前言 ##\n\n在iOS开发中常常要比较两个值是否一样，通常的做法有两种，就是用`isEqual：`或者使用`==`\n\n<!-- more -->\n\n### \"==\" 比较\n\n如果用`==`比较的是两基本类型，则比较的是两个两个基本类型的值，如果比较的是两个对象类型，则比较的是对象的地址\n\n\n这时如果有两个`string`：\n\n```\n    NSString *str1 = @\"hello\";\n    NSString *str2 = [NSString stringWithFormat:@\"hello\"];\n```\n\n这两个string的内容明显是一样的，但是地址却不一样，如果使用`==`比较就会返回`NO`\n\n这样就用到我们的`isEqual：`\n\n注：isEqualToString：会在下面说\n\n### isEqual：比较\n\n\n使用`isEqual：`是想要比较对象的值，而不是地址，注意这里是想要\n\n使用`isEqual：`比较上面两个字符串，会返回`YES`\n\n但是这不代表所有的对象使用都会去自动比较对象的值，比如比较两个自己定义的对象的时候，默认情况下他其实还是比较的两个对象的地址\n\n之所以比较字符串会比较两个值，是因为`NSString`的`isEqual：` 已经被重写了,注意这里是重写因为`isEqual：`是`NSObject`的方法\n\n同时还增加了一个`isEqualToString：`方法，这里是增加，因为这是`NSString`自己的方法\n\n同样的还有还多，比如`NSDate`,`NSArray`,`NSDictionary`,`NSSet`,甚至是`UIColor`\n\n所以当我们想要比较自己定义的对象的值的时候，我们也要重写自己的`isEqual：`\n\n重写的时候其实你可以说任何一个比较的对象都是一样的，换句话说只要你觉得符合你的业务逻辑，你就可以说他是一样\n\n### 重写isEqual：\n\n\n```\n- (BOOL)isEqual:(id)other {  \n \tif (other == self)   \n \t\treturn YES;  \n \tif (!other || ![other isKindOfClass:[self class]])  \n \t\treturn NO;  \n \t\treturn [self isEqualToWidget:other];  \n}  \n\n\n- (BOOL)isEqualToWidget:(MyWidget *)aWidget {  \n \tif (self == aWidget)  \n \t\treturn YES;  \n \tif (![(id)[self name] isEqual:[aWidget name]])  \n \t\treturn NO;  \n \tif (![[self data] isEqualToData:[aWidget data]])  \n \t\treturn NO;  \n \t\treturn YES;  \n}\n```\n\n其实上面的方法可以随意返回，只要你觉得需要\n","slug":"iOS中的isEqual：和 “==”","published":1,"updated":"2021-04-12T09:17:38.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqjdx1nv001h5emuderya9si","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在iOS开发中常常要比较两个值是否一样，通常的做法有两种，就是用<code>isEqual：</code>或者使用<code>==</code></p>\n<a id=\"more\"></a>\n<h3 id=\"“-”-比较\"><a href=\"#“-”-比较\" class=\"headerlink\" title=\"“==” 比较\"></a>“==” 比较</h3><p>如果用<code>==</code>比较的是两基本类型，则比较的是两个两个基本类型的值，如果比较的是两个对象类型，则比较的是对象的地址</p>\n<p>这时如果有两个<code>string</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSString *str1 = @&quot;hello&quot;;</span><br><span class=\"line\">NSString *str2 = [NSString stringWithFormat:@&quot;hello&quot;];</span><br></pre></td></tr></table></figure>\n<p>这两个string的内容明显是一样的，但是地址却不一样，如果使用<code>==</code>比较就会返回<code>NO</code></p>\n<p>这样就用到我们的<code>isEqual：</code></p>\n<p>注：isEqualToString：会在下面说</p>\n<h3 id=\"isEqual：比较\"><a href=\"#isEqual：比较\" class=\"headerlink\" title=\"isEqual：比较\"></a>isEqual：比较</h3><p>使用<code>isEqual：</code>是想要比较对象的值，而不是地址，注意这里是想要</p>\n<p>使用<code>isEqual：</code>比较上面两个字符串，会返回<code>YES</code></p>\n<p>但是这不代表所有的对象使用都会去自动比较对象的值，比如比较两个自己定义的对象的时候，默认情况下他其实还是比较的两个对象的地址</p>\n<p>之所以比较字符串会比较两个值，是因为<code>NSString</code>的<code>isEqual：</code> 已经被重写了,注意这里是重写因为<code>isEqual：</code>是<code>NSObject</code>的方法</p>\n<p>同时还增加了一个<code>isEqualToString：</code>方法，这里是增加，因为这是<code>NSString</code>自己的方法</p>\n<p>同样的还有还多，比如<code>NSDate</code>,<code>NSArray</code>,<code>NSDictionary</code>,<code>NSSet</code>,甚至是<code>UIColor</code></p>\n<p>所以当我们想要比较自己定义的对象的值的时候，我们也要重写自己的<code>isEqual：</code></p>\n<p>重写的时候其实你可以说任何一个比较的对象都是一样的，换句话说只要你觉得符合你的业务逻辑，你就可以说他是一样</p>\n<h3 id=\"重写isEqual：\"><a href=\"#重写isEqual：\" class=\"headerlink\" title=\"重写isEqual：\"></a>重写isEqual：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (BOOL)isEqual:(id)other &#123;  </span><br><span class=\"line\"> \tif (other == self)   </span><br><span class=\"line\"> \t\treturn YES;  </span><br><span class=\"line\"> \tif (!other || ![other isKindOfClass:[self class]])  </span><br><span class=\"line\"> \t\treturn NO;  </span><br><span class=\"line\"> \t\treturn [self isEqualToWidget:other];  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">- (BOOL)isEqualToWidget:(MyWidget *)aWidget &#123;  </span><br><span class=\"line\"> \tif (self == aWidget)  </span><br><span class=\"line\"> \t\treturn YES;  </span><br><span class=\"line\"> \tif (![(id)[self name] isEqual:[aWidget name]])  </span><br><span class=\"line\"> \t\treturn NO;  </span><br><span class=\"line\"> \tif (![[self data] isEqualToData:[aWidget data]])  </span><br><span class=\"line\"> \t\treturn NO;  </span><br><span class=\"line\"> \t\treturn YES;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其实上面的方法可以随意返回，只要你觉得需要</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在iOS开发中常常要比较两个值是否一样，通常的做法有两种，就是用<code>isEqual：</code>或者使用<code>==</code></p>","more":"<h3 id=\"“-”-比较\"><a href=\"#“-”-比较\" class=\"headerlink\" title=\"“==” 比较\"></a>“==” 比较</h3><p>如果用<code>==</code>比较的是两基本类型，则比较的是两个两个基本类型的值，如果比较的是两个对象类型，则比较的是对象的地址</p>\n<p>这时如果有两个<code>string</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSString *str1 = @&quot;hello&quot;;</span><br><span class=\"line\">NSString *str2 = [NSString stringWithFormat:@&quot;hello&quot;];</span><br></pre></td></tr></table></figure>\n<p>这两个string的内容明显是一样的，但是地址却不一样，如果使用<code>==</code>比较就会返回<code>NO</code></p>\n<p>这样就用到我们的<code>isEqual：</code></p>\n<p>注：isEqualToString：会在下面说</p>\n<h3 id=\"isEqual：比较\"><a href=\"#isEqual：比较\" class=\"headerlink\" title=\"isEqual：比较\"></a>isEqual：比较</h3><p>使用<code>isEqual：</code>是想要比较对象的值，而不是地址，注意这里是想要</p>\n<p>使用<code>isEqual：</code>比较上面两个字符串，会返回<code>YES</code></p>\n<p>但是这不代表所有的对象使用都会去自动比较对象的值，比如比较两个自己定义的对象的时候，默认情况下他其实还是比较的两个对象的地址</p>\n<p>之所以比较字符串会比较两个值，是因为<code>NSString</code>的<code>isEqual：</code> 已经被重写了,注意这里是重写因为<code>isEqual：</code>是<code>NSObject</code>的方法</p>\n<p>同时还增加了一个<code>isEqualToString：</code>方法，这里是增加，因为这是<code>NSString</code>自己的方法</p>\n<p>同样的还有还多，比如<code>NSDate</code>,<code>NSArray</code>,<code>NSDictionary</code>,<code>NSSet</code>,甚至是<code>UIColor</code></p>\n<p>所以当我们想要比较自己定义的对象的值的时候，我们也要重写自己的<code>isEqual：</code></p>\n<p>重写的时候其实你可以说任何一个比较的对象都是一样的，换句话说只要你觉得符合你的业务逻辑，你就可以说他是一样</p>\n<h3 id=\"重写isEqual：\"><a href=\"#重写isEqual：\" class=\"headerlink\" title=\"重写isEqual：\"></a>重写isEqual：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (BOOL)isEqual:(id)other &#123;  </span><br><span class=\"line\"> \tif (other == self)   </span><br><span class=\"line\"> \t\treturn YES;  </span><br><span class=\"line\"> \tif (!other || ![other isKindOfClass:[self class]])  </span><br><span class=\"line\"> \t\treturn NO;  </span><br><span class=\"line\"> \t\treturn [self isEqualToWidget:other];  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">- (BOOL)isEqualToWidget:(MyWidget *)aWidget &#123;  </span><br><span class=\"line\"> \tif (self == aWidget)  </span><br><span class=\"line\"> \t\treturn YES;  </span><br><span class=\"line\"> \tif (![(id)[self name] isEqual:[aWidget name]])  </span><br><span class=\"line\"> \t\treturn NO;  </span><br><span class=\"line\"> \tif (![[self data] isEqualToData:[aWidget data]])  </span><br><span class=\"line\"> \t\treturn NO;  </span><br><span class=\"line\"> \t\treturn YES;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其实上面的方法可以随意返回，只要你觉得需要</p>"},{"title":"swift_node_4","date":"2021-06-24T12:13:38.000Z","_content":"\n### 结构体\n\n* 每个结构体都有一个编译器自动生成的初始化器（initializer, 初始化方法，构造器，构造方法）\n\n#### 初始化器\n\n* 编译器会根据情况，可能会为结构体生成多个初始化器，目的是保证所有成员都有初始值\n* 如果成员有默认值，则生成的初始化器可以不带该成员\n* 在定义结构体时，自定义了初始化器，编译器就不会再帮它生成其他初始化器\n\n### 类\n\n* 类的定义和结构体类似，但编译器并没有为类自动生成可以传入成员值的初始化器\n* 如果类的所有成员在定义的时候都指定了初始值，编译器会为类生成无参的初始化器 \n\n","source":"_posts/swift-node-4.md","raw":"---\ntitle: swift_node_4\ndate: 2021-06-24 20:13:38\ntags:\n---\n\n### 结构体\n\n* 每个结构体都有一个编译器自动生成的初始化器（initializer, 初始化方法，构造器，构造方法）\n\n#### 初始化器\n\n* 编译器会根据情况，可能会为结构体生成多个初始化器，目的是保证所有成员都有初始值\n* 如果成员有默认值，则生成的初始化器可以不带该成员\n* 在定义结构体时，自定义了初始化器，编译器就不会再帮它生成其他初始化器\n\n### 类\n\n* 类的定义和结构体类似，但编译器并没有为类自动生成可以传入成员值的初始化器\n* 如果类的所有成员在定义的时候都指定了初始值，编译器会为类生成无参的初始化器 \n\n","slug":"swift-node-4","published":1,"updated":"2021-06-28T12:32:39.532Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqjdx1nw001i5emuk5l0am5v","content":"<h3 id=\"结构体\"><a href=\"#结构体\" class=\"headerlink\" title=\"结构体\"></a>结构体</h3><ul>\n<li>每个结构体都有一个编译器自动生成的初始化器（initializer, 初始化方法，构造器，构造方法）</li>\n</ul>\n<h4 id=\"初始化器\"><a href=\"#初始化器\" class=\"headerlink\" title=\"初始化器\"></a>初始化器</h4><ul>\n<li>编译器会根据情况，可能会为结构体生成多个初始化器，目的是保证所有成员都有初始值</li>\n<li>如果成员有默认值，则生成的初始化器可以不带该成员</li>\n<li>在定义结构体时，自定义了初始化器，编译器就不会再帮它生成其他初始化器</li>\n</ul>\n<h3 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h3><ul>\n<li>类的定义和结构体类似，但编译器并没有为类自动生成可以传入成员值的初始化器</li>\n<li>如果类的所有成员在定义的时候都指定了初始值，编译器会为类生成无参的初始化器 </li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"结构体\"><a href=\"#结构体\" class=\"headerlink\" title=\"结构体\"></a>结构体</h3><ul>\n<li>每个结构体都有一个编译器自动生成的初始化器（initializer, 初始化方法，构造器，构造方法）</li>\n</ul>\n<h4 id=\"初始化器\"><a href=\"#初始化器\" class=\"headerlink\" title=\"初始化器\"></a>初始化器</h4><ul>\n<li>编译器会根据情况，可能会为结构体生成多个初始化器，目的是保证所有成员都有初始值</li>\n<li>如果成员有默认值，则生成的初始化器可以不带该成员</li>\n<li>在定义结构体时，自定义了初始化器，编译器就不会再帮它生成其他初始化器</li>\n</ul>\n<h3 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h3><ul>\n<li>类的定义和结构体类似，但编译器并没有为类自动生成可以传入成员值的初始化器</li>\n<li>如果类的所有成员在定义的时候都指定了初始值，编译器会为类生成无参的初始化器 </li>\n</ul>\n"},{"title":"vim 编辑器使用","date":"2018-11-23T15:32:12.000Z","_content":"\n## 前言 ##\n最近突然觉得使用`vim`在终端查看文本特别高大上，就打算研究一下，但是感觉学习成本太大，效率不高，就简单记录一下，方便以后有需要查询\n\n<!-- more -->\n\n### vim 命令 ###\n\n打开文件\n\n```\nvim 文件名\n```\n\n如果没有会新建一个文件\n\n非正常关闭会有`.swp`的缓存文件\n\n默认打开是命令模式,要想输入要进入\n\n#### 命令模式 ####\n\n `yy`复制光标所在行\n \n `4yy`复制光标所在行及下面三行\n \n `dd`剪切(如果不粘贴就是删除)光标所在行\n \n `4dd`剪切(如果不粘贴就是删除)光标所在行及下面三行\n \n `p`粘贴到光标的下面一行\n \n `h`左移光标\n \n `j`下移光标\n \n `k`上移光标\n \n `l`右移光标\n \n `H`移动光标到当前屏幕上方\n \n `M`移动光标到当前屏幕中间\n \n `L`移动光标到当前屏幕下方\n \n `ctrl+f`下翻一页\n \n `ctrl+b`上翻一页\n \n `ctrl+d`下翻半页\n \n `ctrl+u`上翻半页\n \n `20G`光标移动到20行\n \n `G`光标移动到最后一行\n \n `gg`光标移动到第一行\n \n `w`向后跳一个单词的长度,下一个单词的开始\n \n `b`向前跳一个单词的长度,上一个单词的开始\n \n `D`删除当前行光标以及后面的内容\n \n `u`撤销刚刚的操作\n \n `ctrl+r`反撤销\n\n`d0`删除当前行光标之前的内容\n\n`x`删除当前光标的一个内容\n\n`X`删除当前光标前面的一个内容\n\n`v + 移动光标` 选中块内容(字母选)\n\n`V + 移动光标` 选中块内容(正行选)\n\n`>`右缩进\n\n`<`左缩进\n\n`.`重复上一个命令\n\n`r` 替换光标内容\n\n`R` 替换光标以及后面的内容\n\n`/+内容`搜索内容, (n上一个搜索内容,N下一个搜索内容)\n\n \n#### 编辑模式 #### \n\n命令模式输入`i`从光标的前面开始编辑\n\n命令模式输入`a`从光标的后面开始编辑\n\n命令模式输入`o`从光标下面新起一行编辑\n\n命令模式输入`O`从光标上面新起一行编辑\n\n命令模式输入`I`从光标行首开始编辑\n\n命令模式输入`A`从光标行末开始编辑\n\n按`esc`退出编辑模式\n\n\n#### 末行模式 ####\n\n末行模式  (命令模式输入`:`)\n\n`w`保存\n\n`q`退出\n\n`q!`强制退出\n\n`shift+vv`相当于wq\n\n`%s/abc/123/g`把所有的abc替换成123\n\n`1,10s/abc/123/g`把1到10行的abc替换成123\n\n按`esc`退出编辑模式\n\n","source":"_posts/vim编辑器使用.md","raw":"---\ntitle: vim 编辑器使用\ndate: 2018-11-23 23:32:12\ntags: [Linux]\n---\n\n## 前言 ##\n最近突然觉得使用`vim`在终端查看文本特别高大上，就打算研究一下，但是感觉学习成本太大，效率不高，就简单记录一下，方便以后有需要查询\n\n<!-- more -->\n\n### vim 命令 ###\n\n打开文件\n\n```\nvim 文件名\n```\n\n如果没有会新建一个文件\n\n非正常关闭会有`.swp`的缓存文件\n\n默认打开是命令模式,要想输入要进入\n\n#### 命令模式 ####\n\n `yy`复制光标所在行\n \n `4yy`复制光标所在行及下面三行\n \n `dd`剪切(如果不粘贴就是删除)光标所在行\n \n `4dd`剪切(如果不粘贴就是删除)光标所在行及下面三行\n \n `p`粘贴到光标的下面一行\n \n `h`左移光标\n \n `j`下移光标\n \n `k`上移光标\n \n `l`右移光标\n \n `H`移动光标到当前屏幕上方\n \n `M`移动光标到当前屏幕中间\n \n `L`移动光标到当前屏幕下方\n \n `ctrl+f`下翻一页\n \n `ctrl+b`上翻一页\n \n `ctrl+d`下翻半页\n \n `ctrl+u`上翻半页\n \n `20G`光标移动到20行\n \n `G`光标移动到最后一行\n \n `gg`光标移动到第一行\n \n `w`向后跳一个单词的长度,下一个单词的开始\n \n `b`向前跳一个单词的长度,上一个单词的开始\n \n `D`删除当前行光标以及后面的内容\n \n `u`撤销刚刚的操作\n \n `ctrl+r`反撤销\n\n`d0`删除当前行光标之前的内容\n\n`x`删除当前光标的一个内容\n\n`X`删除当前光标前面的一个内容\n\n`v + 移动光标` 选中块内容(字母选)\n\n`V + 移动光标` 选中块内容(正行选)\n\n`>`右缩进\n\n`<`左缩进\n\n`.`重复上一个命令\n\n`r` 替换光标内容\n\n`R` 替换光标以及后面的内容\n\n`/+内容`搜索内容, (n上一个搜索内容,N下一个搜索内容)\n\n \n#### 编辑模式 #### \n\n命令模式输入`i`从光标的前面开始编辑\n\n命令模式输入`a`从光标的后面开始编辑\n\n命令模式输入`o`从光标下面新起一行编辑\n\n命令模式输入`O`从光标上面新起一行编辑\n\n命令模式输入`I`从光标行首开始编辑\n\n命令模式输入`A`从光标行末开始编辑\n\n按`esc`退出编辑模式\n\n\n#### 末行模式 ####\n\n末行模式  (命令模式输入`:`)\n\n`w`保存\n\n`q`退出\n\n`q!`强制退出\n\n`shift+vv`相当于wq\n\n`%s/abc/123/g`把所有的abc替换成123\n\n`1,10s/abc/123/g`把1到10行的abc替换成123\n\n按`esc`退出编辑模式\n\n","slug":"vim编辑器使用","published":1,"updated":"2021-04-12T09:17:38.421Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqjdx1nx001l5emu2obav0qz","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>最近突然觉得使用<code>vim</code>在终端查看文本特别高大上，就打算研究一下，但是感觉学习成本太大，效率不高，就简单记录一下，方便以后有需要查询</p>\n<a id=\"more\"></a>\n<h3 id=\"vim-命令\"><a href=\"#vim-命令\" class=\"headerlink\" title=\"vim 命令\"></a>vim 命令</h3><p>打开文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim 文件名</span><br></pre></td></tr></table></figure>\n<p>如果没有会新建一个文件</p>\n<p>非正常关闭会有<code>.swp</code>的缓存文件</p>\n<p>默认打开是命令模式,要想输入要进入</p>\n<h4 id=\"命令模式\"><a href=\"#命令模式\" class=\"headerlink\" title=\"命令模式\"></a>命令模式</h4><p> <code>yy</code>复制光标所在行</p>\n<p> <code>4yy</code>复制光标所在行及下面三行</p>\n<p> <code>dd</code>剪切(如果不粘贴就是删除)光标所在行</p>\n<p> <code>4dd</code>剪切(如果不粘贴就是删除)光标所在行及下面三行</p>\n<p> <code>p</code>粘贴到光标的下面一行</p>\n<p> <code>h</code>左移光标</p>\n<p> <code>j</code>下移光标</p>\n<p> <code>k</code>上移光标</p>\n<p> <code>l</code>右移光标</p>\n<p> <code>H</code>移动光标到当前屏幕上方</p>\n<p> <code>M</code>移动光标到当前屏幕中间</p>\n<p> <code>L</code>移动光标到当前屏幕下方</p>\n<p> <code>ctrl+f</code>下翻一页</p>\n<p> <code>ctrl+b</code>上翻一页</p>\n<p> <code>ctrl+d</code>下翻半页</p>\n<p> <code>ctrl+u</code>上翻半页</p>\n<p> <code>20G</code>光标移动到20行</p>\n<p> <code>G</code>光标移动到最后一行</p>\n<p> <code>gg</code>光标移动到第一行</p>\n<p> <code>w</code>向后跳一个单词的长度,下一个单词的开始</p>\n<p> <code>b</code>向前跳一个单词的长度,上一个单词的开始</p>\n<p> <code>D</code>删除当前行光标以及后面的内容</p>\n<p> <code>u</code>撤销刚刚的操作</p>\n<p> <code>ctrl+r</code>反撤销</p>\n<p><code>d0</code>删除当前行光标之前的内容</p>\n<p><code>x</code>删除当前光标的一个内容</p>\n<p><code>X</code>删除当前光标前面的一个内容</p>\n<p><code>v + 移动光标</code> 选中块内容(字母选)</p>\n<p><code>V + 移动光标</code> 选中块内容(正行选)</p>\n<p><code>&gt;</code>右缩进</p>\n<p><code>&lt;</code>左缩进</p>\n<p><code>.</code>重复上一个命令</p>\n<p><code>r</code> 替换光标内容</p>\n<p><code>R</code> 替换光标以及后面的内容</p>\n<p><code>/+内容</code>搜索内容, (n上一个搜索内容,N下一个搜索内容)</p>\n<h4 id=\"编辑模式\"><a href=\"#编辑模式\" class=\"headerlink\" title=\"编辑模式\"></a>编辑模式</h4><p>命令模式输入<code>i</code>从光标的前面开始编辑</p>\n<p>命令模式输入<code>a</code>从光标的后面开始编辑</p>\n<p>命令模式输入<code>o</code>从光标下面新起一行编辑</p>\n<p>命令模式输入<code>O</code>从光标上面新起一行编辑</p>\n<p>命令模式输入<code>I</code>从光标行首开始编辑</p>\n<p>命令模式输入<code>A</code>从光标行末开始编辑</p>\n<p>按<code>esc</code>退出编辑模式</p>\n<h4 id=\"末行模式\"><a href=\"#末行模式\" class=\"headerlink\" title=\"末行模式\"></a>末行模式</h4><p>末行模式  (命令模式输入<code>:</code>)</p>\n<p><code>w</code>保存</p>\n<p><code>q</code>退出</p>\n<p><code>q!</code>强制退出</p>\n<p><code>shift+vv</code>相当于wq</p>\n<p><code>%s/abc/123/g</code>把所有的abc替换成123</p>\n<p><code>1,10s/abc/123/g</code>把1到10行的abc替换成123</p>\n<p>按<code>esc</code>退出编辑模式</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>最近突然觉得使用<code>vim</code>在终端查看文本特别高大上，就打算研究一下，但是感觉学习成本太大，效率不高，就简单记录一下，方便以后有需要查询</p>","more":"<h3 id=\"vim-命令\"><a href=\"#vim-命令\" class=\"headerlink\" title=\"vim 命令\"></a>vim 命令</h3><p>打开文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim 文件名</span><br></pre></td></tr></table></figure>\n<p>如果没有会新建一个文件</p>\n<p>非正常关闭会有<code>.swp</code>的缓存文件</p>\n<p>默认打开是命令模式,要想输入要进入</p>\n<h4 id=\"命令模式\"><a href=\"#命令模式\" class=\"headerlink\" title=\"命令模式\"></a>命令模式</h4><p> <code>yy</code>复制光标所在行</p>\n<p> <code>4yy</code>复制光标所在行及下面三行</p>\n<p> <code>dd</code>剪切(如果不粘贴就是删除)光标所在行</p>\n<p> <code>4dd</code>剪切(如果不粘贴就是删除)光标所在行及下面三行</p>\n<p> <code>p</code>粘贴到光标的下面一行</p>\n<p> <code>h</code>左移光标</p>\n<p> <code>j</code>下移光标</p>\n<p> <code>k</code>上移光标</p>\n<p> <code>l</code>右移光标</p>\n<p> <code>H</code>移动光标到当前屏幕上方</p>\n<p> <code>M</code>移动光标到当前屏幕中间</p>\n<p> <code>L</code>移动光标到当前屏幕下方</p>\n<p> <code>ctrl+f</code>下翻一页</p>\n<p> <code>ctrl+b</code>上翻一页</p>\n<p> <code>ctrl+d</code>下翻半页</p>\n<p> <code>ctrl+u</code>上翻半页</p>\n<p> <code>20G</code>光标移动到20行</p>\n<p> <code>G</code>光标移动到最后一行</p>\n<p> <code>gg</code>光标移动到第一行</p>\n<p> <code>w</code>向后跳一个单词的长度,下一个单词的开始</p>\n<p> <code>b</code>向前跳一个单词的长度,上一个单词的开始</p>\n<p> <code>D</code>删除当前行光标以及后面的内容</p>\n<p> <code>u</code>撤销刚刚的操作</p>\n<p> <code>ctrl+r</code>反撤销</p>\n<p><code>d0</code>删除当前行光标之前的内容</p>\n<p><code>x</code>删除当前光标的一个内容</p>\n<p><code>X</code>删除当前光标前面的一个内容</p>\n<p><code>v + 移动光标</code> 选中块内容(字母选)</p>\n<p><code>V + 移动光标</code> 选中块内容(正行选)</p>\n<p><code>&gt;</code>右缩进</p>\n<p><code>&lt;</code>左缩进</p>\n<p><code>.</code>重复上一个命令</p>\n<p><code>r</code> 替换光标内容</p>\n<p><code>R</code> 替换光标以及后面的内容</p>\n<p><code>/+内容</code>搜索内容, (n上一个搜索内容,N下一个搜索内容)</p>\n<h4 id=\"编辑模式\"><a href=\"#编辑模式\" class=\"headerlink\" title=\"编辑模式\"></a>编辑模式</h4><p>命令模式输入<code>i</code>从光标的前面开始编辑</p>\n<p>命令模式输入<code>a</code>从光标的后面开始编辑</p>\n<p>命令模式输入<code>o</code>从光标下面新起一行编辑</p>\n<p>命令模式输入<code>O</code>从光标上面新起一行编辑</p>\n<p>命令模式输入<code>I</code>从光标行首开始编辑</p>\n<p>命令模式输入<code>A</code>从光标行末开始编辑</p>\n<p>按<code>esc</code>退出编辑模式</p>\n<h4 id=\"末行模式\"><a href=\"#末行模式\" class=\"headerlink\" title=\"末行模式\"></a>末行模式</h4><p>末行模式  (命令模式输入<code>:</code>)</p>\n<p><code>w</code>保存</p>\n<p><code>q</code>退出</p>\n<p><code>q!</code>强制退出</p>\n<p><code>shift+vv</code>相当于wq</p>\n<p><code>%s/abc/123/g</code>把所有的abc替换成123</p>\n<p><code>1,10s/abc/123/g</code>把1到10行的abc替换成123</p>\n<p>按<code>esc</code>退出编辑模式</p>"},{"title":"rvm管理ruby","date":"2018-08-13T12:13:12.000Z","_content":"\n## 前言\n\n最近工程更新开发环境，需要使用`ruby`的2.4.0以上的版本，而本地的开发环境是2.3.0，记录一下更换`ruby`方法\n\n<!-- more -->\n\n\n### 1、安装rvm ###\n\nrvm就是Ruby Version Manager，是Ruby的版本管理器\n\n查看rvm版本：\n\n```\nrvm -v\n```\n\n安装rvm\n\n```\ncurl -L get.rvm.io | bash -s stable\n```\n\n更新修改配置文件使之生效\n\n```\nsource ~/.bashrc  \nsource ~/.bash_profile\n```\n\n安装完成后可以再次查看rvm版本，判断是否安装成功\n\n### 2、升级ruby ###\n\n查看ruby当前版本,以及本地所安装的所有版本\n\n```\nrvm list\n```\n\n查看ruby所有版本\n\n```\nrvm list known\n```\n\n安装新版本ruby 2.4.4\n\n```\nrvm install 2.4.4\n```\n\n切换ruby到需要的版本\n\n```\nrvm --default use 2.4.4\n```\n","source":"_posts/rvm管理ruby.md","raw":"---\ntitle: rvm管理ruby\ndate: 2018-08-13 20:13:12\ntags: [Linux]\n---\n\n## 前言\n\n最近工程更新开发环境，需要使用`ruby`的2.4.0以上的版本，而本地的开发环境是2.3.0，记录一下更换`ruby`方法\n\n<!-- more -->\n\n\n### 1、安装rvm ###\n\nrvm就是Ruby Version Manager，是Ruby的版本管理器\n\n查看rvm版本：\n\n```\nrvm -v\n```\n\n安装rvm\n\n```\ncurl -L get.rvm.io | bash -s stable\n```\n\n更新修改配置文件使之生效\n\n```\nsource ~/.bashrc  \nsource ~/.bash_profile\n```\n\n安装完成后可以再次查看rvm版本，判断是否安装成功\n\n### 2、升级ruby ###\n\n查看ruby当前版本,以及本地所安装的所有版本\n\n```\nrvm list\n```\n\n查看ruby所有版本\n\n```\nrvm list known\n```\n\n安装新版本ruby 2.4.4\n\n```\nrvm install 2.4.4\n```\n\n切换ruby到需要的版本\n\n```\nrvm --default use 2.4.4\n```\n","slug":"rvm管理ruby","published":1,"updated":"2021-04-12T09:17:38.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqjdx1ny001m5emudrdskgmp","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>最近工程更新开发环境，需要使用<code>ruby</code>的2.4.0以上的版本，而本地的开发环境是2.3.0，记录一下更换<code>ruby</code>方法</p>\n<a id=\"more\"></a>\n<h3 id=\"1、安装rvm\"><a href=\"#1、安装rvm\" class=\"headerlink\" title=\"1、安装rvm\"></a>1、安装rvm</h3><p>rvm就是Ruby Version Manager，是Ruby的版本管理器</p>\n<p>查看rvm版本：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rvm -v</span><br></pre></td></tr></table></figure>\n<p>安装rvm</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -L get.rvm.io | bash -s stable</span><br></pre></td></tr></table></figure>\n<p>更新修改配置文件使之生效</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source ~/.bashrc  </span><br><span class=\"line\">source ~/.bash_profile</span><br></pre></td></tr></table></figure>\n<p>安装完成后可以再次查看rvm版本，判断是否安装成功</p>\n<h3 id=\"2、升级ruby\"><a href=\"#2、升级ruby\" class=\"headerlink\" title=\"2、升级ruby\"></a>2、升级ruby</h3><p>查看ruby当前版本,以及本地所安装的所有版本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rvm list</span><br></pre></td></tr></table></figure>\n<p>查看ruby所有版本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rvm list known</span><br></pre></td></tr></table></figure>\n<p>安装新版本ruby 2.4.4</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rvm install 2.4.4</span><br></pre></td></tr></table></figure>\n<p>切换ruby到需要的版本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rvm --default use 2.4.4</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>最近工程更新开发环境，需要使用<code>ruby</code>的2.4.0以上的版本，而本地的开发环境是2.3.0，记录一下更换<code>ruby</code>方法</p>","more":"<h3 id=\"1、安装rvm\"><a href=\"#1、安装rvm\" class=\"headerlink\" title=\"1、安装rvm\"></a>1、安装rvm</h3><p>rvm就是Ruby Version Manager，是Ruby的版本管理器</p>\n<p>查看rvm版本：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rvm -v</span><br></pre></td></tr></table></figure>\n<p>安装rvm</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -L get.rvm.io | bash -s stable</span><br></pre></td></tr></table></figure>\n<p>更新修改配置文件使之生效</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source ~/.bashrc  </span><br><span class=\"line\">source ~/.bash_profile</span><br></pre></td></tr></table></figure>\n<p>安装完成后可以再次查看rvm版本，判断是否安装成功</p>\n<h3 id=\"2、升级ruby\"><a href=\"#2、升级ruby\" class=\"headerlink\" title=\"2、升级ruby\"></a>2、升级ruby</h3><p>查看ruby当前版本,以及本地所安装的所有版本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rvm list</span><br></pre></td></tr></table></figure>\n<p>查看ruby所有版本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rvm list known</span><br></pre></td></tr></table></figure>\n<p>安装新版本ruby 2.4.4</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rvm install 2.4.4</span><br></pre></td></tr></table></figure>\n<p>切换ruby到需要的版本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rvm --default use 2.4.4</span><br></pre></td></tr></table></figure>"},{"title":"使用命令行启动Sublime","date":"2017-10-06T14:10:38.000Z","_content":"\n\n### 使用终端启动Sublime ###\n\n工作中需要经常使用终端，有时候查看文本文件又需要使用`Sublime`,所以可以用终端调用`Sublime`是一件很方便的事情\n\n\n#### 准备工作 ####\n\n系统：mac ox\n\n软件：sublime\n\n<!-- more -->\n\n#### 第一步 查看终端是否能打开Sublime ####\n\n打开终端，`cd`到任意一个文件夹，输入如下命令：\n\n```\n/Applications/Sublime\\ Text.app/Contents/SharedSupport/bin/subl .\n```\n\n这时候如果`Sublime`成功的打开了当前命令所在的文件夹，就说明终端启动成功。\n\n如果无法启动，请查看sublime的路径和名称是否和你安装的相同\n\n`.`表示打开当前文件夹，如果输入具体文件名称，也可以打开具体文件\n\n\n#### 第二步 查看终端环境变量 ####\n\n在终端输入：\n\n```\nvim ~/.bash_profile\n```\n\n在里面找到当前系统的环境变量\n\n```\nexport PATH= \n```\n\n注意：如果你安装过`zsh`,那么你的环境变量应该到`~/.zshrc`中寻找\n\n如果你的环境变量文件编辑了，那么你需要`source 环境变量文件`一下你的环境变量文件，使他生效\n\n#### 第三步 创建命令 ####\n\n终端执行：\n\n```\nln -s /Applications/Sublime\\ Text.app/Contents/SharedSupport/bin/subl /usr/local/bin/subl\n```\n\n然后就搞定了。\n\n前面的路径是sublime的安装路径，后面的路径是设置好的环境变量\n\n在终端中使用下面命令测试一下\n\n```\nsubl .\n```\n\n如果成功打开当前路径文件夹就说明成了，以后使用`subl 文件名`就可以快速的在终端用`Sublime`打开文件啦\n\n\n#### 参考文件：\n\n1. [Open Sublime Text from Terminal in macOS](https://stackoverflow.com/questions/16199581/open-sublime-text-from-terminal-in-macos/41288133)\n\n2. [mac中的环境变量](https://blog.csdn.net/hlllmr1314/article/details/52228672)\n\n3. [sublime 官网描述](http://www.sublimetext.com/docs/3/osx_command_line.html)\n\n\n\n\n","source":"_posts/使用命令行启动Sublime.md","raw":"---\ntitle: 使用命令行启动Sublime\ndate: 2017-10-06 22:10:38\ntags: [日常, Linux]\n---\n\n\n### 使用终端启动Sublime ###\n\n工作中需要经常使用终端，有时候查看文本文件又需要使用`Sublime`,所以可以用终端调用`Sublime`是一件很方便的事情\n\n\n#### 准备工作 ####\n\n系统：mac ox\n\n软件：sublime\n\n<!-- more -->\n\n#### 第一步 查看终端是否能打开Sublime ####\n\n打开终端，`cd`到任意一个文件夹，输入如下命令：\n\n```\n/Applications/Sublime\\ Text.app/Contents/SharedSupport/bin/subl .\n```\n\n这时候如果`Sublime`成功的打开了当前命令所在的文件夹，就说明终端启动成功。\n\n如果无法启动，请查看sublime的路径和名称是否和你安装的相同\n\n`.`表示打开当前文件夹，如果输入具体文件名称，也可以打开具体文件\n\n\n#### 第二步 查看终端环境变量 ####\n\n在终端输入：\n\n```\nvim ~/.bash_profile\n```\n\n在里面找到当前系统的环境变量\n\n```\nexport PATH= \n```\n\n注意：如果你安装过`zsh`,那么你的环境变量应该到`~/.zshrc`中寻找\n\n如果你的环境变量文件编辑了，那么你需要`source 环境变量文件`一下你的环境变量文件，使他生效\n\n#### 第三步 创建命令 ####\n\n终端执行：\n\n```\nln -s /Applications/Sublime\\ Text.app/Contents/SharedSupport/bin/subl /usr/local/bin/subl\n```\n\n然后就搞定了。\n\n前面的路径是sublime的安装路径，后面的路径是设置好的环境变量\n\n在终端中使用下面命令测试一下\n\n```\nsubl .\n```\n\n如果成功打开当前路径文件夹就说明成了，以后使用`subl 文件名`就可以快速的在终端用`Sublime`打开文件啦\n\n\n#### 参考文件：\n\n1. [Open Sublime Text from Terminal in macOS](https://stackoverflow.com/questions/16199581/open-sublime-text-from-terminal-in-macos/41288133)\n\n2. [mac中的环境变量](https://blog.csdn.net/hlllmr1314/article/details/52228672)\n\n3. [sublime 官网描述](http://www.sublimetext.com/docs/3/osx_command_line.html)\n\n\n\n\n","slug":"使用命令行启动Sublime","published":1,"updated":"2021-04-12T09:17:38.421Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqjdx1o0001p5emujneaid15","content":"<h3 id=\"使用终端启动Sublime\"><a href=\"#使用终端启动Sublime\" class=\"headerlink\" title=\"使用终端启动Sublime\"></a>使用终端启动Sublime</h3><p>工作中需要经常使用终端，有时候查看文本文件又需要使用<code>Sublime</code>,所以可以用终端调用<code>Sublime</code>是一件很方便的事情</p>\n<h4 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h4><p>系统：mac ox</p>\n<p>软件：sublime</p>\n<a id=\"more\"></a>\n<h4 id=\"第一步-查看终端是否能打开Sublime\"><a href=\"#第一步-查看终端是否能打开Sublime\" class=\"headerlink\" title=\"第一步 查看终端是否能打开Sublime\"></a>第一步 查看终端是否能打开Sublime</h4><p>打开终端，<code>cd</code>到任意一个文件夹，输入如下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/Applications/Sublime\\ Text.app/Contents/SharedSupport/bin/subl .</span><br></pre></td></tr></table></figure>\n<p>这时候如果<code>Sublime</code>成功的打开了当前命令所在的文件夹，就说明终端启动成功。</p>\n<p>如果无法启动，请查看sublime的路径和名称是否和你安装的相同</p>\n<p><code>.</code>表示打开当前文件夹，如果输入具体文件名称，也可以打开具体文件</p>\n<h4 id=\"第二步-查看终端环境变量\"><a href=\"#第二步-查看终端环境变量\" class=\"headerlink\" title=\"第二步 查看终端环境变量\"></a>第二步 查看终端环境变量</h4><p>在终端输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim ~/.bash_profile</span><br></pre></td></tr></table></figure>\n<p>在里面找到当前系统的环境变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PATH=</span><br></pre></td></tr></table></figure>\n<p>注意：如果你安装过<code>zsh</code>,那么你的环境变量应该到<code>~/.zshrc</code>中寻找</p>\n<p>如果你的环境变量文件编辑了，那么你需要<code>source 环境变量文件</code>一下你的环境变量文件，使他生效</p>\n<h4 id=\"第三步-创建命令\"><a href=\"#第三步-创建命令\" class=\"headerlink\" title=\"第三步 创建命令\"></a>第三步 创建命令</h4><p>终端执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ln -s /Applications/Sublime\\ Text.app/Contents/SharedSupport/bin/subl /usr/local/bin/subl</span><br></pre></td></tr></table></figure>\n<p>然后就搞定了。</p>\n<p>前面的路径是sublime的安装路径，后面的路径是设置好的环境变量</p>\n<p>在终端中使用下面命令测试一下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">subl .</span><br></pre></td></tr></table></figure>\n<p>如果成功打开当前路径文件夹就说明成了，以后使用<code>subl 文件名</code>就可以快速的在终端用<code>Sublime</code>打开文件啦</p>\n<h4 id=\"参考文件：\"><a href=\"#参考文件：\" class=\"headerlink\" title=\"参考文件：\"></a>参考文件：</h4><ol>\n<li><p><a href=\"https://stackoverflow.com/questions/16199581/open-sublime-text-from-terminal-in-macos/41288133\" target=\"_blank\" rel=\"noopener\">Open Sublime Text from Terminal in macOS</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/hlllmr1314/article/details/52228672\" target=\"_blank\" rel=\"noopener\">mac中的环境变量</a></p>\n</li>\n<li><p><a href=\"http://www.sublimetext.com/docs/3/osx_command_line.html\" target=\"_blank\" rel=\"noopener\">sublime 官网描述</a></p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h3 id=\"使用终端启动Sublime\"><a href=\"#使用终端启动Sublime\" class=\"headerlink\" title=\"使用终端启动Sublime\"></a>使用终端启动Sublime</h3><p>工作中需要经常使用终端，有时候查看文本文件又需要使用<code>Sublime</code>,所以可以用终端调用<code>Sublime</code>是一件很方便的事情</p>\n<h4 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h4><p>系统：mac ox</p>\n<p>软件：sublime</p>","more":"<h4 id=\"第一步-查看终端是否能打开Sublime\"><a href=\"#第一步-查看终端是否能打开Sublime\" class=\"headerlink\" title=\"第一步 查看终端是否能打开Sublime\"></a>第一步 查看终端是否能打开Sublime</h4><p>打开终端，<code>cd</code>到任意一个文件夹，输入如下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/Applications/Sublime\\ Text.app/Contents/SharedSupport/bin/subl .</span><br></pre></td></tr></table></figure>\n<p>这时候如果<code>Sublime</code>成功的打开了当前命令所在的文件夹，就说明终端启动成功。</p>\n<p>如果无法启动，请查看sublime的路径和名称是否和你安装的相同</p>\n<p><code>.</code>表示打开当前文件夹，如果输入具体文件名称，也可以打开具体文件</p>\n<h4 id=\"第二步-查看终端环境变量\"><a href=\"#第二步-查看终端环境变量\" class=\"headerlink\" title=\"第二步 查看终端环境变量\"></a>第二步 查看终端环境变量</h4><p>在终端输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim ~/.bash_profile</span><br></pre></td></tr></table></figure>\n<p>在里面找到当前系统的环境变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PATH=</span><br></pre></td></tr></table></figure>\n<p>注意：如果你安装过<code>zsh</code>,那么你的环境变量应该到<code>~/.zshrc</code>中寻找</p>\n<p>如果你的环境变量文件编辑了，那么你需要<code>source 环境变量文件</code>一下你的环境变量文件，使他生效</p>\n<h4 id=\"第三步-创建命令\"><a href=\"#第三步-创建命令\" class=\"headerlink\" title=\"第三步 创建命令\"></a>第三步 创建命令</h4><p>终端执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ln -s /Applications/Sublime\\ Text.app/Contents/SharedSupport/bin/subl /usr/local/bin/subl</span><br></pre></td></tr></table></figure>\n<p>然后就搞定了。</p>\n<p>前面的路径是sublime的安装路径，后面的路径是设置好的环境变量</p>\n<p>在终端中使用下面命令测试一下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">subl .</span><br></pre></td></tr></table></figure>\n<p>如果成功打开当前路径文件夹就说明成了，以后使用<code>subl 文件名</code>就可以快速的在终端用<code>Sublime</code>打开文件啦</p>\n<h4 id=\"参考文件：\"><a href=\"#参考文件：\" class=\"headerlink\" title=\"参考文件：\"></a>参考文件：</h4><ol>\n<li><p><a href=\"https://stackoverflow.com/questions/16199581/open-sublime-text-from-terminal-in-macos/41288133\" target=\"_blank\" rel=\"noopener\">Open Sublime Text from Terminal in macOS</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/hlllmr1314/article/details/52228672\" target=\"_blank\" rel=\"noopener\">mac中的环境变量</a></p>\n</li>\n<li><p><a href=\"http://www.sublimetext.com/docs/3/osx_command_line.html\" target=\"_blank\" rel=\"noopener\">sublime 官网描述</a></p>\n</li>\n</ol>"},{"title":"synthesize和dynamic","date":"2017-05-24T15:07:32.000Z","_content":"\n\n## @property ##\n\n@property  会生成一个`ivar`和他的`getter/setter`方法\n\n但是在`protocol`和`category`中只会生成`getter/setter`方法的声明\n\n\n<!-- more -->\n\n## @synthesize ##\n\n@synthesize 表示如果属性没有手动实现`setter/getter`方法，编译器会自动加上`getter/setter`两个方法,给后面的实例变量\n\neg：\n\n```\n@syntheszie var = _var;\n```\n如果一个属性这么写了，表示你告诉编译器，生成一个以`var`命名的`setter/getter`方法，和一个实例变量`_var`。如果同时你又自己声明了一个名叫`_var`的实例变量，那么`@synthesize`就不会生成实例变量，而是用你声明的那个。也就是两个实例变量是一个。\n\n如果`_var`你写的是另一个属性的实例变量，那么会编译错误，但是你可以交换两个属性的实例变量。（可是没什么意义）\n\neg：\n\n```\n@syntheszie var\n```\n\n如果这么写，那么生成的实例变量就是`var`,这时你自己声明一个`_var`和`var`是不冲突的，也就是两个，属性用的是`var`。\n\n\n## @dynamic ##\n@dynamic 表示属性的`setter/getter`方法由用户自己实现，不自动生成。若没有手动生成，则运行时会报错，因为方法没有实现\n\neg：\n\n```\n@dynamic var;\n```\n","source":"_posts/synthesize和dynamic.md","raw":"---\ntitle: synthesize和dynamic\ndate: 2017-05-24 23:07:32\ntags: [iOS]\n---\n\n\n## @property ##\n\n@property  会生成一个`ivar`和他的`getter/setter`方法\n\n但是在`protocol`和`category`中只会生成`getter/setter`方法的声明\n\n\n<!-- more -->\n\n## @synthesize ##\n\n@synthesize 表示如果属性没有手动实现`setter/getter`方法，编译器会自动加上`getter/setter`两个方法,给后面的实例变量\n\neg：\n\n```\n@syntheszie var = _var;\n```\n如果一个属性这么写了，表示你告诉编译器，生成一个以`var`命名的`setter/getter`方法，和一个实例变量`_var`。如果同时你又自己声明了一个名叫`_var`的实例变量，那么`@synthesize`就不会生成实例变量，而是用你声明的那个。也就是两个实例变量是一个。\n\n如果`_var`你写的是另一个属性的实例变量，那么会编译错误，但是你可以交换两个属性的实例变量。（可是没什么意义）\n\neg：\n\n```\n@syntheszie var\n```\n\n如果这么写，那么生成的实例变量就是`var`,这时你自己声明一个`_var`和`var`是不冲突的，也就是两个，属性用的是`var`。\n\n\n## @dynamic ##\n@dynamic 表示属性的`setter/getter`方法由用户自己实现，不自动生成。若没有手动生成，则运行时会报错，因为方法没有实现\n\neg：\n\n```\n@dynamic var;\n```\n","slug":"synthesize和dynamic","published":1,"updated":"2021-04-12T09:17:38.421Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqjdx1o2001r5emudtzmuobg","content":"<h2 id=\"property\"><a href=\"#property\" class=\"headerlink\" title=\"@property\"></a>@property</h2><p>@property  会生成一个<code>ivar</code>和他的<code>getter/setter</code>方法</p>\n<p>但是在<code>protocol</code>和<code>category</code>中只会生成<code>getter/setter</code>方法的声明</p>\n<a id=\"more\"></a>\n<h2 id=\"synthesize\"><a href=\"#synthesize\" class=\"headerlink\" title=\"@synthesize\"></a>@synthesize</h2><p>@synthesize 表示如果属性没有手动实现<code>setter/getter</code>方法，编译器会自动加上<code>getter/setter</code>两个方法,给后面的实例变量</p>\n<p>eg：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@syntheszie var = _var;</span><br></pre></td></tr></table></figure>\n<p>如果一个属性这么写了，表示你告诉编译器，生成一个以<code>var</code>命名的<code>setter/getter</code>方法，和一个实例变量<code>_var</code>。如果同时你又自己声明了一个名叫<code>_var</code>的实例变量，那么<code>@synthesize</code>就不会生成实例变量，而是用你声明的那个。也就是两个实例变量是一个。</p>\n<p>如果<code>_var</code>你写的是另一个属性的实例变量，那么会编译错误，但是你可以交换两个属性的实例变量。（可是没什么意义）</p>\n<p>eg：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@syntheszie var</span><br></pre></td></tr></table></figure>\n<p>如果这么写，那么生成的实例变量就是<code>var</code>,这时你自己声明一个<code>_var</code>和<code>var</code>是不冲突的，也就是两个，属性用的是<code>var</code>。</p>\n<h2 id=\"dynamic\"><a href=\"#dynamic\" class=\"headerlink\" title=\"@dynamic\"></a>@dynamic</h2><p>@dynamic 表示属性的<code>setter/getter</code>方法由用户自己实现，不自动生成。若没有手动生成，则运行时会报错，因为方法没有实现</p>\n<p>eg：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@dynamic var;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"property\"><a href=\"#property\" class=\"headerlink\" title=\"@property\"></a>@property</h2><p>@property  会生成一个<code>ivar</code>和他的<code>getter/setter</code>方法</p>\n<p>但是在<code>protocol</code>和<code>category</code>中只会生成<code>getter/setter</code>方法的声明</p>","more":"<h2 id=\"synthesize\"><a href=\"#synthesize\" class=\"headerlink\" title=\"@synthesize\"></a>@synthesize</h2><p>@synthesize 表示如果属性没有手动实现<code>setter/getter</code>方法，编译器会自动加上<code>getter/setter</code>两个方法,给后面的实例变量</p>\n<p>eg：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@syntheszie var = _var;</span><br></pre></td></tr></table></figure>\n<p>如果一个属性这么写了，表示你告诉编译器，生成一个以<code>var</code>命名的<code>setter/getter</code>方法，和一个实例变量<code>_var</code>。如果同时你又自己声明了一个名叫<code>_var</code>的实例变量，那么<code>@synthesize</code>就不会生成实例变量，而是用你声明的那个。也就是两个实例变量是一个。</p>\n<p>如果<code>_var</code>你写的是另一个属性的实例变量，那么会编译错误，但是你可以交换两个属性的实例变量。（可是没什么意义）</p>\n<p>eg：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@syntheszie var</span><br></pre></td></tr></table></figure>\n<p>如果这么写，那么生成的实例变量就是<code>var</code>,这时你自己声明一个<code>_var</code>和<code>var</code>是不冲突的，也就是两个，属性用的是<code>var</code>。</p>\n<h2 id=\"dynamic\"><a href=\"#dynamic\" class=\"headerlink\" title=\"@dynamic\"></a>@dynamic</h2><p>@dynamic 表示属性的<code>setter/getter</code>方法由用户自己实现，不自动生成。若没有手动生成，则运行时会报错，因为方法没有实现</p>\n<p>eg：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@dynamic var;</span><br></pre></td></tr></table></figure>"},{"title":"吃黑苹果--Clover美化","date":"2019-07-11T15:10:12.000Z","_content":"\n## 前言 ##\n\n`Clover`是用来引导黑苹果的，但是默认设置有时候会满足不了我们的需求，所以需要美化\n\n<!-- more -->\n\n### 修改Clover分辨率 ###\n\n1. 关闭`CSM`， `CSM`是`BIOS`的一个设置项，它是一个兼容支持模块，可以让新的`UEFI BIOS`兼容老的`legacy+MBR`启动模式。关闭方法在:`BIOS`中设置\n    \n2. 使用`Clover configurator`，打开`‎⁨EFI⁩ ▸ ⁨EFI⁩ ▸ ⁨CLOVER ▸ config.plist`,在左边点击`GUI`栏，然后在右边`Screen Resolution`设置需要的分辨率\n\n### 修改默认启动系统 ###\n\n1. 使用`Clover configurator`，打开`‎⁨EFI⁩ ▸ ⁨EFI⁩ ▸ ⁨CLOVER ▸ config.plist`，在左边点击`boot`栏，在右边找到`Default Boot Volume`，选择`LastBootedVolume`，\n\n2. 在右边找到`Timeout`，并设置需要延迟的时间，如果勾选`-1`则不延迟，如果选择`Fast`则不显示`Clover`,快速启动系统\n\n### 查找所有启动项 ###\n\n1. 使用`Clover configurator`，打开`‎⁨EFI⁩ ▸ ⁨EFI⁩ ▸ ⁨CLOVER ▸ config.plist`，点击左边的`Boot.log`,再点击右下角的`Generate log`\n\n2. 从里面搜索`ScanLoader`，`ScanLoader`下面的`[xx]:启动项`就是启动项名\n\n\n### 隐藏无用启动项 ###\n\n1. 使用`Clover configurator`，打开`‎⁨EFI⁩ ▸ ⁨EFI⁩ ▸ ⁨CLOVER ▸ config.plist`，点击左边的`Gui`栏，在右边的`Hide Volume`里填入上面查找到的想要隐藏的启动项名称\n\n### 修改Clover主题 ###\n\n1. 下载喜欢的`clover`主题，并将文件夹放到`‎⁨EFI⁩ ▸ ⁨EFI⁩ ▸ ⁨CLOVER ▸ themes`文件夹中\n\n2. 修改`‎⁨EFI⁩ ▸ ⁨EFI⁩ ▸ ⁨CLOVER ▸ config.plist`，点击左边的`Gui`栏，在右边`Theme`填入对应主题的文件夹名称\n\n3. 如果找不到喜欢的主题，可以试试`Clover Theme Manager`,这个软件\n","source":"_posts/吃黑苹果--Clover美化.md","raw":"---\ntitle: 吃黑苹果--Clover美化\ndate: 2019-7-11 23:10:12\ntags: [黑苹果]\n---\n\n## 前言 ##\n\n`Clover`是用来引导黑苹果的，但是默认设置有时候会满足不了我们的需求，所以需要美化\n\n<!-- more -->\n\n### 修改Clover分辨率 ###\n\n1. 关闭`CSM`， `CSM`是`BIOS`的一个设置项，它是一个兼容支持模块，可以让新的`UEFI BIOS`兼容老的`legacy+MBR`启动模式。关闭方法在:`BIOS`中设置\n    \n2. 使用`Clover configurator`，打开`‎⁨EFI⁩ ▸ ⁨EFI⁩ ▸ ⁨CLOVER ▸ config.plist`,在左边点击`GUI`栏，然后在右边`Screen Resolution`设置需要的分辨率\n\n### 修改默认启动系统 ###\n\n1. 使用`Clover configurator`，打开`‎⁨EFI⁩ ▸ ⁨EFI⁩ ▸ ⁨CLOVER ▸ config.plist`，在左边点击`boot`栏，在右边找到`Default Boot Volume`，选择`LastBootedVolume`，\n\n2. 在右边找到`Timeout`，并设置需要延迟的时间，如果勾选`-1`则不延迟，如果选择`Fast`则不显示`Clover`,快速启动系统\n\n### 查找所有启动项 ###\n\n1. 使用`Clover configurator`，打开`‎⁨EFI⁩ ▸ ⁨EFI⁩ ▸ ⁨CLOVER ▸ config.plist`，点击左边的`Boot.log`,再点击右下角的`Generate log`\n\n2. 从里面搜索`ScanLoader`，`ScanLoader`下面的`[xx]:启动项`就是启动项名\n\n\n### 隐藏无用启动项 ###\n\n1. 使用`Clover configurator`，打开`‎⁨EFI⁩ ▸ ⁨EFI⁩ ▸ ⁨CLOVER ▸ config.plist`，点击左边的`Gui`栏，在右边的`Hide Volume`里填入上面查找到的想要隐藏的启动项名称\n\n### 修改Clover主题 ###\n\n1. 下载喜欢的`clover`主题，并将文件夹放到`‎⁨EFI⁩ ▸ ⁨EFI⁩ ▸ ⁨CLOVER ▸ themes`文件夹中\n\n2. 修改`‎⁨EFI⁩ ▸ ⁨EFI⁩ ▸ ⁨CLOVER ▸ config.plist`，点击左边的`Gui`栏，在右边`Theme`填入对应主题的文件夹名称\n\n3. 如果找不到喜欢的主题，可以试试`Clover Theme Manager`,这个软件\n","slug":"吃黑苹果--Clover美化","published":1,"updated":"2021-04-12T09:17:38.421Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqjdx1o4001u5emuy2khmy15","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p><code>Clover</code>是用来引导黑苹果的，但是默认设置有时候会满足不了我们的需求，所以需要美化</p>\n<a id=\"more\"></a>\n<h3 id=\"修改Clover分辨率\"><a href=\"#修改Clover分辨率\" class=\"headerlink\" title=\"修改Clover分辨率\"></a>修改Clover分辨率</h3><ol>\n<li><p>关闭<code>CSM</code>， <code>CSM</code>是<code>BIOS</code>的一个设置项，它是一个兼容支持模块，可以让新的<code>UEFI BIOS</code>兼容老的<code>legacy+MBR</code>启动模式。关闭方法在:<code>BIOS</code>中设置</p>\n</li>\n<li><p>使用<code>Clover configurator</code>，打开<code>‎⁨EFI⁩ ▸ ⁨EFI⁩ ▸ ⁨CLOVER ▸ config.plist</code>,在左边点击<code>GUI</code>栏，然后在右边<code>Screen Resolution</code>设置需要的分辨率</p>\n</li>\n</ol>\n<h3 id=\"修改默认启动系统\"><a href=\"#修改默认启动系统\" class=\"headerlink\" title=\"修改默认启动系统\"></a>修改默认启动系统</h3><ol>\n<li><p>使用<code>Clover configurator</code>，打开<code>‎⁨EFI⁩ ▸ ⁨EFI⁩ ▸ ⁨CLOVER ▸ config.plist</code>，在左边点击<code>boot</code>栏，在右边找到<code>Default Boot Volume</code>，选择<code>LastBootedVolume</code>，</p>\n</li>\n<li><p>在右边找到<code>Timeout</code>，并设置需要延迟的时间，如果勾选<code>-1</code>则不延迟，如果选择<code>Fast</code>则不显示<code>Clover</code>,快速启动系统</p>\n</li>\n</ol>\n<h3 id=\"查找所有启动项\"><a href=\"#查找所有启动项\" class=\"headerlink\" title=\"查找所有启动项\"></a>查找所有启动项</h3><ol>\n<li><p>使用<code>Clover configurator</code>，打开<code>‎⁨EFI⁩ ▸ ⁨EFI⁩ ▸ ⁨CLOVER ▸ config.plist</code>，点击左边的<code>Boot.log</code>,再点击右下角的<code>Generate log</code></p>\n</li>\n<li><p>从里面搜索<code>ScanLoader</code>，<code>ScanLoader</code>下面的<code>[xx]:启动项</code>就是启动项名</p>\n</li>\n</ol>\n<h3 id=\"隐藏无用启动项\"><a href=\"#隐藏无用启动项\" class=\"headerlink\" title=\"隐藏无用启动项\"></a>隐藏无用启动项</h3><ol>\n<li>使用<code>Clover configurator</code>，打开<code>‎⁨EFI⁩ ▸ ⁨EFI⁩ ▸ ⁨CLOVER ▸ config.plist</code>，点击左边的<code>Gui</code>栏，在右边的<code>Hide Volume</code>里填入上面查找到的想要隐藏的启动项名称</li>\n</ol>\n<h3 id=\"修改Clover主题\"><a href=\"#修改Clover主题\" class=\"headerlink\" title=\"修改Clover主题\"></a>修改Clover主题</h3><ol>\n<li><p>下载喜欢的<code>clover</code>主题，并将文件夹放到<code>‎⁨EFI⁩ ▸ ⁨EFI⁩ ▸ ⁨CLOVER ▸ themes</code>文件夹中</p>\n</li>\n<li><p>修改<code>‎⁨EFI⁩ ▸ ⁨EFI⁩ ▸ ⁨CLOVER ▸ config.plist</code>，点击左边的<code>Gui</code>栏，在右边<code>Theme</code>填入对应主题的文件夹名称</p>\n</li>\n<li><p>如果找不到喜欢的主题，可以试试<code>Clover Theme Manager</code>,这个软件</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p><code>Clover</code>是用来引导黑苹果的，但是默认设置有时候会满足不了我们的需求，所以需要美化</p>","more":"<h3 id=\"修改Clover分辨率\"><a href=\"#修改Clover分辨率\" class=\"headerlink\" title=\"修改Clover分辨率\"></a>修改Clover分辨率</h3><ol>\n<li><p>关闭<code>CSM</code>， <code>CSM</code>是<code>BIOS</code>的一个设置项，它是一个兼容支持模块，可以让新的<code>UEFI BIOS</code>兼容老的<code>legacy+MBR</code>启动模式。关闭方法在:<code>BIOS</code>中设置</p>\n</li>\n<li><p>使用<code>Clover configurator</code>，打开<code>‎⁨EFI⁩ ▸ ⁨EFI⁩ ▸ ⁨CLOVER ▸ config.plist</code>,在左边点击<code>GUI</code>栏，然后在右边<code>Screen Resolution</code>设置需要的分辨率</p>\n</li>\n</ol>\n<h3 id=\"修改默认启动系统\"><a href=\"#修改默认启动系统\" class=\"headerlink\" title=\"修改默认启动系统\"></a>修改默认启动系统</h3><ol>\n<li><p>使用<code>Clover configurator</code>，打开<code>‎⁨EFI⁩ ▸ ⁨EFI⁩ ▸ ⁨CLOVER ▸ config.plist</code>，在左边点击<code>boot</code>栏，在右边找到<code>Default Boot Volume</code>，选择<code>LastBootedVolume</code>，</p>\n</li>\n<li><p>在右边找到<code>Timeout</code>，并设置需要延迟的时间，如果勾选<code>-1</code>则不延迟，如果选择<code>Fast</code>则不显示<code>Clover</code>,快速启动系统</p>\n</li>\n</ol>\n<h3 id=\"查找所有启动项\"><a href=\"#查找所有启动项\" class=\"headerlink\" title=\"查找所有启动项\"></a>查找所有启动项</h3><ol>\n<li><p>使用<code>Clover configurator</code>，打开<code>‎⁨EFI⁩ ▸ ⁨EFI⁩ ▸ ⁨CLOVER ▸ config.plist</code>，点击左边的<code>Boot.log</code>,再点击右下角的<code>Generate log</code></p>\n</li>\n<li><p>从里面搜索<code>ScanLoader</code>，<code>ScanLoader</code>下面的<code>[xx]:启动项</code>就是启动项名</p>\n</li>\n</ol>\n<h3 id=\"隐藏无用启动项\"><a href=\"#隐藏无用启动项\" class=\"headerlink\" title=\"隐藏无用启动项\"></a>隐藏无用启动项</h3><ol>\n<li>使用<code>Clover configurator</code>，打开<code>‎⁨EFI⁩ ▸ ⁨EFI⁩ ▸ ⁨CLOVER ▸ config.plist</code>，点击左边的<code>Gui</code>栏，在右边的<code>Hide Volume</code>里填入上面查找到的想要隐藏的启动项名称</li>\n</ol>\n<h3 id=\"修改Clover主题\"><a href=\"#修改Clover主题\" class=\"headerlink\" title=\"修改Clover主题\"></a>修改Clover主题</h3><ol>\n<li><p>下载喜欢的<code>clover</code>主题，并将文件夹放到<code>‎⁨EFI⁩ ▸ ⁨EFI⁩ ▸ ⁨CLOVER ▸ themes</code>文件夹中</p>\n</li>\n<li><p>修改<code>‎⁨EFI⁩ ▸ ⁨EFI⁩ ▸ ⁨CLOVER ▸ config.plist</code>，点击左边的<code>Gui</code>栏，在右边<code>Theme</code>填入对应主题的文件夹名称</p>\n</li>\n<li><p>如果找不到喜欢的主题，可以试试<code>Clover Theme Manager</code>,这个软件</p>\n</li>\n</ol>"},{"title":"吃黑苹果--声卡驱动","date":"2019-07-11T15:10:12.000Z","_content":"\n## 前言 ## \n\n电脑升级`10.14.5`之后声卡不能切换设备，不能调整音量，怀疑是声卡驱动不是最新的，所以更新声卡驱动就好\n\n<!-- more -->\n\n### 查看声卡 ###\n\n要找到对应的驱动，首先要知道声卡的型号，我的主板是`华硕B150-A`,中关村在线搜索得知搭载的板载声卡型号是`集成Realtek ALC887 8声道音效芯片`\n\n### 下载驱动 ###\n\n知道声卡型号就可以去下载最新的声卡驱动`AppleALC`，[下载地址](https://github.com/acidanthera/AppleALC/releases)\n\n同时下载对最新`Lilu`, [下载地址](https://github.com/acidanthera/Lilu/releases)\n\n### 更新驱动 ###\n\n将下载好的声卡驱动文件`AppleALC`和`Lilu`解压，并放在`‎⁨EFI⁩ ▸ ⁨EFI⁩ ▸ ⁨CLOVER⁩ ▸ ⁨kexts⁩`\n\n### 修改ID ###\n\n首先在[这里](https://github.com/acidanthera/AppleALC/wiki/Supported-codecs)查看你的声卡支持的ID\n\n然后使用`Clover configurator`或者其他plist编辑文件，编辑你`EFI`分区下的`Clover`配置文件，我的路径是`‎⁨EFI⁩ ▸ ⁨EFI⁩ ▸ ⁨CLOVER ▸ config.plist`\n\n用`Clover configurator`打开`config.plist`,选择左边的`Devices`,然后在右边`Audio`下面填写上面查到的声卡支持的ID,保存，重启\n\n### 注意 ###\n\n1. 替换驱动的时候记得做好备份\n2. 如果没有效果，请确定没安装其他的声卡驱动\n3. 更新系统后，有可能要更新驱动和ID\n4. 如果还没有效果，那么你可以使用`Kext Utility`更新`S/L/E`下的`AppleHDA.kext`,同时使用命令`sudo kextcache -i /`更新缓存\n","source":"_posts/吃黑苹果--声卡驱动.md","raw":"---\ntitle: 吃黑苹果--声卡驱动\ndate: 2019-7-11 23:10:12\ntags: [黑苹果]\n---\n\n## 前言 ## \n\n电脑升级`10.14.5`之后声卡不能切换设备，不能调整音量，怀疑是声卡驱动不是最新的，所以更新声卡驱动就好\n\n<!-- more -->\n\n### 查看声卡 ###\n\n要找到对应的驱动，首先要知道声卡的型号，我的主板是`华硕B150-A`,中关村在线搜索得知搭载的板载声卡型号是`集成Realtek ALC887 8声道音效芯片`\n\n### 下载驱动 ###\n\n知道声卡型号就可以去下载最新的声卡驱动`AppleALC`，[下载地址](https://github.com/acidanthera/AppleALC/releases)\n\n同时下载对最新`Lilu`, [下载地址](https://github.com/acidanthera/Lilu/releases)\n\n### 更新驱动 ###\n\n将下载好的声卡驱动文件`AppleALC`和`Lilu`解压，并放在`‎⁨EFI⁩ ▸ ⁨EFI⁩ ▸ ⁨CLOVER⁩ ▸ ⁨kexts⁩`\n\n### 修改ID ###\n\n首先在[这里](https://github.com/acidanthera/AppleALC/wiki/Supported-codecs)查看你的声卡支持的ID\n\n然后使用`Clover configurator`或者其他plist编辑文件，编辑你`EFI`分区下的`Clover`配置文件，我的路径是`‎⁨EFI⁩ ▸ ⁨EFI⁩ ▸ ⁨CLOVER ▸ config.plist`\n\n用`Clover configurator`打开`config.plist`,选择左边的`Devices`,然后在右边`Audio`下面填写上面查到的声卡支持的ID,保存，重启\n\n### 注意 ###\n\n1. 替换驱动的时候记得做好备份\n2. 如果没有效果，请确定没安装其他的声卡驱动\n3. 更新系统后，有可能要更新驱动和ID\n4. 如果还没有效果，那么你可以使用`Kext Utility`更新`S/L/E`下的`AppleHDA.kext`,同时使用命令`sudo kextcache -i /`更新缓存\n","slug":"吃黑苹果--声卡驱动","published":1,"updated":"2021-04-12T09:17:38.421Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqjdx1o5001w5emuuubc4m9r","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>电脑升级<code>10.14.5</code>之后声卡不能切换设备，不能调整音量，怀疑是声卡驱动不是最新的，所以更新声卡驱动就好</p>\n<a id=\"more\"></a>\n<h3 id=\"查看声卡\"><a href=\"#查看声卡\" class=\"headerlink\" title=\"查看声卡\"></a>查看声卡</h3><p>要找到对应的驱动，首先要知道声卡的型号，我的主板是<code>华硕B150-A</code>,中关村在线搜索得知搭载的板载声卡型号是<code>集成Realtek ALC887 8声道音效芯片</code></p>\n<h3 id=\"下载驱动\"><a href=\"#下载驱动\" class=\"headerlink\" title=\"下载驱动\"></a>下载驱动</h3><p>知道声卡型号就可以去下载最新的声卡驱动<code>AppleALC</code>，<a href=\"https://github.com/acidanthera/AppleALC/releases\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p>同时下载对最新<code>Lilu</code>, <a href=\"https://github.com/acidanthera/Lilu/releases\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<h3 id=\"更新驱动\"><a href=\"#更新驱动\" class=\"headerlink\" title=\"更新驱动\"></a>更新驱动</h3><p>将下载好的声卡驱动文件<code>AppleALC</code>和<code>Lilu</code>解压，并放在<code>‎⁨EFI⁩ ▸ ⁨EFI⁩ ▸ ⁨CLOVER⁩ ▸ ⁨kexts⁩</code></p>\n<h3 id=\"修改ID\"><a href=\"#修改ID\" class=\"headerlink\" title=\"修改ID\"></a>修改ID</h3><p>首先在<a href=\"https://github.com/acidanthera/AppleALC/wiki/Supported-codecs\" target=\"_blank\" rel=\"noopener\">这里</a>查看你的声卡支持的ID</p>\n<p>然后使用<code>Clover configurator</code>或者其他plist编辑文件，编辑你<code>EFI</code>分区下的<code>Clover</code>配置文件，我的路径是<code>‎⁨EFI⁩ ▸ ⁨EFI⁩ ▸ ⁨CLOVER ▸ config.plist</code></p>\n<p>用<code>Clover configurator</code>打开<code>config.plist</code>,选择左边的<code>Devices</code>,然后在右边<code>Audio</code>下面填写上面查到的声卡支持的ID,保存，重启</p>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><ol>\n<li>替换驱动的时候记得做好备份</li>\n<li>如果没有效果，请确定没安装其他的声卡驱动</li>\n<li>更新系统后，有可能要更新驱动和ID</li>\n<li>如果还没有效果，那么你可以使用<code>Kext Utility</code>更新<code>S/L/E</code>下的<code>AppleHDA.kext</code>,同时使用命令<code>sudo kextcache -i /</code>更新缓存</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>电脑升级<code>10.14.5</code>之后声卡不能切换设备，不能调整音量，怀疑是声卡驱动不是最新的，所以更新声卡驱动就好</p>","more":"<h3 id=\"查看声卡\"><a href=\"#查看声卡\" class=\"headerlink\" title=\"查看声卡\"></a>查看声卡</h3><p>要找到对应的驱动，首先要知道声卡的型号，我的主板是<code>华硕B150-A</code>,中关村在线搜索得知搭载的板载声卡型号是<code>集成Realtek ALC887 8声道音效芯片</code></p>\n<h3 id=\"下载驱动\"><a href=\"#下载驱动\" class=\"headerlink\" title=\"下载驱动\"></a>下载驱动</h3><p>知道声卡型号就可以去下载最新的声卡驱动<code>AppleALC</code>，<a href=\"https://github.com/acidanthera/AppleALC/releases\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<p>同时下载对最新<code>Lilu</code>, <a href=\"https://github.com/acidanthera/Lilu/releases\" target=\"_blank\" rel=\"noopener\">下载地址</a></p>\n<h3 id=\"更新驱动\"><a href=\"#更新驱动\" class=\"headerlink\" title=\"更新驱动\"></a>更新驱动</h3><p>将下载好的声卡驱动文件<code>AppleALC</code>和<code>Lilu</code>解压，并放在<code>‎⁨EFI⁩ ▸ ⁨EFI⁩ ▸ ⁨CLOVER⁩ ▸ ⁨kexts⁩</code></p>\n<h3 id=\"修改ID\"><a href=\"#修改ID\" class=\"headerlink\" title=\"修改ID\"></a>修改ID</h3><p>首先在<a href=\"https://github.com/acidanthera/AppleALC/wiki/Supported-codecs\" target=\"_blank\" rel=\"noopener\">这里</a>查看你的声卡支持的ID</p>\n<p>然后使用<code>Clover configurator</code>或者其他plist编辑文件，编辑你<code>EFI</code>分区下的<code>Clover</code>配置文件，我的路径是<code>‎⁨EFI⁩ ▸ ⁨EFI⁩ ▸ ⁨CLOVER ▸ config.plist</code></p>\n<p>用<code>Clover configurator</code>打开<code>config.plist</code>,选择左边的<code>Devices</code>,然后在右边<code>Audio</code>下面填写上面查到的声卡支持的ID,保存，重启</p>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><ol>\n<li>替换驱动的时候记得做好备份</li>\n<li>如果没有效果，请确定没安装其他的声卡驱动</li>\n<li>更新系统后，有可能要更新驱动和ID</li>\n<li>如果还没有效果，那么你可以使用<code>Kext Utility</code>更新<code>S/L/E</code>下的<code>AppleHDA.kext</code>,同时使用命令<code>sudo kextcache -i /</code>更新缓存</li>\n</ol>"},{"title":"我家云搞OMV","date":"2020-11-11T15:10:12.000Z","_content":"\n## 前言 ## \n\n最近闲的蛋疼，收了两个矿渣我家云，想着玩玩NAS，这里记录一下折腾过程\n\n网上有一些现成的教程，都是大佬折腾好的，直接刷入，就可以使用了，基本没什么坑，但是我在使用过程中，发现`transmission`老是爆内存，然后被系统杀死，一个不能挂PT的NAS还是一个好NAS么，所以我打算自己搞一个OMV看看能解决这个问题不\n\n\n<!-- more -->\n\n## 安装linux\n\n我家云的CPU是RK3328，多少核心啥的，自己百度一下吧，但是重点是，这个U是开源的，也就是你可以定制自己的系统，国外这里有详细的介绍，包括刷机，[点击这里](https://roc-rk3328-cc.readthedocs.io/en/latest/resource.html)\n\n刷linux系统你需要如下东西：\n\n硬件：\n1. 我家云，\n2. 公对公USB线一条\n3. Windows电脑一台\n\n软件：\n1. DriverAssistant （驱动）\n2. AndroidTool （刷机软件）\n3. boot.img (引导镜像)\n4. linux.img (系统镜像)\n\n刷机过程：\n\n首先，运行`DriverInstall.exe`安装驱动，然后，我家云用usb线连接电脑（使用白色2.0接口），运行刷机软件，选则上面两个镜像，按住我家云reset键，接入电源，软件找到设备，点击执行，等待刷写完成\n\n成功以后，我家云接入有线网，使用ssh登录\n\n```\nssh root@我家云ip\n密码默认 1234\n```\n这里就进入了我家云linux系统\n\n执行\n```\napt update \napt upgrade\n```\n\n更新系统\n\n## omv安装\n\n``` sh\n<!--下载key-->\nwget http://packages.openmediavault.org/public/archive.key\n<!--添加key-->\napt-key add archive.key\n<!--创建服务列表-->\nvim /etc/apt/sources.list.d/openmediavault.list\n<!--在列表中添加下面两个源-->\ndeb http://packages.openmediavault.org/public arrakis main\ndeb http://packages.openmediavault.org/public usul main\n<!--更新源-->\napt update\n<!--安装omv-->\napt install openmediavaul\n```\n\n漫长的等待之后，就安装好了OMV，用浏览器访问我家云ip，就能看到登录页面。\n账号： admin\n密码： openmediavault\n\n## 安装OMV-Extras\n\nOMV5默认是没有OMV-Extras的，需要我们自己安装\n[官网](https://omv-extras.org/)给出的教程是这样的，在终端使用root用户运行下面命令\n\n```sh\nwget -O - https://github.com/OpenMediaVault-Plugin-Developers/packages/raw/master/install | bash\n```\n\n显示`done`就表示完成了\n\n## OMV的使用\n\n在终端对OMV做一些配置，可以使用如下命令\n\n```\nomv-firstaid\n```\n\n如果出现ip无法访问OMV，可以使用这个命令初始化端口和软件\n\n\n## docker安装\n\n安装完`OMV-Extras`在OMV的web页面，左边系统栏下面会多一个`OMV-Extras`的选项，点击进入，然后选择docker，选择安装，就会自动安装完成docker，同样的可以把portainer安装完成，portainer是docker的可视化管理工具，可以用来创建容器，安装镜像\n\n## transmission安装\n\n进入portainer管理页，选择local，在`container`容器中，新建一个容器，名字随便输入，image镜像输入[docker hub](https://hub.docker.com/)中搜索到的名字`linuxserver/transmission`，从dockerhub说明页中的配置信息可以看到，transmission,需要映射9019，51413，51413udp，三个端口，同时在volumes中将对的的路径映射到本地，添加env变量，接下来部署，等待完成就可以使用transmission了\n\n## 其他\n\n网上有个设置好的`omv`但是，使用过程中风扇一直狂转，声音有些大，所以我找到一个改风扇的文件，估计就是恩山的，但是恩山要币，我下载不下来，不知道是不是同一个，使用方法\n\n在系统 - 计划任务中，停掉`/opt/fan`任务，启动放入文件的任务\n\n","source":"_posts/我家云搞OMV.md","raw":"\n---\ntitle: 我家云搞OMV\ndate: 2020-11-11 23:10:12\ntags: [我家云,OMV,armbian]\n---\n\n## 前言 ## \n\n最近闲的蛋疼，收了两个矿渣我家云，想着玩玩NAS，这里记录一下折腾过程\n\n网上有一些现成的教程，都是大佬折腾好的，直接刷入，就可以使用了，基本没什么坑，但是我在使用过程中，发现`transmission`老是爆内存，然后被系统杀死，一个不能挂PT的NAS还是一个好NAS么，所以我打算自己搞一个OMV看看能解决这个问题不\n\n\n<!-- more -->\n\n## 安装linux\n\n我家云的CPU是RK3328，多少核心啥的，自己百度一下吧，但是重点是，这个U是开源的，也就是你可以定制自己的系统，国外这里有详细的介绍，包括刷机，[点击这里](https://roc-rk3328-cc.readthedocs.io/en/latest/resource.html)\n\n刷linux系统你需要如下东西：\n\n硬件：\n1. 我家云，\n2. 公对公USB线一条\n3. Windows电脑一台\n\n软件：\n1. DriverAssistant （驱动）\n2. AndroidTool （刷机软件）\n3. boot.img (引导镜像)\n4. linux.img (系统镜像)\n\n刷机过程：\n\n首先，运行`DriverInstall.exe`安装驱动，然后，我家云用usb线连接电脑（使用白色2.0接口），运行刷机软件，选则上面两个镜像，按住我家云reset键，接入电源，软件找到设备，点击执行，等待刷写完成\n\n成功以后，我家云接入有线网，使用ssh登录\n\n```\nssh root@我家云ip\n密码默认 1234\n```\n这里就进入了我家云linux系统\n\n执行\n```\napt update \napt upgrade\n```\n\n更新系统\n\n## omv安装\n\n``` sh\n<!--下载key-->\nwget http://packages.openmediavault.org/public/archive.key\n<!--添加key-->\napt-key add archive.key\n<!--创建服务列表-->\nvim /etc/apt/sources.list.d/openmediavault.list\n<!--在列表中添加下面两个源-->\ndeb http://packages.openmediavault.org/public arrakis main\ndeb http://packages.openmediavault.org/public usul main\n<!--更新源-->\napt update\n<!--安装omv-->\napt install openmediavaul\n```\n\n漫长的等待之后，就安装好了OMV，用浏览器访问我家云ip，就能看到登录页面。\n账号： admin\n密码： openmediavault\n\n## 安装OMV-Extras\n\nOMV5默认是没有OMV-Extras的，需要我们自己安装\n[官网](https://omv-extras.org/)给出的教程是这样的，在终端使用root用户运行下面命令\n\n```sh\nwget -O - https://github.com/OpenMediaVault-Plugin-Developers/packages/raw/master/install | bash\n```\n\n显示`done`就表示完成了\n\n## OMV的使用\n\n在终端对OMV做一些配置，可以使用如下命令\n\n```\nomv-firstaid\n```\n\n如果出现ip无法访问OMV，可以使用这个命令初始化端口和软件\n\n\n## docker安装\n\n安装完`OMV-Extras`在OMV的web页面，左边系统栏下面会多一个`OMV-Extras`的选项，点击进入，然后选择docker，选择安装，就会自动安装完成docker，同样的可以把portainer安装完成，portainer是docker的可视化管理工具，可以用来创建容器，安装镜像\n\n## transmission安装\n\n进入portainer管理页，选择local，在`container`容器中，新建一个容器，名字随便输入，image镜像输入[docker hub](https://hub.docker.com/)中搜索到的名字`linuxserver/transmission`，从dockerhub说明页中的配置信息可以看到，transmission,需要映射9019，51413，51413udp，三个端口，同时在volumes中将对的的路径映射到本地，添加env变量，接下来部署，等待完成就可以使用transmission了\n\n## 其他\n\n网上有个设置好的`omv`但是，使用过程中风扇一直狂转，声音有些大，所以我找到一个改风扇的文件，估计就是恩山的，但是恩山要币，我下载不下来，不知道是不是同一个，使用方法\n\n在系统 - 计划任务中，停掉`/opt/fan`任务，启动放入文件的任务\n\n","slug":"我家云搞OMV","published":1,"updated":"2021-04-12T09:30:47.203Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqjdx1o6001z5emu4vzocaps","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>最近闲的蛋疼，收了两个矿渣我家云，想着玩玩NAS，这里记录一下折腾过程</p>\n<p>网上有一些现成的教程，都是大佬折腾好的，直接刷入，就可以使用了，基本没什么坑，但是我在使用过程中，发现<code>transmission</code>老是爆内存，然后被系统杀死，一个不能挂PT的NAS还是一个好NAS么，所以我打算自己搞一个OMV看看能解决这个问题不</p>\n<a id=\"more\"></a>\n<h2 id=\"安装linux\"><a href=\"#安装linux\" class=\"headerlink\" title=\"安装linux\"></a>安装linux</h2><p>我家云的CPU是RK3328，多少核心啥的，自己百度一下吧，但是重点是，这个U是开源的，也就是你可以定制自己的系统，国外这里有详细的介绍，包括刷机，<a href=\"https://roc-rk3328-cc.readthedocs.io/en/latest/resource.html\" target=\"_blank\" rel=\"noopener\">点击这里</a></p>\n<p>刷linux系统你需要如下东西：</p>\n<p>硬件：</p>\n<ol>\n<li>我家云，</li>\n<li>公对公USB线一条</li>\n<li>Windows电脑一台</li>\n</ol>\n<p>软件：</p>\n<ol>\n<li>DriverAssistant （驱动）</li>\n<li>AndroidTool （刷机软件）</li>\n<li>boot.img (引导镜像)</li>\n<li>linux.img (系统镜像)</li>\n</ol>\n<p>刷机过程：</p>\n<p>首先，运行<code>DriverInstall.exe</code>安装驱动，然后，我家云用usb线连接电脑（使用白色2.0接口），运行刷机软件，选则上面两个镜像，按住我家云reset键，接入电源，软件找到设备，点击执行，等待刷写完成</p>\n<p>成功以后，我家云接入有线网，使用ssh登录</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh root@我家云ip</span><br><span class=\"line\">密码默认 1234</span><br></pre></td></tr></table></figure>\n<p>这里就进入了我家云linux系统</p>\n<p>执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt update </span><br><span class=\"line\">apt upgrade</span><br></pre></td></tr></table></figure></p>\n<p>更新系统</p>\n<h2 id=\"omv安装\"><a href=\"#omv安装\" class=\"headerlink\" title=\"omv安装\"></a>omv安装</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--下载key--&gt;</span><br><span class=\"line\">wget http://packages.openmediavault.org/public/archive.key</span><br><span class=\"line\">&lt;!--添加key--&gt;</span><br><span class=\"line\">apt-key add archive.key</span><br><span class=\"line\">&lt;!--创建服务列表--&gt;</span><br><span class=\"line\">vim /etc/apt/sources.list.d/openmediavault.list</span><br><span class=\"line\">&lt;!--在列表中添加下面两个源--&gt;</span><br><span class=\"line\">deb http://packages.openmediavault.org/public arrakis main</span><br><span class=\"line\">deb http://packages.openmediavault.org/public usul main</span><br><span class=\"line\">&lt;!--更新源--&gt;</span><br><span class=\"line\">apt update</span><br><span class=\"line\">&lt;!--安装omv--&gt;</span><br><span class=\"line\">apt install openmediavaul</span><br></pre></td></tr></table></figure>\n<p>漫长的等待之后，就安装好了OMV，用浏览器访问我家云ip，就能看到登录页面。<br>账号： admin<br>密码： openmediavault</p>\n<h2 id=\"安装OMV-Extras\"><a href=\"#安装OMV-Extras\" class=\"headerlink\" title=\"安装OMV-Extras\"></a>安装OMV-Extras</h2><p>OMV5默认是没有OMV-Extras的，需要我们自己安装<br><a href=\"https://omv-extras.org/\" target=\"_blank\" rel=\"noopener\">官网</a>给出的教程是这样的，在终端使用root用户运行下面命令</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget -O - https://github.com/OpenMediaVault-Plugin-Developers/packages/raw/master/install | bash</span><br></pre></td></tr></table></figure>\n<p>显示<code>done</code>就表示完成了</p>\n<h2 id=\"OMV的使用\"><a href=\"#OMV的使用\" class=\"headerlink\" title=\"OMV的使用\"></a>OMV的使用</h2><p>在终端对OMV做一些配置，可以使用如下命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">omv-firstaid</span><br></pre></td></tr></table></figure>\n<p>如果出现ip无法访问OMV，可以使用这个命令初始化端口和软件</p>\n<h2 id=\"docker安装\"><a href=\"#docker安装\" class=\"headerlink\" title=\"docker安装\"></a>docker安装</h2><p>安装完<code>OMV-Extras</code>在OMV的web页面，左边系统栏下面会多一个<code>OMV-Extras</code>的选项，点击进入，然后选择docker，选择安装，就会自动安装完成docker，同样的可以把portainer安装完成，portainer是docker的可视化管理工具，可以用来创建容器，安装镜像</p>\n<h2 id=\"transmission安装\"><a href=\"#transmission安装\" class=\"headerlink\" title=\"transmission安装\"></a>transmission安装</h2><p>进入portainer管理页，选择local，在<code>container</code>容器中，新建一个容器，名字随便输入，image镜像输入<a href=\"https://hub.docker.com/\" target=\"_blank\" rel=\"noopener\">docker hub</a>中搜索到的名字<code>linuxserver/transmission</code>，从dockerhub说明页中的配置信息可以看到，transmission,需要映射9019，51413，51413udp，三个端口，同时在volumes中将对的的路径映射到本地，添加env变量，接下来部署，等待完成就可以使用transmission了</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>网上有个设置好的<code>omv</code>但是，使用过程中风扇一直狂转，声音有些大，所以我找到一个改风扇的文件，估计就是恩山的，但是恩山要币，我下载不下来，不知道是不是同一个，使用方法</p>\n<p>在系统 - 计划任务中，停掉<code>/opt/fan</code>任务，启动放入文件的任务</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>最近闲的蛋疼，收了两个矿渣我家云，想着玩玩NAS，这里记录一下折腾过程</p>\n<p>网上有一些现成的教程，都是大佬折腾好的，直接刷入，就可以使用了，基本没什么坑，但是我在使用过程中，发现<code>transmission</code>老是爆内存，然后被系统杀死，一个不能挂PT的NAS还是一个好NAS么，所以我打算自己搞一个OMV看看能解决这个问题不</p>","more":"<h2 id=\"安装linux\"><a href=\"#安装linux\" class=\"headerlink\" title=\"安装linux\"></a>安装linux</h2><p>我家云的CPU是RK3328，多少核心啥的，自己百度一下吧，但是重点是，这个U是开源的，也就是你可以定制自己的系统，国外这里有详细的介绍，包括刷机，<a href=\"https://roc-rk3328-cc.readthedocs.io/en/latest/resource.html\" target=\"_blank\" rel=\"noopener\">点击这里</a></p>\n<p>刷linux系统你需要如下东西：</p>\n<p>硬件：</p>\n<ol>\n<li>我家云，</li>\n<li>公对公USB线一条</li>\n<li>Windows电脑一台</li>\n</ol>\n<p>软件：</p>\n<ol>\n<li>DriverAssistant （驱动）</li>\n<li>AndroidTool （刷机软件）</li>\n<li>boot.img (引导镜像)</li>\n<li>linux.img (系统镜像)</li>\n</ol>\n<p>刷机过程：</p>\n<p>首先，运行<code>DriverInstall.exe</code>安装驱动，然后，我家云用usb线连接电脑（使用白色2.0接口），运行刷机软件，选则上面两个镜像，按住我家云reset键，接入电源，软件找到设备，点击执行，等待刷写完成</p>\n<p>成功以后，我家云接入有线网，使用ssh登录</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh root@我家云ip</span><br><span class=\"line\">密码默认 1234</span><br></pre></td></tr></table></figure>\n<p>这里就进入了我家云linux系统</p>\n<p>执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt update </span><br><span class=\"line\">apt upgrade</span><br></pre></td></tr></table></figure></p>\n<p>更新系统</p>\n<h2 id=\"omv安装\"><a href=\"#omv安装\" class=\"headerlink\" title=\"omv安装\"></a>omv安装</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--下载key--&gt;</span><br><span class=\"line\">wget http://packages.openmediavault.org/public/archive.key</span><br><span class=\"line\">&lt;!--添加key--&gt;</span><br><span class=\"line\">apt-key add archive.key</span><br><span class=\"line\">&lt;!--创建服务列表--&gt;</span><br><span class=\"line\">vim /etc/apt/sources.list.d/openmediavault.list</span><br><span class=\"line\">&lt;!--在列表中添加下面两个源--&gt;</span><br><span class=\"line\">deb http://packages.openmediavault.org/public arrakis main</span><br><span class=\"line\">deb http://packages.openmediavault.org/public usul main</span><br><span class=\"line\">&lt;!--更新源--&gt;</span><br><span class=\"line\">apt update</span><br><span class=\"line\">&lt;!--安装omv--&gt;</span><br><span class=\"line\">apt install openmediavaul</span><br></pre></td></tr></table></figure>\n<p>漫长的等待之后，就安装好了OMV，用浏览器访问我家云ip，就能看到登录页面。<br>账号： admin<br>密码： openmediavault</p>\n<h2 id=\"安装OMV-Extras\"><a href=\"#安装OMV-Extras\" class=\"headerlink\" title=\"安装OMV-Extras\"></a>安装OMV-Extras</h2><p>OMV5默认是没有OMV-Extras的，需要我们自己安装<br><a href=\"https://omv-extras.org/\" target=\"_blank\" rel=\"noopener\">官网</a>给出的教程是这样的，在终端使用root用户运行下面命令</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget -O - https://github.com/OpenMediaVault-Plugin-Developers/packages/raw/master/install | bash</span><br></pre></td></tr></table></figure>\n<p>显示<code>done</code>就表示完成了</p>\n<h2 id=\"OMV的使用\"><a href=\"#OMV的使用\" class=\"headerlink\" title=\"OMV的使用\"></a>OMV的使用</h2><p>在终端对OMV做一些配置，可以使用如下命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">omv-firstaid</span><br></pre></td></tr></table></figure>\n<p>如果出现ip无法访问OMV，可以使用这个命令初始化端口和软件</p>\n<h2 id=\"docker安装\"><a href=\"#docker安装\" class=\"headerlink\" title=\"docker安装\"></a>docker安装</h2><p>安装完<code>OMV-Extras</code>在OMV的web页面，左边系统栏下面会多一个<code>OMV-Extras</code>的选项，点击进入，然后选择docker，选择安装，就会自动安装完成docker，同样的可以把portainer安装完成，portainer是docker的可视化管理工具，可以用来创建容器，安装镜像</p>\n<h2 id=\"transmission安装\"><a href=\"#transmission安装\" class=\"headerlink\" title=\"transmission安装\"></a>transmission安装</h2><p>进入portainer管理页，选择local，在<code>container</code>容器中，新建一个容器，名字随便输入，image镜像输入<a href=\"https://hub.docker.com/\" target=\"_blank\" rel=\"noopener\">docker hub</a>中搜索到的名字<code>linuxserver/transmission</code>，从dockerhub说明页中的配置信息可以看到，transmission,需要映射9019，51413，51413udp，三个端口，同时在volumes中将对的的路径映射到本地，添加env变量，接下来部署，等待完成就可以使用transmission了</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>网上有个设置好的<code>omv</code>但是，使用过程中风扇一直狂转，声音有些大，所以我找到一个改风扇的文件，估计就是恩山的，但是恩山要币，我下载不下来，不知道是不是同一个，使用方法</p>\n<p>在系统 - 计划任务中，停掉<code>/opt/fan</code>任务，启动放入文件的任务</p>"},{"title":"iOS中的枚举","date":"2016-05-11T03:02:30.000Z","_content":"\n### 普通的枚举 ###\n\n#### 第一种实现方式 ####\n\n```objectivec\ntypedef enum {\n    EnumTypeTop,\n    EnumTypeBottom\n}EnumType\n```\n\n#### 第二种实现方式 ####\n\n```objectivec\ntypedef NS_ENUM(NSInteger,EnumType) {\n    EnumTypeTop,\n    EnumTypeBottom\n};\n```\n\n枚举的作用就是增加程序的可读性,将原来使用数值代表的状态转换成自然语言中有相应含义的单词,所以这样写出来的代码更易读懂。编译器会为枚举分配一个独有的编号,从0开始,每个枚举递增1，也可以使用`=` 指定需要的值\n\n<!----- more ----->\n\n### 移位枚举 ###\n\n#### 实现方式 ####\n\n```objectivec\ntypedef NS_OPTIONS(NSUInteger, EnumType) {\n   EnumTypeNone  = 0,     // 0000 0000   0\n   EnumTypeTop    = 1<<0, // 0000 0001   1\n   EnumTypeBottom = 1<<1, // 0000 0010   2\n   EnumTypeLeft   = 1<<2, // 0000 0100   4\n   EnumTypeRight  = 1<<3, // 0000 1000   8\n   EnumTypeCenter = 1<<4, // 0001 0000   16\n   EnumTypeHeight = 1<<5, // 0010 0000   32\n   EnumTypeWidth  = 1<<6  // 0100 0000   64\n}\n```\n\n上面就是一个移位枚举, 和普通的枚举的区别就是,每个状态的值不是递增的,而是用只有1个二进制位的值是1数字表示的,这么做的好处就是可以对状态值进行\"位或\"运算,从而实现同时使用多个枚举\n\n\n```objectivec\n- (void)testEnum {\n    [self needMutEnum:EnumTypeTop | EnumTypeBottom | EnumTypeLeft | EnumTypeRight | EnumTypeCenter];\n}\n\n- (void)needMutEnum:(EnumType) type {\n    if (type==0) {\n      NSLog(@\"EnumTypeNone\");\n      return;\n    }\n    if (type & EnumTypeTop) {\n        NSLog(@\"EnumTypeTop\");\n    }\n    if (type & EnumTypeBottom) {\n        NSLog(@\"EnumTypeBottom\");\n    }\n    if (type & EnumTypeLeft) {\n        NSLog(@\"EnumTypeLeft\");\n\n    }\n    if (type & EnumTypeRight) {\n        NSLog(@\"EnumTypeRight\");\n\n    }\n    if (type & EnumTypeCenter) {\n        NSLog(@\"EnumTypeCenter\");\n\n    }\n    if (type & EnumTypeHeight) {\n        NSLog(@\"EnumTypeHeight\");\n\n    }\n    if (type & EnumTypeWidth) {\n        NSLog(@\"EnumTypeWidth\");\n    }\n}\n```\n\n输出\n\n```\nEnumTypeTop\nEnumTypeBottom\nEnumTypeLeft\nEnumTypeRight\nEnumTypeCenter\n```\n\n这样就实现了同时使用多个枚举\n\n### 原因 ###\n\n#### \"位或\"和\"位与\"运算 ####\n\n\"位或\": 0 | 0 = 0 ; 0 | 1 = 1 ; 1 | 1 = 1;\n\n\"位与\": 0 & 0 = 0 ; 0 & 1 = 0 ; 1 & 1 = 1;\n\n#### 对移位枚举进行\"位或\"运算 ####\n\nEnumTypeTop | EnumTypeBottom | EnumTypeLeft | EnumTypeRight | EnumTypeCenter 转换成二进制就是\n\n0000 0001 | 0000 0010 | 0000 0100 | 0000 1000 | 0010 0000 = 0011 1111  其10进制的值时63\n\n所以\"needMutEnum\"这个方法传入的值`type`是十进制的63,\n\n当使用的时候又用`type`的值和枚举做\"位与运算\",63的二进制是 0011 1111  \n\nEnumTypeTop的二进制是 0000 0001 ,\"位与\"运算的结果就是 0000 0001 ,\n\n也就是说传入的`type`的值转换成二进制,哪个位上是`1`,对应的那个类型的枚举就被传入了,\n\n但是要注意的是,如果不需要None的状态,就不要把第一个枚举状态设置成`0`,直接从0000 0001 设置\n","source":"_posts/枚举的实现方式(移位枚举).md","raw":"---\ntitle: iOS中的枚举\ndate: 2016-05-11 11:02:30\ntags: iOS\n---\n\n### 普通的枚举 ###\n\n#### 第一种实现方式 ####\n\n```objectivec\ntypedef enum {\n    EnumTypeTop,\n    EnumTypeBottom\n}EnumType\n```\n\n#### 第二种实现方式 ####\n\n```objectivec\ntypedef NS_ENUM(NSInteger,EnumType) {\n    EnumTypeTop,\n    EnumTypeBottom\n};\n```\n\n枚举的作用就是增加程序的可读性,将原来使用数值代表的状态转换成自然语言中有相应含义的单词,所以这样写出来的代码更易读懂。编译器会为枚举分配一个独有的编号,从0开始,每个枚举递增1，也可以使用`=` 指定需要的值\n\n<!----- more ----->\n\n### 移位枚举 ###\n\n#### 实现方式 ####\n\n```objectivec\ntypedef NS_OPTIONS(NSUInteger, EnumType) {\n   EnumTypeNone  = 0,     // 0000 0000   0\n   EnumTypeTop    = 1<<0, // 0000 0001   1\n   EnumTypeBottom = 1<<1, // 0000 0010   2\n   EnumTypeLeft   = 1<<2, // 0000 0100   4\n   EnumTypeRight  = 1<<3, // 0000 1000   8\n   EnumTypeCenter = 1<<4, // 0001 0000   16\n   EnumTypeHeight = 1<<5, // 0010 0000   32\n   EnumTypeWidth  = 1<<6  // 0100 0000   64\n}\n```\n\n上面就是一个移位枚举, 和普通的枚举的区别就是,每个状态的值不是递增的,而是用只有1个二进制位的值是1数字表示的,这么做的好处就是可以对状态值进行\"位或\"运算,从而实现同时使用多个枚举\n\n\n```objectivec\n- (void)testEnum {\n    [self needMutEnum:EnumTypeTop | EnumTypeBottom | EnumTypeLeft | EnumTypeRight | EnumTypeCenter];\n}\n\n- (void)needMutEnum:(EnumType) type {\n    if (type==0) {\n      NSLog(@\"EnumTypeNone\");\n      return;\n    }\n    if (type & EnumTypeTop) {\n        NSLog(@\"EnumTypeTop\");\n    }\n    if (type & EnumTypeBottom) {\n        NSLog(@\"EnumTypeBottom\");\n    }\n    if (type & EnumTypeLeft) {\n        NSLog(@\"EnumTypeLeft\");\n\n    }\n    if (type & EnumTypeRight) {\n        NSLog(@\"EnumTypeRight\");\n\n    }\n    if (type & EnumTypeCenter) {\n        NSLog(@\"EnumTypeCenter\");\n\n    }\n    if (type & EnumTypeHeight) {\n        NSLog(@\"EnumTypeHeight\");\n\n    }\n    if (type & EnumTypeWidth) {\n        NSLog(@\"EnumTypeWidth\");\n    }\n}\n```\n\n输出\n\n```\nEnumTypeTop\nEnumTypeBottom\nEnumTypeLeft\nEnumTypeRight\nEnumTypeCenter\n```\n\n这样就实现了同时使用多个枚举\n\n### 原因 ###\n\n#### \"位或\"和\"位与\"运算 ####\n\n\"位或\": 0 | 0 = 0 ; 0 | 1 = 1 ; 1 | 1 = 1;\n\n\"位与\": 0 & 0 = 0 ; 0 & 1 = 0 ; 1 & 1 = 1;\n\n#### 对移位枚举进行\"位或\"运算 ####\n\nEnumTypeTop | EnumTypeBottom | EnumTypeLeft | EnumTypeRight | EnumTypeCenter 转换成二进制就是\n\n0000 0001 | 0000 0010 | 0000 0100 | 0000 1000 | 0010 0000 = 0011 1111  其10进制的值时63\n\n所以\"needMutEnum\"这个方法传入的值`type`是十进制的63,\n\n当使用的时候又用`type`的值和枚举做\"位与运算\",63的二进制是 0011 1111  \n\nEnumTypeTop的二进制是 0000 0001 ,\"位与\"运算的结果就是 0000 0001 ,\n\n也就是说传入的`type`的值转换成二进制,哪个位上是`1`,对应的那个类型的枚举就被传入了,\n\n但是要注意的是,如果不需要None的状态,就不要把第一个枚举状态设置成`0`,直接从0000 0001 设置\n","slug":"枚举的实现方式(移位枚举)","published":1,"updated":"2021-04-12T09:17:38.422Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqjdx1o700215emu2afr8qag","content":"<h3 id=\"普通的枚举\"><a href=\"#普通的枚举\" class=\"headerlink\" title=\"普通的枚举\"></a>普通的枚举</h3><h4 id=\"第一种实现方式\"><a href=\"#第一种实现方式\" class=\"headerlink\" title=\"第一种实现方式\"></a>第一种实现方式</h4><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">enum</span> &#123;</span><br><span class=\"line\">    EnumTypeTop,</span><br><span class=\"line\">    EnumTypeBottom</span><br><span class=\"line\">&#125;EnumType</span><br></pre></td></tr></table></figure>\n<h4 id=\"第二种实现方式\"><a href=\"#第二种实现方式\" class=\"headerlink\" title=\"第二种实现方式\"></a>第二种实现方式</h4><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSInteger</span>,EnumType) &#123;</span><br><span class=\"line\">    EnumTypeTop,</span><br><span class=\"line\">    EnumTypeBottom</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>枚举的作用就是增加程序的可读性,将原来使用数值代表的状态转换成自然语言中有相应含义的单词,所以这样写出来的代码更易读懂。编译器会为枚举分配一个独有的编号,从0开始,每个枚举递增1，也可以使用<code>=</code> 指定需要的值</p>\n<a id=\"more\"></a>\n<h3 id=\"移位枚举\"><a href=\"#移位枚举\" class=\"headerlink\" title=\"移位枚举\"></a>移位枚举</h3><h4 id=\"实现方式\"><a href=\"#实现方式\" class=\"headerlink\" title=\"实现方式\"></a>实现方式</h4><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_OPTIONS</span>(<span class=\"built_in\">NSUInteger</span>, EnumType) &#123;</span><br><span class=\"line\">   EnumTypeNone  = <span class=\"number\">0</span>,     <span class=\"comment\">// 0000 0000   0</span></span><br><span class=\"line\">   EnumTypeTop    = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">0</span>, <span class=\"comment\">// 0000 0001   1</span></span><br><span class=\"line\">   EnumTypeBottom = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">1</span>, <span class=\"comment\">// 0000 0010   2</span></span><br><span class=\"line\">   EnumTypeLeft   = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">2</span>, <span class=\"comment\">// 0000 0100   4</span></span><br><span class=\"line\">   EnumTypeRight  = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">3</span>, <span class=\"comment\">// 0000 1000   8</span></span><br><span class=\"line\">   EnumTypeCenter = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">4</span>, <span class=\"comment\">// 0001 0000   16</span></span><br><span class=\"line\">   EnumTypeHeight = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">5</span>, <span class=\"comment\">// 0010 0000   32</span></span><br><span class=\"line\">   EnumTypeWidth  = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">6</span>  <span class=\"comment\">// 0100 0000   64</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面就是一个移位枚举, 和普通的枚举的区别就是,每个状态的值不是递增的,而是用只有1个二进制位的值是1数字表示的,这么做的好处就是可以对状态值进行”位或”运算,从而实现同时使用多个枚举</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)testEnum &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> needMutEnum:EnumTypeTop | EnumTypeBottom | EnumTypeLeft | EnumTypeRight | EnumTypeCenter];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)needMutEnum:(EnumType) type &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type==<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"EnumTypeNone\"</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type &amp; EnumTypeTop) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"EnumTypeTop\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type &amp; EnumTypeBottom) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"EnumTypeBottom\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type &amp; EnumTypeLeft) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"EnumTypeLeft\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type &amp; EnumTypeRight) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"EnumTypeRight\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type &amp; EnumTypeCenter) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"EnumTypeCenter\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type &amp; EnumTypeHeight) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"EnumTypeHeight\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type &amp; EnumTypeWidth) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"EnumTypeWidth\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EnumTypeTop</span><br><span class=\"line\">EnumTypeBottom</span><br><span class=\"line\">EnumTypeLeft</span><br><span class=\"line\">EnumTypeRight</span><br><span class=\"line\">EnumTypeCenter</span><br></pre></td></tr></table></figure>\n<p>这样就实现了同时使用多个枚举</p>\n<h3 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h3><h4 id=\"“位或”和”位与”运算\"><a href=\"#“位或”和”位与”运算\" class=\"headerlink\" title=\"“位或”和”位与”运算\"></a>“位或”和”位与”运算</h4><p>“位或”: 0 | 0 = 0 ; 0 | 1 = 1 ; 1 | 1 = 1;</p>\n<p>“位与”: 0 &amp; 0 = 0 ; 0 &amp; 1 = 0 ; 1 &amp; 1 = 1;</p>\n<h4 id=\"对移位枚举进行”位或”运算\"><a href=\"#对移位枚举进行”位或”运算\" class=\"headerlink\" title=\"对移位枚举进行”位或”运算\"></a>对移位枚举进行”位或”运算</h4><p>EnumTypeTop | EnumTypeBottom | EnumTypeLeft | EnumTypeRight | EnumTypeCenter 转换成二进制就是</p>\n<p>0000 0001 | 0000 0010 | 0000 0100 | 0000 1000 | 0010 0000 = 0011 1111  其10进制的值时63</p>\n<p>所以”needMutEnum”这个方法传入的值<code>type</code>是十进制的63,</p>\n<p>当使用的时候又用<code>type</code>的值和枚举做”位与运算”,63的二进制是 0011 1111  </p>\n<p>EnumTypeTop的二进制是 0000 0001 ,”位与”运算的结果就是 0000 0001 ,</p>\n<p>也就是说传入的<code>type</code>的值转换成二进制,哪个位上是<code>1</code>,对应的那个类型的枚举就被传入了,</p>\n<p>但是要注意的是,如果不需要None的状态,就不要把第一个枚举状态设置成<code>0</code>,直接从0000 0001 设置</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"普通的枚举\"><a href=\"#普通的枚举\" class=\"headerlink\" title=\"普通的枚举\"></a>普通的枚举</h3><h4 id=\"第一种实现方式\"><a href=\"#第一种实现方式\" class=\"headerlink\" title=\"第一种实现方式\"></a>第一种实现方式</h4><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">enum</span> &#123;</span><br><span class=\"line\">    EnumTypeTop,</span><br><span class=\"line\">    EnumTypeBottom</span><br><span class=\"line\">&#125;EnumType</span><br></pre></td></tr></table></figure>\n<h4 id=\"第二种实现方式\"><a href=\"#第二种实现方式\" class=\"headerlink\" title=\"第二种实现方式\"></a>第二种实现方式</h4><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_ENUM</span>(<span class=\"built_in\">NSInteger</span>,EnumType) &#123;</span><br><span class=\"line\">    EnumTypeTop,</span><br><span class=\"line\">    EnumTypeBottom</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>枚举的作用就是增加程序的可读性,将原来使用数值代表的状态转换成自然语言中有相应含义的单词,所以这样写出来的代码更易读懂。编译器会为枚举分配一个独有的编号,从0开始,每个枚举递增1，也可以使用<code>=</code> 指定需要的值</p>","more":"<h3 id=\"移位枚举\"><a href=\"#移位枚举\" class=\"headerlink\" title=\"移位枚举\"></a>移位枚举</h3><h4 id=\"实现方式\"><a href=\"#实现方式\" class=\"headerlink\" title=\"实现方式\"></a>实现方式</h4><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">NS_OPTIONS</span>(<span class=\"built_in\">NSUInteger</span>, EnumType) &#123;</span><br><span class=\"line\">   EnumTypeNone  = <span class=\"number\">0</span>,     <span class=\"comment\">// 0000 0000   0</span></span><br><span class=\"line\">   EnumTypeTop    = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">0</span>, <span class=\"comment\">// 0000 0001   1</span></span><br><span class=\"line\">   EnumTypeBottom = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">1</span>, <span class=\"comment\">// 0000 0010   2</span></span><br><span class=\"line\">   EnumTypeLeft   = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">2</span>, <span class=\"comment\">// 0000 0100   4</span></span><br><span class=\"line\">   EnumTypeRight  = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">3</span>, <span class=\"comment\">// 0000 1000   8</span></span><br><span class=\"line\">   EnumTypeCenter = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">4</span>, <span class=\"comment\">// 0001 0000   16</span></span><br><span class=\"line\">   EnumTypeHeight = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">5</span>, <span class=\"comment\">// 0010 0000   32</span></span><br><span class=\"line\">   EnumTypeWidth  = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">6</span>  <span class=\"comment\">// 0100 0000   64</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面就是一个移位枚举, 和普通的枚举的区别就是,每个状态的值不是递增的,而是用只有1个二进制位的值是1数字表示的,这么做的好处就是可以对状态值进行”位或”运算,从而实现同时使用多个枚举</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)testEnum &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> needMutEnum:EnumTypeTop | EnumTypeBottom | EnumTypeLeft | EnumTypeRight | EnumTypeCenter];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)needMutEnum:(EnumType) type &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type==<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"EnumTypeNone\"</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type &amp; EnumTypeTop) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"EnumTypeTop\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type &amp; EnumTypeBottom) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"EnumTypeBottom\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type &amp; EnumTypeLeft) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"EnumTypeLeft\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type &amp; EnumTypeRight) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"EnumTypeRight\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type &amp; EnumTypeCenter) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"EnumTypeCenter\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type &amp; EnumTypeHeight) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"EnumTypeHeight\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type &amp; EnumTypeWidth) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"EnumTypeWidth\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EnumTypeTop</span><br><span class=\"line\">EnumTypeBottom</span><br><span class=\"line\">EnumTypeLeft</span><br><span class=\"line\">EnumTypeRight</span><br><span class=\"line\">EnumTypeCenter</span><br></pre></td></tr></table></figure>\n<p>这样就实现了同时使用多个枚举</p>\n<h3 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h3><h4 id=\"“位或”和”位与”运算\"><a href=\"#“位或”和”位与”运算\" class=\"headerlink\" title=\"“位或”和”位与”运算\"></a>“位或”和”位与”运算</h4><p>“位或”: 0 | 0 = 0 ; 0 | 1 = 1 ; 1 | 1 = 1;</p>\n<p>“位与”: 0 &amp; 0 = 0 ; 0 &amp; 1 = 0 ; 1 &amp; 1 = 1;</p>\n<h4 id=\"对移位枚举进行”位或”运算\"><a href=\"#对移位枚举进行”位或”运算\" class=\"headerlink\" title=\"对移位枚举进行”位或”运算\"></a>对移位枚举进行”位或”运算</h4><p>EnumTypeTop | EnumTypeBottom | EnumTypeLeft | EnumTypeRight | EnumTypeCenter 转换成二进制就是</p>\n<p>0000 0001 | 0000 0010 | 0000 0100 | 0000 1000 | 0010 0000 = 0011 1111  其10进制的值时63</p>\n<p>所以”needMutEnum”这个方法传入的值<code>type</code>是十进制的63,</p>\n<p>当使用的时候又用<code>type</code>的值和枚举做”位与运算”,63的二进制是 0011 1111  </p>\n<p>EnumTypeTop的二进制是 0000 0001 ,”位与”运算的结果就是 0000 0001 ,</p>\n<p>也就是说传入的<code>type</code>的值转换成二进制,哪个位上是<code>1</code>,对应的那个类型的枚举就被传入了,</p>\n<p>但是要注意的是,如果不需要None的状态,就不要把第一个枚举状态设置成<code>0</code>,直接从0000 0001 设置</p>"},{"title":"读《iOS与OS X多线程和内存管理》—— ARC规则","date":"2017-05-05T13:14:13.000Z","_content":"\n## 前言 ##\n\n在`ARC`有效的情况下编译源代码需要遵守的规则\n\n<!-- more -->\n\n\n### 不能使用 retain/release/retainCount/autorelease ###\n\n这些方法都是在`MRC`中手动管理引用计数的方法，在`ARC`中，既然自动管理了引用计数了，自然不可以使用了，因为都管理，就会出现冲突\n\n\n### 不能使用 NSAllocateObject/NSDeallocateObject ###\n\n不能使用的原因同上\n\n### 须遵守内存管理的方法命名规则 ###\n\n`alloc/new/copy/mutableCopy/init`以这些名称开始的方法在返回对象是，必须返回给调用方所应当持有的对象。\n\n`init`是`ARC`追加的命名规则，切`init`必须是实例方法，必须要返回对象\n\n\n### 不要显式调用 dealloc ###\n\n在对象被释放的时候，系统会自动调用`dealloc`方法，不需要我们手动调用，原因也很简单，如果手动调用了，就意味着要释放对象，但是这时候如果对象的引用计数不是0，那么引用计数为0就释放对象的规则就失效了。\n\n在`MRC`时，在`dealloc`方法中需要显式的调用`[super dealloc]`,但是在`ARC`时，这是不需要的\n\n\n### 使用@autoreleasepool 块替代 NSAutoreleasePool ###\n\n在`ARC`中使用`NSAutoreleasePool`会引起编译器报错\n\n\n### 不能使用区域（NSZone） ###\n\n无论`MRC`还是`ARC`都无法使用。\n\n\n### 对象型变量不能作为C语言结构体的成员 ###\n\n原因是C语言没有方法来管理结构体成员的生存周期，`ARC`的内存管理是编译器完成的，所以编译器必须能知道并管理对象的生存周期。\n\n要想把对象型变量加入结构体成员中，可以强制转换为`void *`或是附加`__unsafe_unretained`修饰符\n\n\n### 显式转换 id 和 void * ###\n\n在`MRC`时，将id变量强制转换void *变量并不会出问题,如下面代码：\n\n\n```\nid obj = [[NSObject alloc] init];\nvoid *p = obj;\nid o = p;\n```\n\n但是在`ARC`时，是会引起编译错误的，要想在id和void *之间相互赋值，需要`__bridge`转换。\n\n```\nid obj = [[NSObject alloc] init];\nvoid *p = (__bridge void *)obj;\nid o = (__bridge id)p;\n```\n\n`__bridge`还有两种转换：\n\n`__bridge_retained` 可以使转换赋值的变量也持有所赋值的对象，相当于目标变量`retain`\n\n`__bridge_transfer` 可以是被转换的变量所持有的对象在该变量被赋值给转换目标变量后随之释放，就是目标变量`retain`,自己`release`","source":"_posts/读《iOS与OS X多线程和内存管理》—— ARC规则.md","raw":"---\ntitle: 读《iOS与OS X多线程和内存管理》—— ARC规则\ndate: 2017-05-05 21:14:13\ntags: [iOS]\n---\n\n## 前言 ##\n\n在`ARC`有效的情况下编译源代码需要遵守的规则\n\n<!-- more -->\n\n\n### 不能使用 retain/release/retainCount/autorelease ###\n\n这些方法都是在`MRC`中手动管理引用计数的方法，在`ARC`中，既然自动管理了引用计数了，自然不可以使用了，因为都管理，就会出现冲突\n\n\n### 不能使用 NSAllocateObject/NSDeallocateObject ###\n\n不能使用的原因同上\n\n### 须遵守内存管理的方法命名规则 ###\n\n`alloc/new/copy/mutableCopy/init`以这些名称开始的方法在返回对象是，必须返回给调用方所应当持有的对象。\n\n`init`是`ARC`追加的命名规则，切`init`必须是实例方法，必须要返回对象\n\n\n### 不要显式调用 dealloc ###\n\n在对象被释放的时候，系统会自动调用`dealloc`方法，不需要我们手动调用，原因也很简单，如果手动调用了，就意味着要释放对象，但是这时候如果对象的引用计数不是0，那么引用计数为0就释放对象的规则就失效了。\n\n在`MRC`时，在`dealloc`方法中需要显式的调用`[super dealloc]`,但是在`ARC`时，这是不需要的\n\n\n### 使用@autoreleasepool 块替代 NSAutoreleasePool ###\n\n在`ARC`中使用`NSAutoreleasePool`会引起编译器报错\n\n\n### 不能使用区域（NSZone） ###\n\n无论`MRC`还是`ARC`都无法使用。\n\n\n### 对象型变量不能作为C语言结构体的成员 ###\n\n原因是C语言没有方法来管理结构体成员的生存周期，`ARC`的内存管理是编译器完成的，所以编译器必须能知道并管理对象的生存周期。\n\n要想把对象型变量加入结构体成员中，可以强制转换为`void *`或是附加`__unsafe_unretained`修饰符\n\n\n### 显式转换 id 和 void * ###\n\n在`MRC`时，将id变量强制转换void *变量并不会出问题,如下面代码：\n\n\n```\nid obj = [[NSObject alloc] init];\nvoid *p = obj;\nid o = p;\n```\n\n但是在`ARC`时，是会引起编译错误的，要想在id和void *之间相互赋值，需要`__bridge`转换。\n\n```\nid obj = [[NSObject alloc] init];\nvoid *p = (__bridge void *)obj;\nid o = (__bridge id)p;\n```\n\n`__bridge`还有两种转换：\n\n`__bridge_retained` 可以使转换赋值的变量也持有所赋值的对象，相当于目标变量`retain`\n\n`__bridge_transfer` 可以是被转换的变量所持有的对象在该变量被赋值给转换目标变量后随之释放，就是目标变量`retain`,自己`release`","slug":"读《iOS与OS X多线程和内存管理》—— ARC规则","published":1,"updated":"2021-04-12T09:17:38.422Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqjdx1o800245emu77nt3lqt","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在<code>ARC</code>有效的情况下编译源代码需要遵守的规则</p>\n<a id=\"more\"></a>\n<h3 id=\"不能使用-retain-release-retainCount-autorelease\"><a href=\"#不能使用-retain-release-retainCount-autorelease\" class=\"headerlink\" title=\"不能使用 retain/release/retainCount/autorelease\"></a>不能使用 retain/release/retainCount/autorelease</h3><p>这些方法都是在<code>MRC</code>中手动管理引用计数的方法，在<code>ARC</code>中，既然自动管理了引用计数了，自然不可以使用了，因为都管理，就会出现冲突</p>\n<h3 id=\"不能使用-NSAllocateObject-NSDeallocateObject\"><a href=\"#不能使用-NSAllocateObject-NSDeallocateObject\" class=\"headerlink\" title=\"不能使用 NSAllocateObject/NSDeallocateObject\"></a>不能使用 NSAllocateObject/NSDeallocateObject</h3><p>不能使用的原因同上</p>\n<h3 id=\"须遵守内存管理的方法命名规则\"><a href=\"#须遵守内存管理的方法命名规则\" class=\"headerlink\" title=\"须遵守内存管理的方法命名规则\"></a>须遵守内存管理的方法命名规则</h3><p><code>alloc/new/copy/mutableCopy/init</code>以这些名称开始的方法在返回对象是，必须返回给调用方所应当持有的对象。</p>\n<p><code>init</code>是<code>ARC</code>追加的命名规则，切<code>init</code>必须是实例方法，必须要返回对象</p>\n<h3 id=\"不要显式调用-dealloc\"><a href=\"#不要显式调用-dealloc\" class=\"headerlink\" title=\"不要显式调用 dealloc\"></a>不要显式调用 dealloc</h3><p>在对象被释放的时候，系统会自动调用<code>dealloc</code>方法，不需要我们手动调用，原因也很简单，如果手动调用了，就意味着要释放对象，但是这时候如果对象的引用计数不是0，那么引用计数为0就释放对象的规则就失效了。</p>\n<p>在<code>MRC</code>时，在<code>dealloc</code>方法中需要显式的调用<code>[super dealloc]</code>,但是在<code>ARC</code>时，这是不需要的</p>\n<h3 id=\"使用-autoreleasepool-块替代-NSAutoreleasePool\"><a href=\"#使用-autoreleasepool-块替代-NSAutoreleasePool\" class=\"headerlink\" title=\"使用@autoreleasepool 块替代 NSAutoreleasePool\"></a>使用@autoreleasepool 块替代 NSAutoreleasePool</h3><p>在<code>ARC</code>中使用<code>NSAutoreleasePool</code>会引起编译器报错</p>\n<h3 id=\"不能使用区域（NSZone）\"><a href=\"#不能使用区域（NSZone）\" class=\"headerlink\" title=\"不能使用区域（NSZone）\"></a>不能使用区域（NSZone）</h3><p>无论<code>MRC</code>还是<code>ARC</code>都无法使用。</p>\n<h3 id=\"对象型变量不能作为C语言结构体的成员\"><a href=\"#对象型变量不能作为C语言结构体的成员\" class=\"headerlink\" title=\"对象型变量不能作为C语言结构体的成员\"></a>对象型变量不能作为C语言结构体的成员</h3><p>原因是C语言没有方法来管理结构体成员的生存周期，<code>ARC</code>的内存管理是编译器完成的，所以编译器必须能知道并管理对象的生存周期。</p>\n<p>要想把对象型变量加入结构体成员中，可以强制转换为<code>void *</code>或是附加<code>__unsafe_unretained</code>修饰符</p>\n<h3 id=\"显式转换-id-和-void\"><a href=\"#显式转换-id-和-void\" class=\"headerlink\" title=\"显式转换 id 和 void *\"></a>显式转换 id 和 void *</h3><p>在<code>MRC</code>时，将id变量强制转换void *变量并不会出问题,如下面代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id obj = [[NSObject alloc] init];</span><br><span class=\"line\">void *p = obj;</span><br><span class=\"line\">id o = p;</span><br></pre></td></tr></table></figure>\n<p>但是在<code>ARC</code>时，是会引起编译错误的，要想在id和void *之间相互赋值，需要<code>__bridge</code>转换。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id obj = [[NSObject alloc] init];</span><br><span class=\"line\">void *p = (__bridge void *)obj;</span><br><span class=\"line\">id o = (__bridge id)p;</span><br></pre></td></tr></table></figure>\n<p><code>__bridge</code>还有两种转换：</p>\n<p><code>__bridge_retained</code> 可以使转换赋值的变量也持有所赋值的对象，相当于目标变量<code>retain</code></p>\n<p><code>__bridge_transfer</code> 可以是被转换的变量所持有的对象在该变量被赋值给转换目标变量后随之释放，就是目标变量<code>retain</code>,自己<code>release</code></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在<code>ARC</code>有效的情况下编译源代码需要遵守的规则</p>","more":"<h3 id=\"不能使用-retain-release-retainCount-autorelease\"><a href=\"#不能使用-retain-release-retainCount-autorelease\" class=\"headerlink\" title=\"不能使用 retain/release/retainCount/autorelease\"></a>不能使用 retain/release/retainCount/autorelease</h3><p>这些方法都是在<code>MRC</code>中手动管理引用计数的方法，在<code>ARC</code>中，既然自动管理了引用计数了，自然不可以使用了，因为都管理，就会出现冲突</p>\n<h3 id=\"不能使用-NSAllocateObject-NSDeallocateObject\"><a href=\"#不能使用-NSAllocateObject-NSDeallocateObject\" class=\"headerlink\" title=\"不能使用 NSAllocateObject/NSDeallocateObject\"></a>不能使用 NSAllocateObject/NSDeallocateObject</h3><p>不能使用的原因同上</p>\n<h3 id=\"须遵守内存管理的方法命名规则\"><a href=\"#须遵守内存管理的方法命名规则\" class=\"headerlink\" title=\"须遵守内存管理的方法命名规则\"></a>须遵守内存管理的方法命名规则</h3><p><code>alloc/new/copy/mutableCopy/init</code>以这些名称开始的方法在返回对象是，必须返回给调用方所应当持有的对象。</p>\n<p><code>init</code>是<code>ARC</code>追加的命名规则，切<code>init</code>必须是实例方法，必须要返回对象</p>\n<h3 id=\"不要显式调用-dealloc\"><a href=\"#不要显式调用-dealloc\" class=\"headerlink\" title=\"不要显式调用 dealloc\"></a>不要显式调用 dealloc</h3><p>在对象被释放的时候，系统会自动调用<code>dealloc</code>方法，不需要我们手动调用，原因也很简单，如果手动调用了，就意味着要释放对象，但是这时候如果对象的引用计数不是0，那么引用计数为0就释放对象的规则就失效了。</p>\n<p>在<code>MRC</code>时，在<code>dealloc</code>方法中需要显式的调用<code>[super dealloc]</code>,但是在<code>ARC</code>时，这是不需要的</p>\n<h3 id=\"使用-autoreleasepool-块替代-NSAutoreleasePool\"><a href=\"#使用-autoreleasepool-块替代-NSAutoreleasePool\" class=\"headerlink\" title=\"使用@autoreleasepool 块替代 NSAutoreleasePool\"></a>使用@autoreleasepool 块替代 NSAutoreleasePool</h3><p>在<code>ARC</code>中使用<code>NSAutoreleasePool</code>会引起编译器报错</p>\n<h3 id=\"不能使用区域（NSZone）\"><a href=\"#不能使用区域（NSZone）\" class=\"headerlink\" title=\"不能使用区域（NSZone）\"></a>不能使用区域（NSZone）</h3><p>无论<code>MRC</code>还是<code>ARC</code>都无法使用。</p>\n<h3 id=\"对象型变量不能作为C语言结构体的成员\"><a href=\"#对象型变量不能作为C语言结构体的成员\" class=\"headerlink\" title=\"对象型变量不能作为C语言结构体的成员\"></a>对象型变量不能作为C语言结构体的成员</h3><p>原因是C语言没有方法来管理结构体成员的生存周期，<code>ARC</code>的内存管理是编译器完成的，所以编译器必须能知道并管理对象的生存周期。</p>\n<p>要想把对象型变量加入结构体成员中，可以强制转换为<code>void *</code>或是附加<code>__unsafe_unretained</code>修饰符</p>\n<h3 id=\"显式转换-id-和-void\"><a href=\"#显式转换-id-和-void\" class=\"headerlink\" title=\"显式转换 id 和 void *\"></a>显式转换 id 和 void *</h3><p>在<code>MRC</code>时，将id变量强制转换void *变量并不会出问题,如下面代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id obj = [[NSObject alloc] init];</span><br><span class=\"line\">void *p = obj;</span><br><span class=\"line\">id o = p;</span><br></pre></td></tr></table></figure>\n<p>但是在<code>ARC</code>时，是会引起编译错误的，要想在id和void *之间相互赋值，需要<code>__bridge</code>转换。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id obj = [[NSObject alloc] init];</span><br><span class=\"line\">void *p = (__bridge void *)obj;</span><br><span class=\"line\">id o = (__bridge id)p;</span><br></pre></td></tr></table></figure>\n<p><code>__bridge</code>还有两种转换：</p>\n<p><code>__bridge_retained</code> 可以使转换赋值的变量也持有所赋值的对象，相当于目标变量<code>retain</code></p>\n<p><code>__bridge_transfer</code> 可以是被转换的变量所持有的对象在该变量被赋值给转换目标变量后随之释放，就是目标变量<code>retain</code>,自己<code>release</code></p>"},{"title":"读《iOS与OS X多线程和内存管理》—— GCD","date":"2017-05-14T13:53:48.000Z","_content":"\n## 前言 ##\n\n《iOS与OS X多线程和内存管理》的第三章是对`GCD`的介绍，`GCD`就是`Grand Central Dispatch`,是将应用程序中记述的线程管理用的代码在系统级中实现。说简单点就是，用简单的方法实现多线程\n\n<!-- more -->\n\n### 队列 Dispatch Queue ###\n\n队列（Dispatch Queue）是存放任务等待执行处理的地方。既然是队列，那么他要遵循`FIFO`先进先出原则。\n\n队列有两种：\n\n1. Serial Dispatch Queue  (串行队列)\n\n2. Concurrent Dispatch Queue (并行队列)\n\n\n`Serial Dispatch Queue`（串行队列）的特点是需要等待现在执行中的任务处理结束才可以处理下一个任务\n\n`Concurrent Dispatch Queue` (并行队列)的特点是不等待现在执行中的任务处理结束，可以并行执行多个处理，但是并行处理的数量取决于当前系统的状态\n\n### 线程 ###\n\n一个CPU执行的CPU命令列是一条无分叉路径，这就是一个线程，所以从队列的种类来看，串行队列始终在使用一个线程处理任务，而并行队列使用的是多个线程处理任务，多个线程的数量取决于当前系统状态\n\n\n### API ###\n\n`GCD`使用过程中的各种`API`\n\n#### 创建和获取队列 ####\n\n创建一个串行队列:\n\n```\ndispatch_queue_t serialDispatchQueue = dispatch_queue_create(\"queueName\"，DISPATCH_QUEUE_SERIAL);\n```\n\n创建一个并行队列：\n\n```\ndispatch_queue_t concurrentDispatchQueue = dispatch_queue_create(\"queueName\", DISPATCH_QUEUE_CONCURRENT);\n```\n\n创建串行队列和并行队列的方法是一样的，唯一的区别是第二个参数，如果创建的是串行队列，传入`DISPATCH_QUEUE_SERIAL`就好，如果是创建并行队列，则指定为`DISPATCH_QUEUE_CONCURRENT`。\n\n创建队列的第一个参数，是队列的名称，他可以在调试器中显示，苹果推荐的名称是，逆序全程域名，你也可以传`NULL`\n\n获取系统提供的队列：\n\n```\n//获取主线程队列 （串行队列）\ndispatch_queue_t mainDispatchQueue = dispatch_get_main_queue();\n\n//获取全局队列--高优先级 （并行队列）\ndispatch_queue_t highQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);\n\n//获取全局队列--默认优先级 （并行队列）\ndispatch_queue_t defaultQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n\n//获取全局队列--低优先级 （并行队列）\ndispatch_queue_t lowQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0);\n\n//获取全局队列--后台优先级 （并行队列）\ndispatch_queue_t backgroundQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0);\n```\n\n#### 改变队列优先级 ####\n\n在使用`dispatch_queue_create`函数生成的队列，不管是串行还是并行的都是默认优先级的。要改变优先级需要使用`dispatch_set_target_queue`函数。\n\n```\ndispatch_queue_t myQueue = dispatch_queue_create(\"queueName\", DISPATCH_QUEUE_SERIAL);\ndispatch_queue_t globalBackgroundQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND,0);\ndispatch_set_target_queue(myQueue, globalBackgroundQueue);\n```\n这样`myQueue`的优先级就是`DISPATCH_QUEUE_PRIORITY_BACKGROUND `的了。\n\n注意，不能改变系统提供的队列的优先级，也就是系统提供的队列不能写在第一个参数中\n\n`dispatch_set_target_queue`还可以改变队列执行优先级，如果有多个串行任务在多个串行队列中执行，这时如果要防止并行，就可以将多个串行队列，指定到同一个目标串行队列中，原本并行执行的多个串行队列就会变成真正的串行，同时执行一个处理。\n\n\n#### 延迟执行 ####\n\n使用`dispatch_after`可以实现延迟指定时间执行\n\n```\ndispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 3ull*NSEC_PER_SEC);\n\ndispatch_after(time, dispatch_get_main_queue(), ^{\n\t//延迟执行的任务内容\n});\n\n```\n\n注意，这里的延迟是在指定时间追加任务到指定队列，所以有可能有延时，不算绝对精确。\n\n\n#### Dispatch Group ####\n\n`Dispatch Group`可以在多个队列都执行完成后，执行指定队列\n\n```\ndispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\ndispatch_group_t group = dispatch_group_create();\n\ndispatch_group_async(group,queue, ^{NSLog(@\"blk1\");});\ndispatch_group_async(group,queue, ^{NSLog(@\"blk2\");});\ndispatch_group_async(group,queue, ^{NSLog(@\"blk3\");});\n\ndispatch_group_notify(group, dispatch_get_main_queue(),^{NSLog(@\"done\");});\n//dispatch_group_wait(group,DISPATCH_TIME_FOREVER); //指定超时时间\n```\n\n#### dispatch_barrier_async ####\n\n`dispatch_barrier_asyne`函数会等待在他前面追加在并行队列上的任务全部执行完，然后执行他的任务，在他的任务执行完再恢复并行队列的任务\n\neg：\n\n```\ndispatch_queue_t queue = dispatch_queue_create(\"queueName\",DISPATCH_QUEUE_CONCURRENT);\ndispatch_async(queue,blk0_for_reading);\ndispatch_async(queue,blk1_for_reading);\ndispatch_async(queue,blk2_for_reading);\ndispatch_async(queue,blk3_for_reading);\ndispatch_barrier_async(queue, blk_for_writing);\ndispatch_async(queue,blk4_for_reading);\ndispatch_async(queue,blk5_for_reading);\ndispatch_async(queue,blk6_for_reading);\n```\n\n#### dispatch_sync ####\n\n`dispatch_sync`是同步将`block`追加到队列中，`dispatch_async`是非同步的将`block`追加到队列中，区别就是`dispatch_sync`会在追加完成后，等待任务执行完，而`dispatch_async`不做任何等待。\n\n一旦调用`dispatch_sync`函数，在指定的处理执行结束之前，该函数不会返回，所以该函数容易引起死锁问题，比如在主线程同步添加任务。\n\n#### dispatch_apply ####\n\n`dispatch_apply`可以按照指定的次数将指定的`block`追加到指定的队列中，并等待全部处理执行结束\n\n```\ndispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);\ndispatch_apply(10, queue, ^(size_t index) {\n\tNSLog(@\"%zu\",index);\n});\n```\n\n因为他也会等待处理执行结束，所以也会有死锁问题。\n\n\n#### dispatch_suspend/dispatch_resume ####\n\n`dispatch_suspend`函数可以挂起指定的队列\n\n`dispatch_resume`函数可以恢复指定的队列\n\n\n#### dispatch_once ####\n\n这是经常写单例使用的方法，`dispatch_once`函数可以保证在应用程序执行中只执行一次。\n\neg：\n\n```\nstatic dispatch_once_t pred;\n\ndispatch_once(&pred, ^{\n\t//do something\n});\n```\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/读《iOS与OS X多线程和内存管理》—— GCD.md","raw":"---\ntitle: 读《iOS与OS X多线程和内存管理》—— GCD\ndate: 2017-05-14 21:53:48\ntags: [iOS]\n---\n\n## 前言 ##\n\n《iOS与OS X多线程和内存管理》的第三章是对`GCD`的介绍，`GCD`就是`Grand Central Dispatch`,是将应用程序中记述的线程管理用的代码在系统级中实现。说简单点就是，用简单的方法实现多线程\n\n<!-- more -->\n\n### 队列 Dispatch Queue ###\n\n队列（Dispatch Queue）是存放任务等待执行处理的地方。既然是队列，那么他要遵循`FIFO`先进先出原则。\n\n队列有两种：\n\n1. Serial Dispatch Queue  (串行队列)\n\n2. Concurrent Dispatch Queue (并行队列)\n\n\n`Serial Dispatch Queue`（串行队列）的特点是需要等待现在执行中的任务处理结束才可以处理下一个任务\n\n`Concurrent Dispatch Queue` (并行队列)的特点是不等待现在执行中的任务处理结束，可以并行执行多个处理，但是并行处理的数量取决于当前系统的状态\n\n### 线程 ###\n\n一个CPU执行的CPU命令列是一条无分叉路径，这就是一个线程，所以从队列的种类来看，串行队列始终在使用一个线程处理任务，而并行队列使用的是多个线程处理任务，多个线程的数量取决于当前系统状态\n\n\n### API ###\n\n`GCD`使用过程中的各种`API`\n\n#### 创建和获取队列 ####\n\n创建一个串行队列:\n\n```\ndispatch_queue_t serialDispatchQueue = dispatch_queue_create(\"queueName\"，DISPATCH_QUEUE_SERIAL);\n```\n\n创建一个并行队列：\n\n```\ndispatch_queue_t concurrentDispatchQueue = dispatch_queue_create(\"queueName\", DISPATCH_QUEUE_CONCURRENT);\n```\n\n创建串行队列和并行队列的方法是一样的，唯一的区别是第二个参数，如果创建的是串行队列，传入`DISPATCH_QUEUE_SERIAL`就好，如果是创建并行队列，则指定为`DISPATCH_QUEUE_CONCURRENT`。\n\n创建队列的第一个参数，是队列的名称，他可以在调试器中显示，苹果推荐的名称是，逆序全程域名，你也可以传`NULL`\n\n获取系统提供的队列：\n\n```\n//获取主线程队列 （串行队列）\ndispatch_queue_t mainDispatchQueue = dispatch_get_main_queue();\n\n//获取全局队列--高优先级 （并行队列）\ndispatch_queue_t highQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);\n\n//获取全局队列--默认优先级 （并行队列）\ndispatch_queue_t defaultQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n\n//获取全局队列--低优先级 （并行队列）\ndispatch_queue_t lowQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0);\n\n//获取全局队列--后台优先级 （并行队列）\ndispatch_queue_t backgroundQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0);\n```\n\n#### 改变队列优先级 ####\n\n在使用`dispatch_queue_create`函数生成的队列，不管是串行还是并行的都是默认优先级的。要改变优先级需要使用`dispatch_set_target_queue`函数。\n\n```\ndispatch_queue_t myQueue = dispatch_queue_create(\"queueName\", DISPATCH_QUEUE_SERIAL);\ndispatch_queue_t globalBackgroundQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND,0);\ndispatch_set_target_queue(myQueue, globalBackgroundQueue);\n```\n这样`myQueue`的优先级就是`DISPATCH_QUEUE_PRIORITY_BACKGROUND `的了。\n\n注意，不能改变系统提供的队列的优先级，也就是系统提供的队列不能写在第一个参数中\n\n`dispatch_set_target_queue`还可以改变队列执行优先级，如果有多个串行任务在多个串行队列中执行，这时如果要防止并行，就可以将多个串行队列，指定到同一个目标串行队列中，原本并行执行的多个串行队列就会变成真正的串行，同时执行一个处理。\n\n\n#### 延迟执行 ####\n\n使用`dispatch_after`可以实现延迟指定时间执行\n\n```\ndispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 3ull*NSEC_PER_SEC);\n\ndispatch_after(time, dispatch_get_main_queue(), ^{\n\t//延迟执行的任务内容\n});\n\n```\n\n注意，这里的延迟是在指定时间追加任务到指定队列，所以有可能有延时，不算绝对精确。\n\n\n#### Dispatch Group ####\n\n`Dispatch Group`可以在多个队列都执行完成后，执行指定队列\n\n```\ndispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\ndispatch_group_t group = dispatch_group_create();\n\ndispatch_group_async(group,queue, ^{NSLog(@\"blk1\");});\ndispatch_group_async(group,queue, ^{NSLog(@\"blk2\");});\ndispatch_group_async(group,queue, ^{NSLog(@\"blk3\");});\n\ndispatch_group_notify(group, dispatch_get_main_queue(),^{NSLog(@\"done\");});\n//dispatch_group_wait(group,DISPATCH_TIME_FOREVER); //指定超时时间\n```\n\n#### dispatch_barrier_async ####\n\n`dispatch_barrier_asyne`函数会等待在他前面追加在并行队列上的任务全部执行完，然后执行他的任务，在他的任务执行完再恢复并行队列的任务\n\neg：\n\n```\ndispatch_queue_t queue = dispatch_queue_create(\"queueName\",DISPATCH_QUEUE_CONCURRENT);\ndispatch_async(queue,blk0_for_reading);\ndispatch_async(queue,blk1_for_reading);\ndispatch_async(queue,blk2_for_reading);\ndispatch_async(queue,blk3_for_reading);\ndispatch_barrier_async(queue, blk_for_writing);\ndispatch_async(queue,blk4_for_reading);\ndispatch_async(queue,blk5_for_reading);\ndispatch_async(queue,blk6_for_reading);\n```\n\n#### dispatch_sync ####\n\n`dispatch_sync`是同步将`block`追加到队列中，`dispatch_async`是非同步的将`block`追加到队列中，区别就是`dispatch_sync`会在追加完成后，等待任务执行完，而`dispatch_async`不做任何等待。\n\n一旦调用`dispatch_sync`函数，在指定的处理执行结束之前，该函数不会返回，所以该函数容易引起死锁问题，比如在主线程同步添加任务。\n\n#### dispatch_apply ####\n\n`dispatch_apply`可以按照指定的次数将指定的`block`追加到指定的队列中，并等待全部处理执行结束\n\n```\ndispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);\ndispatch_apply(10, queue, ^(size_t index) {\n\tNSLog(@\"%zu\",index);\n});\n```\n\n因为他也会等待处理执行结束，所以也会有死锁问题。\n\n\n#### dispatch_suspend/dispatch_resume ####\n\n`dispatch_suspend`函数可以挂起指定的队列\n\n`dispatch_resume`函数可以恢复指定的队列\n\n\n#### dispatch_once ####\n\n这是经常写单例使用的方法，`dispatch_once`函数可以保证在应用程序执行中只执行一次。\n\neg：\n\n```\nstatic dispatch_once_t pred;\n\ndispatch_once(&pred, ^{\n\t//do something\n});\n```\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"读《iOS与OS X多线程和内存管理》—— GCD","published":1,"updated":"2021-04-12T09:17:38.422Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqjdx1o900265emu26uair8v","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>《iOS与OS X多线程和内存管理》的第三章是对<code>GCD</code>的介绍，<code>GCD</code>就是<code>Grand Central Dispatch</code>,是将应用程序中记述的线程管理用的代码在系统级中实现。说简单点就是，用简单的方法实现多线程</p>\n<a id=\"more\"></a>\n<h3 id=\"队列-Dispatch-Queue\"><a href=\"#队列-Dispatch-Queue\" class=\"headerlink\" title=\"队列 Dispatch Queue\"></a>队列 Dispatch Queue</h3><p>队列（Dispatch Queue）是存放任务等待执行处理的地方。既然是队列，那么他要遵循<code>FIFO</code>先进先出原则。</p>\n<p>队列有两种：</p>\n<ol>\n<li><p>Serial Dispatch Queue  (串行队列)</p>\n</li>\n<li><p>Concurrent Dispatch Queue (并行队列)</p>\n</li>\n</ol>\n<p><code>Serial Dispatch Queue</code>（串行队列）的特点是需要等待现在执行中的任务处理结束才可以处理下一个任务</p>\n<p><code>Concurrent Dispatch Queue</code> (并行队列)的特点是不等待现在执行中的任务处理结束，可以并行执行多个处理，但是并行处理的数量取决于当前系统的状态</p>\n<h3 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h3><p>一个CPU执行的CPU命令列是一条无分叉路径，这就是一个线程，所以从队列的种类来看，串行队列始终在使用一个线程处理任务，而并行队列使用的是多个线程处理任务，多个线程的数量取决于当前系统状态</p>\n<h3 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h3><p><code>GCD</code>使用过程中的各种<code>API</code></p>\n<h4 id=\"创建和获取队列\"><a href=\"#创建和获取队列\" class=\"headerlink\" title=\"创建和获取队列\"></a>创建和获取队列</h4><p>创建一个串行队列:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t serialDispatchQueue = dispatch_queue_create(&quot;queueName&quot;，DISPATCH_QUEUE_SERIAL);</span><br></pre></td></tr></table></figure>\n<p>创建一个并行队列：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t concurrentDispatchQueue = dispatch_queue_create(&quot;queueName&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure>\n<p>创建串行队列和并行队列的方法是一样的，唯一的区别是第二个参数，如果创建的是串行队列，传入<code>DISPATCH_QUEUE_SERIAL</code>就好，如果是创建并行队列，则指定为<code>DISPATCH_QUEUE_CONCURRENT</code>。</p>\n<p>创建队列的第一个参数，是队列的名称，他可以在调试器中显示，苹果推荐的名称是，逆序全程域名，你也可以传<code>NULL</code></p>\n<p>获取系统提供的队列：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//获取主线程队列 （串行队列）</span><br><span class=\"line\">dispatch_queue_t mainDispatchQueue = dispatch_get_main_queue();</span><br><span class=\"line\"></span><br><span class=\"line\">//获取全局队列--高优先级 （并行队列）</span><br><span class=\"line\">dispatch_queue_t highQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">//获取全局队列--默认优先级 （并行队列）</span><br><span class=\"line\">dispatch_queue_t defaultQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">//获取全局队列--低优先级 （并行队列）</span><br><span class=\"line\">dispatch_queue_t lowQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">//获取全局队列--后台优先级 （并行队列）</span><br><span class=\"line\">dispatch_queue_t backgroundQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0);</span><br></pre></td></tr></table></figure>\n<h4 id=\"改变队列优先级\"><a href=\"#改变队列优先级\" class=\"headerlink\" title=\"改变队列优先级\"></a>改变队列优先级</h4><p>在使用<code>dispatch_queue_create</code>函数生成的队列，不管是串行还是并行的都是默认优先级的。要改变优先级需要使用<code>dispatch_set_target_queue</code>函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t myQueue = dispatch_queue_create(&quot;queueName&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class=\"line\">dispatch_queue_t globalBackgroundQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND,0);</span><br><span class=\"line\">dispatch_set_target_queue(myQueue, globalBackgroundQueue);</span><br></pre></td></tr></table></figure>\n<p>这样<code>myQueue</code>的优先级就是<code>DISPATCH_QUEUE_PRIORITY_BACKGROUND</code>的了。</p>\n<p>注意，不能改变系统提供的队列的优先级，也就是系统提供的队列不能写在第一个参数中</p>\n<p><code>dispatch_set_target_queue</code>还可以改变队列执行优先级，如果有多个串行任务在多个串行队列中执行，这时如果要防止并行，就可以将多个串行队列，指定到同一个目标串行队列中，原本并行执行的多个串行队列就会变成真正的串行，同时执行一个处理。</p>\n<h4 id=\"延迟执行\"><a href=\"#延迟执行\" class=\"headerlink\" title=\"延迟执行\"></a>延迟执行</h4><p>使用<code>dispatch_after</code>可以实现延迟指定时间执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 3ull*NSEC_PER_SEC);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_after(time, dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">\t//延迟执行的任务内容</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>注意，这里的延迟是在指定时间追加任务到指定队列，所以有可能有延时，不算绝对精确。</p>\n<h4 id=\"Dispatch-Group\"><a href=\"#Dispatch-Group\" class=\"headerlink\" title=\"Dispatch Group\"></a>Dispatch Group</h4><p><code>Dispatch Group</code>可以在多个队列都执行完成后，执行指定队列</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class=\"line\">dispatch_group_t group = dispatch_group_create();</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_group_async(group,queue, ^&#123;NSLog(@&quot;blk1&quot;);&#125;);</span><br><span class=\"line\">dispatch_group_async(group,queue, ^&#123;NSLog(@&quot;blk2&quot;);&#125;);</span><br><span class=\"line\">dispatch_group_async(group,queue, ^&#123;NSLog(@&quot;blk3&quot;);&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_group_notify(group, dispatch_get_main_queue(),^&#123;NSLog(@&quot;done&quot;);&#125;);</span><br><span class=\"line\">//dispatch_group_wait(group,DISPATCH_TIME_FOREVER); //指定超时时间</span><br></pre></td></tr></table></figure>\n<h4 id=\"dispatch-barrier-async\"><a href=\"#dispatch-barrier-async\" class=\"headerlink\" title=\"dispatch_barrier_async\"></a>dispatch_barrier_async</h4><p><code>dispatch_barrier_asyne</code>函数会等待在他前面追加在并行队列上的任务全部执行完，然后执行他的任务，在他的任务执行完再恢复并行队列的任务</p>\n<p>eg：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t queue = dispatch_queue_create(&quot;queueName&quot;,DISPATCH_QUEUE_CONCURRENT);</span><br><span class=\"line\">dispatch_async(queue,blk0_for_reading);</span><br><span class=\"line\">dispatch_async(queue,blk1_for_reading);</span><br><span class=\"line\">dispatch_async(queue,blk2_for_reading);</span><br><span class=\"line\">dispatch_async(queue,blk3_for_reading);</span><br><span class=\"line\">dispatch_barrier_async(queue, blk_for_writing);</span><br><span class=\"line\">dispatch_async(queue,blk4_for_reading);</span><br><span class=\"line\">dispatch_async(queue,blk5_for_reading);</span><br><span class=\"line\">dispatch_async(queue,blk6_for_reading);</span><br></pre></td></tr></table></figure>\n<h4 id=\"dispatch-sync\"><a href=\"#dispatch-sync\" class=\"headerlink\" title=\"dispatch_sync\"></a>dispatch_sync</h4><p><code>dispatch_sync</code>是同步将<code>block</code>追加到队列中，<code>dispatch_async</code>是非同步的将<code>block</code>追加到队列中，区别就是<code>dispatch_sync</code>会在追加完成后，等待任务执行完，而<code>dispatch_async</code>不做任何等待。</p>\n<p>一旦调用<code>dispatch_sync</code>函数，在指定的处理执行结束之前，该函数不会返回，所以该函数容易引起死锁问题，比如在主线程同步添加任务。</p>\n<h4 id=\"dispatch-apply\"><a href=\"#dispatch-apply\" class=\"headerlink\" title=\"dispatch_apply\"></a>dispatch_apply</h4><p><code>dispatch_apply</code>可以按照指定的次数将指定的<code>block</code>追加到指定的队列中，并等待全部处理执行结束</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);</span><br><span class=\"line\">dispatch_apply(10, queue, ^(size_t index) &#123;</span><br><span class=\"line\">\tNSLog(@&quot;%zu&quot;,index);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>因为他也会等待处理执行结束，所以也会有死锁问题。</p>\n<h4 id=\"dispatch-suspend-dispatch-resume\"><a href=\"#dispatch-suspend-dispatch-resume\" class=\"headerlink\" title=\"dispatch_suspend/dispatch_resume\"></a>dispatch_suspend/dispatch_resume</h4><p><code>dispatch_suspend</code>函数可以挂起指定的队列</p>\n<p><code>dispatch_resume</code>函数可以恢复指定的队列</p>\n<h4 id=\"dispatch-once\"><a href=\"#dispatch-once\" class=\"headerlink\" title=\"dispatch_once\"></a>dispatch_once</h4><p>这是经常写单例使用的方法，<code>dispatch_once</code>函数可以保证在应用程序执行中只执行一次。</p>\n<p>eg：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static dispatch_once_t pred;</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_once(&amp;pred, ^&#123;</span><br><span class=\"line\">\t//do something</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>《iOS与OS X多线程和内存管理》的第三章是对<code>GCD</code>的介绍，<code>GCD</code>就是<code>Grand Central Dispatch</code>,是将应用程序中记述的线程管理用的代码在系统级中实现。说简单点就是，用简单的方法实现多线程</p>","more":"<h3 id=\"队列-Dispatch-Queue\"><a href=\"#队列-Dispatch-Queue\" class=\"headerlink\" title=\"队列 Dispatch Queue\"></a>队列 Dispatch Queue</h3><p>队列（Dispatch Queue）是存放任务等待执行处理的地方。既然是队列，那么他要遵循<code>FIFO</code>先进先出原则。</p>\n<p>队列有两种：</p>\n<ol>\n<li><p>Serial Dispatch Queue  (串行队列)</p>\n</li>\n<li><p>Concurrent Dispatch Queue (并行队列)</p>\n</li>\n</ol>\n<p><code>Serial Dispatch Queue</code>（串行队列）的特点是需要等待现在执行中的任务处理结束才可以处理下一个任务</p>\n<p><code>Concurrent Dispatch Queue</code> (并行队列)的特点是不等待现在执行中的任务处理结束，可以并行执行多个处理，但是并行处理的数量取决于当前系统的状态</p>\n<h3 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h3><p>一个CPU执行的CPU命令列是一条无分叉路径，这就是一个线程，所以从队列的种类来看，串行队列始终在使用一个线程处理任务，而并行队列使用的是多个线程处理任务，多个线程的数量取决于当前系统状态</p>\n<h3 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h3><p><code>GCD</code>使用过程中的各种<code>API</code></p>\n<h4 id=\"创建和获取队列\"><a href=\"#创建和获取队列\" class=\"headerlink\" title=\"创建和获取队列\"></a>创建和获取队列</h4><p>创建一个串行队列:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t serialDispatchQueue = dispatch_queue_create(&quot;queueName&quot;，DISPATCH_QUEUE_SERIAL);</span><br></pre></td></tr></table></figure>\n<p>创建一个并行队列：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t concurrentDispatchQueue = dispatch_queue_create(&quot;queueName&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure>\n<p>创建串行队列和并行队列的方法是一样的，唯一的区别是第二个参数，如果创建的是串行队列，传入<code>DISPATCH_QUEUE_SERIAL</code>就好，如果是创建并行队列，则指定为<code>DISPATCH_QUEUE_CONCURRENT</code>。</p>\n<p>创建队列的第一个参数，是队列的名称，他可以在调试器中显示，苹果推荐的名称是，逆序全程域名，你也可以传<code>NULL</code></p>\n<p>获取系统提供的队列：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//获取主线程队列 （串行队列）</span><br><span class=\"line\">dispatch_queue_t mainDispatchQueue = dispatch_get_main_queue();</span><br><span class=\"line\"></span><br><span class=\"line\">//获取全局队列--高优先级 （并行队列）</span><br><span class=\"line\">dispatch_queue_t highQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">//获取全局队列--默认优先级 （并行队列）</span><br><span class=\"line\">dispatch_queue_t defaultQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">//获取全局队列--低优先级 （并行队列）</span><br><span class=\"line\">dispatch_queue_t lowQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">//获取全局队列--后台优先级 （并行队列）</span><br><span class=\"line\">dispatch_queue_t backgroundQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0);</span><br></pre></td></tr></table></figure>\n<h4 id=\"改变队列优先级\"><a href=\"#改变队列优先级\" class=\"headerlink\" title=\"改变队列优先级\"></a>改变队列优先级</h4><p>在使用<code>dispatch_queue_create</code>函数生成的队列，不管是串行还是并行的都是默认优先级的。要改变优先级需要使用<code>dispatch_set_target_queue</code>函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t myQueue = dispatch_queue_create(&quot;queueName&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class=\"line\">dispatch_queue_t globalBackgroundQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND,0);</span><br><span class=\"line\">dispatch_set_target_queue(myQueue, globalBackgroundQueue);</span><br></pre></td></tr></table></figure>\n<p>这样<code>myQueue</code>的优先级就是<code>DISPATCH_QUEUE_PRIORITY_BACKGROUND</code>的了。</p>\n<p>注意，不能改变系统提供的队列的优先级，也就是系统提供的队列不能写在第一个参数中</p>\n<p><code>dispatch_set_target_queue</code>还可以改变队列执行优先级，如果有多个串行任务在多个串行队列中执行，这时如果要防止并行，就可以将多个串行队列，指定到同一个目标串行队列中，原本并行执行的多个串行队列就会变成真正的串行，同时执行一个处理。</p>\n<h4 id=\"延迟执行\"><a href=\"#延迟执行\" class=\"headerlink\" title=\"延迟执行\"></a>延迟执行</h4><p>使用<code>dispatch_after</code>可以实现延迟指定时间执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 3ull*NSEC_PER_SEC);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_after(time, dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">\t//延迟执行的任务内容</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>注意，这里的延迟是在指定时间追加任务到指定队列，所以有可能有延时，不算绝对精确。</p>\n<h4 id=\"Dispatch-Group\"><a href=\"#Dispatch-Group\" class=\"headerlink\" title=\"Dispatch Group\"></a>Dispatch Group</h4><p><code>Dispatch Group</code>可以在多个队列都执行完成后，执行指定队列</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class=\"line\">dispatch_group_t group = dispatch_group_create();</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_group_async(group,queue, ^&#123;NSLog(@&quot;blk1&quot;);&#125;);</span><br><span class=\"line\">dispatch_group_async(group,queue, ^&#123;NSLog(@&quot;blk2&quot;);&#125;);</span><br><span class=\"line\">dispatch_group_async(group,queue, ^&#123;NSLog(@&quot;blk3&quot;);&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_group_notify(group, dispatch_get_main_queue(),^&#123;NSLog(@&quot;done&quot;);&#125;);</span><br><span class=\"line\">//dispatch_group_wait(group,DISPATCH_TIME_FOREVER); //指定超时时间</span><br></pre></td></tr></table></figure>\n<h4 id=\"dispatch-barrier-async\"><a href=\"#dispatch-barrier-async\" class=\"headerlink\" title=\"dispatch_barrier_async\"></a>dispatch_barrier_async</h4><p><code>dispatch_barrier_asyne</code>函数会等待在他前面追加在并行队列上的任务全部执行完，然后执行他的任务，在他的任务执行完再恢复并行队列的任务</p>\n<p>eg：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t queue = dispatch_queue_create(&quot;queueName&quot;,DISPATCH_QUEUE_CONCURRENT);</span><br><span class=\"line\">dispatch_async(queue,blk0_for_reading);</span><br><span class=\"line\">dispatch_async(queue,blk1_for_reading);</span><br><span class=\"line\">dispatch_async(queue,blk2_for_reading);</span><br><span class=\"line\">dispatch_async(queue,blk3_for_reading);</span><br><span class=\"line\">dispatch_barrier_async(queue, blk_for_writing);</span><br><span class=\"line\">dispatch_async(queue,blk4_for_reading);</span><br><span class=\"line\">dispatch_async(queue,blk5_for_reading);</span><br><span class=\"line\">dispatch_async(queue,blk6_for_reading);</span><br></pre></td></tr></table></figure>\n<h4 id=\"dispatch-sync\"><a href=\"#dispatch-sync\" class=\"headerlink\" title=\"dispatch_sync\"></a>dispatch_sync</h4><p><code>dispatch_sync</code>是同步将<code>block</code>追加到队列中，<code>dispatch_async</code>是非同步的将<code>block</code>追加到队列中，区别就是<code>dispatch_sync</code>会在追加完成后，等待任务执行完，而<code>dispatch_async</code>不做任何等待。</p>\n<p>一旦调用<code>dispatch_sync</code>函数，在指定的处理执行结束之前，该函数不会返回，所以该函数容易引起死锁问题，比如在主线程同步添加任务。</p>\n<h4 id=\"dispatch-apply\"><a href=\"#dispatch-apply\" class=\"headerlink\" title=\"dispatch_apply\"></a>dispatch_apply</h4><p><code>dispatch_apply</code>可以按照指定的次数将指定的<code>block</code>追加到指定的队列中，并等待全部处理执行结束</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);</span><br><span class=\"line\">dispatch_apply(10, queue, ^(size_t index) &#123;</span><br><span class=\"line\">\tNSLog(@&quot;%zu&quot;,index);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>因为他也会等待处理执行结束，所以也会有死锁问题。</p>\n<h4 id=\"dispatch-suspend-dispatch-resume\"><a href=\"#dispatch-suspend-dispatch-resume\" class=\"headerlink\" title=\"dispatch_suspend/dispatch_resume\"></a>dispatch_suspend/dispatch_resume</h4><p><code>dispatch_suspend</code>函数可以挂起指定的队列</p>\n<p><code>dispatch_resume</code>函数可以恢复指定的队列</p>\n<h4 id=\"dispatch-once\"><a href=\"#dispatch-once\" class=\"headerlink\" title=\"dispatch_once\"></a>dispatch_once</h4><p>这是经常写单例使用的方法，<code>dispatch_once</code>函数可以保证在应用程序执行中只执行一次。</p>\n<p>eg：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static dispatch_once_t pred;</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_once(&amp;pred, ^&#123;</span><br><span class=\"line\">\t//do something</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>"},{"title":"读《iOS与OS X多线程和内存管理》—— 属性","date":"2017-05-10T11:26:12.000Z","_content":"\n## 前言 ##\n\n在`ARC`中是使用所有权修饰符来实现自动引用计数的，但是编程中我们几乎很少显式的写所有权修饰符，而是写属性关键字。\n\n<!-- more -->\n\n\n### 属性与所有权修饰符的对应关系 ###\n\n| 属性        | 所有权修饰符    |\n| ----       | -----         |\n| assign     | __unsafe_unretained |\n| copy       | __strong (赋值的是被复制对象)     |\n| retain     | __strong      |\n| strong     | __strong      |\n| unsafe_unretained     | __unsafe_unretained      |\n| weak     | __weak      |\n\n\n### __strong 实现 ###\n\n```mm\n{\nid __strong obj = [NSObject alloc] init];\n}\n```\n在编译时会转换成\n\n```\nid obj = objc_msgSend(NSObject, @selector(alloc));\nobjc_msgSend(obj, @selector(init));\nobjc_release(obj);//变量作用域结束编译器自动插入了release\n```\n使用alloc/new/copy/mutableCopy以外的方法\n\n```\n{\nid __strong obj = [NSMutableArray array];\n}\n```\n\n在编译时会转换成\n\n```\nid obj = objc_msgSend(NSMutableArray,@selector(array));\n/*\narray方法在编译时转换成了\n{\nid obj = objc_msgSend(NSMutableArray, @selector(alloc));\nobjc_msgSend(obj, @selector(init));\nreturn objc_autoreleaseReturnValue(obj);\n}\n*/\nobjc_retainAutoreleasedReturnValue(obj);\nobjc_release(obj);//变量作用域结束编译器自动插入了release\n```\n\n\nobjc_retainAutoreleasedReturnValue() 和 objc_autoreleaseReturnValue是成对出现的，用在alloc/new/copy/mutableCopy以外的类方法时\n\nobjc_autoreleaseReturnValue函数和objc_autorelease函数不同，objc_autorelease函数会注册对象到autoreleasepool中\nobjc_autoreleaseReturnValue函数会检查使用该函数的方法或函数调用方的执行命令列表，\n如果在后面紧接着调用objc_retainAutoreleaseReturnValue()函数，则将返回的对象直接传递到方法或函数的调用方，而不注册到autoreleasepool\n\nobjc_retainAutoreleasedReturnValue函数和objc_retain函数不同，它即便不注册到autoreleasepool中而返回对象，也能够正确地获取对象\n通过objc_autoreleaseReturnValue函数和objc_retainAutoreleasedReturnValue函数，可以不将对象注册到autoreleasepool中而直接传递\n\n\n### __weak 实现 ###\n\n```\n{\nid __weak obj1 = obj;//此处假设变量obj附加__strong修饰符且对象被赋值\n}\n```\n在编译时会转换成\n\n```\nid obj1;\nobjc_initWeak(&obj1, obj);\n/*\nobjc_initWeak函数在这里转换成\nobj1 = 0；\nobjc_storeWeak(&obj1, obj);\n*/\nobjc_destroyWeak(&obj1);\n/*\nobjc_destroyWeak函数在这里相当于\nobjc_storeWeak(&obj1, 0);\n*/\n```\n\nobjc_stroeWeak函数把第二个参数的赋值对象的地址作为键值，将第一个参数的附有`__weak`修饰符的变量的地址注册到weak表中，\n如果第二个参数为0，则把变量的地址从weak表中删除\n\nweak表与引用计数表相同，都是作为散列表实现的。使用weak表，将废弃的对象的地址作为键值进行检索，就能高速地获取对应的附有`__weak`修饰符的变量的地址\n由于一个对象可同时赋值给多个附有`__weak`修饰符的变量中，所以对于一个键值，可注册多个变量的地址\n\n对象释放时，程序的将进行下面几步：\n\n1. objc_release\n2. 执行dealloc\n3. _objc_rootDealloc\n4. object_dispose\n5. objc_destructInstance\n6. objc_clear_deallocating\n\nobjc_clear_deallocating函数做了下面几件事：\n\n1. 从weak表中获取废弃对象的地址为键值的记录（获取所有的__weak修饰的变量的地址）\n2. 将所有的__weak修饰的变量的地址，赋值为nil\n3. 从weak表中删除该记录\n4. 从引用计数表中删除废弃对象的地址为键值的记录\n\n经过以上步骤，`__weak`修饰符的变量所引用的对象被废弃，且将nil赋值给该变量。\n由此可知，如果大量使用附有`__weak`修饰符的变量，则会销毁相应的CPU资源，因此只是在需要避免循环引用时使用`__weak`修饰符\n\n将自己生成并持有的对象赋值给`__weak`修饰符修饰的变量时，会引起编译器警告\n\n```\n{\nid __weak obj = [[NSObject alloc] init];\n}\n```\n\n在编译时转换成：\n\n```\nid obj;\nid tmp = objc_msgSend(NSObject, @selector(alloc));\nobjc_msgSend(tmp, @selector(init));\nobjc_initWeak(&obj, tmp);\nobjc_release(tmp);\nobjc_destroyWeak(&object);\n```\n\n自己生成并持有的对象通过objc_initWeak函数被赋值给附有`__weak`修饰符的变量中，但变量无法持有，\n故编译器判断其没有持有者，则该对象立即通过objc_release函数被释放和废弃，同时变量也被置nil\n\n使用附有`__weak`修饰符的变量，即是使用注册到autoreleasepool中的对象\n\n```\n{\nid __weak obj1 = obj;\nNSLog(@\"%@\",obj1);\n}\n```\n\n可以转化成如下形式\n\n```\nid obj1;\nobjc_initWeak(&obj1, obj);\nid tmp = objc_loadWeakRetained(&obj1);\nobjc_autorelease(tmp);\nNSLog(@\"%@\" ,tmp);\nobjc_destroyWeak(&obj1);\n```\n\n和被赋值相比，此处增加了objc_loadWeakRetained函数和objc_autorelease函数\n\n1. objc_loadWeakRetained函数取出附有__weak 修饰符变量所引用的对象并retain。\n2. objc_autorelease函数将对象注册到autoreleasepool中。\n\n由此可知，`__weak`修饰符变量所引用的对象像这样被注册到autoreleasepool中，所以在@autoreleasepool 块结束之前都可以放心使用。\n但是，如果大量地使用附有`__weak` 修饰符的变量，注册到autorpool的对象也会大量地增加，\n因此，在使用附有`__weak`修饰符的变量时，最好先暂时赋值给附有`__strong`修饰符的变量后再使用\n\neg：\n\n```\n{\nid __weak o = obj;\nNSLog(@\"1 %@\", o);\nNSLog(@\"2 %@\", o);\nNSLog(@\"3 %@\", o);\nNSLog(@\"4 %@\", o);\nNSLog(@\"5 %@\", o);\n}\n```\n这样o所赋值的对象注册到autoreleasepool中5次\n\n但使用\n\n```\n{\nid __weak o = obj;\nid tmp = o;\nNSLog(@\"1 %@\", tmp);\nNSLog(@\"2 %@\", tmp);\nNSLog(@\"3 %@\", tmp);\nNSLog(@\"4 %@\", tmp);\nNSLog(@\"5 %@\", tmp);\n}\n```\n只会在\"tmp = o\"时，对象会登录到autoreleasepool中1次\n\n在一些特定环境中是不能使用`__weak` 修饰符的，而且也存在着不支持`__weak`修饰符的类，这些类重写了retain/release\n并实现该类独自的引用计数机制。因此独自实现引用计数机制的类大多数不支持__weak修饰符。\n不支持__weak修饰符的类，其类声明中附加了`\"__attribute__((objc_arc_weak_reference_unavailable))\"`这一属性，\n同时定义了`\"NS_AUTOMATED_REFCOUNT_WEAK_UNAVAILABLE\"`。如果将不支持`__weak`声明类的对象赋值给附有`__weak`修饰符的变量，\n那么一旦编译器检验出来就会报告编译错误。而且Cocoa框架类中，不支持`__weak`修饰符的类极为罕见\n\nallowsWeakReference/retainWeakReference方法\n当allowsWeakReference/retainWeakReference实例方法返回NO时，同样不能使用`__weak`修饰符\n\n在赋值给`__weak`修饰符的变量时，如果赋值对象的allowsWeakReference 方法返回NO,程序将异常终止\n\n在赋值给`__weak`修饰符的变量时，如果赋值对象的retainWeakReference 方法返回NO,该变量将使用nil\n\neg：\n\n```\n{\nid __strong obj = [[NSObject alloc] init];\nid __weak o = obj;\nNSLog(@\"1 %@\",o);\nNSLog(@\"2 %@\",o);\nNSLog(@\"3 %@\",o);\nNSLog(@\"4 %@\",o);\nNSLog(@\"5 %@\",o);\n}\n```\n\n运行结果所有的NSLog都可以打印出地址\n\n如果自定义一个MyObject继承自NSObject的类，并实现retainWeakReference方法\n\n```\n- (BOOL)retainWeakReference {\n  if (++count > 3)\n    return NO;\n  return [super retainWeakReference];\n}\n```\n\n使用MyObject类生成并持有对象\n\n```\n{\nid __strong obj = [[MyObject alloc] init];\nid __weak o = obj;\nNSLog(@\"1 %@\",o);\nNSLog(@\"2 %@\",o);\nNSLog(@\"3 %@\",o);\nNSLog(@\"4 %@\",o);\nNSLog(@\"5 %@\",o);\n}\n```\n\n运行结果4和5的NSLog打印的为nil\n\n\n### __autoreleasing 实现\n\n```\n@autoreleasepool {\n    id __autoreleaseing obj = [[NSObject alloc] init];\n}\n```\n\n在编译的时候转换为\n\n```\nid pool = objc_autoreleasePoolPush();\nid obj = objc_msgSend(NSObject, @selector(alloc));\nobjc_msgSend(obj, @selector(init));\nobjc_autorelease(obj);\nobjc_autoreleasePoolPop(pool);\n```\n\n在alloc/new/copy/mutableCopy方法群之外的方法使用\n\n```\n@autoreleasepool {\n  id __autoreleasing obj = [NSMutableArray array];\n}\n```\n\n在编译时转换为\n\n```\nid pool = objc_autoreleasePoolPush();\nid obj = objc_msgSend(NSMutableArray, @selector(array));\nobjc_retainAutoreleasedReturnValue(obj);\nobjc_autorelease(obj);\nobjc_autoreleasePoolPop(pool);\n```","source":"_posts/读《iOS与OS X多线程和内存管理》—— 属性.md","raw":"---\ntitle: 读《iOS与OS X多线程和内存管理》—— 属性\ndate: 2017-05-10 19:26:12\ntags: [iOS]\n---\n\n## 前言 ##\n\n在`ARC`中是使用所有权修饰符来实现自动引用计数的，但是编程中我们几乎很少显式的写所有权修饰符，而是写属性关键字。\n\n<!-- more -->\n\n\n### 属性与所有权修饰符的对应关系 ###\n\n| 属性        | 所有权修饰符    |\n| ----       | -----         |\n| assign     | __unsafe_unretained |\n| copy       | __strong (赋值的是被复制对象)     |\n| retain     | __strong      |\n| strong     | __strong      |\n| unsafe_unretained     | __unsafe_unretained      |\n| weak     | __weak      |\n\n\n### __strong 实现 ###\n\n```mm\n{\nid __strong obj = [NSObject alloc] init];\n}\n```\n在编译时会转换成\n\n```\nid obj = objc_msgSend(NSObject, @selector(alloc));\nobjc_msgSend(obj, @selector(init));\nobjc_release(obj);//变量作用域结束编译器自动插入了release\n```\n使用alloc/new/copy/mutableCopy以外的方法\n\n```\n{\nid __strong obj = [NSMutableArray array];\n}\n```\n\n在编译时会转换成\n\n```\nid obj = objc_msgSend(NSMutableArray,@selector(array));\n/*\narray方法在编译时转换成了\n{\nid obj = objc_msgSend(NSMutableArray, @selector(alloc));\nobjc_msgSend(obj, @selector(init));\nreturn objc_autoreleaseReturnValue(obj);\n}\n*/\nobjc_retainAutoreleasedReturnValue(obj);\nobjc_release(obj);//变量作用域结束编译器自动插入了release\n```\n\n\nobjc_retainAutoreleasedReturnValue() 和 objc_autoreleaseReturnValue是成对出现的，用在alloc/new/copy/mutableCopy以外的类方法时\n\nobjc_autoreleaseReturnValue函数和objc_autorelease函数不同，objc_autorelease函数会注册对象到autoreleasepool中\nobjc_autoreleaseReturnValue函数会检查使用该函数的方法或函数调用方的执行命令列表，\n如果在后面紧接着调用objc_retainAutoreleaseReturnValue()函数，则将返回的对象直接传递到方法或函数的调用方，而不注册到autoreleasepool\n\nobjc_retainAutoreleasedReturnValue函数和objc_retain函数不同，它即便不注册到autoreleasepool中而返回对象，也能够正确地获取对象\n通过objc_autoreleaseReturnValue函数和objc_retainAutoreleasedReturnValue函数，可以不将对象注册到autoreleasepool中而直接传递\n\n\n### __weak 实现 ###\n\n```\n{\nid __weak obj1 = obj;//此处假设变量obj附加__strong修饰符且对象被赋值\n}\n```\n在编译时会转换成\n\n```\nid obj1;\nobjc_initWeak(&obj1, obj);\n/*\nobjc_initWeak函数在这里转换成\nobj1 = 0；\nobjc_storeWeak(&obj1, obj);\n*/\nobjc_destroyWeak(&obj1);\n/*\nobjc_destroyWeak函数在这里相当于\nobjc_storeWeak(&obj1, 0);\n*/\n```\n\nobjc_stroeWeak函数把第二个参数的赋值对象的地址作为键值，将第一个参数的附有`__weak`修饰符的变量的地址注册到weak表中，\n如果第二个参数为0，则把变量的地址从weak表中删除\n\nweak表与引用计数表相同，都是作为散列表实现的。使用weak表，将废弃的对象的地址作为键值进行检索，就能高速地获取对应的附有`__weak`修饰符的变量的地址\n由于一个对象可同时赋值给多个附有`__weak`修饰符的变量中，所以对于一个键值，可注册多个变量的地址\n\n对象释放时，程序的将进行下面几步：\n\n1. objc_release\n2. 执行dealloc\n3. _objc_rootDealloc\n4. object_dispose\n5. objc_destructInstance\n6. objc_clear_deallocating\n\nobjc_clear_deallocating函数做了下面几件事：\n\n1. 从weak表中获取废弃对象的地址为键值的记录（获取所有的__weak修饰的变量的地址）\n2. 将所有的__weak修饰的变量的地址，赋值为nil\n3. 从weak表中删除该记录\n4. 从引用计数表中删除废弃对象的地址为键值的记录\n\n经过以上步骤，`__weak`修饰符的变量所引用的对象被废弃，且将nil赋值给该变量。\n由此可知，如果大量使用附有`__weak`修饰符的变量，则会销毁相应的CPU资源，因此只是在需要避免循环引用时使用`__weak`修饰符\n\n将自己生成并持有的对象赋值给`__weak`修饰符修饰的变量时，会引起编译器警告\n\n```\n{\nid __weak obj = [[NSObject alloc] init];\n}\n```\n\n在编译时转换成：\n\n```\nid obj;\nid tmp = objc_msgSend(NSObject, @selector(alloc));\nobjc_msgSend(tmp, @selector(init));\nobjc_initWeak(&obj, tmp);\nobjc_release(tmp);\nobjc_destroyWeak(&object);\n```\n\n自己生成并持有的对象通过objc_initWeak函数被赋值给附有`__weak`修饰符的变量中，但变量无法持有，\n故编译器判断其没有持有者，则该对象立即通过objc_release函数被释放和废弃，同时变量也被置nil\n\n使用附有`__weak`修饰符的变量，即是使用注册到autoreleasepool中的对象\n\n```\n{\nid __weak obj1 = obj;\nNSLog(@\"%@\",obj1);\n}\n```\n\n可以转化成如下形式\n\n```\nid obj1;\nobjc_initWeak(&obj1, obj);\nid tmp = objc_loadWeakRetained(&obj1);\nobjc_autorelease(tmp);\nNSLog(@\"%@\" ,tmp);\nobjc_destroyWeak(&obj1);\n```\n\n和被赋值相比，此处增加了objc_loadWeakRetained函数和objc_autorelease函数\n\n1. objc_loadWeakRetained函数取出附有__weak 修饰符变量所引用的对象并retain。\n2. objc_autorelease函数将对象注册到autoreleasepool中。\n\n由此可知，`__weak`修饰符变量所引用的对象像这样被注册到autoreleasepool中，所以在@autoreleasepool 块结束之前都可以放心使用。\n但是，如果大量地使用附有`__weak` 修饰符的变量，注册到autorpool的对象也会大量地增加，\n因此，在使用附有`__weak`修饰符的变量时，最好先暂时赋值给附有`__strong`修饰符的变量后再使用\n\neg：\n\n```\n{\nid __weak o = obj;\nNSLog(@\"1 %@\", o);\nNSLog(@\"2 %@\", o);\nNSLog(@\"3 %@\", o);\nNSLog(@\"4 %@\", o);\nNSLog(@\"5 %@\", o);\n}\n```\n这样o所赋值的对象注册到autoreleasepool中5次\n\n但使用\n\n```\n{\nid __weak o = obj;\nid tmp = o;\nNSLog(@\"1 %@\", tmp);\nNSLog(@\"2 %@\", tmp);\nNSLog(@\"3 %@\", tmp);\nNSLog(@\"4 %@\", tmp);\nNSLog(@\"5 %@\", tmp);\n}\n```\n只会在\"tmp = o\"时，对象会登录到autoreleasepool中1次\n\n在一些特定环境中是不能使用`__weak` 修饰符的，而且也存在着不支持`__weak`修饰符的类，这些类重写了retain/release\n并实现该类独自的引用计数机制。因此独自实现引用计数机制的类大多数不支持__weak修饰符。\n不支持__weak修饰符的类，其类声明中附加了`\"__attribute__((objc_arc_weak_reference_unavailable))\"`这一属性，\n同时定义了`\"NS_AUTOMATED_REFCOUNT_WEAK_UNAVAILABLE\"`。如果将不支持`__weak`声明类的对象赋值给附有`__weak`修饰符的变量，\n那么一旦编译器检验出来就会报告编译错误。而且Cocoa框架类中，不支持`__weak`修饰符的类极为罕见\n\nallowsWeakReference/retainWeakReference方法\n当allowsWeakReference/retainWeakReference实例方法返回NO时，同样不能使用`__weak`修饰符\n\n在赋值给`__weak`修饰符的变量时，如果赋值对象的allowsWeakReference 方法返回NO,程序将异常终止\n\n在赋值给`__weak`修饰符的变量时，如果赋值对象的retainWeakReference 方法返回NO,该变量将使用nil\n\neg：\n\n```\n{\nid __strong obj = [[NSObject alloc] init];\nid __weak o = obj;\nNSLog(@\"1 %@\",o);\nNSLog(@\"2 %@\",o);\nNSLog(@\"3 %@\",o);\nNSLog(@\"4 %@\",o);\nNSLog(@\"5 %@\",o);\n}\n```\n\n运行结果所有的NSLog都可以打印出地址\n\n如果自定义一个MyObject继承自NSObject的类，并实现retainWeakReference方法\n\n```\n- (BOOL)retainWeakReference {\n  if (++count > 3)\n    return NO;\n  return [super retainWeakReference];\n}\n```\n\n使用MyObject类生成并持有对象\n\n```\n{\nid __strong obj = [[MyObject alloc] init];\nid __weak o = obj;\nNSLog(@\"1 %@\",o);\nNSLog(@\"2 %@\",o);\nNSLog(@\"3 %@\",o);\nNSLog(@\"4 %@\",o);\nNSLog(@\"5 %@\",o);\n}\n```\n\n运行结果4和5的NSLog打印的为nil\n\n\n### __autoreleasing 实现\n\n```\n@autoreleasepool {\n    id __autoreleaseing obj = [[NSObject alloc] init];\n}\n```\n\n在编译的时候转换为\n\n```\nid pool = objc_autoreleasePoolPush();\nid obj = objc_msgSend(NSObject, @selector(alloc));\nobjc_msgSend(obj, @selector(init));\nobjc_autorelease(obj);\nobjc_autoreleasePoolPop(pool);\n```\n\n在alloc/new/copy/mutableCopy方法群之外的方法使用\n\n```\n@autoreleasepool {\n  id __autoreleasing obj = [NSMutableArray array];\n}\n```\n\n在编译时转换为\n\n```\nid pool = objc_autoreleasePoolPush();\nid obj = objc_msgSend(NSMutableArray, @selector(array));\nobjc_retainAutoreleasedReturnValue(obj);\nobjc_autorelease(obj);\nobjc_autoreleasePoolPop(pool);\n```","slug":"读《iOS与OS X多线程和内存管理》—— 属性","published":1,"updated":"2021-04-12T09:17:38.422Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqjdx1oa00295emu4xq2v3ky","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在<code>ARC</code>中是使用所有权修饰符来实现自动引用计数的，但是编程中我们几乎很少显式的写所有权修饰符，而是写属性关键字。</p>\n<a id=\"more\"></a>\n<h3 id=\"属性与所有权修饰符的对应关系\"><a href=\"#属性与所有权修饰符的对应关系\" class=\"headerlink\" title=\"属性与所有权修饰符的对应关系\"></a>属性与所有权修饰符的对应关系</h3><table>\n<thead>\n<tr>\n<th>属性</th>\n<th>所有权修饰符</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>assign</td>\n<td>__unsafe_unretained</td>\n</tr>\n<tr>\n<td>copy</td>\n<td>__strong (赋值的是被复制对象)</td>\n</tr>\n<tr>\n<td>retain</td>\n<td>__strong</td>\n</tr>\n<tr>\n<td>strong</td>\n<td>__strong</td>\n</tr>\n<tr>\n<td>unsafe_unretained</td>\n<td>__unsafe_unretained</td>\n</tr>\n<tr>\n<td>weak</td>\n<td>__weak</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"strong-实现\"><a href=\"#strong-实现\" class=\"headerlink\" title=\"__strong 实现\"></a>__strong 实现</h3><figure class=\"highlight mm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">id</span> __<span class=\"keyword\">strong</span> obj = [<span class=\"built_in\">NSObject</span> alloc] init];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在编译时会转换成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id obj = objc_msgSend(NSObject, @selector(alloc));</span><br><span class=\"line\">objc_msgSend(obj, @selector(init));</span><br><span class=\"line\">objc_release(obj);//变量作用域结束编译器自动插入了release</span><br></pre></td></tr></table></figure>\n<p>使用alloc/new/copy/mutableCopy以外的方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">id __strong obj = [NSMutableArray array];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在编译时会转换成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id obj = objc_msgSend(NSMutableArray,@selector(array));</span><br><span class=\"line\">/*</span><br><span class=\"line\">array方法在编译时转换成了</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">id obj = objc_msgSend(NSMutableArray, @selector(alloc));</span><br><span class=\"line\">objc_msgSend(obj, @selector(init));</span><br><span class=\"line\">return objc_autoreleaseReturnValue(obj);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">*/</span><br><span class=\"line\">objc_retainAutoreleasedReturnValue(obj);</span><br><span class=\"line\">objc_release(obj);//变量作用域结束编译器自动插入了release</span><br></pre></td></tr></table></figure>\n<p>objc_retainAutoreleasedReturnValue() 和 objc_autoreleaseReturnValue是成对出现的，用在alloc/new/copy/mutableCopy以外的类方法时</p>\n<p>objc_autoreleaseReturnValue函数和objc_autorelease函数不同，objc_autorelease函数会注册对象到autoreleasepool中<br>objc_autoreleaseReturnValue函数会检查使用该函数的方法或函数调用方的执行命令列表，<br>如果在后面紧接着调用objc_retainAutoreleaseReturnValue()函数，则将返回的对象直接传递到方法或函数的调用方，而不注册到autoreleasepool</p>\n<p>objc_retainAutoreleasedReturnValue函数和objc_retain函数不同，它即便不注册到autoreleasepool中而返回对象，也能够正确地获取对象<br>通过objc_autoreleaseReturnValue函数和objc_retainAutoreleasedReturnValue函数，可以不将对象注册到autoreleasepool中而直接传递</p>\n<h3 id=\"weak-实现\"><a href=\"#weak-实现\" class=\"headerlink\" title=\"__weak 实现\"></a>__weak 实现</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">id __weak obj1 = obj;//此处假设变量obj附加__strong修饰符且对象被赋值</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在编译时会转换成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id obj1;</span><br><span class=\"line\">objc_initWeak(&amp;obj1, obj);</span><br><span class=\"line\">/*</span><br><span class=\"line\">objc_initWeak函数在这里转换成</span><br><span class=\"line\">obj1 = 0；</span><br><span class=\"line\">objc_storeWeak(&amp;obj1, obj);</span><br><span class=\"line\">*/</span><br><span class=\"line\">objc_destroyWeak(&amp;obj1);</span><br><span class=\"line\">/*</span><br><span class=\"line\">objc_destroyWeak函数在这里相当于</span><br><span class=\"line\">objc_storeWeak(&amp;obj1, 0);</span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure>\n<p>objc_stroeWeak函数把第二个参数的赋值对象的地址作为键值，将第一个参数的附有<code>__weak</code>修饰符的变量的地址注册到weak表中，<br>如果第二个参数为0，则把变量的地址从weak表中删除</p>\n<p>weak表与引用计数表相同，都是作为散列表实现的。使用weak表，将废弃的对象的地址作为键值进行检索，就能高速地获取对应的附有<code>__weak</code>修饰符的变量的地址<br>由于一个对象可同时赋值给多个附有<code>__weak</code>修饰符的变量中，所以对于一个键值，可注册多个变量的地址</p>\n<p>对象释放时，程序的将进行下面几步：</p>\n<ol>\n<li>objc_release</li>\n<li>执行dealloc</li>\n<li>_objc_rootDealloc</li>\n<li>object_dispose</li>\n<li>objc_destructInstance</li>\n<li>objc_clear_deallocating</li>\n</ol>\n<p>objc_clear_deallocating函数做了下面几件事：</p>\n<ol>\n<li>从weak表中获取废弃对象的地址为键值的记录（获取所有的__weak修饰的变量的地址）</li>\n<li>将所有的__weak修饰的变量的地址，赋值为nil</li>\n<li>从weak表中删除该记录</li>\n<li>从引用计数表中删除废弃对象的地址为键值的记录</li>\n</ol>\n<p>经过以上步骤，<code>__weak</code>修饰符的变量所引用的对象被废弃，且将nil赋值给该变量。<br>由此可知，如果大量使用附有<code>__weak</code>修饰符的变量，则会销毁相应的CPU资源，因此只是在需要避免循环引用时使用<code>__weak</code>修饰符</p>\n<p>将自己生成并持有的对象赋值给<code>__weak</code>修饰符修饰的变量时，会引起编译器警告</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">id __weak obj = [[NSObject alloc] init];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在编译时转换成：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id obj;</span><br><span class=\"line\">id tmp = objc_msgSend(NSObject, @selector(alloc));</span><br><span class=\"line\">objc_msgSend(tmp, @selector(init));</span><br><span class=\"line\">objc_initWeak(&amp;obj, tmp);</span><br><span class=\"line\">objc_release(tmp);</span><br><span class=\"line\">objc_destroyWeak(&amp;object);</span><br></pre></td></tr></table></figure>\n<p>自己生成并持有的对象通过objc_initWeak函数被赋值给附有<code>__weak</code>修饰符的变量中，但变量无法持有，<br>故编译器判断其没有持有者，则该对象立即通过objc_release函数被释放和废弃，同时变量也被置nil</p>\n<p>使用附有<code>__weak</code>修饰符的变量，即是使用注册到autoreleasepool中的对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">id __weak obj1 = obj;</span><br><span class=\"line\">NSLog(@&quot;%@&quot;,obj1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以转化成如下形式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id obj1;</span><br><span class=\"line\">objc_initWeak(&amp;obj1, obj);</span><br><span class=\"line\">id tmp = objc_loadWeakRetained(&amp;obj1);</span><br><span class=\"line\">objc_autorelease(tmp);</span><br><span class=\"line\">NSLog(@&quot;%@&quot; ,tmp);</span><br><span class=\"line\">objc_destroyWeak(&amp;obj1);</span><br></pre></td></tr></table></figure>\n<p>和被赋值相比，此处增加了objc_loadWeakRetained函数和objc_autorelease函数</p>\n<ol>\n<li>objc_loadWeakRetained函数取出附有__weak 修饰符变量所引用的对象并retain。</li>\n<li>objc_autorelease函数将对象注册到autoreleasepool中。</li>\n</ol>\n<p>由此可知，<code>__weak</code>修饰符变量所引用的对象像这样被注册到autoreleasepool中，所以在@autoreleasepool 块结束之前都可以放心使用。<br>但是，如果大量地使用附有<code>__weak</code> 修饰符的变量，注册到autorpool的对象也会大量地增加，<br>因此，在使用附有<code>__weak</code>修饰符的变量时，最好先暂时赋值给附有<code>__strong</code>修饰符的变量后再使用</p>\n<p>eg：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">id __weak o = obj;</span><br><span class=\"line\">NSLog(@&quot;1 %@&quot;, o);</span><br><span class=\"line\">NSLog(@&quot;2 %@&quot;, o);</span><br><span class=\"line\">NSLog(@&quot;3 %@&quot;, o);</span><br><span class=\"line\">NSLog(@&quot;4 %@&quot;, o);</span><br><span class=\"line\">NSLog(@&quot;5 %@&quot;, o);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样o所赋值的对象注册到autoreleasepool中5次</p>\n<p>但使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">id __weak o = obj;</span><br><span class=\"line\">id tmp = o;</span><br><span class=\"line\">NSLog(@&quot;1 %@&quot;, tmp);</span><br><span class=\"line\">NSLog(@&quot;2 %@&quot;, tmp);</span><br><span class=\"line\">NSLog(@&quot;3 %@&quot;, tmp);</span><br><span class=\"line\">NSLog(@&quot;4 %@&quot;, tmp);</span><br><span class=\"line\">NSLog(@&quot;5 %@&quot;, tmp);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>只会在”tmp = o”时，对象会登录到autoreleasepool中1次</p>\n<p>在一些特定环境中是不能使用<code>__weak</code> 修饰符的，而且也存在着不支持<code>__weak</code>修饰符的类，这些类重写了retain/release<br>并实现该类独自的引用计数机制。因此独自实现引用计数机制的类大多数不支持<strong>weak修饰符。<br>不支持</strong>weak修饰符的类，其类声明中附加了<code>&quot;__attribute__((objc_arc_weak_reference_unavailable))&quot;</code>这一属性，<br>同时定义了<code>&quot;NS_AUTOMATED_REFCOUNT_WEAK_UNAVAILABLE&quot;</code>。如果将不支持<code>__weak</code>声明类的对象赋值给附有<code>__weak</code>修饰符的变量，<br>那么一旦编译器检验出来就会报告编译错误。而且Cocoa框架类中，不支持<code>__weak</code>修饰符的类极为罕见</p>\n<p>allowsWeakReference/retainWeakReference方法<br>当allowsWeakReference/retainWeakReference实例方法返回NO时，同样不能使用<code>__weak</code>修饰符</p>\n<p>在赋值给<code>__weak</code>修饰符的变量时，如果赋值对象的allowsWeakReference 方法返回NO,程序将异常终止</p>\n<p>在赋值给<code>__weak</code>修饰符的变量时，如果赋值对象的retainWeakReference 方法返回NO,该变量将使用nil</p>\n<p>eg：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">id __strong obj = [[NSObject alloc] init];</span><br><span class=\"line\">id __weak o = obj;</span><br><span class=\"line\">NSLog(@&quot;1 %@&quot;,o);</span><br><span class=\"line\">NSLog(@&quot;2 %@&quot;,o);</span><br><span class=\"line\">NSLog(@&quot;3 %@&quot;,o);</span><br><span class=\"line\">NSLog(@&quot;4 %@&quot;,o);</span><br><span class=\"line\">NSLog(@&quot;5 %@&quot;,o);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果所有的NSLog都可以打印出地址</p>\n<p>如果自定义一个MyObject继承自NSObject的类，并实现retainWeakReference方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (BOOL)retainWeakReference &#123;</span><br><span class=\"line\">  if (++count &gt; 3)</span><br><span class=\"line\">    return NO;</span><br><span class=\"line\">  return [super retainWeakReference];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用MyObject类生成并持有对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">id __strong obj = [[MyObject alloc] init];</span><br><span class=\"line\">id __weak o = obj;</span><br><span class=\"line\">NSLog(@&quot;1 %@&quot;,o);</span><br><span class=\"line\">NSLog(@&quot;2 %@&quot;,o);</span><br><span class=\"line\">NSLog(@&quot;3 %@&quot;,o);</span><br><span class=\"line\">NSLog(@&quot;4 %@&quot;,o);</span><br><span class=\"line\">NSLog(@&quot;5 %@&quot;,o);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果4和5的NSLog打印的为nil</p>\n<h3 id=\"autoreleasing-实现\"><a href=\"#autoreleasing-实现\" class=\"headerlink\" title=\"__autoreleasing 实现\"></a>__autoreleasing 实现</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@autoreleasepool &#123;</span><br><span class=\"line\">    id __autoreleaseing obj = [[NSObject alloc] init];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在编译的时候转换为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id pool = objc_autoreleasePoolPush();</span><br><span class=\"line\">id obj = objc_msgSend(NSObject, @selector(alloc));</span><br><span class=\"line\">objc_msgSend(obj, @selector(init));</span><br><span class=\"line\">objc_autorelease(obj);</span><br><span class=\"line\">objc_autoreleasePoolPop(pool);</span><br></pre></td></tr></table></figure>\n<p>在alloc/new/copy/mutableCopy方法群之外的方法使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@autoreleasepool &#123;</span><br><span class=\"line\">  id __autoreleasing obj = [NSMutableArray array];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在编译时转换为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id pool = objc_autoreleasePoolPush();</span><br><span class=\"line\">id obj = objc_msgSend(NSMutableArray, @selector(array));</span><br><span class=\"line\">objc_retainAutoreleasedReturnValue(obj);</span><br><span class=\"line\">objc_autorelease(obj);</span><br><span class=\"line\">objc_autoreleasePoolPop(pool);</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在<code>ARC</code>中是使用所有权修饰符来实现自动引用计数的，但是编程中我们几乎很少显式的写所有权修饰符，而是写属性关键字。</p>","more":"<h3 id=\"属性与所有权修饰符的对应关系\"><a href=\"#属性与所有权修饰符的对应关系\" class=\"headerlink\" title=\"属性与所有权修饰符的对应关系\"></a>属性与所有权修饰符的对应关系</h3><table>\n<thead>\n<tr>\n<th>属性</th>\n<th>所有权修饰符</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>assign</td>\n<td>__unsafe_unretained</td>\n</tr>\n<tr>\n<td>copy</td>\n<td>__strong (赋值的是被复制对象)</td>\n</tr>\n<tr>\n<td>retain</td>\n<td>__strong</td>\n</tr>\n<tr>\n<td>strong</td>\n<td>__strong</td>\n</tr>\n<tr>\n<td>unsafe_unretained</td>\n<td>__unsafe_unretained</td>\n</tr>\n<tr>\n<td>weak</td>\n<td>__weak</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"strong-实现\"><a href=\"#strong-实现\" class=\"headerlink\" title=\"__strong 实现\"></a>__strong 实现</h3><figure class=\"highlight mm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">id</span> __<span class=\"keyword\">strong</span> obj = [<span class=\"built_in\">NSObject</span> alloc] init];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在编译时会转换成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id obj = objc_msgSend(NSObject, @selector(alloc));</span><br><span class=\"line\">objc_msgSend(obj, @selector(init));</span><br><span class=\"line\">objc_release(obj);//变量作用域结束编译器自动插入了release</span><br></pre></td></tr></table></figure>\n<p>使用alloc/new/copy/mutableCopy以外的方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">id __strong obj = [NSMutableArray array];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在编译时会转换成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id obj = objc_msgSend(NSMutableArray,@selector(array));</span><br><span class=\"line\">/*</span><br><span class=\"line\">array方法在编译时转换成了</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">id obj = objc_msgSend(NSMutableArray, @selector(alloc));</span><br><span class=\"line\">objc_msgSend(obj, @selector(init));</span><br><span class=\"line\">return objc_autoreleaseReturnValue(obj);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">*/</span><br><span class=\"line\">objc_retainAutoreleasedReturnValue(obj);</span><br><span class=\"line\">objc_release(obj);//变量作用域结束编译器自动插入了release</span><br></pre></td></tr></table></figure>\n<p>objc_retainAutoreleasedReturnValue() 和 objc_autoreleaseReturnValue是成对出现的，用在alloc/new/copy/mutableCopy以外的类方法时</p>\n<p>objc_autoreleaseReturnValue函数和objc_autorelease函数不同，objc_autorelease函数会注册对象到autoreleasepool中<br>objc_autoreleaseReturnValue函数会检查使用该函数的方法或函数调用方的执行命令列表，<br>如果在后面紧接着调用objc_retainAutoreleaseReturnValue()函数，则将返回的对象直接传递到方法或函数的调用方，而不注册到autoreleasepool</p>\n<p>objc_retainAutoreleasedReturnValue函数和objc_retain函数不同，它即便不注册到autoreleasepool中而返回对象，也能够正确地获取对象<br>通过objc_autoreleaseReturnValue函数和objc_retainAutoreleasedReturnValue函数，可以不将对象注册到autoreleasepool中而直接传递</p>\n<h3 id=\"weak-实现\"><a href=\"#weak-实现\" class=\"headerlink\" title=\"__weak 实现\"></a>__weak 实现</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">id __weak obj1 = obj;//此处假设变量obj附加__strong修饰符且对象被赋值</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在编译时会转换成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id obj1;</span><br><span class=\"line\">objc_initWeak(&amp;obj1, obj);</span><br><span class=\"line\">/*</span><br><span class=\"line\">objc_initWeak函数在这里转换成</span><br><span class=\"line\">obj1 = 0；</span><br><span class=\"line\">objc_storeWeak(&amp;obj1, obj);</span><br><span class=\"line\">*/</span><br><span class=\"line\">objc_destroyWeak(&amp;obj1);</span><br><span class=\"line\">/*</span><br><span class=\"line\">objc_destroyWeak函数在这里相当于</span><br><span class=\"line\">objc_storeWeak(&amp;obj1, 0);</span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure>\n<p>objc_stroeWeak函数把第二个参数的赋值对象的地址作为键值，将第一个参数的附有<code>__weak</code>修饰符的变量的地址注册到weak表中，<br>如果第二个参数为0，则把变量的地址从weak表中删除</p>\n<p>weak表与引用计数表相同，都是作为散列表实现的。使用weak表，将废弃的对象的地址作为键值进行检索，就能高速地获取对应的附有<code>__weak</code>修饰符的变量的地址<br>由于一个对象可同时赋值给多个附有<code>__weak</code>修饰符的变量中，所以对于一个键值，可注册多个变量的地址</p>\n<p>对象释放时，程序的将进行下面几步：</p>\n<ol>\n<li>objc_release</li>\n<li>执行dealloc</li>\n<li>_objc_rootDealloc</li>\n<li>object_dispose</li>\n<li>objc_destructInstance</li>\n<li>objc_clear_deallocating</li>\n</ol>\n<p>objc_clear_deallocating函数做了下面几件事：</p>\n<ol>\n<li>从weak表中获取废弃对象的地址为键值的记录（获取所有的__weak修饰的变量的地址）</li>\n<li>将所有的__weak修饰的变量的地址，赋值为nil</li>\n<li>从weak表中删除该记录</li>\n<li>从引用计数表中删除废弃对象的地址为键值的记录</li>\n</ol>\n<p>经过以上步骤，<code>__weak</code>修饰符的变量所引用的对象被废弃，且将nil赋值给该变量。<br>由此可知，如果大量使用附有<code>__weak</code>修饰符的变量，则会销毁相应的CPU资源，因此只是在需要避免循环引用时使用<code>__weak</code>修饰符</p>\n<p>将自己生成并持有的对象赋值给<code>__weak</code>修饰符修饰的变量时，会引起编译器警告</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">id __weak obj = [[NSObject alloc] init];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在编译时转换成：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id obj;</span><br><span class=\"line\">id tmp = objc_msgSend(NSObject, @selector(alloc));</span><br><span class=\"line\">objc_msgSend(tmp, @selector(init));</span><br><span class=\"line\">objc_initWeak(&amp;obj, tmp);</span><br><span class=\"line\">objc_release(tmp);</span><br><span class=\"line\">objc_destroyWeak(&amp;object);</span><br></pre></td></tr></table></figure>\n<p>自己生成并持有的对象通过objc_initWeak函数被赋值给附有<code>__weak</code>修饰符的变量中，但变量无法持有，<br>故编译器判断其没有持有者，则该对象立即通过objc_release函数被释放和废弃，同时变量也被置nil</p>\n<p>使用附有<code>__weak</code>修饰符的变量，即是使用注册到autoreleasepool中的对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">id __weak obj1 = obj;</span><br><span class=\"line\">NSLog(@&quot;%@&quot;,obj1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以转化成如下形式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id obj1;</span><br><span class=\"line\">objc_initWeak(&amp;obj1, obj);</span><br><span class=\"line\">id tmp = objc_loadWeakRetained(&amp;obj1);</span><br><span class=\"line\">objc_autorelease(tmp);</span><br><span class=\"line\">NSLog(@&quot;%@&quot; ,tmp);</span><br><span class=\"line\">objc_destroyWeak(&amp;obj1);</span><br></pre></td></tr></table></figure>\n<p>和被赋值相比，此处增加了objc_loadWeakRetained函数和objc_autorelease函数</p>\n<ol>\n<li>objc_loadWeakRetained函数取出附有__weak 修饰符变量所引用的对象并retain。</li>\n<li>objc_autorelease函数将对象注册到autoreleasepool中。</li>\n</ol>\n<p>由此可知，<code>__weak</code>修饰符变量所引用的对象像这样被注册到autoreleasepool中，所以在@autoreleasepool 块结束之前都可以放心使用。<br>但是，如果大量地使用附有<code>__weak</code> 修饰符的变量，注册到autorpool的对象也会大量地增加，<br>因此，在使用附有<code>__weak</code>修饰符的变量时，最好先暂时赋值给附有<code>__strong</code>修饰符的变量后再使用</p>\n<p>eg：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">id __weak o = obj;</span><br><span class=\"line\">NSLog(@&quot;1 %@&quot;, o);</span><br><span class=\"line\">NSLog(@&quot;2 %@&quot;, o);</span><br><span class=\"line\">NSLog(@&quot;3 %@&quot;, o);</span><br><span class=\"line\">NSLog(@&quot;4 %@&quot;, o);</span><br><span class=\"line\">NSLog(@&quot;5 %@&quot;, o);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样o所赋值的对象注册到autoreleasepool中5次</p>\n<p>但使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">id __weak o = obj;</span><br><span class=\"line\">id tmp = o;</span><br><span class=\"line\">NSLog(@&quot;1 %@&quot;, tmp);</span><br><span class=\"line\">NSLog(@&quot;2 %@&quot;, tmp);</span><br><span class=\"line\">NSLog(@&quot;3 %@&quot;, tmp);</span><br><span class=\"line\">NSLog(@&quot;4 %@&quot;, tmp);</span><br><span class=\"line\">NSLog(@&quot;5 %@&quot;, tmp);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>只会在”tmp = o”时，对象会登录到autoreleasepool中1次</p>\n<p>在一些特定环境中是不能使用<code>__weak</code> 修饰符的，而且也存在着不支持<code>__weak</code>修饰符的类，这些类重写了retain/release<br>并实现该类独自的引用计数机制。因此独自实现引用计数机制的类大多数不支持<strong>weak修饰符。<br>不支持</strong>weak修饰符的类，其类声明中附加了<code>&quot;__attribute__((objc_arc_weak_reference_unavailable))&quot;</code>这一属性，<br>同时定义了<code>&quot;NS_AUTOMATED_REFCOUNT_WEAK_UNAVAILABLE&quot;</code>。如果将不支持<code>__weak</code>声明类的对象赋值给附有<code>__weak</code>修饰符的变量，<br>那么一旦编译器检验出来就会报告编译错误。而且Cocoa框架类中，不支持<code>__weak</code>修饰符的类极为罕见</p>\n<p>allowsWeakReference/retainWeakReference方法<br>当allowsWeakReference/retainWeakReference实例方法返回NO时，同样不能使用<code>__weak</code>修饰符</p>\n<p>在赋值给<code>__weak</code>修饰符的变量时，如果赋值对象的allowsWeakReference 方法返回NO,程序将异常终止</p>\n<p>在赋值给<code>__weak</code>修饰符的变量时，如果赋值对象的retainWeakReference 方法返回NO,该变量将使用nil</p>\n<p>eg：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">id __strong obj = [[NSObject alloc] init];</span><br><span class=\"line\">id __weak o = obj;</span><br><span class=\"line\">NSLog(@&quot;1 %@&quot;,o);</span><br><span class=\"line\">NSLog(@&quot;2 %@&quot;,o);</span><br><span class=\"line\">NSLog(@&quot;3 %@&quot;,o);</span><br><span class=\"line\">NSLog(@&quot;4 %@&quot;,o);</span><br><span class=\"line\">NSLog(@&quot;5 %@&quot;,o);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果所有的NSLog都可以打印出地址</p>\n<p>如果自定义一个MyObject继承自NSObject的类，并实现retainWeakReference方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (BOOL)retainWeakReference &#123;</span><br><span class=\"line\">  if (++count &gt; 3)</span><br><span class=\"line\">    return NO;</span><br><span class=\"line\">  return [super retainWeakReference];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用MyObject类生成并持有对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">id __strong obj = [[MyObject alloc] init];</span><br><span class=\"line\">id __weak o = obj;</span><br><span class=\"line\">NSLog(@&quot;1 %@&quot;,o);</span><br><span class=\"line\">NSLog(@&quot;2 %@&quot;,o);</span><br><span class=\"line\">NSLog(@&quot;3 %@&quot;,o);</span><br><span class=\"line\">NSLog(@&quot;4 %@&quot;,o);</span><br><span class=\"line\">NSLog(@&quot;5 %@&quot;,o);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果4和5的NSLog打印的为nil</p>\n<h3 id=\"autoreleasing-实现\"><a href=\"#autoreleasing-实现\" class=\"headerlink\" title=\"__autoreleasing 实现\"></a>__autoreleasing 实现</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@autoreleasepool &#123;</span><br><span class=\"line\">    id __autoreleaseing obj = [[NSObject alloc] init];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在编译的时候转换为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id pool = objc_autoreleasePoolPush();</span><br><span class=\"line\">id obj = objc_msgSend(NSObject, @selector(alloc));</span><br><span class=\"line\">objc_msgSend(obj, @selector(init));</span><br><span class=\"line\">objc_autorelease(obj);</span><br><span class=\"line\">objc_autoreleasePoolPop(pool);</span><br></pre></td></tr></table></figure>\n<p>在alloc/new/copy/mutableCopy方法群之外的方法使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@autoreleasepool &#123;</span><br><span class=\"line\">  id __autoreleasing obj = [NSMutableArray array];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在编译时转换为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id pool = objc_autoreleasePoolPush();</span><br><span class=\"line\">id obj = objc_msgSend(NSMutableArray, @selector(array));</span><br><span class=\"line\">objc_retainAutoreleasedReturnValue(obj);</span><br><span class=\"line\">objc_autorelease(obj);</span><br><span class=\"line\">objc_autoreleasePoolPop(pool);</span><br></pre></td></tr></table></figure>"},{"title":"读《iOS与OS X多线程和内存管理》——引用计数(总结)","date":"2017-04-22T14:05:43.000Z","_content":"\n## 前言 ##\n\n上一篇文章介绍了引用计数，用`GNUstep`的实现，推测了`cocoa`框架的实现，现在总结一下个人觉得重要的地方，和上一篇没说的地方\n\n\n<!-- more -->\n\n### 非自己生成的对象，自己也能持有 ###\n\n这一条内存管理举的例子是\n\n```\nid obj = [NSArray array];\n[obj retain];\n```\n\n开始不是很明白，这里的工厂方法，和普通的初始化有什么区别，个人当时认为的是这也应该算做是`自己生成的对象，自己所持有`\n\n但是后面说了，`[NSArray array]`的时候，其实他面会把生成的临时对象`[tempObj autorelease]`,那么反回的时候，就需要`[obj retain]`,因为之前说了，这个地方的内容还没涉及到`ARC`，所以需要`retain`一下\n\n\n\n### NSAutoreleasePool ###\n\n这个东西，说的简单点，就是一个块，让在他里面的东西，都保持状态，不释放，但是出了他的作用域，就全部释放一遍\n\n继续用开关灯那个例子的话，`NSAutoreleasePool`就相当于一个屋子里面多了一个管理员，对象在`NSAutoreleasePool`中，就好比管理员在屋子中，所以屋子会一直亮着，而且，管理员肯定是第一个进来，最后一个走，这就保证了，屋子的灯可以由管理员控制，也就是对象的释放时机，是出了`NSAutoreleasePool`的时候\n\n\n在`ARC`中，`NSAutoreleasePool`是不只直接使用的，你可以使用下面这个：\n\n```\n@autoreleasepool{\n\n// Code benefitting from a local autorelease pool.\n\n}\n```\n\n在自动释放池中，一个对象如果被`autorelease`了多次，那么在池子释放的时候，对象会被执行多次`release`\n\n\n在运行时系统中调用方法\n\n```mm\n/* 函数声明 */\nextern void _objc_autoreleasePoolPrint();\n\n/* 调试处调用 */\n_objc_autoreleasePoolPrint();\n```\n\n这个方法在`ARC`中的调试中可以使用，可以打印出，当前缓冲池中的所有对象，还是比较有用的。\n\n\n","source":"_posts/读《iOS与OS X多线程和内存管理》——引用计数(总结).md","raw":"---\ntitle: 读《iOS与OS X多线程和内存管理》——引用计数(总结)\ndate: 2017-04-22 22:05:43\ntags: [iOS]\n---\n\n## 前言 ##\n\n上一篇文章介绍了引用计数，用`GNUstep`的实现，推测了`cocoa`框架的实现，现在总结一下个人觉得重要的地方，和上一篇没说的地方\n\n\n<!-- more -->\n\n### 非自己生成的对象，自己也能持有 ###\n\n这一条内存管理举的例子是\n\n```\nid obj = [NSArray array];\n[obj retain];\n```\n\n开始不是很明白，这里的工厂方法，和普通的初始化有什么区别，个人当时认为的是这也应该算做是`自己生成的对象，自己所持有`\n\n但是后面说了，`[NSArray array]`的时候，其实他面会把生成的临时对象`[tempObj autorelease]`,那么反回的时候，就需要`[obj retain]`,因为之前说了，这个地方的内容还没涉及到`ARC`，所以需要`retain`一下\n\n\n\n### NSAutoreleasePool ###\n\n这个东西，说的简单点，就是一个块，让在他里面的东西，都保持状态，不释放，但是出了他的作用域，就全部释放一遍\n\n继续用开关灯那个例子的话，`NSAutoreleasePool`就相当于一个屋子里面多了一个管理员，对象在`NSAutoreleasePool`中，就好比管理员在屋子中，所以屋子会一直亮着，而且，管理员肯定是第一个进来，最后一个走，这就保证了，屋子的灯可以由管理员控制，也就是对象的释放时机，是出了`NSAutoreleasePool`的时候\n\n\n在`ARC`中，`NSAutoreleasePool`是不只直接使用的，你可以使用下面这个：\n\n```\n@autoreleasepool{\n\n// Code benefitting from a local autorelease pool.\n\n}\n```\n\n在自动释放池中，一个对象如果被`autorelease`了多次，那么在池子释放的时候，对象会被执行多次`release`\n\n\n在运行时系统中调用方法\n\n```mm\n/* 函数声明 */\nextern void _objc_autoreleasePoolPrint();\n\n/* 调试处调用 */\n_objc_autoreleasePoolPrint();\n```\n\n这个方法在`ARC`中的调试中可以使用，可以打印出，当前缓冲池中的所有对象，还是比较有用的。\n\n\n","slug":"读《iOS与OS X多线程和内存管理》——引用计数(总结)","published":1,"updated":"2021-04-12T09:17:38.423Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqjdx1ob002b5emuw1mzpshp","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>上一篇文章介绍了引用计数，用<code>GNUstep</code>的实现，推测了<code>cocoa</code>框架的实现，现在总结一下个人觉得重要的地方，和上一篇没说的地方</p>\n<a id=\"more\"></a>\n<h3 id=\"非自己生成的对象，自己也能持有\"><a href=\"#非自己生成的对象，自己也能持有\" class=\"headerlink\" title=\"非自己生成的对象，自己也能持有\"></a>非自己生成的对象，自己也能持有</h3><p>这一条内存管理举的例子是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id obj = [NSArray array];</span><br><span class=\"line\">[obj retain];</span><br></pre></td></tr></table></figure>\n<p>开始不是很明白，这里的工厂方法，和普通的初始化有什么区别，个人当时认为的是这也应该算做是<code>自己生成的对象，自己所持有</code></p>\n<p>但是后面说了，<code>[NSArray array]</code>的时候，其实他面会把生成的临时对象<code>[tempObj autorelease]</code>,那么反回的时候，就需要<code>[obj retain]</code>,因为之前说了，这个地方的内容还没涉及到<code>ARC</code>，所以需要<code>retain</code>一下</p>\n<h3 id=\"NSAutoreleasePool\"><a href=\"#NSAutoreleasePool\" class=\"headerlink\" title=\"NSAutoreleasePool\"></a>NSAutoreleasePool</h3><p>这个东西，说的简单点，就是一个块，让在他里面的东西，都保持状态，不释放，但是出了他的作用域，就全部释放一遍</p>\n<p>继续用开关灯那个例子的话，<code>NSAutoreleasePool</code>就相当于一个屋子里面多了一个管理员，对象在<code>NSAutoreleasePool</code>中，就好比管理员在屋子中，所以屋子会一直亮着，而且，管理员肯定是第一个进来，最后一个走，这就保证了，屋子的灯可以由管理员控制，也就是对象的释放时机，是出了<code>NSAutoreleasePool</code>的时候</p>\n<p>在<code>ARC</code>中，<code>NSAutoreleasePool</code>是不只直接使用的，你可以使用下面这个：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@autoreleasepool&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">// Code benefitting from a local autorelease pool.</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在自动释放池中，一个对象如果被<code>autorelease</code>了多次，那么在池子释放的时候，对象会被执行多次<code>release</code></p>\n<p>在运行时系统中调用方法</p>\n<figure class=\"highlight mm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 函数声明 */</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">void</span> _objc_autoreleasePoolPrint();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 调试处调用 */</span></span><br><span class=\"line\">_objc_autoreleasePoolPrint();</span><br></pre></td></tr></table></figure>\n<p>这个方法在<code>ARC</code>中的调试中可以使用，可以打印出，当前缓冲池中的所有对象，还是比较有用的。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>上一篇文章介绍了引用计数，用<code>GNUstep</code>的实现，推测了<code>cocoa</code>框架的实现，现在总结一下个人觉得重要的地方，和上一篇没说的地方</p>","more":"<h3 id=\"非自己生成的对象，自己也能持有\"><a href=\"#非自己生成的对象，自己也能持有\" class=\"headerlink\" title=\"非自己生成的对象，自己也能持有\"></a>非自己生成的对象，自己也能持有</h3><p>这一条内存管理举的例子是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id obj = [NSArray array];</span><br><span class=\"line\">[obj retain];</span><br></pre></td></tr></table></figure>\n<p>开始不是很明白，这里的工厂方法，和普通的初始化有什么区别，个人当时认为的是这也应该算做是<code>自己生成的对象，自己所持有</code></p>\n<p>但是后面说了，<code>[NSArray array]</code>的时候，其实他面会把生成的临时对象<code>[tempObj autorelease]</code>,那么反回的时候，就需要<code>[obj retain]</code>,因为之前说了，这个地方的内容还没涉及到<code>ARC</code>，所以需要<code>retain</code>一下</p>\n<h3 id=\"NSAutoreleasePool\"><a href=\"#NSAutoreleasePool\" class=\"headerlink\" title=\"NSAutoreleasePool\"></a>NSAutoreleasePool</h3><p>这个东西，说的简单点，就是一个块，让在他里面的东西，都保持状态，不释放，但是出了他的作用域，就全部释放一遍</p>\n<p>继续用开关灯那个例子的话，<code>NSAutoreleasePool</code>就相当于一个屋子里面多了一个管理员，对象在<code>NSAutoreleasePool</code>中，就好比管理员在屋子中，所以屋子会一直亮着，而且，管理员肯定是第一个进来，最后一个走，这就保证了，屋子的灯可以由管理员控制，也就是对象的释放时机，是出了<code>NSAutoreleasePool</code>的时候</p>\n<p>在<code>ARC</code>中，<code>NSAutoreleasePool</code>是不只直接使用的，你可以使用下面这个：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@autoreleasepool&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">// Code benefitting from a local autorelease pool.</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在自动释放池中，一个对象如果被<code>autorelease</code>了多次，那么在池子释放的时候，对象会被执行多次<code>release</code></p>\n<p>在运行时系统中调用方法</p>\n<figure class=\"highlight mm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 函数声明 */</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">void</span> _objc_autoreleasePoolPrint();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 调试处调用 */</span></span><br><span class=\"line\">_objc_autoreleasePoolPrint();</span><br></pre></td></tr></table></figure>\n<p>这个方法在<code>ARC</code>中的调试中可以使用，可以打印出，当前缓冲池中的所有对象，还是比较有用的。</p>"},{"title":"读《iOS与OS X多线程和内存管理》—— 自动引用计数","date":"2017-04-26T15:32:33.000Z","_content":"\n## 前言 ##\n\n下面是自动引用计数部分书中内容的笔记\n\n\n<!-- more -->\n\n\n### 自动引用计数设置 ###\n\n前面说到过，自动引用计数（Automatic Reference Counting）简称就是我们现在使用的`ARC`了，顾名思义自动引用计数就是编译器自动帮我们处理引用计数\n\n在编译的时候，我们可以指定每个文件是否使用`ARC`，Xcode4.2以后编译器默认为`ARC`有效。\n\n在创建完工程的时候，我们可以在工程的配置文件中设置工程模式是`MRC`还是`ARC`，设置的方法是：\n\n在工程配置文件的，`Build Settings`中，找到`Objective-C Automatic Reference Counting` 选项，设置为`YES`,就是`ARC`工程模式，设置为`NO`就是`MRC`工程模式。\n\n在`ARC`工程模式或`MRC`工程模式也可以设置部分文件编译模式与之相反，设置方法：\n\n在`Build pyases`中的`compile source`找到对应的文件设置参数`-fno-objc-arc`为`MRC`模式，反之`-fobjc-arc`为`ARC`模式。\n\n\n### 所有权修饰符 ###\n\n在引用计数中，我们知道，对象的销毁，是通过引用计数的值来判断的，但是引用计数的值是需要我们手动去维护的，那么要想让编译器去维护引用计数，我们就要通过一些修饰符，去告诉编译器，变量什么时候需要引用计数加一，什么时候引用计数需要减一，那么这个修饰符就是所有权修饰符\n\n\n在`ARC`模式下，所有权修饰符有四种：\n\n- __strong\n- __weak\n- __unsafe_unretained\n- __autoreleasing\n\n\n#### __strong ####\n\n`__strong`修饰符是id类型和对象类型的默认所有权修饰符\n\n```\nid obj = [[NSObject alloc] init];\n```\n\n```\nid __strong obj = [[NSObject alloc] init];\n```\n\n这两种表示方法的结果是一样的\n\n在`ARC`中，被`__strong`修饰符修饰的变量，表示对对象的强引用，持有强引用的变量在超出其作用域时被废弃，随着强引用的失效，引用的对象会随之释放\n\n在变量赋值的时候，也会对对象强引用，如果赋值为`nil`,则强引用失效\n\n`__strong`也可以修饰在方法参数上，虽然平常我们写的方法上都没有，那是因为默认是不用写的\n\n\n#### __weak ####\n\n`__weak`修饰符，提供弱引用，弱引用不能持有对象实例。`__weak`修饰符是为了解决`__strong`修饰符会产生循环引用出现的。 所谓循环引用，就是自己引用自己，或者多个对象相互引用，导致谁都无法释放的问题\n\n`__weak`修饰符，的另一个作用是，在持有某对象的弱引用时，若该对象被废弃，则此弱引用将自动失效且处于`nil`被赋值的状态（空弱引用）。\n\n所以，检查`__weak`修饰符的变量是否为空，可以判断被赋值的对象是否已废弃\n\n\n#### __unsafe_unretained ####\n\n`__unsafe_unretained`修饰符，是不安全的所有权修饰符，被他修饰的变量，是不属于编译器的内存管理对象。\n\n\n`__unsafe_unretained`修饰符，和`__weak`修饰符的作用相似，他也无法持有对象实例，但是他在对象已经释放的时候，仍然指向对象，形成垂悬指针。\n\n所以，在使用`__unsafe_unretained`修饰符的变量的时候，必须确保被赋值的对象确实存在，不然会导致程序崩溃\n\n\n#### __autoreleasing ####\n\n在`MRC`的时候，`NSAutoreleasePool`类中的要想让对象自动释放，有个`autorelease`方法，但是在`ARC`中，`NSAutoreleasePool`已经改用`@autoreleasepool`了，所以，需要`__autoreleasing`修饰符，来表示对象自动释放。\n\n\n`__autoreleasing`和`__strong`修饰符都不需要显示的添加，因为在使用`alloc/new/copy/mutableCopy`以外的方法取来的对象，已经被注册到`autoreleasepool`中了。\n\n在`__weak`修饰符修饰的变量在访问对象的时候，也会把对象注册到`autoreleasepool`中\n\nid的指针或者对象的指针在没有显式指定是，也会被加上`__autoreleasing`修饰符\n","source":"_posts/读《iOS与OS X多线程和内存管理》—— 自动引用计数.md","raw":"---\ntitle: 读《iOS与OS X多线程和内存管理》—— 自动引用计数\ndate: 2017-04-26 23:32:33\ntags: [iOS]\n---\n\n## 前言 ##\n\n下面是自动引用计数部分书中内容的笔记\n\n\n<!-- more -->\n\n\n### 自动引用计数设置 ###\n\n前面说到过，自动引用计数（Automatic Reference Counting）简称就是我们现在使用的`ARC`了，顾名思义自动引用计数就是编译器自动帮我们处理引用计数\n\n在编译的时候，我们可以指定每个文件是否使用`ARC`，Xcode4.2以后编译器默认为`ARC`有效。\n\n在创建完工程的时候，我们可以在工程的配置文件中设置工程模式是`MRC`还是`ARC`，设置的方法是：\n\n在工程配置文件的，`Build Settings`中，找到`Objective-C Automatic Reference Counting` 选项，设置为`YES`,就是`ARC`工程模式，设置为`NO`就是`MRC`工程模式。\n\n在`ARC`工程模式或`MRC`工程模式也可以设置部分文件编译模式与之相反，设置方法：\n\n在`Build pyases`中的`compile source`找到对应的文件设置参数`-fno-objc-arc`为`MRC`模式，反之`-fobjc-arc`为`ARC`模式。\n\n\n### 所有权修饰符 ###\n\n在引用计数中，我们知道，对象的销毁，是通过引用计数的值来判断的，但是引用计数的值是需要我们手动去维护的，那么要想让编译器去维护引用计数，我们就要通过一些修饰符，去告诉编译器，变量什么时候需要引用计数加一，什么时候引用计数需要减一，那么这个修饰符就是所有权修饰符\n\n\n在`ARC`模式下，所有权修饰符有四种：\n\n- __strong\n- __weak\n- __unsafe_unretained\n- __autoreleasing\n\n\n#### __strong ####\n\n`__strong`修饰符是id类型和对象类型的默认所有权修饰符\n\n```\nid obj = [[NSObject alloc] init];\n```\n\n```\nid __strong obj = [[NSObject alloc] init];\n```\n\n这两种表示方法的结果是一样的\n\n在`ARC`中，被`__strong`修饰符修饰的变量，表示对对象的强引用，持有强引用的变量在超出其作用域时被废弃，随着强引用的失效，引用的对象会随之释放\n\n在变量赋值的时候，也会对对象强引用，如果赋值为`nil`,则强引用失效\n\n`__strong`也可以修饰在方法参数上，虽然平常我们写的方法上都没有，那是因为默认是不用写的\n\n\n#### __weak ####\n\n`__weak`修饰符，提供弱引用，弱引用不能持有对象实例。`__weak`修饰符是为了解决`__strong`修饰符会产生循环引用出现的。 所谓循环引用，就是自己引用自己，或者多个对象相互引用，导致谁都无法释放的问题\n\n`__weak`修饰符，的另一个作用是，在持有某对象的弱引用时，若该对象被废弃，则此弱引用将自动失效且处于`nil`被赋值的状态（空弱引用）。\n\n所以，检查`__weak`修饰符的变量是否为空，可以判断被赋值的对象是否已废弃\n\n\n#### __unsafe_unretained ####\n\n`__unsafe_unretained`修饰符，是不安全的所有权修饰符，被他修饰的变量，是不属于编译器的内存管理对象。\n\n\n`__unsafe_unretained`修饰符，和`__weak`修饰符的作用相似，他也无法持有对象实例，但是他在对象已经释放的时候，仍然指向对象，形成垂悬指针。\n\n所以，在使用`__unsafe_unretained`修饰符的变量的时候，必须确保被赋值的对象确实存在，不然会导致程序崩溃\n\n\n#### __autoreleasing ####\n\n在`MRC`的时候，`NSAutoreleasePool`类中的要想让对象自动释放，有个`autorelease`方法，但是在`ARC`中，`NSAutoreleasePool`已经改用`@autoreleasepool`了，所以，需要`__autoreleasing`修饰符，来表示对象自动释放。\n\n\n`__autoreleasing`和`__strong`修饰符都不需要显示的添加，因为在使用`alloc/new/copy/mutableCopy`以外的方法取来的对象，已经被注册到`autoreleasepool`中了。\n\n在`__weak`修饰符修饰的变量在访问对象的时候，也会把对象注册到`autoreleasepool`中\n\nid的指针或者对象的指针在没有显式指定是，也会被加上`__autoreleasing`修饰符\n","slug":"读《iOS与OS X多线程和内存管理》—— 自动引用计数","published":1,"updated":"2021-04-12T09:17:38.422Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqjdx1oc002e5emui8jqz1b5","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>下面是自动引用计数部分书中内容的笔记</p>\n<a id=\"more\"></a>\n<h3 id=\"自动引用计数设置\"><a href=\"#自动引用计数设置\" class=\"headerlink\" title=\"自动引用计数设置\"></a>自动引用计数设置</h3><p>前面说到过，自动引用计数（Automatic Reference Counting）简称就是我们现在使用的<code>ARC</code>了，顾名思义自动引用计数就是编译器自动帮我们处理引用计数</p>\n<p>在编译的时候，我们可以指定每个文件是否使用<code>ARC</code>，Xcode4.2以后编译器默认为<code>ARC</code>有效。</p>\n<p>在创建完工程的时候，我们可以在工程的配置文件中设置工程模式是<code>MRC</code>还是<code>ARC</code>，设置的方法是：</p>\n<p>在工程配置文件的，<code>Build Settings</code>中，找到<code>Objective-C Automatic Reference Counting</code> 选项，设置为<code>YES</code>,就是<code>ARC</code>工程模式，设置为<code>NO</code>就是<code>MRC</code>工程模式。</p>\n<p>在<code>ARC</code>工程模式或<code>MRC</code>工程模式也可以设置部分文件编译模式与之相反，设置方法：</p>\n<p>在<code>Build pyases</code>中的<code>compile source</code>找到对应的文件设置参数<code>-fno-objc-arc</code>为<code>MRC</code>模式，反之<code>-fobjc-arc</code>为<code>ARC</code>模式。</p>\n<h3 id=\"所有权修饰符\"><a href=\"#所有权修饰符\" class=\"headerlink\" title=\"所有权修饰符\"></a>所有权修饰符</h3><p>在引用计数中，我们知道，对象的销毁，是通过引用计数的值来判断的，但是引用计数的值是需要我们手动去维护的，那么要想让编译器去维护引用计数，我们就要通过一些修饰符，去告诉编译器，变量什么时候需要引用计数加一，什么时候引用计数需要减一，那么这个修饰符就是所有权修饰符</p>\n<p>在<code>ARC</code>模式下，所有权修饰符有四种：</p>\n<ul>\n<li>__strong</li>\n<li>__weak</li>\n<li>__unsafe_unretained</li>\n<li>__autoreleasing</li>\n</ul>\n<h4 id=\"strong\"><a href=\"#strong\" class=\"headerlink\" title=\"__strong\"></a>__strong</h4><p><code>__strong</code>修饰符是id类型和对象类型的默认所有权修饰符</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id obj = [[NSObject alloc] init];</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id __strong obj = [[NSObject alloc] init];</span><br></pre></td></tr></table></figure>\n<p>这两种表示方法的结果是一样的</p>\n<p>在<code>ARC</code>中，被<code>__strong</code>修饰符修饰的变量，表示对对象的强引用，持有强引用的变量在超出其作用域时被废弃，随着强引用的失效，引用的对象会随之释放</p>\n<p>在变量赋值的时候，也会对对象强引用，如果赋值为<code>nil</code>,则强引用失效</p>\n<p><code>__strong</code>也可以修饰在方法参数上，虽然平常我们写的方法上都没有，那是因为默认是不用写的</p>\n<h4 id=\"weak\"><a href=\"#weak\" class=\"headerlink\" title=\"__weak\"></a>__weak</h4><p><code>__weak</code>修饰符，提供弱引用，弱引用不能持有对象实例。<code>__weak</code>修饰符是为了解决<code>__strong</code>修饰符会产生循环引用出现的。 所谓循环引用，就是自己引用自己，或者多个对象相互引用，导致谁都无法释放的问题</p>\n<p><code>__weak</code>修饰符，的另一个作用是，在持有某对象的弱引用时，若该对象被废弃，则此弱引用将自动失效且处于<code>nil</code>被赋值的状态（空弱引用）。</p>\n<p>所以，检查<code>__weak</code>修饰符的变量是否为空，可以判断被赋值的对象是否已废弃</p>\n<h4 id=\"unsafe-unretained\"><a href=\"#unsafe-unretained\" class=\"headerlink\" title=\"__unsafe_unretained\"></a>__unsafe_unretained</h4><p><code>__unsafe_unretained</code>修饰符，是不安全的所有权修饰符，被他修饰的变量，是不属于编译器的内存管理对象。</p>\n<p><code>__unsafe_unretained</code>修饰符，和<code>__weak</code>修饰符的作用相似，他也无法持有对象实例，但是他在对象已经释放的时候，仍然指向对象，形成垂悬指针。</p>\n<p>所以，在使用<code>__unsafe_unretained</code>修饰符的变量的时候，必须确保被赋值的对象确实存在，不然会导致程序崩溃</p>\n<h4 id=\"autoreleasing\"><a href=\"#autoreleasing\" class=\"headerlink\" title=\"__autoreleasing\"></a>__autoreleasing</h4><p>在<code>MRC</code>的时候，<code>NSAutoreleasePool</code>类中的要想让对象自动释放，有个<code>autorelease</code>方法，但是在<code>ARC</code>中，<code>NSAutoreleasePool</code>已经改用<code>@autoreleasepool</code>了，所以，需要<code>__autoreleasing</code>修饰符，来表示对象自动释放。</p>\n<p><code>__autoreleasing</code>和<code>__strong</code>修饰符都不需要显示的添加，因为在使用<code>alloc/new/copy/mutableCopy</code>以外的方法取来的对象，已经被注册到<code>autoreleasepool</code>中了。</p>\n<p>在<code>__weak</code>修饰符修饰的变量在访问对象的时候，也会把对象注册到<code>autoreleasepool</code>中</p>\n<p>id的指针或者对象的指针在没有显式指定是，也会被加上<code>__autoreleasing</code>修饰符</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>下面是自动引用计数部分书中内容的笔记</p>","more":"<h3 id=\"自动引用计数设置\"><a href=\"#自动引用计数设置\" class=\"headerlink\" title=\"自动引用计数设置\"></a>自动引用计数设置</h3><p>前面说到过，自动引用计数（Automatic Reference Counting）简称就是我们现在使用的<code>ARC</code>了，顾名思义自动引用计数就是编译器自动帮我们处理引用计数</p>\n<p>在编译的时候，我们可以指定每个文件是否使用<code>ARC</code>，Xcode4.2以后编译器默认为<code>ARC</code>有效。</p>\n<p>在创建完工程的时候，我们可以在工程的配置文件中设置工程模式是<code>MRC</code>还是<code>ARC</code>，设置的方法是：</p>\n<p>在工程配置文件的，<code>Build Settings</code>中，找到<code>Objective-C Automatic Reference Counting</code> 选项，设置为<code>YES</code>,就是<code>ARC</code>工程模式，设置为<code>NO</code>就是<code>MRC</code>工程模式。</p>\n<p>在<code>ARC</code>工程模式或<code>MRC</code>工程模式也可以设置部分文件编译模式与之相反，设置方法：</p>\n<p>在<code>Build pyases</code>中的<code>compile source</code>找到对应的文件设置参数<code>-fno-objc-arc</code>为<code>MRC</code>模式，反之<code>-fobjc-arc</code>为<code>ARC</code>模式。</p>\n<h3 id=\"所有权修饰符\"><a href=\"#所有权修饰符\" class=\"headerlink\" title=\"所有权修饰符\"></a>所有权修饰符</h3><p>在引用计数中，我们知道，对象的销毁，是通过引用计数的值来判断的，但是引用计数的值是需要我们手动去维护的，那么要想让编译器去维护引用计数，我们就要通过一些修饰符，去告诉编译器，变量什么时候需要引用计数加一，什么时候引用计数需要减一，那么这个修饰符就是所有权修饰符</p>\n<p>在<code>ARC</code>模式下，所有权修饰符有四种：</p>\n<ul>\n<li>__strong</li>\n<li>__weak</li>\n<li>__unsafe_unretained</li>\n<li>__autoreleasing</li>\n</ul>\n<h4 id=\"strong\"><a href=\"#strong\" class=\"headerlink\" title=\"__strong\"></a>__strong</h4><p><code>__strong</code>修饰符是id类型和对象类型的默认所有权修饰符</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id obj = [[NSObject alloc] init];</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id __strong obj = [[NSObject alloc] init];</span><br></pre></td></tr></table></figure>\n<p>这两种表示方法的结果是一样的</p>\n<p>在<code>ARC</code>中，被<code>__strong</code>修饰符修饰的变量，表示对对象的强引用，持有强引用的变量在超出其作用域时被废弃，随着强引用的失效，引用的对象会随之释放</p>\n<p>在变量赋值的时候，也会对对象强引用，如果赋值为<code>nil</code>,则强引用失效</p>\n<p><code>__strong</code>也可以修饰在方法参数上，虽然平常我们写的方法上都没有，那是因为默认是不用写的</p>\n<h4 id=\"weak\"><a href=\"#weak\" class=\"headerlink\" title=\"__weak\"></a>__weak</h4><p><code>__weak</code>修饰符，提供弱引用，弱引用不能持有对象实例。<code>__weak</code>修饰符是为了解决<code>__strong</code>修饰符会产生循环引用出现的。 所谓循环引用，就是自己引用自己，或者多个对象相互引用，导致谁都无法释放的问题</p>\n<p><code>__weak</code>修饰符，的另一个作用是，在持有某对象的弱引用时，若该对象被废弃，则此弱引用将自动失效且处于<code>nil</code>被赋值的状态（空弱引用）。</p>\n<p>所以，检查<code>__weak</code>修饰符的变量是否为空，可以判断被赋值的对象是否已废弃</p>\n<h4 id=\"unsafe-unretained\"><a href=\"#unsafe-unretained\" class=\"headerlink\" title=\"__unsafe_unretained\"></a>__unsafe_unretained</h4><p><code>__unsafe_unretained</code>修饰符，是不安全的所有权修饰符，被他修饰的变量，是不属于编译器的内存管理对象。</p>\n<p><code>__unsafe_unretained</code>修饰符，和<code>__weak</code>修饰符的作用相似，他也无法持有对象实例，但是他在对象已经释放的时候，仍然指向对象，形成垂悬指针。</p>\n<p>所以，在使用<code>__unsafe_unretained</code>修饰符的变量的时候，必须确保被赋值的对象确实存在，不然会导致程序崩溃</p>\n<h4 id=\"autoreleasing\"><a href=\"#autoreleasing\" class=\"headerlink\" title=\"__autoreleasing\"></a>__autoreleasing</h4><p>在<code>MRC</code>的时候，<code>NSAutoreleasePool</code>类中的要想让对象自动释放，有个<code>autorelease</code>方法，但是在<code>ARC</code>中，<code>NSAutoreleasePool</code>已经改用<code>@autoreleasepool</code>了，所以，需要<code>__autoreleasing</code>修饰符，来表示对象自动释放。</p>\n<p><code>__autoreleasing</code>和<code>__strong</code>修饰符都不需要显示的添加，因为在使用<code>alloc/new/copy/mutableCopy</code>以外的方法取来的对象，已经被注册到<code>autoreleasepool</code>中了。</p>\n<p>在<code>__weak</code>修饰符修饰的变量在访问对象的时候，也会把对象注册到<code>autoreleasepool</code>中</p>\n<p>id的指针或者对象的指针在没有显式指定是，也会被加上<code>__autoreleasing</code>修饰符</p>"},{"title":"读《iOS与OS X多线程和内存管理》——前言","date":"2017-04-13T03:10:12.000Z","_content":"\n# 前言 #\n\n  都说不会写部落格的程序猿不是好作家，本作家本来想着当一个小小的初级工程师，每天码码界面，终其一生就算了。\n谁知天有不测风云，人有祸福旦夕，那天在工程中多看了一眼别人的代码，顿时觉得自己的知识储备实在是太匮乏了。\n\n那么究竟是什么样的代码，居然有如此神奇的功效，闲话少叙，上代码：\n\n<!-- more -->\n\n代码一：\n\n```mm\n@interface MyView ()\n\n@property (nonatomic, weak) UILabel *label;\n\n@end\n\n@implementation MyView\n- (void)setupSubview {\n\tUILabel *label = [[UILabel alloc] init];\n\tlabel.font = [UIFont systemFontOfSize:14];\n\tlabel.textColor = [UIColor whiteColor];\n\tlabel.textAlignment = NSTextAlignmentCenter;\n\tlabel.text = @\"你好\";\n\t[self addSubview:label];\n\t_label = label;\n}\n@end\n```\n\n就是这么一段代码，如果要让楼主写 则是下面这样的\n\n代码二：\n\n```objectivec\n@interface MyView ()\n\n@property (nonatomic, strong) UILabel *label;\n\n@end\n\n@implementation MyView\n- (void)setupSubview {\n\tself.label = [[UILabel alloc] init];\n\tself.label.font = [UIFont systemFontOfSize:14];\n\tself.label.textColor = [UIColor whiteColor];\n\tself.label.textAlignment = NSTextAlignmentCenter;\n\tself.label.text = @\"你好\";\n\t[self addSubview:self.label];\n}\n@end\n```\n\n\n当然你也可以直接用`_label`赋值，这里问题的重点不是set方法和成员变量的区别，而是我的属性\n用的是`strong`修饰而他的是使用`weak`修饰。\n\n本着不耻下问，虚心求教的态度我问了一下我同事，得到了这样的解答：\n\n代码一的属性使用的`weak`修饰，因为在`addSubview：`的时候`self`会强引用`label`对象`weak`修饰的成员变量`_label`弱引用着`label`对象\n\n代码二的属性使用`strong`修饰， 在`addSubview：`的时候`self`会强引用`label`对象 ```strong``` 修饰的成员变量`_label`也强引用着`label`对象\n\n第一种代码的好处是在`self`移除`label`的时候`label`对象就释放了。因为`label`只有一个`self`强引用着\n\n第二种代码在`self`移除`label`的时候`label`对象不会释放，因为还有个`_label`的变量强引用这`label`对象，\n只有在`self`释放的时候`label`对象才会释放。\n\n\n本人读书少，仔细一想确实是这么回事，用`weak`修饰，`label`对象只被`self`强引用，从view上移除后就可以释放，\n不用等到`self`释放的时候才释放，创建和释放都很合理(哪里创建哪里释放)。\n\n但是细思极恐，难道我多年来的开发经验是错误的么，用了n年的`strong`原来是个低效的使用方法。这时候我突然想到了一个面试题，\n\n那就是你真的了解属性修饰符的用法么？\n\n好吧我承认！我不了解，这就是我看这本书的原因。\n\n\n注：\n1. 上面的解释不一定是正确的。\n2. 小弟初来乍到要是有啥说的不对的地方希望各位大大不吝赐教。\n3. 要是你们有什么意见和建议，也可以随便吐槽。\n","source":"_posts/读《iOS与OS X多线程和内存管理》——前言.md","raw":"---\ntitle: 读《iOS与OS X多线程和内存管理》——前言\ndate: 2017-04-13 11:10:12\ntags: [iOS]\n---\n\n# 前言 #\n\n  都说不会写部落格的程序猿不是好作家，本作家本来想着当一个小小的初级工程师，每天码码界面，终其一生就算了。\n谁知天有不测风云，人有祸福旦夕，那天在工程中多看了一眼别人的代码，顿时觉得自己的知识储备实在是太匮乏了。\n\n那么究竟是什么样的代码，居然有如此神奇的功效，闲话少叙，上代码：\n\n<!-- more -->\n\n代码一：\n\n```mm\n@interface MyView ()\n\n@property (nonatomic, weak) UILabel *label;\n\n@end\n\n@implementation MyView\n- (void)setupSubview {\n\tUILabel *label = [[UILabel alloc] init];\n\tlabel.font = [UIFont systemFontOfSize:14];\n\tlabel.textColor = [UIColor whiteColor];\n\tlabel.textAlignment = NSTextAlignmentCenter;\n\tlabel.text = @\"你好\";\n\t[self addSubview:label];\n\t_label = label;\n}\n@end\n```\n\n就是这么一段代码，如果要让楼主写 则是下面这样的\n\n代码二：\n\n```objectivec\n@interface MyView ()\n\n@property (nonatomic, strong) UILabel *label;\n\n@end\n\n@implementation MyView\n- (void)setupSubview {\n\tself.label = [[UILabel alloc] init];\n\tself.label.font = [UIFont systemFontOfSize:14];\n\tself.label.textColor = [UIColor whiteColor];\n\tself.label.textAlignment = NSTextAlignmentCenter;\n\tself.label.text = @\"你好\";\n\t[self addSubview:self.label];\n}\n@end\n```\n\n\n当然你也可以直接用`_label`赋值，这里问题的重点不是set方法和成员变量的区别，而是我的属性\n用的是`strong`修饰而他的是使用`weak`修饰。\n\n本着不耻下问，虚心求教的态度我问了一下我同事，得到了这样的解答：\n\n代码一的属性使用的`weak`修饰，因为在`addSubview：`的时候`self`会强引用`label`对象`weak`修饰的成员变量`_label`弱引用着`label`对象\n\n代码二的属性使用`strong`修饰， 在`addSubview：`的时候`self`会强引用`label`对象 ```strong``` 修饰的成员变量`_label`也强引用着`label`对象\n\n第一种代码的好处是在`self`移除`label`的时候`label`对象就释放了。因为`label`只有一个`self`强引用着\n\n第二种代码在`self`移除`label`的时候`label`对象不会释放，因为还有个`_label`的变量强引用这`label`对象，\n只有在`self`释放的时候`label`对象才会释放。\n\n\n本人读书少，仔细一想确实是这么回事，用`weak`修饰，`label`对象只被`self`强引用，从view上移除后就可以释放，\n不用等到`self`释放的时候才释放，创建和释放都很合理(哪里创建哪里释放)。\n\n但是细思极恐，难道我多年来的开发经验是错误的么，用了n年的`strong`原来是个低效的使用方法。这时候我突然想到了一个面试题，\n\n那就是你真的了解属性修饰符的用法么？\n\n好吧我承认！我不了解，这就是我看这本书的原因。\n\n\n注：\n1. 上面的解释不一定是正确的。\n2. 小弟初来乍到要是有啥说的不对的地方希望各位大大不吝赐教。\n3. 要是你们有什么意见和建议，也可以随便吐槽。\n","slug":"读《iOS与OS X多线程和内存管理》——前言","published":1,"updated":"2021-04-12T09:17:38.422Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqjdx1od002g5emuf42xaq1d","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>  都说不会写部落格的程序猿不是好作家，本作家本来想着当一个小小的初级工程师，每天码码界面，终其一生就算了。<br>谁知天有不测风云，人有祸福旦夕，那天在工程中多看了一眼别人的代码，顿时觉得自己的知识储备实在是太匮乏了。</p>\n<p>那么究竟是什么样的代码，居然有如此神奇的功效，闲话少叙，上代码：</p>\n<a id=\"more\"></a>\n<p>代码一：</p>\n<figure class=\"highlight mm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MyView</span> ()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">weak</span>) <span class=\"built_in\">UILabel</span> *label;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">MyView</span></span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setupSubview &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">UILabel</span> *label = [[<span class=\"built_in\">UILabel</span> alloc] init];</span><br><span class=\"line\">\tlabel.font = [<span class=\"built_in\">UIFont</span> systemFontOfSize:<span class=\"number\">14</span>];</span><br><span class=\"line\">\tlabel.textColor = [<span class=\"built_in\">UIColor</span> whiteColor];</span><br><span class=\"line\">\tlabel.textAlignment = <span class=\"built_in\">NSTextAlignmentCenter</span>;</span><br><span class=\"line\">\tlabel.text = <span class=\"string\">@\"你好\"</span>;</span><br><span class=\"line\">\t[<span class=\"keyword\">self</span> addSubview:label];</span><br><span class=\"line\">\t_label = label;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>就是这么一段代码，如果要让楼主写 则是下面这样的</p>\n<p>代码二：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MyView</span> ()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">UILabel</span> *label;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">MyView</span></span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setupSubview &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">self</span>.label = [[<span class=\"built_in\">UILabel</span> alloc] init];</span><br><span class=\"line\">\t<span class=\"keyword\">self</span>.label.font = [<span class=\"built_in\">UIFont</span> systemFontOfSize:<span class=\"number\">14</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">self</span>.label.textColor = [<span class=\"built_in\">UIColor</span> whiteColor];</span><br><span class=\"line\">\t<span class=\"keyword\">self</span>.label.textAlignment = <span class=\"built_in\">NSTextAlignmentCenter</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">self</span>.label.text = <span class=\"string\">@\"你好\"</span>;</span><br><span class=\"line\">\t[<span class=\"keyword\">self</span> addSubview:<span class=\"keyword\">self</span>.label];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>当然你也可以直接用<code>_label</code>赋值，这里问题的重点不是set方法和成员变量的区别，而是我的属性<br>用的是<code>strong</code>修饰而他的是使用<code>weak</code>修饰。</p>\n<p>本着不耻下问，虚心求教的态度我问了一下我同事，得到了这样的解答：</p>\n<p>代码一的属性使用的<code>weak</code>修饰，因为在<code>addSubview：</code>的时候<code>self</code>会强引用<code>label</code>对象<code>weak</code>修饰的成员变量<code>_label</code>弱引用着<code>label</code>对象</p>\n<p>代码二的属性使用<code>strong</code>修饰， 在<code>addSubview：</code>的时候<code>self</code>会强引用<code>label</code>对象 <code>strong</code> 修饰的成员变量<code>_label</code>也强引用着<code>label</code>对象</p>\n<p>第一种代码的好处是在<code>self</code>移除<code>label</code>的时候<code>label</code>对象就释放了。因为<code>label</code>只有一个<code>self</code>强引用着</p>\n<p>第二种代码在<code>self</code>移除<code>label</code>的时候<code>label</code>对象不会释放，因为还有个<code>_label</code>的变量强引用这<code>label</code>对象，<br>只有在<code>self</code>释放的时候<code>label</code>对象才会释放。</p>\n<p>本人读书少，仔细一想确实是这么回事，用<code>weak</code>修饰，<code>label</code>对象只被<code>self</code>强引用，从view上移除后就可以释放，<br>不用等到<code>self</code>释放的时候才释放，创建和释放都很合理(哪里创建哪里释放)。</p>\n<p>但是细思极恐，难道我多年来的开发经验是错误的么，用了n年的<code>strong</code>原来是个低效的使用方法。这时候我突然想到了一个面试题，</p>\n<p>那就是你真的了解属性修饰符的用法么？</p>\n<p>好吧我承认！我不了解，这就是我看这本书的原因。</p>\n<p>注：</p>\n<ol>\n<li>上面的解释不一定是正确的。</li>\n<li>小弟初来乍到要是有啥说的不对的地方希望各位大大不吝赐教。</li>\n<li>要是你们有什么意见和建议，也可以随便吐槽。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>  都说不会写部落格的程序猿不是好作家，本作家本来想着当一个小小的初级工程师，每天码码界面，终其一生就算了。<br>谁知天有不测风云，人有祸福旦夕，那天在工程中多看了一眼别人的代码，顿时觉得自己的知识储备实在是太匮乏了。</p>\n<p>那么究竟是什么样的代码，居然有如此神奇的功效，闲话少叙，上代码：</p>","more":"<p>代码一：</p>\n<figure class=\"highlight mm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MyView</span> ()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">weak</span>) <span class=\"built_in\">UILabel</span> *label;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">MyView</span></span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setupSubview &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">UILabel</span> *label = [[<span class=\"built_in\">UILabel</span> alloc] init];</span><br><span class=\"line\">\tlabel.font = [<span class=\"built_in\">UIFont</span> systemFontOfSize:<span class=\"number\">14</span>];</span><br><span class=\"line\">\tlabel.textColor = [<span class=\"built_in\">UIColor</span> whiteColor];</span><br><span class=\"line\">\tlabel.textAlignment = <span class=\"built_in\">NSTextAlignmentCenter</span>;</span><br><span class=\"line\">\tlabel.text = <span class=\"string\">@\"你好\"</span>;</span><br><span class=\"line\">\t[<span class=\"keyword\">self</span> addSubview:label];</span><br><span class=\"line\">\t_label = label;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>就是这么一段代码，如果要让楼主写 则是下面这样的</p>\n<p>代码二：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MyView</span> ()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">UILabel</span> *label;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">MyView</span></span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setupSubview &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">self</span>.label = [[<span class=\"built_in\">UILabel</span> alloc] init];</span><br><span class=\"line\">\t<span class=\"keyword\">self</span>.label.font = [<span class=\"built_in\">UIFont</span> systemFontOfSize:<span class=\"number\">14</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">self</span>.label.textColor = [<span class=\"built_in\">UIColor</span> whiteColor];</span><br><span class=\"line\">\t<span class=\"keyword\">self</span>.label.textAlignment = <span class=\"built_in\">NSTextAlignmentCenter</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">self</span>.label.text = <span class=\"string\">@\"你好\"</span>;</span><br><span class=\"line\">\t[<span class=\"keyword\">self</span> addSubview:<span class=\"keyword\">self</span>.label];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n<p>当然你也可以直接用<code>_label</code>赋值，这里问题的重点不是set方法和成员变量的区别，而是我的属性<br>用的是<code>strong</code>修饰而他的是使用<code>weak</code>修饰。</p>\n<p>本着不耻下问，虚心求教的态度我问了一下我同事，得到了这样的解答：</p>\n<p>代码一的属性使用的<code>weak</code>修饰，因为在<code>addSubview：</code>的时候<code>self</code>会强引用<code>label</code>对象<code>weak</code>修饰的成员变量<code>_label</code>弱引用着<code>label</code>对象</p>\n<p>代码二的属性使用<code>strong</code>修饰， 在<code>addSubview：</code>的时候<code>self</code>会强引用<code>label</code>对象 <code>strong</code> 修饰的成员变量<code>_label</code>也强引用着<code>label</code>对象</p>\n<p>第一种代码的好处是在<code>self</code>移除<code>label</code>的时候<code>label</code>对象就释放了。因为<code>label</code>只有一个<code>self</code>强引用着</p>\n<p>第二种代码在<code>self</code>移除<code>label</code>的时候<code>label</code>对象不会释放，因为还有个<code>_label</code>的变量强引用这<code>label</code>对象，<br>只有在<code>self</code>释放的时候<code>label</code>对象才会释放。</p>\n<p>本人读书少，仔细一想确实是这么回事，用<code>weak</code>修饰，<code>label</code>对象只被<code>self</code>强引用，从view上移除后就可以释放，<br>不用等到<code>self</code>释放的时候才释放，创建和释放都很合理(哪里创建哪里释放)。</p>\n<p>但是细思极恐，难道我多年来的开发经验是错误的么，用了n年的<code>strong</code>原来是个低效的使用方法。这时候我突然想到了一个面试题，</p>\n<p>那就是你真的了解属性修饰符的用法么？</p>\n<p>好吧我承认！我不了解，这就是我看这本书的原因。</p>\n<p>注：</p>\n<ol>\n<li>上面的解释不一定是正确的。</li>\n<li>小弟初来乍到要是有啥说的不对的地方希望各位大大不吝赐教。</li>\n<li>要是你们有什么意见和建议，也可以随便吐槽。</li>\n</ol>"},{"title":"读《iOS与OS X多线程和内存管理》——引用计数","date":"2017-04-17T11:34:12.000Z","_content":"\n## 前言\n\n上一章说了看这本的目的，下面就算是读书笔记吧\n\n<!-- more -->\n\n### 1. 什么是自动引用计数(ARC) ###\n\nARC（Automatic Reference Counting）简而言之就是编译器自动进行内存管理，那为什么不叫\"自动内存管理\"，而叫\"自动引用计数\"，当然是因为内存管理是的方法是通过引用计数实现的\n\n要说自动引用计数，首先要说什么是\"引用计数\"\n\n#### 1.1引用计数 ####\n\n什么是引用计数，书中举了一个生活中开关房间灯的例子。\n\n简单的描述一下就是，第一个人来屋子的时候要开灯(创建对象)，最后一个人走的时候要关灯(释放对象)，中间来人走人都不需要开关灯。\n那么办公室里的人数就是引用计数。也就是有多少个人用着灯\n\n#### 1.2内存管理的思考方式 ####\n\n内存管理的思考方式总结出来就是下面四点  \n\n注：这里还没到ARC所以还是非ARC\n\n1.自己生成的对象，自己所持有 (指通过`alloc/new/copy/mutableCopy`等创建的对象)\neg:\n\n```mm\nid obj = [NSObject new];\n```\n\n2.非自己生成的对象，自己也能持有 (指持有通过类方法创建的对象)\neg:\n\n```mm\nid obj = [NSArray array];\n[obj retain];\n```\n\n3.不再需要自己持有的对象时释放  (释放对象)\neg:\n\n```mm\nid obj = [[NSObject alloc] init];\n[obj release];  \n```\n4.非自己持有的对象无法释放  (多次释放，或未持有释放）\neg:\n\n```mm\nid obj = [[NSObject alloc] init];\n[obj release];\n[obj release];\n```\n\n\n对象的操作与Objective-C方法的对应\n生成并持有对象------ alloc/new/copy/mutableCopy 等\n持有对象----------- retain\n释放对象----------- release\n废弃对象----------- dealloc\n\n\n### 2.alloc/retain/release/dealloc 实现 ###\n\n这一节研究的是`alloc/retain/release/dealloc`的实现。\n\n讲之前先说一个常识，那就是Objective-C的框架，底层的是一个叫Cocoa框架其中包含一个Foundation框架\n\n首先Objective-C内存管理的方法是包含在Cocoa框架中的，这里所说的内存管理是的方法`alloc/retain/release/dealloc` 指的是`NSObject`类的`alloc`类方法,`retain`实例方法,`release`实例方法和`dealloc`实例方法，但是`NSObject`类的`Foundation`框架没有公开过源码，所以这里使用开源软件`GNUstep`的框架，一个能和Cocoa框架互换的框架，来理解苹果Cocoa框架的实现。\n\n这里我把代码给大家写出来，供大家参考，但书的作者把有些地方的源码在不改变意思的范围进行了修改\n\n#### 2.1 alloc 实现 ####\n\nGNUstep的```alloc```实现：\n\n\n```mm\n+(id)alloc\n{\n    return [self allocWithZone:NSDefaultMallocZone()];\n}\n\n+ (id)allocWithZone:(NSZone *)z\n{\n    return NSAllocateObject (self, 0, z);\n}\n\n/* ------- NSAllocateObject ------- */\nstruct obj_layout {\n    NSUInteger retained;\n};\n\ninline id NSAllocateObject (Class aClass, NSUInteger extraBytes, NSZone *zone)\n{\n    int size = 计算容纳对象所需内存大小；\n    id new = NSZoneMalloc(zone,size);\n    memset(new, 0, size);\n    new = (id)&((struct obj_layout *) new)[1];\n}\n\n/* ----- 简化版alloc ----- */\n+ alloc\n{\n    int size = sizeof(struct obj_layout) + 对象大小;\n    struct obj_layout *p = (struct obj_layout *)calloc(1,size);\n    return(id)(p+1);\n}\n```\n\n简化版的是去掉了`NSZone`之后的代码，`NSZone`是为了防止内存碎片化引入的结构，对内存管理没有影响，所以可以忽略。从简化版的代码中可以看出`GNUstep`申请的对象的内存比需要的大了`sizeof(struct obj_layout)`，这个多出来的空间就是用来存放引用计数的\n\n在非ARC即MRC中是可以通过`retainCount`查看对象的引用计数的。\n\nretainCount的实现:\n\n```mm\n- (NSUInteger)retainCount\n{\n    return NSExtraRefCount(self) + 1;\n}\n\ninline NSUInteger NSExtraRefCount(id anObject)\n{\n    return((struct obj_layout *) anObject)[-1].retained;\n}\n```\n\n#### 2.2 retain 实现 ####\n\nGNUstep的`retain`实现：\n\n```mm\n- (id)retain\n{\n    NSIncrementExtraRefCount(self);\n    return self;\n}\n\ninline void NSIncrementExtraRefCount(id anObject)\n{\n    if(((struct obj_layout *)anObject)[-1].retained == UINT_MAX -1)\n        抛出异常\n    ((struct obj_layout *)anObject)[-1].retained++;\n}\n```\n\n#### 2.3 release 实现 ####\nGNUstep的`release`实现：\n\n```mm\n- (void)release\n{\n    if(NSDecrementExtraRefCountWasZero(self))\n        [self dealloc];\n}\n\nBOOL NSDecrementExtraRefCountWasZero(id anObject)\n{\n    if(((struct obj_layout *)anObject)[-1].retained == 0){\n        return YES;\n    }else {\n        ((struct obj_layout *)anObject)[-1].retained--;\n        return NO;\n    }\n}\n```\n\n#### 2.4 dealloc 实现 ####\nGNUstep的`dealloc`实现：\n\n```mm\n- (void)dealloc\n{\n    NSDeallocateObject(self);\n}\n\ninline void NSDeallocateObject(id anObject)\n{\n    struct obj_layout *o = &((struct obj_layout *) anObject)[-1];\n    free(o);\n}\n```\n\n可以看到`GNUstep`实现引用计数的方法是在变量在内存块头部保存的当前对象的引用计数，默认是0，当调用`retainCount`时会自动+1，这就说明了自己生成的对象，自己所持有。\n\n\n#### 2.5 苹果实现 ####\n苹果由于官方未公开源代码，根据运行时调用的代码可以看出苹果实现引用计数和`GNUsetp`的主要区别就是`GNUsetp`将引用计数存放在内存块头，而苹果使用的是散列表（键为内存块地址的散列值）\n\n存放在头部管理引用计数的好处：\n- 代码量少\n- 能够统一管理引用计数用内存块和对象用内存块\n\n用散列表(引用计数表)管理引用计数的好处：\n- 对象用内存块的分配无需考虑内存块头部\n- 引用计数表各记录中存有内存块地址，可从各个记录追溯到各对象的内存块\n\n\n### 3 autorelease ###\n所谓`autorelease`就是自动释放，原理就是若某自动变量超出其作用域，该自动变量将被自动废弃\n\nGNUstep的`autorelease`实现：\n\n\n```mm\n- (id)autorelease\n{\n    [NSAutoreleasePool addObject:self];\n}\n\n+ (void) addObject:(id)anObj\n{\n    NSAutoreleasePool *pool = 取得当前NSAutoreleasePool对象\n    if(pool != nil) {\n        [pool addObject:anObj];\n    }else {\n        NSLog(@\"NSAutoreleasePool对象非存在状态下调用autorelease\")；\n    }\n}\n```\n\n废弃`NSAutoreleasePool`方法`drain`实现\n\n\n```mm\n- (void)drain\n{\n    [self dealloc];\n}\n\n- (void)dealloc\n{\n    [self emptyPool];\n    [array release];\n}\n\n- (void)emptyPool\n{\n    for(id obj in array) {\n        [obj release];\n    }\n}\n```\n\n查看`AutoreleasePool`中的内容\n\n```mm\n[NSAutoreleasePool showPools];//此方法只能在iOS中使用\n```\n在运行时系统中调用方法\n\n```mm\n/* 函数声明 */\nextern void _objc_autoreleasePoolPrint();\n\n/* 调试处调用 */\n_objc_autoreleasePoolPrint();\n```\n\n注：\n(1).上面的内容全部是本人读《Objective-C高级编程 iOS与OS X多线程和内存管理》一书觉得重点的部分，如果大家感兴趣可以支持一下正版。\n(2).如果各位看官觉得有什么是小弟说的不对的地方，欢迎指出。\n(3).这篇基本上都是说引用计数的实现的，还没有涉及到前言提出的问题的解答。\n(4).看到这里的都是真爱啊。\n","source":"_posts/读《iOS与OS X多线程和内存管理》——引用计数.md","raw":"---\ntitle: 读《iOS与OS X多线程和内存管理》——引用计数\ndate: 2017-04-17 19:34:12\ntags: [iOS]\n---\n\n## 前言\n\n上一章说了看这本的目的，下面就算是读书笔记吧\n\n<!-- more -->\n\n### 1. 什么是自动引用计数(ARC) ###\n\nARC（Automatic Reference Counting）简而言之就是编译器自动进行内存管理，那为什么不叫\"自动内存管理\"，而叫\"自动引用计数\"，当然是因为内存管理是的方法是通过引用计数实现的\n\n要说自动引用计数，首先要说什么是\"引用计数\"\n\n#### 1.1引用计数 ####\n\n什么是引用计数，书中举了一个生活中开关房间灯的例子。\n\n简单的描述一下就是，第一个人来屋子的时候要开灯(创建对象)，最后一个人走的时候要关灯(释放对象)，中间来人走人都不需要开关灯。\n那么办公室里的人数就是引用计数。也就是有多少个人用着灯\n\n#### 1.2内存管理的思考方式 ####\n\n内存管理的思考方式总结出来就是下面四点  \n\n注：这里还没到ARC所以还是非ARC\n\n1.自己生成的对象，自己所持有 (指通过`alloc/new/copy/mutableCopy`等创建的对象)\neg:\n\n```mm\nid obj = [NSObject new];\n```\n\n2.非自己生成的对象，自己也能持有 (指持有通过类方法创建的对象)\neg:\n\n```mm\nid obj = [NSArray array];\n[obj retain];\n```\n\n3.不再需要自己持有的对象时释放  (释放对象)\neg:\n\n```mm\nid obj = [[NSObject alloc] init];\n[obj release];  \n```\n4.非自己持有的对象无法释放  (多次释放，或未持有释放）\neg:\n\n```mm\nid obj = [[NSObject alloc] init];\n[obj release];\n[obj release];\n```\n\n\n对象的操作与Objective-C方法的对应\n生成并持有对象------ alloc/new/copy/mutableCopy 等\n持有对象----------- retain\n释放对象----------- release\n废弃对象----------- dealloc\n\n\n### 2.alloc/retain/release/dealloc 实现 ###\n\n这一节研究的是`alloc/retain/release/dealloc`的实现。\n\n讲之前先说一个常识，那就是Objective-C的框架，底层的是一个叫Cocoa框架其中包含一个Foundation框架\n\n首先Objective-C内存管理的方法是包含在Cocoa框架中的，这里所说的内存管理是的方法`alloc/retain/release/dealloc` 指的是`NSObject`类的`alloc`类方法,`retain`实例方法,`release`实例方法和`dealloc`实例方法，但是`NSObject`类的`Foundation`框架没有公开过源码，所以这里使用开源软件`GNUstep`的框架，一个能和Cocoa框架互换的框架，来理解苹果Cocoa框架的实现。\n\n这里我把代码给大家写出来，供大家参考，但书的作者把有些地方的源码在不改变意思的范围进行了修改\n\n#### 2.1 alloc 实现 ####\n\nGNUstep的```alloc```实现：\n\n\n```mm\n+(id)alloc\n{\n    return [self allocWithZone:NSDefaultMallocZone()];\n}\n\n+ (id)allocWithZone:(NSZone *)z\n{\n    return NSAllocateObject (self, 0, z);\n}\n\n/* ------- NSAllocateObject ------- */\nstruct obj_layout {\n    NSUInteger retained;\n};\n\ninline id NSAllocateObject (Class aClass, NSUInteger extraBytes, NSZone *zone)\n{\n    int size = 计算容纳对象所需内存大小；\n    id new = NSZoneMalloc(zone,size);\n    memset(new, 0, size);\n    new = (id)&((struct obj_layout *) new)[1];\n}\n\n/* ----- 简化版alloc ----- */\n+ alloc\n{\n    int size = sizeof(struct obj_layout) + 对象大小;\n    struct obj_layout *p = (struct obj_layout *)calloc(1,size);\n    return(id)(p+1);\n}\n```\n\n简化版的是去掉了`NSZone`之后的代码，`NSZone`是为了防止内存碎片化引入的结构，对内存管理没有影响，所以可以忽略。从简化版的代码中可以看出`GNUstep`申请的对象的内存比需要的大了`sizeof(struct obj_layout)`，这个多出来的空间就是用来存放引用计数的\n\n在非ARC即MRC中是可以通过`retainCount`查看对象的引用计数的。\n\nretainCount的实现:\n\n```mm\n- (NSUInteger)retainCount\n{\n    return NSExtraRefCount(self) + 1;\n}\n\ninline NSUInteger NSExtraRefCount(id anObject)\n{\n    return((struct obj_layout *) anObject)[-1].retained;\n}\n```\n\n#### 2.2 retain 实现 ####\n\nGNUstep的`retain`实现：\n\n```mm\n- (id)retain\n{\n    NSIncrementExtraRefCount(self);\n    return self;\n}\n\ninline void NSIncrementExtraRefCount(id anObject)\n{\n    if(((struct obj_layout *)anObject)[-1].retained == UINT_MAX -1)\n        抛出异常\n    ((struct obj_layout *)anObject)[-1].retained++;\n}\n```\n\n#### 2.3 release 实现 ####\nGNUstep的`release`实现：\n\n```mm\n- (void)release\n{\n    if(NSDecrementExtraRefCountWasZero(self))\n        [self dealloc];\n}\n\nBOOL NSDecrementExtraRefCountWasZero(id anObject)\n{\n    if(((struct obj_layout *)anObject)[-1].retained == 0){\n        return YES;\n    }else {\n        ((struct obj_layout *)anObject)[-1].retained--;\n        return NO;\n    }\n}\n```\n\n#### 2.4 dealloc 实现 ####\nGNUstep的`dealloc`实现：\n\n```mm\n- (void)dealloc\n{\n    NSDeallocateObject(self);\n}\n\ninline void NSDeallocateObject(id anObject)\n{\n    struct obj_layout *o = &((struct obj_layout *) anObject)[-1];\n    free(o);\n}\n```\n\n可以看到`GNUstep`实现引用计数的方法是在变量在内存块头部保存的当前对象的引用计数，默认是0，当调用`retainCount`时会自动+1，这就说明了自己生成的对象，自己所持有。\n\n\n#### 2.5 苹果实现 ####\n苹果由于官方未公开源代码，根据运行时调用的代码可以看出苹果实现引用计数和`GNUsetp`的主要区别就是`GNUsetp`将引用计数存放在内存块头，而苹果使用的是散列表（键为内存块地址的散列值）\n\n存放在头部管理引用计数的好处：\n- 代码量少\n- 能够统一管理引用计数用内存块和对象用内存块\n\n用散列表(引用计数表)管理引用计数的好处：\n- 对象用内存块的分配无需考虑内存块头部\n- 引用计数表各记录中存有内存块地址，可从各个记录追溯到各对象的内存块\n\n\n### 3 autorelease ###\n所谓`autorelease`就是自动释放，原理就是若某自动变量超出其作用域，该自动变量将被自动废弃\n\nGNUstep的`autorelease`实现：\n\n\n```mm\n- (id)autorelease\n{\n    [NSAutoreleasePool addObject:self];\n}\n\n+ (void) addObject:(id)anObj\n{\n    NSAutoreleasePool *pool = 取得当前NSAutoreleasePool对象\n    if(pool != nil) {\n        [pool addObject:anObj];\n    }else {\n        NSLog(@\"NSAutoreleasePool对象非存在状态下调用autorelease\")；\n    }\n}\n```\n\n废弃`NSAutoreleasePool`方法`drain`实现\n\n\n```mm\n- (void)drain\n{\n    [self dealloc];\n}\n\n- (void)dealloc\n{\n    [self emptyPool];\n    [array release];\n}\n\n- (void)emptyPool\n{\n    for(id obj in array) {\n        [obj release];\n    }\n}\n```\n\n查看`AutoreleasePool`中的内容\n\n```mm\n[NSAutoreleasePool showPools];//此方法只能在iOS中使用\n```\n在运行时系统中调用方法\n\n```mm\n/* 函数声明 */\nextern void _objc_autoreleasePoolPrint();\n\n/* 调试处调用 */\n_objc_autoreleasePoolPrint();\n```\n\n注：\n(1).上面的内容全部是本人读《Objective-C高级编程 iOS与OS X多线程和内存管理》一书觉得重点的部分，如果大家感兴趣可以支持一下正版。\n(2).如果各位看官觉得有什么是小弟说的不对的地方，欢迎指出。\n(3).这篇基本上都是说引用计数的实现的，还没有涉及到前言提出的问题的解答。\n(4).看到这里的都是真爱啊。\n","slug":"读《iOS与OS X多线程和内存管理》——引用计数","published":1,"updated":"2021-04-12T09:17:38.423Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqjdx1oe002j5emubjasarpq","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>上一章说了看这本的目的，下面就算是读书笔记吧</p>\n<a id=\"more\"></a>\n<h3 id=\"1-什么是自动引用计数-ARC\"><a href=\"#1-什么是自动引用计数-ARC\" class=\"headerlink\" title=\"1. 什么是自动引用计数(ARC)\"></a>1. 什么是自动引用计数(ARC)</h3><p>ARC（Automatic Reference Counting）简而言之就是编译器自动进行内存管理，那为什么不叫”自动内存管理”，而叫”自动引用计数”，当然是因为内存管理是的方法是通过引用计数实现的</p>\n<p>要说自动引用计数，首先要说什么是”引用计数”</p>\n<h4 id=\"1-1引用计数\"><a href=\"#1-1引用计数\" class=\"headerlink\" title=\"1.1引用计数\"></a>1.1引用计数</h4><p>什么是引用计数，书中举了一个生活中开关房间灯的例子。</p>\n<p>简单的描述一下就是，第一个人来屋子的时候要开灯(创建对象)，最后一个人走的时候要关灯(释放对象)，中间来人走人都不需要开关灯。<br>那么办公室里的人数就是引用计数。也就是有多少个人用着灯</p>\n<h4 id=\"1-2内存管理的思考方式\"><a href=\"#1-2内存管理的思考方式\" class=\"headerlink\" title=\"1.2内存管理的思考方式\"></a>1.2内存管理的思考方式</h4><p>内存管理的思考方式总结出来就是下面四点  </p>\n<p>注：这里还没到ARC所以还是非ARC</p>\n<p>1.自己生成的对象，自己所持有 (指通过<code>alloc/new/copy/mutableCopy</code>等创建的对象)<br>eg:</p>\n<figure class=\"highlight mm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">id</span> obj = [<span class=\"built_in\">NSObject</span> new];</span><br></pre></td></tr></table></figure>\n<p>2.非自己生成的对象，自己也能持有 (指持有通过类方法创建的对象)<br>eg:</p>\n<figure class=\"highlight mm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">id</span> obj = [<span class=\"built_in\">NSArray</span> array];</span><br><span class=\"line\">[obj <span class=\"keyword\">retain</span>];</span><br></pre></td></tr></table></figure>\n<p>3.不再需要自己持有的对象时释放  (释放对象)<br>eg:</p>\n<figure class=\"highlight mm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">id</span> obj = [[<span class=\"built_in\">NSObject</span> alloc] init];</span><br><span class=\"line\">[obj release];</span><br></pre></td></tr></table></figure>\n<p>4.非自己持有的对象无法释放  (多次释放，或未持有释放）<br>eg:</p>\n<figure class=\"highlight mm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">id</span> obj = [[<span class=\"built_in\">NSObject</span> alloc] init];</span><br><span class=\"line\">[obj release];</span><br><span class=\"line\">[obj release];</span><br></pre></td></tr></table></figure>\n<p>对象的操作与Objective-C方法的对应<br>生成并持有对象—— alloc/new/copy/mutableCopy 等<br>持有对象———– retain<br>释放对象———– release<br>废弃对象———– dealloc</p>\n<h3 id=\"2-alloc-retain-release-dealloc-实现\"><a href=\"#2-alloc-retain-release-dealloc-实现\" class=\"headerlink\" title=\"2.alloc/retain/release/dealloc 实现\"></a>2.alloc/retain/release/dealloc 实现</h3><p>这一节研究的是<code>alloc/retain/release/dealloc</code>的实现。</p>\n<p>讲之前先说一个常识，那就是Objective-C的框架，底层的是一个叫Cocoa框架其中包含一个Foundation框架</p>\n<p>首先Objective-C内存管理的方法是包含在Cocoa框架中的，这里所说的内存管理是的方法<code>alloc/retain/release/dealloc</code> 指的是<code>NSObject</code>类的<code>alloc</code>类方法,<code>retain</code>实例方法,<code>release</code>实例方法和<code>dealloc</code>实例方法，但是<code>NSObject</code>类的<code>Foundation</code>框架没有公开过源码，所以这里使用开源软件<code>GNUstep</code>的框架，一个能和Cocoa框架互换的框架，来理解苹果Cocoa框架的实现。</p>\n<p>这里我把代码给大家写出来，供大家参考，但书的作者把有些地方的源码在不改变意思的范围进行了修改</p>\n<h4 id=\"2-1-alloc-实现\"><a href=\"#2-1-alloc-实现\" class=\"headerlink\" title=\"2.1 alloc 实现\"></a>2.1 alloc 实现</h4><p>GNUstep的<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">```mm</span><br><span class=\"line\">+(id)alloc</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return [self allocWithZone:NSDefaultMallocZone()];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (id)allocWithZone:(NSZone *)z</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return NSAllocateObject (self, 0, z);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* ------- NSAllocateObject ------- */</span><br><span class=\"line\">struct obj_layout &#123;</span><br><span class=\"line\">    NSUInteger retained;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">inline id NSAllocateObject (Class aClass, NSUInteger extraBytes, NSZone *zone)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int size = 计算容纳对象所需内存大小；</span><br><span class=\"line\">    id new = NSZoneMalloc(zone,size);</span><br><span class=\"line\">    memset(new, 0, size);</span><br><span class=\"line\">    new = (id)&amp;((struct obj_layout *) new)[1];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* ----- 简化版alloc ----- */</span><br><span class=\"line\">+ alloc</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int size = sizeof(struct obj_layout) + 对象大小;</span><br><span class=\"line\">    struct obj_layout *p = (struct obj_layout *)calloc(1,size);</span><br><span class=\"line\">    return(id)(p+1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>简化版的是去掉了<code>NSZone</code>之后的代码，<code>NSZone</code>是为了防止内存碎片化引入的结构，对内存管理没有影响，所以可以忽略。从简化版的代码中可以看出<code>GNUstep</code>申请的对象的内存比需要的大了<code>sizeof(struct obj_layout)</code>，这个多出来的空间就是用来存放引用计数的</p>\n<p>在非ARC即MRC中是可以通过<code>retainCount</code>查看对象的引用计数的。</p>\n<p>retainCount的实现:</p>\n<figure class=\"highlight mm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSUInteger</span>)retainCount</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">NSExtraRefCount</span>(<span class=\"keyword\">self</span>) + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"built_in\">NSUInteger</span> <span class=\"built_in\">NSExtraRefCount</span>(<span class=\"keyword\">id</span> anObject)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>((<span class=\"keyword\">struct</span> obj_layout *) anObject)[<span class=\"number\">-1</span>].retained;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-2-retain-实现\"><a href=\"#2-2-retain-实现\" class=\"headerlink\" title=\"2.2 retain 实现\"></a>2.2 retain 实现</h4><p>GNUstep的<code>retain</code>实现：</p>\n<figure class=\"highlight mm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">id</span>)<span class=\"keyword\">retain</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSIncrementExtraRefCount</span>(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"built_in\">NSIncrementExtraRefCount</span>(<span class=\"keyword\">id</span> anObject)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(((<span class=\"keyword\">struct</span> obj_layout *)anObject)[<span class=\"number\">-1</span>].retained == <span class=\"built_in\">UINT_MAX</span> <span class=\"number\">-1</span>)</span><br><span class=\"line\">        抛出异常</span><br><span class=\"line\">    ((<span class=\"keyword\">struct</span> obj_layout *)anObject)[<span class=\"number\">-1</span>].retained++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-3-release-实现\"><a href=\"#2-3-release-实现\" class=\"headerlink\" title=\"2.3 release 实现\"></a>2.3 release 实现</h4><p>GNUstep的<code>release</code>实现：</p>\n<figure class=\"highlight mm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)release</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">NSDecrementExtraRefCountWasZero</span>(<span class=\"keyword\">self</span>))</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> dealloc];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">BOOL</span> <span class=\"built_in\">NSDecrementExtraRefCountWasZero</span>(<span class=\"keyword\">id</span> anObject)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(((<span class=\"keyword\">struct</span> obj_layout *)anObject)[<span class=\"number\">-1</span>].retained == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        ((<span class=\"keyword\">struct</span> obj_layout *)anObject)[<span class=\"number\">-1</span>].retained--;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-4-dealloc-实现\"><a href=\"#2-4-dealloc-实现\" class=\"headerlink\" title=\"2.4 dealloc 实现\"></a>2.4 dealloc 实现</h4><p>GNUstep的<code>dealloc</code>实现：</p>\n<figure class=\"highlight mm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)dealloc</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSDeallocateObject</span>(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"built_in\">NSDeallocateObject</span>(<span class=\"keyword\">id</span> anObject)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> obj_layout *o = &amp;((<span class=\"keyword\">struct</span> obj_layout *) anObject)[<span class=\"number\">-1</span>];</span><br><span class=\"line\">    free(o);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到<code>GNUstep</code>实现引用计数的方法是在变量在内存块头部保存的当前对象的引用计数，默认是0，当调用<code>retainCount</code>时会自动+1，这就说明了自己生成的对象，自己所持有。</p>\n<h4 id=\"2-5-苹果实现\"><a href=\"#2-5-苹果实现\" class=\"headerlink\" title=\"2.5 苹果实现\"></a>2.5 苹果实现</h4><p>苹果由于官方未公开源代码，根据运行时调用的代码可以看出苹果实现引用计数和<code>GNUsetp</code>的主要区别就是<code>GNUsetp</code>将引用计数存放在内存块头，而苹果使用的是散列表（键为内存块地址的散列值）</p>\n<p>存放在头部管理引用计数的好处：</p>\n<ul>\n<li>代码量少</li>\n<li>能够统一管理引用计数用内存块和对象用内存块</li>\n</ul>\n<p>用散列表(引用计数表)管理引用计数的好处：</p>\n<ul>\n<li>对象用内存块的分配无需考虑内存块头部</li>\n<li>引用计数表各记录中存有内存块地址，可从各个记录追溯到各对象的内存块</li>\n</ul>\n<h3 id=\"3-autorelease\"><a href=\"#3-autorelease\" class=\"headerlink\" title=\"3 autorelease\"></a>3 autorelease</h3><p>所谓<code>autorelease</code>就是自动释放，原理就是若某自动变量超出其作用域，该自动变量将被自动废弃</p>\n<p>GNUstep的<code>autorelease</code>实现：</p>\n<figure class=\"highlight mm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">id</span>)autorelease</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"built_in\">NSAutoreleasePool</span> addObject:<span class=\"keyword\">self</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"keyword\">void</span>) addObject:(<span class=\"keyword\">id</span>)anObj</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSAutoreleasePool</span> *pool = 取得当前<span class=\"built_in\">NSAutoreleasePool</span>对象</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pool != <span class=\"literal\">nil</span>) &#123;</span><br><span class=\"line\">        [pool addObject:anObj];</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"NSAutoreleasePool对象非存在状态下调用autorelease\"</span>)；</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>废弃<code>NSAutoreleasePool</code>方法<code>drain</code>实现</p>\n<figure class=\"highlight mm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)drain</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> dealloc];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)dealloc</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> emptyPool];</span><br><span class=\"line\">    [array release];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)emptyPool</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">id</span> obj <span class=\"keyword\">in</span> array) &#123;</span><br><span class=\"line\">        [obj release];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>查看<code>AutoreleasePool</code>中的内容</p>\n<figure class=\"highlight mm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"built_in\">NSAutoreleasePool</span> showPools];<span class=\"comment\">//此方法只能在iOS中使用</span></span><br></pre></td></tr></table></figure>\n<p>在运行时系统中调用方法</p>\n<figure class=\"highlight mm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 函数声明 */</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">void</span> _objc_autoreleasePoolPrint();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 调试处调用 */</span></span><br><span class=\"line\">_objc_autoreleasePoolPrint();</span><br></pre></td></tr></table></figure>\n<p>注：<br>(1).上面的内容全部是本人读《Objective-C高级编程 iOS与OS X多线程和内存管理》一书觉得重点的部分，如果大家感兴趣可以支持一下正版。<br>(2).如果各位看官觉得有什么是小弟说的不对的地方，欢迎指出。<br>(3).这篇基本上都是说引用计数的实现的，还没有涉及到前言提出的问题的解答。<br>(4).看到这里的都是真爱啊。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>上一章说了看这本的目的，下面就算是读书笔记吧</p>","more":"<h3 id=\"1-什么是自动引用计数-ARC\"><a href=\"#1-什么是自动引用计数-ARC\" class=\"headerlink\" title=\"1. 什么是自动引用计数(ARC)\"></a>1. 什么是自动引用计数(ARC)</h3><p>ARC（Automatic Reference Counting）简而言之就是编译器自动进行内存管理，那为什么不叫”自动内存管理”，而叫”自动引用计数”，当然是因为内存管理是的方法是通过引用计数实现的</p>\n<p>要说自动引用计数，首先要说什么是”引用计数”</p>\n<h4 id=\"1-1引用计数\"><a href=\"#1-1引用计数\" class=\"headerlink\" title=\"1.1引用计数\"></a>1.1引用计数</h4><p>什么是引用计数，书中举了一个生活中开关房间灯的例子。</p>\n<p>简单的描述一下就是，第一个人来屋子的时候要开灯(创建对象)，最后一个人走的时候要关灯(释放对象)，中间来人走人都不需要开关灯。<br>那么办公室里的人数就是引用计数。也就是有多少个人用着灯</p>\n<h4 id=\"1-2内存管理的思考方式\"><a href=\"#1-2内存管理的思考方式\" class=\"headerlink\" title=\"1.2内存管理的思考方式\"></a>1.2内存管理的思考方式</h4><p>内存管理的思考方式总结出来就是下面四点  </p>\n<p>注：这里还没到ARC所以还是非ARC</p>\n<p>1.自己生成的对象，自己所持有 (指通过<code>alloc/new/copy/mutableCopy</code>等创建的对象)<br>eg:</p>\n<figure class=\"highlight mm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">id</span> obj = [<span class=\"built_in\">NSObject</span> new];</span><br></pre></td></tr></table></figure>\n<p>2.非自己生成的对象，自己也能持有 (指持有通过类方法创建的对象)<br>eg:</p>\n<figure class=\"highlight mm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">id</span> obj = [<span class=\"built_in\">NSArray</span> array];</span><br><span class=\"line\">[obj <span class=\"keyword\">retain</span>];</span><br></pre></td></tr></table></figure>\n<p>3.不再需要自己持有的对象时释放  (释放对象)<br>eg:</p>\n<figure class=\"highlight mm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">id</span> obj = [[<span class=\"built_in\">NSObject</span> alloc] init];</span><br><span class=\"line\">[obj release];</span><br></pre></td></tr></table></figure>\n<p>4.非自己持有的对象无法释放  (多次释放，或未持有释放）<br>eg:</p>\n<figure class=\"highlight mm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">id</span> obj = [[<span class=\"built_in\">NSObject</span> alloc] init];</span><br><span class=\"line\">[obj release];</span><br><span class=\"line\">[obj release];</span><br></pre></td></tr></table></figure>\n<p>对象的操作与Objective-C方法的对应<br>生成并持有对象—— alloc/new/copy/mutableCopy 等<br>持有对象———– retain<br>释放对象———– release<br>废弃对象———– dealloc</p>\n<h3 id=\"2-alloc-retain-release-dealloc-实现\"><a href=\"#2-alloc-retain-release-dealloc-实现\" class=\"headerlink\" title=\"2.alloc/retain/release/dealloc 实现\"></a>2.alloc/retain/release/dealloc 实现</h3><p>这一节研究的是<code>alloc/retain/release/dealloc</code>的实现。</p>\n<p>讲之前先说一个常识，那就是Objective-C的框架，底层的是一个叫Cocoa框架其中包含一个Foundation框架</p>\n<p>首先Objective-C内存管理的方法是包含在Cocoa框架中的，这里所说的内存管理是的方法<code>alloc/retain/release/dealloc</code> 指的是<code>NSObject</code>类的<code>alloc</code>类方法,<code>retain</code>实例方法,<code>release</code>实例方法和<code>dealloc</code>实例方法，但是<code>NSObject</code>类的<code>Foundation</code>框架没有公开过源码，所以这里使用开源软件<code>GNUstep</code>的框架，一个能和Cocoa框架互换的框架，来理解苹果Cocoa框架的实现。</p>\n<p>这里我把代码给大家写出来，供大家参考，但书的作者把有些地方的源码在不改变意思的范围进行了修改</p>\n<h4 id=\"2-1-alloc-实现\"><a href=\"#2-1-alloc-实现\" class=\"headerlink\" title=\"2.1 alloc 实现\"></a>2.1 alloc 实现</h4><p>GNUstep的<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">```mm</span><br><span class=\"line\">+(id)alloc</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return [self allocWithZone:NSDefaultMallocZone()];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (id)allocWithZone:(NSZone *)z</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return NSAllocateObject (self, 0, z);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* ------- NSAllocateObject ------- */</span><br><span class=\"line\">struct obj_layout &#123;</span><br><span class=\"line\">    NSUInteger retained;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">inline id NSAllocateObject (Class aClass, NSUInteger extraBytes, NSZone *zone)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int size = 计算容纳对象所需内存大小；</span><br><span class=\"line\">    id new = NSZoneMalloc(zone,size);</span><br><span class=\"line\">    memset(new, 0, size);</span><br><span class=\"line\">    new = (id)&amp;((struct obj_layout *) new)[1];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* ----- 简化版alloc ----- */</span><br><span class=\"line\">+ alloc</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int size = sizeof(struct obj_layout) + 对象大小;</span><br><span class=\"line\">    struct obj_layout *p = (struct obj_layout *)calloc(1,size);</span><br><span class=\"line\">    return(id)(p+1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>简化版的是去掉了<code>NSZone</code>之后的代码，<code>NSZone</code>是为了防止内存碎片化引入的结构，对内存管理没有影响，所以可以忽略。从简化版的代码中可以看出<code>GNUstep</code>申请的对象的内存比需要的大了<code>sizeof(struct obj_layout)</code>，这个多出来的空间就是用来存放引用计数的</p>\n<p>在非ARC即MRC中是可以通过<code>retainCount</code>查看对象的引用计数的。</p>\n<p>retainCount的实现:</p>\n<figure class=\"highlight mm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSUInteger</span>)retainCount</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">NSExtraRefCount</span>(<span class=\"keyword\">self</span>) + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"built_in\">NSUInteger</span> <span class=\"built_in\">NSExtraRefCount</span>(<span class=\"keyword\">id</span> anObject)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>((<span class=\"keyword\">struct</span> obj_layout *) anObject)[<span class=\"number\">-1</span>].retained;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-2-retain-实现\"><a href=\"#2-2-retain-实现\" class=\"headerlink\" title=\"2.2 retain 实现\"></a>2.2 retain 实现</h4><p>GNUstep的<code>retain</code>实现：</p>\n<figure class=\"highlight mm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">id</span>)<span class=\"keyword\">retain</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSIncrementExtraRefCount</span>(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"built_in\">NSIncrementExtraRefCount</span>(<span class=\"keyword\">id</span> anObject)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(((<span class=\"keyword\">struct</span> obj_layout *)anObject)[<span class=\"number\">-1</span>].retained == <span class=\"built_in\">UINT_MAX</span> <span class=\"number\">-1</span>)</span><br><span class=\"line\">        抛出异常</span><br><span class=\"line\">    ((<span class=\"keyword\">struct</span> obj_layout *)anObject)[<span class=\"number\">-1</span>].retained++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-3-release-实现\"><a href=\"#2-3-release-实现\" class=\"headerlink\" title=\"2.3 release 实现\"></a>2.3 release 实现</h4><p>GNUstep的<code>release</code>实现：</p>\n<figure class=\"highlight mm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)release</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">NSDecrementExtraRefCountWasZero</span>(<span class=\"keyword\">self</span>))</span><br><span class=\"line\">        [<span class=\"keyword\">self</span> dealloc];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">BOOL</span> <span class=\"built_in\">NSDecrementExtraRefCountWasZero</span>(<span class=\"keyword\">id</span> anObject)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(((<span class=\"keyword\">struct</span> obj_layout *)anObject)[<span class=\"number\">-1</span>].retained == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        ((<span class=\"keyword\">struct</span> obj_layout *)anObject)[<span class=\"number\">-1</span>].retained--;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-4-dealloc-实现\"><a href=\"#2-4-dealloc-实现\" class=\"headerlink\" title=\"2.4 dealloc 实现\"></a>2.4 dealloc 实现</h4><p>GNUstep的<code>dealloc</code>实现：</p>\n<figure class=\"highlight mm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)dealloc</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSDeallocateObject</span>(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"built_in\">NSDeallocateObject</span>(<span class=\"keyword\">id</span> anObject)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> obj_layout *o = &amp;((<span class=\"keyword\">struct</span> obj_layout *) anObject)[<span class=\"number\">-1</span>];</span><br><span class=\"line\">    free(o);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到<code>GNUstep</code>实现引用计数的方法是在变量在内存块头部保存的当前对象的引用计数，默认是0，当调用<code>retainCount</code>时会自动+1，这就说明了自己生成的对象，自己所持有。</p>\n<h4 id=\"2-5-苹果实现\"><a href=\"#2-5-苹果实现\" class=\"headerlink\" title=\"2.5 苹果实现\"></a>2.5 苹果实现</h4><p>苹果由于官方未公开源代码，根据运行时调用的代码可以看出苹果实现引用计数和<code>GNUsetp</code>的主要区别就是<code>GNUsetp</code>将引用计数存放在内存块头，而苹果使用的是散列表（键为内存块地址的散列值）</p>\n<p>存放在头部管理引用计数的好处：</p>\n<ul>\n<li>代码量少</li>\n<li>能够统一管理引用计数用内存块和对象用内存块</li>\n</ul>\n<p>用散列表(引用计数表)管理引用计数的好处：</p>\n<ul>\n<li>对象用内存块的分配无需考虑内存块头部</li>\n<li>引用计数表各记录中存有内存块地址，可从各个记录追溯到各对象的内存块</li>\n</ul>\n<h3 id=\"3-autorelease\"><a href=\"#3-autorelease\" class=\"headerlink\" title=\"3 autorelease\"></a>3 autorelease</h3><p>所谓<code>autorelease</code>就是自动释放，原理就是若某自动变量超出其作用域，该自动变量将被自动废弃</p>\n<p>GNUstep的<code>autorelease</code>实现：</p>\n<figure class=\"highlight mm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">id</span>)autorelease</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"built_in\">NSAutoreleasePool</span> addObject:<span class=\"keyword\">self</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"keyword\">void</span>) addObject:(<span class=\"keyword\">id</span>)anObj</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSAutoreleasePool</span> *pool = 取得当前<span class=\"built_in\">NSAutoreleasePool</span>对象</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pool != <span class=\"literal\">nil</span>) &#123;</span><br><span class=\"line\">        [pool addObject:anObj];</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"NSAutoreleasePool对象非存在状态下调用autorelease\"</span>)；</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>废弃<code>NSAutoreleasePool</code>方法<code>drain</code>实现</p>\n<figure class=\"highlight mm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)drain</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> dealloc];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)dealloc</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> emptyPool];</span><br><span class=\"line\">    [array release];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)emptyPool</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">id</span> obj <span class=\"keyword\">in</span> array) &#123;</span><br><span class=\"line\">        [obj release];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>查看<code>AutoreleasePool</code>中的内容</p>\n<figure class=\"highlight mm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"built_in\">NSAutoreleasePool</span> showPools];<span class=\"comment\">//此方法只能在iOS中使用</span></span><br></pre></td></tr></table></figure>\n<p>在运行时系统中调用方法</p>\n<figure class=\"highlight mm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 函数声明 */</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">void</span> _objc_autoreleasePoolPrint();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 调试处调用 */</span></span><br><span class=\"line\">_objc_autoreleasePoolPrint();</span><br></pre></td></tr></table></figure>\n<p>注：<br>(1).上面的内容全部是本人读《Objective-C高级编程 iOS与OS X多线程和内存管理》一书觉得重点的部分，如果大家感兴趣可以支持一下正版。<br>(2).如果各位看官觉得有什么是小弟说的不对的地方，欢迎指出。<br>(3).这篇基本上都是说引用计数的实现的，还没有涉及到前言提出的问题的解答。<br>(4).看到这里的都是真爱啊。</p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ckqjdx1mu00005emuz730ax9k","tag_id":"ckqjdx1mz00025emu2ocnh8sc","_id":"ckqjdx1n400075emuebkhd4gg"},{"post_id":"ckqjdx1mx00015emuzlio74de","tag_id":"ckqjdx1n300065emuotz40x73","_id":"ckqjdx1n7000c5emuo8uwbo27"},{"post_id":"ckqjdx1n000035emup255xmmy","tag_id":"ckqjdx1n6000a5emu21z3kq1o","_id":"ckqjdx1nd000j5emuif01r55g"},{"post_id":"ckqjdx1n000035emup255xmmy","tag_id":"ckqjdx1n8000e5emuy4sz71ot","_id":"ckqjdx1ne000l5emur3lkr40q"},{"post_id":"ckqjdx1n100045emumn1oy8ji","tag_id":"ckqjdx1n6000a5emu21z3kq1o","_id":"ckqjdx1nh000r5emu9isuad9c"},{"post_id":"ckqjdx1n100045emumn1oy8ji","tag_id":"ckqjdx1n8000e5emuy4sz71ot","_id":"ckqjdx1ni000t5emuahefwmsw"},{"post_id":"ckqjdx1n200055emuflfn1u40","tag_id":"ckqjdx1ng000p5emu6r9o9d9f","_id":"ckqjdx1nj000w5emu52uovxgo"},{"post_id":"ckqjdx1ni000u5emu30434meq","tag_id":"ckqjdx1ng000p5emu6r9o9d9f","_id":"ckqjdx1nk000y5emua7qsx4zg"},{"post_id":"ckqjdx1nj000x5emu95jppavp","tag_id":"ckqjdx1ng000p5emu6r9o9d9f","_id":"ckqjdx1nm00115emugdd0eq6a"},{"post_id":"ckqjdx1n400085emubjhz5j8t","tag_id":"ckqjdx1ng000p5emu6r9o9d9f","_id":"ckqjdx1nm00135emuwlpvjehm"},{"post_id":"ckqjdx1n500095emu1pjcgt3e","tag_id":"ckqjdx1ng000p5emu6r9o9d9f","_id":"ckqjdx1no00165emuhplnt4b5"},{"post_id":"ckqjdx1nn00145emuonudlgqp","tag_id":"ckqjdx1ng000p5emu6r9o9d9f","_id":"ckqjdx1np00185emurqxclmzh"},{"post_id":"ckqjdx1n6000b5emu5197iwrm","tag_id":"ckqjdx1ng000p5emu6r9o9d9f","_id":"ckqjdx1nt001b5emu0dp22543"},{"post_id":"ckqjdx1np00195emu4f0o0bzt","tag_id":"ckqjdx1n6000a5emu21z3kq1o","_id":"ckqjdx1nu001d5emu66eh1m3c"},{"post_id":"ckqjdx1n7000d5emuwzdaxz7m","tag_id":"ckqjdx1ng000p5emu6r9o9d9f","_id":"ckqjdx1nv001g5emueqfavzoa"},{"post_id":"ckqjdx1n9000f5emudv0p2p7t","tag_id":"ckqjdx1ng000p5emu6r9o9d9f","_id":"ckqjdx1nx001k5emu14irsitg"},{"post_id":"ckqjdx1nx001l5emu2obav0qz","tag_id":"ckqjdx1ng000p5emu6r9o9d9f","_id":"ckqjdx1o0001o5emufkc9kpr1"},{"post_id":"ckqjdx1na000g5emuimu2t7nk","tag_id":"ckqjdx1ng000p5emu6r9o9d9f","_id":"ckqjdx1o2001q5emu3fjy7rfx"},{"post_id":"ckqjdx1ny001m5emudrdskgmp","tag_id":"ckqjdx1ng000p5emu6r9o9d9f","_id":"ckqjdx1o3001t5emuv1r60ud4"},{"post_id":"ckqjdx1o0001p5emujneaid15","tag_id":"ckqjdx1n6000a5emu21z3kq1o","_id":"ckqjdx1o5001v5emuuorlb6u9"},{"post_id":"ckqjdx1o0001p5emujneaid15","tag_id":"ckqjdx1ng000p5emu6r9o9d9f","_id":"ckqjdx1o6001y5emucapbxuf4"},{"post_id":"ckqjdx1nb000i5emukc9e7kzz","tag_id":"ckqjdx1ng000p5emu6r9o9d9f","_id":"ckqjdx1o700205emu8yeykv35"},{"post_id":"ckqjdx1nd000k5emur02dejxt","tag_id":"ckqjdx1ng000p5emu6r9o9d9f","_id":"ckqjdx1o800235emucbg5vhlw"},{"post_id":"ckqjdx1ne000n5emucw5scefh","tag_id":"ckqjdx1o5001x5emun9yk1z5s","_id":"ckqjdx1o900255emus0n04ksg"},{"post_id":"ckqjdx1o800245emu77nt3lqt","tag_id":"ckqjdx1o800225emutyg2db8l","_id":"ckqjdx1oa00285emuz9awcwik"},{"post_id":"ckqjdx1nf000o5emupdl735va","tag_id":"ckqjdx1o800225emutyg2db8l","_id":"ckqjdx1ob002a5emuyhpx5xob"},{"post_id":"ckqjdx1o900265emu26uair8v","tag_id":"ckqjdx1o800225emutyg2db8l","_id":"ckqjdx1oc002d5emueo6zv0mn"},{"post_id":"ckqjdx1oa00295emu4xq2v3ky","tag_id":"ckqjdx1o800225emutyg2db8l","_id":"ckqjdx1od002f5emuns7yj7mg"},{"post_id":"ckqjdx1ng000q5emubpry3rhp","tag_id":"ckqjdx1o5001x5emun9yk1z5s","_id":"ckqjdx1oe002h5emuhncxtz6w"},{"post_id":"ckqjdx1ob002b5emuw1mzpshp","tag_id":"ckqjdx1o800225emutyg2db8l","_id":"ckqjdx1of002k5emuk8wo9wu1"},{"post_id":"ckqjdx1oc002e5emui8jqz1b5","tag_id":"ckqjdx1o800225emutyg2db8l","_id":"ckqjdx1of002l5emutcjlyf2d"},{"post_id":"ckqjdx1nh000s5emumgz5icyy","tag_id":"ckqjdx1oc002c5emupilv1n9r","_id":"ckqjdx1of002n5emugt75tcei"},{"post_id":"ckqjdx1od002g5emuf42xaq1d","tag_id":"ckqjdx1o800225emutyg2db8l","_id":"ckqjdx1of002o5emuj0akd6f8"},{"post_id":"ckqjdx1oe002j5emubjasarpq","tag_id":"ckqjdx1o800225emutyg2db8l","_id":"ckqjdx1og002q5emuxxem1tip"},{"post_id":"ckqjdx1nk000z5emux4mszq3j","tag_id":"ckqjdx1o800225emutyg2db8l","_id":"ckqjdx1og002r5emuouzrygcw"},{"post_id":"ckqjdx1nm00125emu356bx8ar","tag_id":"ckqjdx1o800225emutyg2db8l","_id":"ckqjdx1og002t5emup5hrweaq"},{"post_id":"ckqjdx1nt001c5emuq1uy2ara","tag_id":"ckqjdx1o800225emutyg2db8l","_id":"ckqjdx1og002u5emuvhhz3xgg"},{"post_id":"ckqjdx1nu001e5emu6ydjx9sq","tag_id":"ckqjdx1og002s5emuw2d3bdm1","_id":"ckqjdx1oh002w5emukls6goyg"},{"post_id":"ckqjdx1nv001h5emuderya9si","tag_id":"ckqjdx1o800225emutyg2db8l","_id":"ckqjdx1oh002y5emud912591r"},{"post_id":"ckqjdx1o2001r5emudtzmuobg","tag_id":"ckqjdx1o800225emutyg2db8l","_id":"ckqjdx1oh00305emujdd56ihn"},{"post_id":"ckqjdx1o4001u5emuy2khmy15","tag_id":"ckqjdx1oh002z5emueupplfr6","_id":"ckqjdx1oi00325emu5t5ttpan"},{"post_id":"ckqjdx1o5001w5emuuubc4m9r","tag_id":"ckqjdx1oh002z5emueupplfr6","_id":"ckqjdx1oi00345emueou4q1vd"},{"post_id":"ckqjdx1o6001z5emu4vzocaps","tag_id":"ckqjdx1oi00335emufpqu4gyu","_id":"ckqjdx1oj00385emu9unq4yrk"},{"post_id":"ckqjdx1o6001z5emu4vzocaps","tag_id":"ckqjdx1oi00355emu2a6k8qa1","_id":"ckqjdx1oj00395emu3tnwg0sp"},{"post_id":"ckqjdx1o6001z5emu4vzocaps","tag_id":"ckqjdx1oj00365emud1k6bjui","_id":"ckqjdx1oj003a5emuix4h3uu3"},{"post_id":"ckqjdx1o700215emu2afr8qag","tag_id":"ckqjdx1o800225emutyg2db8l","_id":"ckqjdx1oj003b5emusiccp3zz"}],"Tag":[{"name":"Flutter","_id":"ckqjdx1mz00025emu2ocnh8sc"},{"name":"JavaScript","_id":"ckqjdx1n300065emuotz40x73"},{"name":"日常","_id":"ckqjdx1n6000a5emu21z3kq1o"},{"name":"Hexo","_id":"ckqjdx1n8000e5emuy4sz71ot"},{"name":"Linux","_id":"ckqjdx1ng000p5emu6r9o9d9f"},{"name":"Mac软件","_id":"ckqjdx1o5001x5emun9yk1z5s"},{"name":"iOS","_id":"ckqjdx1o800225emutyg2db8l"},{"name":"Python","_id":"ckqjdx1oc002c5emupilv1n9r"},{"name":"VPS那些事","_id":"ckqjdx1og002s5emuw2d3bdm1"},{"name":"黑苹果","_id":"ckqjdx1oh002z5emueupplfr6"},{"name":"我家云","_id":"ckqjdx1oi00335emufpqu4gyu"},{"name":"OMV","_id":"ckqjdx1oi00355emu2a6k8qa1"},{"name":"armbian","_id":"ckqjdx1oj00365emud1k6bjui"}]}}