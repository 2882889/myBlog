[{"title":"OC使用静态库中的类别","date":"2017-04-05T12:02:30.000Z","path":"2017/04/05/OC使用静态库中的类别/","text":"OC中使用静态库中的类别的问题OC的源文件经过 clang 编译首先生成中间代码,接着通过优化生成目标代码(目标代码中包括符号表,标示了此代码中的全局符号和静态符号,还标示了导入符号等),连接器会根据符号表分析各个目标代码之间的调用关系,然后将使用到的代码进行连接和重定位,最后生成可执行文件. 在编译Objective-C源文件到目标文件时,编译器并不知道方法的对应实现,只能在运行时才知道,所以编译器只会为类生成连接符号,不会对类中的方法生成连接符号,由于Category方法并不对应一个新类,所以不会生成连接符号,连接器也不会将Category方法合并到原始的类中,最终导致连接器忽略了Category方法,不会将其连接到可执行文件中. 在OC使用静态库中的类别,需要设置下面5种方法中的一种 Other Linker Flags 设置 1.通过在Other Linder Flags 添加 -all\\_load 它会告诉编译器对”所有文档中的所有对象文件,不管里面的符号有没有被用到,全部都载入”,这样会产生比较大的二进制文件 2.通过在Other Linder Flags 添加 -force\\_load 和指定路径 e.g: -force\\_load $(SRCROOT)/RHAddressBook/libRHAddressBook.a 这种方法会只载入指定的归档 3.通过在Other Linder Flags 添加 -ObjC ,这个标识告诉编译器”如果在文档中发现了OC代码,就把文档载入” 4.在Xcode里build setting中的 Perform Single-Object PreLink，如果启用这个选项，所有的对象文件都会被合并成一个单文件（这不是真正的链接，所以叫做预链接），这个对象文件（有时被称做主对象文件(master object file)）被添加到文档中。现在如果主对象文件中的任何符号被认为是“在使用”，整个主对象文件都会被认为在使用，这样它里面的OC部分就会被载入了。因为里面的类都被正常符号化了，所以能使从这样的静态库中使用所有的Category 5.最后一种解决方法是在只有Category的源文件里添加Fake symbol。如果你想在运行时使用Category，一定要确保你以某种方法在编译时引用了fake symbol，这会使得对象文件以及它里面的OC代码被载入。例如，它可以是一个有空函数体的函数，也可以是一个被访问的全局变量（例如一个全局的int变量，只要它被读或者写了一次就足够了）。和上面其他的解决方法不一样，这种解决方法可以控制哪些category可以在运行时被编译后的代码使用（可以通过使用这个符号，使它们被链接并变得可用；也可以不使用这个符号，这样链接器就会忽略它）","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"Xcode8报错","date":"2017-03-31T03:02:30.000Z","path":"2017/03/31/Xcode8 报错resource fork, Finder information, or similar detritus not allowed/","text":"Xcode8 报错resource fork, Finder information, or similar detritus not allowed 原因这是因为Xcode8引进的新的安全机制, Code signing不允许app的bundle里面的文件有未知的文件系统扩展属性 解决方法在终端中输入 xattr -lr &lt;path_to_app_bundle&gt; 可以查看存在未知扩展属性的文件 在终端中输入 xattr -cr &lt;path_to_app_bundle&gt; 可以移除所有未知的扩展属性 然后清理Xcode 重新build 工程","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"","date":"2017-03-28T09:49:52.000Z","path":"2017/03/28/Untitled/","text":"AFNetworking 相关网络通讯建立一个TCP协议的连接通常需要三次”握手”,断开一个TCP协议的连接需要四次”挥手” 三次”握手” 1.”Client”端(客户端)发送连接请求报文. 2.”Server”端(服务端)接受连接后回复ACK(指令正确)报文,并为这次连接分配资源 3.”Client”端(客户端)收到ACK报文后像”Server”端发送ACK(指令正确报文),并分配资源 举个栗子: A(客户端)和B(服务端)进行交易 A:”我要的东西带来了么?” (客户端向服务端请求) B:”天王盖地府,先对暗号” (服务端给客户端一个回应,表示知道客户端要请求了,并且准备好了请求资源) A:”小鸡炖蘑菇” (客户端给服务端一个回应,表示自己知道已经连接上服务端,并且知道服务端准备好了,且自己也准备好了) 接头完成,进行可以进行交易(连接成功)","tags":[]},{"title":"Learn JavaScript","date":"2017-01-11T03:10:12.000Z","path":"2017/01/11/JavaScript/","text":"Equality (相等比较符)1234var foo = 42;var bar = 42;var baz = \"42\";var qux = \"life\"; 定义了四个变量在Javascript中 ==是用来比较两个值但是不会判断类型故 foo == baz返回的值是true 使用==比较的时候编译器会先把类型转换成相同的类型,再去比较 因此在JavaScript 要是比较不同类型的两个值可以使用===这样会先判断类型,如果类型不同就会返回false 所以推荐使用===比较 注意: 1.NaN是个特殊的Number,他与所有其他值都不相等,包括它自己1NaN === NaN ; // false 唯一能判断NaN的方法是通过isNaN()函数:1isNaN(NaN); // true 2.浮点数的比较:11/3 === (1 - 2 / 3); //false 这个结果是正确的,出现这个结果这是因为浮点数在运算过程中会产生误差,计算机无法精确的表示无限小数,所以要比较两个浮点数是否相等,只能计算他们之差的绝对值,看是否小于某个阈值: 1Math.abs(1/3 - (1 - 2 / 3)) &lt; 0.0000001; //true TypesnumbersJavaScript中只有一种数字类型 – 64-bit float point,类似于Java中的double类型,所以在JavaScript中1和1.0是相同的值number可以直接做四则运算，规则和数学一致 字符串字符串是以’单引号’或”双引号”括起来的文本,如&#39;abc&#39; &quot;xyz&quot; 注意&#39; &#39;和&quot; &quot;并不是字符串的一部分 如果字符串中包含&#39; 就使用&quot;&quot;把文本包起来,如果字符串中包含&quot; 就需要使用转义字符了\\ 在多行字符串中换行使用的是\\n 但是如果行数太多\\n需要写多个,不方便,在JavaScript中又增加了一种表示方法(ES6),就是将多行文本用`… `括起来,就是键盘上tab键上边的那个按键. 模板字符串多个字符串可以使用+连接起来.字符串也可以是变量如: 123var name = '小王吧';var age = '100';var message = '你好,' + name + ',你现在' + age + '岁'; 同样,如果要连接的变量有很多,使用+就会很不方便,在JavaScript中增加了一种模板字符串的表示(ES6): 123var name = '小王吧';var age = '101';var message = `$&#123;name&#125;,你今年$&#123;age&#125;岁,是不是?` 注意:新的表示方法使用的是` ,就是新的多行文本使用的符号,就是键盘上tab按键上边的那个按键,不能使用&quot;&quot;或&#39;&#39;,那样无法转换变量 字符串操作获取字符的长度 12var name = 'xiao wang ba.';alert(name.length); //13 获取指定位置字符,可以把字符串看成是特殊的数组,对字符串进行下标操作,从0索引开始 123456var name = 'xiao wang ba.';name[0]; //'x'name[1]; //'i'name[4]; //' 'name[12];//'.'name[13];//undefined 超出范围的索引一律返回undefined 注意:给字符串的索引赋值不会有报错,也不会有任何效果,字符串也不会改变 改变字符串为大写 12var name = 'xiao wang ba.';name.toUpperCase(); //返回'XIAO WANG BA.' 改变字符串为小写 12var name = 'Xiao Wang Ba.';name.toLowerCase(); //返回'xiao wang ba.' 注意:如果字符串是中文,则没效果 返回字符串出现的位置 123var name = 'Xiao Wang Ba.';name.indexOf('Wang');//返回5name.indexOf('wang');//如果没有找到指定的子串,返回-1 获取字符串中的子串 123var name = 'xiao wang ba.';name.substring(0,4);//从索引0开始到4(不包括4),返回'xiao'name.substring(10);//从索引10开始到结束,返回'ba.' 布尔值JavaScript中的布尔值有true和false两种值,可以直接用true或false表示,也可以通过布尔运算计算出来 null和undefinednull表示一个”空”的值,同Java中的null,Swift中的nil,Python中的None用法类似.undefined表示”未定义”.JavaScript设计的时候希望用null表示一个空的值,用undefined表示值未定义,但是大多数情况下我们都应该用null.undefined仅仅在判断函数参数是否传递的情况下有用 数组数组是一组按顺序排列的集合,集合的每个值称为元素.JavaScript的数组可以包括任意数据类型.创建方法: 1[1,2,3.14,\"hello\",null,true]; //推荐使用 另一种创建方法: 1new Array(1,2,3); 获取数组的长度 12345var arr = [1,2,3.14,\"hello\",null,true];arr.length;//6//可以给数组的长度赋值,改变数组的大小arr.length = 7;//数组改变为[1,2,3.14,\"hello\",null,true,undefined]arr.length = 4;//数组改变为[1,2,3.14,\"hello\"] 数组可以通过索引来访问每个元素的值,也可以改变索引对应元素的值: 123var arr = [1,2,3.14,\"hello\",null,true];arr[0]; //数组第一个元素,值为1arr[1] = 10;//修改数组第二个元素的值为10 注意:如果通过索引给数组赋值的时候,索引超过了数组长度,数组会被变大 12var arr = ['A', 'B', 'C'];arr[5] = 'F';//arr会变为['A', 'B', 'C', undefined, undefined, 'F']; 获取对应元素的索引 12345var arr = [10, 20 ,'30', 'xyz'];arr.indexOf(10);//元素10的索引是0arr.indexOf(20);//元素20的索引是1arr.indexOf(30);//元素30的索引是 -1 因为没有找到元素arr.indexOf('30');//元素'30'的索引是2 注意：数字30和&#39;30&#39;是不同的元素 获取数组中的部分元素 123var arr =['A','B','C','D','E','F','G'];arr.slice(0,3);//从索引0开始,到索引3结束,但不包括索引3:['A','B','C']arr.slice(3);//从索引3开始到结束:['D','E','F','G'] 注意:slice()的起止参数包括开始索引,不包括结束索引如果不给slice()传递任何参数,它会从头到尾截取所有元素,这个方法可以复制一个array 123456789var arr = ['A','B','C','D','E','F','G'];var aCopy = arr.slice();aCopy; //['A','B','C','D','E','F','G'];aCopy === arr; //falseif(aCopy.toString() === arr.toString()) &#123; alert('一样');//数组相同&#125;else &#123; alert('不一样');//数组不同&#125; 注意:JavaScript比较两个数组是否相同不能直接使用=== 要比较两个数组是否相同,需要先把数组转换成字符串,然后再比较 在数组末尾添加或删除若干元素,push()和pop() 123456789var arr = [1 , 2];arr.push('A','B'); //返回新的长度为4的数组arr; //[1,2,'A','B']arr.pop();//pop()返回'B'arr; // [1,2,'A']arr.pop();arr.pop();arr.pop(); //连续pop 3次arr; //[]arr.pop(); //空数组继续pop不会报错,而是返回undefinedarr;//[] 在数组头部添加或删除若干元素,unshift()和shift() 123456789var arr =[1,2];arr.unshift('A','B');//返回新的长度为4的数组arr;//['A','B',1,2]arr.shift();//'A'arr;//['B',1,2]arr.shift();arr.shift();arr.shift();//连续shift 3次arr;//[]arr.shift();//空数组继续shift不会报错,而是返回undefinedarr;//[] 数组排序sort()可以对当前数组进行排序,它会直接修改当前的数组元素的位置,直接调用时,会按照默认顺序排序 123var arr = ['B','C','A'];arr.sort();arr;//['A','B','C'] 注意 在函数中可以自定义排序条件 数组反转 reverse()可以把数组的元素反转 123var arr = ['A','B','C'];arr.reverse();arr;//['three','two','one'] 数组修改的”万能方法”,可以从指定索引开始删除若干元素,然后再从该位置添加若干元素 123456var arr =['Microsoft','Apple','Yahoo','AOL','Excite','Oracle']arr.splice(2,3,'Google','Facebook');//从索引2开始删除3个元素,然后再添加两个元素,返回删除的元素['Yahoo','AOL','Excite']arr.splice(2,2);//只删除不添加,返回['Google','Facebook']arr;//['Microsoft','Apple','Oracle']arr.splice(2.0,'Google','Facebook');//只添加,不删除,返回[]arr;//['Microsoft','Apple','Google','Facebook','Oracle'] 把两个数组连接起来,返回一个新的数组 1234var arr = ['A','B','C'];var added = arr.concat([1,2,3]);added; //['A','B','C',1,2,3]ARR;//['A','B','C'] 注意 concat()方法并没有修改当前数组,而是返回了一个新的数组 而且concat()可以接收任意个元素和数组,并把所有数组自动拆开,添加到新的数组中 12var arr = ['A','B','C'];arr.concat(1,2,[3,4]);//['A','B','C',1,2,3,4] 把数组的每个元素都用指定的字符串连接起来,然后返回字符串 12var arr = ['A','B','C',1,2,3];arr.join('-'); //'A-B-C-1-2-3' 注意如果数组的元素不是字符串,会自动转换成字符串再连接 多维数组,指的是数组中的某个元素又是一个数组 1var arr = [[1,2,3],[400,500,600],'-']; 上述Array包含3个元素,其中头两个元素本身也是Array 对象对象是一组由键-值组成的无序集合: 12345678var person = &#123; name: 'XiaoWang', tags: ['js', 'web', 'mobile'], age: 12, city: 'shanghai', hasCar: false, zipcode: null&#125;; JavaScript用一个{...} 表示一个对象,键值对以xxx: xxx形式申明,用,隔开,最后一个键值对不需要加 JavaScript对象的键都是字符串类型,值可以是任意数据类型,每个键都是对象的一个属性,获取属性的方法: 12person.name; // 'XiaoWang'person.zipcode; // null 注:var person 是JavaScript的一个变量,person是变量名,变量名是大小写英文,数字,$和_的组合,且不能用数字开头,也不能使用JavaScript中的关键字 strict模式蛋疼的布兰登在设计JavaScript的时候为了赶工期,并没有强制使用var声明变量,如果一个变量没有通过var声明就被使用,这个变量就会被自动声明为全局变量 1i = 10; //i就是一个全局变量 如果在不同的JavaScript文件中,你都使用了同样名字的变量,而且都没有用var声明,那么你就麻烦了. 因此,为了给布兰登填坑,ECMA在后续的规范中推出了strict模式,在strict模式下运行JavaScript代码不允许使用没有var声明的变量,如果有那么就给你报错 启动strict模式的方法很简单,就是在JavaScript代码的第一行写上: 1'use strict'; 注:如果你用的是老爷机,你的浏览器太老了,他会自以为是的把上面那就话当做一个字符串语句执行,如果这样的话还是换个最新版的浏览器吧 Advanced Operaters (高级运算符)取余运算 x = y % 2累加运算 a = 5 c = a++/Users/YaoWanXin/Desktop/app.html resulets : c = 5 and a = 6 c = ++a resulets : c = 6 and a = 6累减运算 a = 5 c = a-- resulets : c = 5 and a = 4 c = --a resulets : c = 4 and a = 4","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"iOS的CF和OC中间的类型转换","date":"2017-01-11T03:10:12.000Z","path":"2017/01/11/bridged/","text":"iOS的CF和OC中间的类型转换Toll-Free bridgedToll-Free bridged 是Core Foundation和Foundation之间交换使用数据类型的技术.即同一数据类型既可作为Core Foundation函数的参数,也可以作为接收者向其发送Objective-C消息. 说的简单点,就是OC中的有些类型,通过Toll-Free bridged 既可以当做Core Foundation的类型使用(CFxxxx),又可以当做Foundation的类型使用(NSxxxx). Toll-Free bridged原理每一个能够bridge的ObjC类，都是一个类簇（class cluster）。类簇是一个公开的抽象类，但其核心功能的是在不同的私有子类中实现的，公开类只暴露一致的接口和实现一些辅助的创建方法。而与该ObjC类相对应的Core Foundation类的内存结构，正好与类簇的其中一个私有子类相同。 举个例子，NSString是一个类簇，一个公开的抽象类，但每次创建一个NSString的实例时，实际上我们会获得其中一个私有子类的实例。而NSString的其中一个私有子类实现既为NSCFString，其内存的结构与CFString是相同的，CFString的isa指针就指向NSCFString类，即CFString对象就是一个NSCFString类的实例。所以，当NSString的实现刚好是NSCFString的时候，他们两者之间的转换是相当容易而直接的，他们就是同一个类的实例。 当NSString的实现不是NSCFString的时候（比如我们自己subclass了NSString），我们调用CF函数，就需要先检查对象的具体实现。如果发现其不是NSCFString，我们不会调用CF函数的实现来获得结果，而是通过给对象发送与函数功能相对应的ObjC消息（调用相对应的NSString的接口）来获得其结果。 例如CFStringGetLength函数，当收到一个作为参数传递进来的对象时，会先确认该对象到底是不是NSCFString实现。如果是的话，就会直接调用CFStringGetLength函数的实现来获得字符串的长度；如果不是的话，会给对象发送length消息（调用NSString的length接口），来得到字符串的长度。 Toll-Free bridged的内存管理在ARC中编译器不知道如何处理这个同时拥有ObjC和CFTypeRef指向的对象,所以你必须为编译器提供额外的信息：将类型显示转换为互换类型；同时可能需明确对象的声明周期。 因此我们需要使用 __bridge, __bridge_retained, __bridge_transfer 修饰符告诉编译器该如何去做。 __bridge1234//objc to cf NSString *str = @\"hello\"; CFStringRef cfStr = (__bridge CFStringRef)str; CFRelease(cfStr);//这里不需要release 编译器会继续负责nsStr的内存管理的事情，不会在bridge的时候retain对象，所以也不需要开发者在CF 一端释放。需要注意的是，当nsStr被释放的时候（比如出了作用域），意味着cfStr指向的对象被释放了，这时如果继续使用cfStr将会引起程序崩溃。 1234//cf to objc CFStringRef cfStr = CFStringCreateWithCString(kCFAllpacatorDefaule,\"hello\",kCFStringEncodingUTF8); NSString *str = (__bridge NSString *)(cfStr); CFRelease(cfStr);//这里需要release bridge的时候编译器不会做任何内存管理的事情，bridge之后，编译器会负责ObjC一端的内存管理的事情。同时，开发者需要负责管理CF 一端的内存管理的事情，需要在bridge之后，负责release对象。 __bridge_retained接着上面的例子，Foundation类型对应的Core Foundation类型时，为了防止str被释放，引起我们使用cfStr的时候程序崩溃，可以使用__bridge_retained修饰符。这意味着，在bridge的时候，编译器会retain对象，而由开发者在CF一端负责release。这样，就算str在objc一端被释放，只要开发者不手动去释放cfStr，其指向的对象就不会被真的销毁。但同时，开发者也必须保证和负责对象的释放。 1234//objc to cf NSString *str = @\"hello\"; CFStringRef cfStr = (__bridge_retained CFStringRef)str; CFRelease(cfStr);//这里不需要release __bridge_transfer当Core Foundation类型转化为Foundation类型时，如果使用bridge修饰符在cf转objc的时候非常的麻烦，我们既需要一个CFTypeRef的变量，还需要在bridge之后负责释放。这时我们可以使用bridge_transfer，意味着在bridge的时候，编译器转移了对象的所有权，开发者不再需要负责对象的释放。 1234//cf to objc CFStringRef cfStr = CFStringCreateWithCString(kCFAllpacatorDefaule,\"hello\",kCFStringEncodingUTF8); NSString *str = (__bridge NSString *)(cfStr); CFRelease(cfStr);//这里需要release 总结 __bridge :编译器在bridge的时候不要做任何事情 __bridge_retained :（ObjC转CF的时候使用）编译器在bridge的时候retain对象，开发者需要在CF一端负责释放对象 __bridge_transfer :（CF转ObjC的时候使用）编译器转移CF对象的所有权，开发者不再需要在CF一端负责释放对象","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"读《iOS与OS X多线程和内存管理》——引用计数","date":"2017-01-11T03:10:12.000Z","path":"2017/01/11/读《iOS与OS X多线程和内存管理》——引用计数/","text":"1. 什么是自动引用计数(ARC)ARC简而言之就是编译器自动进行内存管理，那为什么不叫”自动内存管理”，而叫”自动引用计数”，当然是因为内存管理是的方法是通过引用计数实现的 要说自动引用计数，首先要说什么是”引用计数” 1.1引用计数什么是引用计数，书中举了一个生活中开关房间灯的例子。 简单的描述一下就是，第一个人来的时候要开灯(创建对象)，最后一个人走的时候要关灯(释放对象)，中间来人走人都不需要开关灯。那么办公室里的人数就是引用计数。 1.2内存管理的思考方式内存管理的思考方式总结出来就是下面四点 注：这里还没到ARC所以还是非ARC 1.自己生成的对象，自己所持有 (指通过1234eg:```mmid obj = [NSObject new]; 2.非自己生成的对象，自己也能持有 (指持有通过类方法创建的对象)eg: 12id obj = [NSArray array];[obj retain]; 3.不再需要自己持有的对象时释放 (释放对象)eg: 12id obj = [[NSObject alloc] init];[obj release]; 4.非自己持有的对象无法释放 (多次释放，或未持有释放）eg: 123id obj = [[NSObject alloc] init];[obj release];[obj release]; 对象的操作与Objective-C方法的对应生成并持有对象—— alloc/new/copy/mutableCopy 等持有对象———– retain释放对象———– release废弃对象———– dealloc 2.alloc/retain/release/dealloc 实现书中这个节研究的是alloc/retain/release/dealloc的实现。 讲之前先说一个我不知道的常识，那就是Objective-C的框架，底层的是一个叫Cocoa框架其中包含一个Foundation框架 首先Objective-C内存管理的方法是包含在Cocoa框架中的，这里所说的内存管理是的方法alloc/retain/release/dealloc 指的是 NSObject类的alloc类方法,retain实例方法,release实例方法和dealloc实例方法，但是NSObject类的 框架没有公开过源码，所以这里使用开源软件GNUstep的框架，一个能和Cocoa框架互换的框架，来理解苹果Cocoa框架的实现。123456789101112131415161718192021222324252627282930313233343536373839这里我把代码给大家写出来，供大家参考，但书的作者把有些地方的源码在不改变意思的范围进行了修改### 2.1 alloc 实现 ###GNUstep的```alloc```实现：```mm+(id)alloc&#123; return [self allocWithZone:NSDefaultMallocZone()];&#125;+ (id)allocWithZone:(NSZone *)z&#123; return NSAllocateObject (self, 0, z);&#125;/* ------- NSAllocateObject ------- */struct obj_layout &#123; NSUInteger retained;&#125;;inline id NSAllocateObject (Class aClass, NSUInteger extraBytes, NSZone *zone)&#123; int size = 计算容纳对象所需内存大小； id new = NSZoneMalloc(zone,size); memset(new, 0, size); new = (id)&amp;((struct obj_layout *) new)[1];&#125;/* ----- 简化版alloc ----- */+ alloc&#123; int size = sizeof(struct obj_layout) + 对象大小; struct obj_layout *p = (struct obj_layout *)calloc(1,size); return(id)(p+1);&#125; 简化版的是去掉了 之后的代码，```NSZone``` 是为了防止内存碎片化引入的结构，对内存管理没有影响，所以可以忽略。从简化版的代码中可以看出 ```GNUstep``` 申请的对象的内存比需要的大了 ```sizeof(struct obj_layout)```，这个多出来的空间就是用来存放引用计数的123456789101112131415在非ARC即MRC中是可以通过 ```retainCount``` 查看对象的引用计数的。retainCount的实现:```mm- (NSUInteger)retainCount&#123; return NSExtraRefCount(self) + 1;&#125;inline NSUInteger NSExtraRefCount(id anObject)&#123; return((struct obj_layout *) anObject)[-1].retained;&#125; 2.2 retain 实现GNUstep的 实现：1234567891011121314```mm- (id)retain&#123; NSIncrementExtraRefCount(self); return self;&#125;inline void NSIncrementExtraRefCount(id anObject)&#123; if(((struct obj_layout *)anObject)[-1].retained == UINT_MAX -1) 抛出异常 ((struct obj_layout *)anObject)[-1].retained++;&#125; 2.3 release 实现GNUstep的 实现：1234567891011121314151617```mm- (void)release&#123; if(NSDecrementExtraRefCountWasZero(self)) [self dealloc];&#125;BOOL NSDecrementExtraRefCountWasZero(id anObject)&#123; if(((struct obj_layout *)anObject)[-1].retained == 0)&#123; return YES; &#125;else &#123; ((struct obj_layout *)anObject)[-1].retained--; return NO; &#125;&#125; 2.4dealloc 实现GNUstep的123456789101112```mm- (void)dealloc&#123; NSDeallocateObject(self);&#125;inline void NSDeallocateObject(id anObject)&#123; struct obj_layout *o = &amp;((struct obj_layout *) anObject)[-1]; free(o);&#125; 可以看到 实现引用计数的方法是在变量在内存块头部保存的当前对象的引用计数，默认是0，当调用 ```retainCount``` 时会自动+1，这就说明了自己生成的对象，自己所持有。1234567891011121314151617181920212223242526272829303132333435### 2.5 苹果实现 ###苹果由于官方未公开源代码，根据运行时调用的代码可以看出苹果实现引用计数和 ```GNUsetp``` 的主要区别就是 ```GNUsetp``` 将引用计数存放在内存块头，而苹果使用的是散列表（键为内存块地址的散列值）存放在头部管理引用计数的好处：- 代码量少- 能够统一管理引用计数用内存块和对象用内存块用散列表(引用计数表)管理引用计数的好处：- 对象用内存块的分配无需考虑内存块头部- 引用计数表各记录中存有内存块地址，可从各个记录追溯到各对象的内存块### autorelease ###所谓 ```autorelease``` 就是自动释放，原理就是若某自动变量超出其作用域，该自动变量将被自动废弃GNUstep的 ```autorelease``` 实现：```mm- (id)autorelease&#123; [NSAutoreleasePool addObject:self];&#125;+ (void) addObject:(id)anObj&#123; NSAutoreleasePool *pool = 取得当前NSAutoreleasePool对象 if(pool != nil) &#123; [pool addObject:anObj]; &#125;else &#123; NSLog(@&quot;NSAutoreleasePool对象非存在状态下调用autorelease&quot;)； &#125;&#125; 废弃 方法 ``` drain``` 实现1234567891011121314151617181920```mm- (void)drain&#123; [self dealloc];&#125;- (void)dealloc&#123; [self emptyPool]; [array release];&#125;- (void)emptyPool&#123; for(id obj in array) &#123; [obj release]; &#125;&#125; 查看 中的内容123```mm[NSAutoreleasePool showPools];//此方法只能在iOS中使用 在运行时系统中调用方法 12345/* 函数声明 */extern void _objc_autoreleasePoolPrint();/* 调试处调用 */_objc_autoreleasePoolPrint(); 注：(1).上面的内容全部是本人读《Objective-C高级编程 iOS与OS X多线程和内存管理》一书觉得重点的部分，如果大家感兴趣可以支持一下正版。(2).如果各位看官觉得有什么事小弟说的不对的地方，欢迎指出。(3).这篇基本上都是说引用计数的实现的，还没有涉及到前言提出的问题的解答。(4).看到这里的都是真爱啊。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"appium测试时候的那些事","date":"2017-01-11T03:10:12.000Z","path":"2017/01/11/appium测试时候的那些事/","text":"遇到的问题1.org.openqa.selenium.WebDriverException: Method has not yet been implemented 在使用appium跑java脚本的时候,如果出现异常,提示如上面显示的,说明你的appium安装出现了问题,具体原因是我的appium当时卸载的时候没有完全卸载干净,导致appium无法连接到WebDriverException 解决方法: 卸载appium ,最好再使用清理工具如:cleanMyMac 清理一下残留文件,然后从新安装新的appium ,问题就可以解决,如果还不行,可以新建一个电脑账户,在新的账户中重新搭建appium也可以","tags":[{"name":"appium","slug":"appium","permalink":"http://yoursite.com/tags/appium/"}]},{"title":"读《iOS与OS X多线程和内存管理》——前言","date":"2017-01-11T03:10:12.000Z","path":"2017/01/11/读《iOS与OS X多线程和内存管理》——前言/","text":"前言 都说不会写部落格的程序猿不是好作家，本作家本来想着当一个小小的初级工程师，每天码码界面，终其一生就算了。谁知天有不测风云，人有祸福旦夕，那天在工程中多看了一眼别人的代码，顿时觉得自己的知识储备实在是太匮乏了。 那么究竟是什么样的代码，居然有如此神奇的功效，闲话少叙，上代码： 代码一： 1234567891011121314151617@interface MyView ()@property (nonatomic, weak) UILabel *label;@end@implementation MyView&#123;UILabel *label = [[UILabel alloc] init];label.font = [UIFont systemFontOfSize:14];label.textColor = [UIColor whiteColor];label.textAlignment = NSTextAlignmentCenter;label.text = @\"你好\";[self addSubview:label];_label = label;&#125;@end 就是这么一段代码，如果要让楼主写 则是下面这样的 代码二： 12345678910111213141516@interface MyView ()@property (nonatomic, strong) UILabel *label;@end@implementation MyView&#123;self.label = [[UILabel alloc] init];self.label.font = [UIFont systemFontOfSize:14];self.label.textColor = [UIColor whiteColor];self.label.textAlignment = NSTextAlignmentCenter;self.label.text = @\"你好\";[self addSubview:self.label];&#125;@end 当然你也可以直接用 _label 赋值，这里问题的重点不是set方法和成员变量的区别，而是我的属性用的是 strong 修饰而他的是使用 weak修饰。 本着不耻下问，虚心求教的态度我问了一下我同事，得到了这样的解答： 代码一的属性使用的 weak 修饰，因为在 addSubview： 的时候 self 会强引用 label 对象 weak 修饰的成员变量 _label 弱引用着 label对象 代码二的属性使用 strong 修饰， 在 addSubview： 的时候 self 会强引用 label对象 strong 修饰的成员变量 _label 也强引用着 label 对象 第一种代码的好处是在 self移除 label的时候 label对象就释放了。因为 label只有一个 self强引用着 第二种代码在 self移除label的时候label对象不会释放，因为还有个 _label的变量强引用这 label对象，只有在 self 释放的时候 label 对象才会释放。 本人读书少，仔细一想确实是这么回事，用weak修饰，label对象只被 self强引用，从view上移除后就可以释放，不用等到self释放的时候才释放，创建和释放都很合理(哪里创建哪里释放)。 但是细思极恐，难道我多年来的开发经验是错误的么，用了n年的strong原来是个低效的使用方法。这时候我突然想到了一个面试题，那就是你真的了解属性修饰符的用法么？ 好吧我承认！我不了解，这就是我看这本书的原因。 注：(1).上面的解释不一定是正确的.(2).小弟初来乍到要是有啥说的不对的地方希望各位大大不吝赐教。(3).要是你们有什么意见和建议，也可以随便吐槽。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"my first blog","date":"2017-01-11T03:02:30.000Z","path":"2017/01/11/my-first-blog/","text":"这就是传说中的第一个blog #超级偶像","tags":[{"name":"hello","slug":"hello","permalink":"http://yoursite.com/tags/hello/"}]},{"title":"Hello World","date":"2017-01-11T02:34:00.000Z","path":"2017/01/11/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"ssh连接报错","date":"2016-12-11T03:02:30.000Z","path":"2016/12/11/ssh连接报错/","text":"使用ssh连接远程服务器在使用VPS的时候由于更换了数据中心，导致远程服务ip地址改变，使用ssh连接的时候报如下错误 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!Someone could be eavesdropping on you right now (man-in-the-middle attack)!It is also possible that a host key has just been changed.The fingerprint for the RSA key sent by the remote host is6e:45:f9:a8:af:38:3d:a1:a5:c7:76:1d:02:f8:77:00.Please contact your system administrator.Add correct host key in /home/hostname /.ssh/known_hosts to get rid of this message.Offending RSA key in /var/lib/sss/pubconf/known_hosts:4RSA host key for pong has changed and you have requested strict checking.Host key verification failed. 解决办法找到~/.ssh/路径下的known_hosts打开，删除对应的ip以及对应信息保存就好","tags":[{"name":"VPS那些事","slug":"VPS那些事","permalink":"http://yoursite.com/tags/VPS那些事/"}]},{"title":"centOS Linux系统命令--VPS那些事","date":"2016-12-11T03:02:30.000Z","path":"2016/12/11/centOS系统命令/","text":"升级系统1yum update -y 安装wgetwget是一个从网络上自动下载文件的自由工具，支持通过HTTP、HTTPS、FTP三个最常见的TCP/IP协议下载，并可以使用HTTP代理。wget名称的由来是“World Wide Web”与“get”的结合 1yum -y install wget 查看当前内核版本1uname -r 修改内核1rpm -ivh http://gongju.wn789.com/neihei/kernel-firmware-2.6.32-504.3.3.el6.noarch.rpm 1rpm -ivh http://gongju.wn789.com/neihei/kernel-2.6.32-504.3.3.el6.x86_64.rpm --force 查看内核1rpm -qa | grep kernel 安装锐速破解版1wget -N --no-check-certificate https://github.com/91yun/serverspeeder/raw/master/serverspeeder.sh &amp;&amp; bash serverspeeder.sh 锐速卸载1chattr -i /serverspeeder/etc/apx* &amp;&amp; /serverspeeder/bin/serverSpeeder.sh uninstall -f 查看锐速状态1service serverSpeeder status 锐速相关1service serverSpeeder start | stop | restart 搭建shadowsocks 安装 安装pip1yum install python-setuptools &amp;&amp; easy_install pip 安装shadowsocks1pip install shadowsocks 配置 创建一个文件在1234```cd /etcvi shadowsocks.json 在json文件中写入如下信息 12345678&#123; &quot;server&quot;:&quot;x.x.x.x&quot;, #服务器IP地址 &quot;server_port&quot;:8388, #服务监听端口 &quot;local_port&quot;:1080, #本地连接端口 &quot;password&quot;:&quot;barfoo&quot;, #加密传输使用到的密码 &quot;timeout&quot;:600, #连接超时时间 &quot;method&quot;:&quot;aes-256-cfb&quot; #加密算法&#125; 启动、停止 1ssserver -c /etc/shadowsocks.json -d start | stop 安装使用Apache在Linux中Apache的名字叫 12查看服务器版本 apachectl -v12安装Apache yum install httpd12打开Apache /etc/init.d/httpd start或者httpd -k start | stop | restart12Apache的配置文件路径 /etc/httpd/conf/httpd.conf12## 安装Mysql ## yum list installed | grep mysql#查看是否已经安装yum install mysql-server#安装服务端yum install mysql-devel#这个应该是组件，不知道有什么用yum install mysql#安装客户端 service mysqld start#启动service mysqld stop#停止service mysqld restart#重启mysqladmin -u root password 123456#设置密码mysql -u root -p #登录```","tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"iOS中的枚举","date":"2016-05-11T03:02:30.000Z","path":"2016/05/11/枚举的实现方式(移位枚举)/","text":"普通的枚举第一种实现方式1234typedef enum &#123; EnumTypeTop, EnumTypeBottom&#125;EnumType 第二种实现方式1234typedef NS_ENUM(NSInteger,EnumType) &#123; EnumTypeTop, EnumTypeBottom&#125;; 枚举的作用就是增加程序的可读性,将原来使用数值代表的状态转换成自然语言中有相应含义的单词,所以这样写出来的代码更易读懂。编译器会为枚举分配一个独有的编号,从0开始,每个枚举递增1 移位枚举实现方式12345678910typedef NS_OPTIONS(NSUInteger, EnumType) &#123; EnumTypeNone = 0, // 0000 0000 0 EnumTypeTop = 1&lt;&lt;0, // 0000 0001 1 EnumTypeBottom = 1&lt;&lt;1, // 0000 0010 2 EnumTypeLeft = 1&lt;&lt;2, // 0000 0100 4 EnumTypeRight = 1&lt;&lt;3, // 0000 1000 8 EnumTypeCenter = 1&lt;&lt;4, // 0001 0000 16 EnumTypeHeight = 1&lt;&lt;5, // 0010 0000 32 EnumTypeWidth = 1&lt;&lt;6 // 0100 0000 64&#125; 上面就是一个移位枚举, 和普通的枚举的区别就是,每个状态的值不是递增的,而是用只有1个二进制位的值是1数字表示的,这么做的好处就是可以对状态值进行”位或”运算,从而实现同时使用多个枚举 1234567891011121314151617181920212223242526272829303132333435- (void)testEnum &#123; [self needMutEnum:EnumTypeTop | EnumTypeBottom | EnumTypeLeft | EnumTypeRight | EnumTypeCenter];&#125;- (void)needMutEnum:(EnumType) type &#123; if (type==0) &#123; NSLog(@\"EnumTypeNone\"); return; &#125; if (type &amp; EnumTypeTop) &#123; NSLog(@\"EnumTypeTop\"); &#125; if (type &amp; EnumTypeBottom) &#123; NSLog(@\"EnumTypeBottom\"); &#125; if (type &amp; EnumTypeLeft) &#123; NSLog(@\"EnumTypeLeft\"); &#125; if (type &amp; EnumTypeRight) &#123; NSLog(@\"EnumTypeRight\"); &#125; if (type &amp; EnumTypeCenter) &#123; NSLog(@\"EnumTypeCenter\"); &#125; if (type &amp; EnumTypeHeight) &#123; NSLog(@\"EnumTypeHeight\"); &#125; if (type &amp; EnumTypeWidth) &#123; NSLog(@\"EnumTypeWidth\"); &#125;&#125; 输出 12345EnumTypeTopEnumTypeBottomEnumTypeLeftEnumTypeRightEnumTypeCenter 这样就实现了同时使用多个枚举 原因“位或”和”位与”运算“位或”: 0 | 0 = 0 ; 0 | 1 = 1 ; 1 | 1 = 1;“位与”: 0 &amp; 0 = 0 ; 0 &amp; 1 = 0 ; 1 &amp; 1 = 1; 对移位枚举进行”位或”运算 EnumTypeTop | EnumTypeBottom | EnumTypeLeft | EnumTypeRight | EnumTypeCenter 转换成二进制就是 0000 0001 | 0000 0010 | 0000 0100 | 0000 1000 | 0010 0000 = 0011 1111 其10进制的值时63 所以”needMutEnum”这个方法传入的值 type 是十进制的63, 当使用的时候又用 type 的值和枚举做”位与运算”,63的二进制是 0011 1111 EnumTypeTop的二进制是 0000 0001 ,”位与”运算的结果就是 0000 0001 , 也就是说传入的 type 的值转换成二进制,哪个位上是 1 ,对应的那个类型的枚举就被传入了, 但是要注意的是,如果不需要None的状态,就不要把第一个枚举状态设置成 0 ,直接从0000 0001 设置","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]}]