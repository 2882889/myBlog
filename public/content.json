[{"title":"MAC使用密钥登录VPS","date":"2019-02-12T13:30:12.000Z","path":"2019/02/12/MAC使用密钥登录VPS/","text":"前言今天登录VPS,突然提示如下信息 12Last failed login: Tue Feb 12 07:55:56 EST 2019 from 218.92.1.143 on ssh:nottyThere were 49 failed login attempts since the last successful login. 貌似被别人跑猴子了，所以我就关了密码登录 使用密钥登录MAC默认是有一个密钥的，没有的话先生成一对 接下运行如下命令： 1ssh-copy-id root@X.X.X.X root是你VPS的用户名，后面是IP 运行完会提示输入VPS的密码 如下 123456789/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: &quot;/Users/xxx/.ssh/id_rsa.pub&quot;/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keysroot@X.X.X.X&apos;s password:Number of key(s) added: 1Now try logging into the machine, with: &quot;ssh &apos;root@X.X.X.X&apos;&quot;and check to make sure that only the key(s) you wanted were added. 接下来尝试登录： 1ssh &apos;root@X.X.X.X&apos; 没有问题会直接登录成功 关闭密码登录打开VPS的ssh配置文件 1vi /etc/ssh/sshd_config 找到PasswordAuthentication改yes为no,如果没有就手动添加上 然后保存重启ssh服务 1systemctl restart sshd.service","tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"vim 编辑器使用","date":"2018-11-23T15:32:12.000Z","path":"2018/11/23/vim编辑器使用/","text":"前言最近突然觉得使用vim在终端查看文本特别高大上，就打算研究一下，但是感觉学习成本太大，效率不高，就简单记录一下，方便以后有需要查询 vim 命令打开文件 1vim 文件名 如果没有会新建一个文件 非正常关闭会有.swp的缓存文件 默认打开是命令模式,要想输入要进入 命令模式 yy复制光标所在行 4yy复制光标所在行及下面三行 dd剪切(如果不粘贴就是删除)光标所在行 4dd剪切(如果不粘贴就是删除)光标所在行及下面三行 p粘贴到光标的下面一行 h左移光标 j下移光标 k上移光标 l右移光标 H移动光标到当前屏幕上方 M移动光标到当前屏幕中间 L移动光标到当前屏幕下方 ctrl+f下翻一页 ctrl+b上翻一页 ctrl+d下翻半页 ctrl+u上翻半页 20G光标移动到20行 G光标移动到最后一行 gg光标移动到第一行 w向后跳一个单词的长度,下一个单词的开始 b向前跳一个单词的长度,上一个单词的开始 D删除当前行光标以及后面的内容 u撤销刚刚的操作 ctrl+r反撤销 d0删除当前行光标之前的内容 x删除当前光标的一个内容 X删除当前光标前面的一个内容 v + 移动光标 选中块内容(字母选) V + 移动光标 选中块内容(正行选) &gt;右缩进 &lt;左缩进 .重复上一个命令 r 替换光标内容 R 替换光标以及后面的内容 /+内容搜索内容, (n上一个搜索内容,N下一个搜索内容) 编辑模式命令模式输入i从光标的前面开始编辑 命令模式输入a从光标的后面开始编辑 命令模式输入o从光标下面新起一行编辑 命令模式输入O从光标上面新起一行编辑 命令模式输入I从光标行首开始编辑 命令模式输入A从光标行末开始编辑 按esc退出编辑模式 末行模式末行模式 (命令模式输入:) w保存 q退出 q!强制退出 shift+vv相当于wq %s/abc/123/g把所有的abc替换成123 1,10s/abc/123/g把1到10行的abc替换成123 按esc退出编辑模式","tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Flutter的安装","date":"2018-11-10T11:26:12.000Z","path":"2018/11/10/Flutter的安装/","text":"前言记录一下安装flutter的过程，方便以后查询 安装下载flutter: 终端输入： 1git clone -b beta https://github.com/flutter/flutter.git 添加临时环境变量： 1export PATH=`pwd`/flutter/bin:$PATH 注意：pwd表示当前路径，后面的flutter就是你git下来的文件夹，里面会有一个bin文件夹，这里如果git下来的文件夹不叫flutter，需要改上面的命令为对应的文件名称，而且要和pwd打印出来的路径能连接上 检查依赖： 1flutter doctor 这一步可能需要翻墙，解决办法是添加这两个镜像 12export PUB_HOSTED_URL=https://pub.flutter-io.cnexport FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn 如果flutter doctor跑出什么问题，按照提示解决就好 如果是如下错误，需要在android studio中添加插件 1234 ✗ Flutter plugin not installed; this adds Flutter specific functionality. ✗ Dart plugin not installed; this adds Dart specific functionality.[!] Connected device ! No devices available 如果需要安装dart点同意就好，如果没有其他错误，就表示flutter安装成功","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://yoursite.com/tags/Flutter/"}]},{"title":"UITableViewCell的创建","date":"2018-10-20T11:58:55.000Z","path":"2018/10/20/UITableViewCell的创建/","text":"前言cell的创建通常有两种方法，平时使用的时候没有注意，这里记录一下 UITableViewCell的创建我们都知道iOS中tableview的cell在创建的时候会用到重用机制，简单的说，就是把每个cell绑定一个标识，然后当cell在屏幕中显示的时候，系统首先会去缓冲池中取对应标志的cell，如果没有那就创建一个cell，如果有就直接拿出来使用，当cell滚动出屏幕的时候，系统会把cell放回缓冲池中，这样，缓冲池中最多也就一两个对象，而系统也不需要每次显示都创建对象。 12345678- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;identiffier&quot;]; if (!cell) &#123; cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:@&quot;identiffier&quot;]; &#125; return cell;&#125; 这个是一个默认的tablecell的创建，可以看到 1UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;identiffier&quot;]; 先是去缓冲池去取cell，如果没有再去创建 所以这个写法必须要加上下面的if判断，如果不加，而且缓冲池中没有cell，那么程序就会因为返回一个nil崩溃 12345- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;identiffier&quot; forIndexPath:indexPath]; return cell;&#125; 在iOS6之后，又有了这种创建cell的方法，这种方法不需要写if，也就是说，如果缓冲池中没有，系统会自动的去创建一个cell，但是如果只是这么写还是不够的，系统还是会崩溃，因为你你要告诉tableview用什么标识创建一个什么cell 简单的说，你还要在tableview创建的时候写上下面的方法 1[tableView registerClass:[UITableViewCell class] forCellReuseIdentifier:@&quot;identiffier&quot;]; 这样tableview就知道，在缓冲池中没有cell的时候，需要用什么类创建一个什么标识的cell 总结tableviewcell的重用有两种方法 1UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;identiffier&quot;]; 这种方法不需要注册cell，但如果缓冲池没有需要手动创建 1UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;identiffier&quot; forIndexPath:indexPath]; 这种方法需要注册cell，但是不需要手动创建了","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"rvm管理ruby","date":"2018-08-13T12:13:12.000Z","path":"2018/08/13/rvm管理ruby/","text":"前言最近工程更新开发环境，需要使用ruby的2.4.0以上的版本，而本地的开发环境是2.3.0，记录一下更换ruby方法 1、安装rvmrvm就是Ruby Version Manager，是Ruby的版本管理器 查看rvm版本： 1rvm -v 安装rvm 1curl -L get.rvm.io | bash -s stable 更新修改配置文件使之生效 12source ~/.bashrc source ~/.bash_profile 安装完成后可以再次查看rvm版本，判断是否安装成功 2、升级ruby查看ruby当前版本,以及本地所安装的所有版本 1rvm list 查看ruby所有版本 1rvm list known 安装新版本ruby 2.4.4 1rvm install 2.4.4 切换ruby到需要的版本 1rvm --default use 2.4.4","tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"SSH Key","date":"2018-06-01T07:41:23.000Z","path":"2018/06/01/SSH Key/","text":"前言记录SSH的使用 SSH Key 的生成 一个ssh key是由两个文件组成,一个是私钥名字默认是id_rsa,另一个就是公钥默认名字是id_rsa.pub,两个是配套使用的 Mac系统默认秘钥的存放路径是~/.ssh 如果在存放路径中有公钥和私钥就不需要生成,可以直接使用,如果没有就需要使用下面命令生成一个 1ssh-keygen -t rsa -C &quot;your_email@example.com&quot; 敲完回车首先会让你填写一个文件名,就是生成的ssh文件的文件名,不填写默认会是id_rsa和id_rsa.pub或id_dsa和id_dsa.pub 注意:这里的文件如果输入了文件名,生成的公钥和私钥文件存放的位置是当前命令的位置 输入完文件名回车后会让你输出密码和确认密码,可以为空,但是如果输出了,每次使用ssh的时候都会让你输入密码 输入完密码生成一个ssh key文件就大功告成了 最后会给你一个randomart image这个东西是用来方便比对key是否一样的,以为人们对不图片比对不字符串的接受更容易 SSH Key 的参数-t xxxxxx可以是rsa rsa1 或dsa,这个是几种不同的加密算法 -C &quot;your_email@example.com&quot;生成的时候添加一个注释 -f ~/.ssh/id_rsa_soho 指定保存文件名和位置 其他参数暂时用不到,就不介绍了 多个SSH Key 同时使用如果需要使用多ssh文件给不同的服务器时,就要使用配置文件了 在~/.ssh目录创建一个名字为dconfig的文本文件 里面写如下内容 1234567891011121314151617# 配置github.comHost github.com# 这个是真实的域名地址 HostName github.com# 这是id_rsa的路径 IdentityFile ~/.ssh/id_rsa_github# 配置登录时用什么权限认证--可设为publickey,password,publickey,keyboard-interactive等 PreferredAuthentications publickey# 配置使用用户名 User username1# 配置git.oschina.net Host git.oschina.net HostName git.oschina.net IdentityFile ~/.ssh/id_rsa_oschina PreferredAuthentications publickey User username2 每个ssh文件单独配置一个Host，Host可以随便起，只要配置好HostName和IdentityFile两个属性即可 注意：如果 Host mygithub这样定义的话，命令如下，git的命令应该写成:git clone git@mygithub:123.git 测试配置是否成功,使用如下命令: 1ssh -T git@github.com 附录: Mac下开启/关闭 显示隐藏文件的方法 12显示：defaults write com.apple.finder AppleShowAllFiles -bool true隐藏：defaults write com.apple.finder AppleShowAllFiles -bool false","tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"RAS 加密算法原理","date":"2018-05-02T13:45:12.000Z","path":"2018/05/02/RSA非对称加密/","text":"前言网上看了一下李永乐老师讲的非对称加密的原理，挺有意思的，记录一下 非对称加密传递信息的非对称加密过程： A想要把信息m发送给B B生成两个有相关性的数字，e（公钥）和d（私钥） B把公钥e以公开的形式传给A A通过公钥的某一种算法得到密文C A把密文C传给B B通过私钥d解密密文C，得到信息m RSA加密算法RSA就是一种非对称加密的算法 RSA加密过程： 首页B找出两个质数p，q n = p*q 带入欧拉函数 Φ（n）= （p-1）*（q-1） 找出公钥e ，e需要满足两个条件（1）1&lt;e&lt;Φ（n）(2) e 和 Φ（n）互质 找出私钥d ，d需要满足e*d/Φ（n）余数是1 加密算法：m的e次幂除以n求余数C 解密算法：C的d次方除以n求余数m 安全性A在传播信息的时候传播了n，e，c 解密需要n，d，c 如果想知道私钥d，由上面可知，需要知道Φ（n） Φ（n）需要知道p，q p，q需要知道n，因为n=p*q 求p，q的过程叫分解质因数 但是大数的质因数特别难分解，所以RSA加密算法安全，当然如果可以做到大数质因数分解那么就。。。 eg：量子计算机","tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Linux执行定时脚本","date":"2018-04-11T03:10:12.000Z","path":"2018/04/11/Linux执行定时脚本/","text":"前言新租的的服务器内存有点小，经常在使用一段时间后，就回因为内存不够，导致服务停止，所以写了一个定时启动服务的脚本 定时服务脚本这个脚本的作用就是找到当前任务中有没有叫shadowsocks.json的任务，如果有，就证明服务没挂，那就重启一下，如果没有，就证明服务挂了，那就启动一下 脚本内容如下: 1234567891011#! /bin/shproc_name=&quot;shadowsocks.json&quot;number=`ps -ef | grep $proc_name | grep -v grep | wc -l`if [ $number -eq 0 ];then ssserver -c /etc/shadowsocks.json -d startelse ssserver -c /etc/shadowsocks.json -d restartfi 使用vi编辑完成后保存为xxx.sh 给脚本添加执行权限1chmod 777 xxx.sh 添加定时任务通过crontab命令，在固定时间间隔执行指定的系统指令或shell脚本 crontab其实就是一个定时任务，如果开启的时候，他会按照配置文件中的时间，定时执行指定脚本 crontab服务的开启方法： 12345sudo service crond start #启动服务sudo service crond stop #关闭服务sudo service crond restart #重启服务sudo service crond reload #重新载入配置sudo service crond status #查看服务状态 crontab配置文件的编辑方法： 123crontab -l #查看配置文件内容crontab -e #编辑配置文件内容 crontab配置文件格式： 12345678910# .---------------- minute (0 - 59) # | .------------- hour (0 - 23)# | | .---------- day of month (1 - 31)# | | | .------- month (1 - 12) OR jan,feb,mar,apr ... # | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat # | | | | |# * * * * * command to be executed#eg:* */4 * * * ~/xxx.sh #表示每四分之一小时执行一次xxx.sh脚本","tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Linux权限问题","date":"2018-04-11T03:10:12.000Z","path":"2018/04/11/linux修改权限/","text":"前言在linux/unix上面执行脚本的时候，通常需要脚本有执行权限，这里记录一下设置权限的方法 chmod 命令-rw-rw-r– 权限描述一共十位 第一位表示文件类型:-是文件 d是文件夹 第二位到第四位 表示文件拥有者的权限 第五位到第七位 表示同组者的权限 第八位到第十位 表示其他人的权限 r是读权限 w是写权限 x是运行权限 修改权限: 字母法 u文件拥有者 g文件同组者 o其它人 chmod u=rwx 文件名 chmod g=w 文件名 chmod u=r,g=r,o=r 文件名 所有用户都是读权限 chmod u=,g=,o= 文件名 所以用户都没有权限 数字法 r—4w—2x—1 chmod 137 文件名 拥有者是执行权限,同组者是写执行权限,其它人是读写执行权限","tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"MAC下安装Python3","date":"2018-03-24T14:32:17.000Z","path":"2018/03/24/MAC下安装Python3/","text":"前言MAC os本身是自带Python的,但是不是Python3，这里记录一下安装Python3的步骤 1、安装Xcode步骤： 1）、打开App Store 搜索Xcode,点击安装，安装完成后打开 如果是第一次打开Xcode需要同意License Agreement 2）、然后安装Xcode command line tool 在终端输入 1xcode-select --install 在弹出的窗口中点击安装等待完成 2、安装HOMEBREWHomeBrew的介绍和安装方法可以在其官网找到 HomeBrew官网 1）、在终端输入： 1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 等待HomeBrew安装完成 2）、验证安装结果，在终端输入： 1brew doctor 如果显示Your system is ready to brew. 代表Homebrew安装成功 3、安装Python如前言所说其实MAC os是自带一个Python的,我们可以使用下面命令查看Python版本 1python --version 首先安装Python 终端输入： 1brew install python 完成后Python3就会被安装到/usr/local/Cellar目录下 输入which python3查看python3的命令路径 4、修改系统路径首先查看系统路径，输入： 1echo $PATH 显示出来的路径就是系统搜索命令的路径 如果里面没有Python3的路径，就需要我们手动添加一下 输入： 1sudo emacs /etc/paths 把Python3的路径添加进去 然后按：ctrl+x+c 回复y保存退出 5、注意TensorFlow在Python3.7下目前不支持，而brew的新版本又不支持指定版本Python安装，所以最简单的解决办法是从Python官网下载3.6版本的pkg安装，pkg安装的路径是/Library/Frameworks/Python.framework/ 移除brew安装的Python 12#移除所有版本Pythonbrew uninstall --force python","tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Mac下打造属于你自己的终端","date":"2018-03-16T14:46:17.000Z","path":"2018/03/16/Mac下打造属于你自己的终端/","text":"item2的自定义样式让你的终端用上主题 准备工具 item2 item2是Mac下超好用的一款终端产品,而且是免费的,你可以点击这里 下载到. oh-my-zsh oh-my-zsh是一个管理自己zsh的工具,可以方便得管理自己的item2样式主题 Powerline (可选) Powerline是一个字体补丁,不安装有可能出现乱码,但不是所有的主题都需要 安装过程安装oh-my-zsh首先下载item2,从上面的官网点击download,然后解压下载下来的解压包,拷贝到应用程序中,item2就安装完成了 接着安装oh-my-zsh,直接在终端输入下面的命令 1curl -L https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh | sh 如果想要卸载oh-my-zsh需要在终端输入下面的命令 1uninstall_oh_my_zsh oh-my-zsh安装完成会有如下提示: 1Please look over the ~/.zshrc file to select plugins, themes, and options. 此时你的oh-my-zsh就安装完成了 关掉你的item2然后再重新启动一下看看,样子是不是已经发生变化了 配置oh-my-zshoh-my-zsh安装完成会有一个默认主题的,上面重启之后看到的主题就是默认的主题,下面我们配置一下自定义主题 安装完成后在你的用户目录下面(就是通常的123456789101112`.oh-my-zsh`这个文件夹里面存放着oh-my-zsh的主题文件夹`themes`,配置模板`templates`,字体文件夹`plugins`,日志`log`,库`lib`,工具`tools`等`.zshrc`这个文件是`oh-my-zsh`的配置文件好知道了这些就可以更换主题了:1. 创建一个zsh配置文件到`~`目录 使用`cp`命令拷贝`~/.oh-my-zsh/templates/zshrc.zsh-template`这个文件到`~/.zshrc` 输入: cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc 12注意: 如果你的`~/.zshrc`存在,最好使用下面命令备份一下 cp ~/.zshrc ~/.zshrc.orig 1234 2. 设置zsh为默认的shell 输入: chsh -s /bin/zsh 123456 3. 查看主题 到主题文件夹目录中选一个主题 输入: cd ~/.oh-my-zsh/themes 12345678 查看并选择一个想要设置的主题 4. 修改配置文件 用vim打开oh-my-zsh的配置文件,修改主题名字 输入: vim ~/.zshrc 12345678910111213修改`ZSH_THEME=&quot;xxx&quot;`一行引号中的内容为想要设置的主题名字,保存退出,重启item2.附录:想知道每个主题的样式可以点击这里,[官方对照表](https://github.com/robbyrussell/oh-my-zsh/wiki/themes)如果有自己下载的主题也可以放到`~/.oh-my-zsh/themes`中然后按照上面的方法设置如果有的主题显示乱码,就需要上面的字体补丁,安装方法输入: pip install powerline-status 12如果提示: zsh: command not found: pip 12则先安装pip,输入: sudo easy_install pip ```","tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"hexo部署报错解决","date":"2017-12-06T15:21:15.000Z","path":"2017/12/06/hexo部署报错解决/","text":"前言由于换了一个电脑搭建hexo,在部署的时候报错了，这里记录一下解决办法： 删除.deploy_git 报错操作从git拉下代码，在新搭建的hexo环境中hexo d部署的时候报一下错误 1234567891011121314~/Desktop/myBlog (master ✘)✖✹✭ ᐅ hexo dINFO Deploying: gitINFO Clearing .deploy_git folder...INFO Copying files from public folder...fatal: in unpopulated submodule &apos;.deploy_git&apos;FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlError: fatal: in unpopulated submodule &apos;.deploy_git&apos; at ChildProcess.&lt;anonymous&gt; (/Users/xxx/Desktop/myBlog/node_modules/hexo-util/lib/spawn.js:37:17) at ChildProcess.emit (events.js:182:13) at maybeClose (internal/child_process.js:978:16) at Socket.stream.socket.on (internal/child_process.js:395:11) at Socket.emit (events.js:182:13) at Pipe._handle.close (net.js:616:12) 解决办法解决办法很简单，把博客目录下的.deploy_git删除重新构建部署就好，命令如下 123rm -rf .deploy_githexo ghexo d 看来以后要把这个文件夹添加到.gitignore文件中试试","tags":[{"name":"日常","slug":"日常","permalink":"http://yoursite.com/tags/日常/"}]},{"title":"Learn JavaScript","date":"2017-11-11T13:10:12.000Z","path":"2017/11/11/JavaScript/","text":"前言闲来无事看了看JavaScript,这里记录部分内容。 Equality (相等比较符)1234var foo = 42;var bar = 42;var baz = \"42\";var qux = \"life\"; 定义了四个变量在Javascript中==是用来比较两个值但是不会判断类型故foo == baz返回的值是true 使用==比较的时候编译器会先把类型转换成相同的类型,再去比较 因此在JavaScript 要是比较不同类型的两个值可以使用===这样会先判断类型,如果类型不同就会返回false 所以推荐使用===比较 注意: 1.NaN是个特殊的Number,他与所有其他值都不相等,包括它自己 1NaN === NaN ; // false 唯一能判断NaN的方法是通过isNaN()函数: 1isNaN(NaN); // true 2.浮点数的比较: 11/3 === (1 - 2 / 3); //false 这个结果是正确的,出现这个结果这是因为浮点数在运算过程中会产生误差,计算机无法精确的表示无限小数,所以要比较两个浮点数是否相等,只能计算他们之差的绝对值,看是否小于某个阈值: 1Math.abs(1/3 - (1 - 2 / 3)) &lt; 0.0000001; //true TypesnumbersJavaScript中只有一种数字类型 – 64-bit float point,类似于Java中的double类型,所以在JavaScript中1和1.0是相同的值number可以直接做四则运算，规则和数学一致 字符串字符串是以’单引号’或”双引号”括起来的文本,如&#39;abc&#39; &quot;xyz&quot; 注意&#39; &#39;和&quot; &quot;并不是字符串的一部分 如果字符串中包含&#39; 就使用&quot;&quot;把文本包起来,如果字符串中包含&quot; 就需要使用转义字符了\\ 在多行字符串中换行使用的是\\n 但是如果行数太多\\n需要写多个,不方便,在JavaScript中又增加了一种表示方法(ES6),就是将多行文本用`… `括起来,就是键盘上tab键上边的那个按键. 模板字符串多个字符串可以使用+连接起来.字符串也可以是变量如: 123var name = '小王吧';var age = '100';var message = '你好,' + name + ',你现在' + age + '岁'; 同样,如果要连接的变量有很多,使用+就会很不方便,在JavaScript中增加了一种模板字符串的表示(ES6): 123var name = '小王吧';var age = '101';var message = `$&#123;name&#125;,你今年$&#123;age&#125;岁,是不是?` 注意:新的表示方法使用的是` ,就是新的多行文本使用的符号,就是键盘上tab按键上边的那个按键,不能使用&quot;&quot;或&#39;&#39;,那样无法转换变量 字符串操作获取字符的长度 12var name = 'xiao wang ba.';alert(name.length); //13 获取指定位置字符,可以把字符串看成是特殊的数组,对字符串进行下标操作,从0索引开始 123456var name = 'xiao wang ba.';name[0]; //'x'name[1]; //'i'name[4]; //' 'name[12];//'.'name[13];//undefined 超出范围的索引一律返回undefined 注意:给字符串的索引赋值不会有报错,也不会有任何效果,字符串也不会改变 改变字符串为大写 12var name = 'xiao wang ba.';name.toUpperCase(); //返回'XIAO WANG BA.' 改变字符串为小写 12var name = 'Xiao Wang Ba.';name.toLowerCase(); //返回'xiao wang ba.' 注意:如果字符串是中文,则没效果 返回字符串出现的位置 123var name = 'Xiao Wang Ba.';name.indexOf('Wang');//返回5name.indexOf('wang');//如果没有找到指定的子串,返回-1 获取字符串中的子串 123var name = 'xiao wang ba.';name.substring(0,4);//从索引0开始到4(不包括4),返回'xiao'name.substring(10);//从索引10开始到结束,返回'ba.' 布尔值JavaScript中的布尔值有true和false两种值,可以直接用true或false表示,也可以通过布尔运算计算出来 null和undefinednull表示一个”空”的值,同Java中的null,Swift中的nil,Python中的None用法类似.undefined表示”未定义”.JavaScript设计的时候希望用null表示一个空的值,用undefined表示值未定义,但是大多数情况下我们都应该用null.undefined仅仅在判断函数参数是否传递的情况下有用 数组数组是一组按顺序排列的集合,集合的每个值称为元素.JavaScript的数组可以包括任意数据类型.创建方法: 1[1,2,3.14,\"hello\",null,true]; //推荐使用 另一种创建方法: 1new Array(1,2,3); 获取数组的长度 12345var arr = [1,2,3.14,\"hello\",null,true];arr.length;//6//可以给数组的长度赋值,改变数组的大小arr.length = 7;//数组改变为[1,2,3.14,\"hello\",null,true,undefined]arr.length = 4;//数组改变为[1,2,3.14,\"hello\"] 数组可以通过索引来访问每个元素的值,也可以改变索引对应元素的值: 123var arr = [1,2,3.14,\"hello\",null,true];arr[0]; //数组第一个元素,值为1arr[1] = 10;//修改数组第二个元素的值为10 注意:如果通过索引给数组赋值的时候,索引超过了数组长度,数组会被变大 12var arr = ['A', 'B', 'C'];arr[5] = 'F';//arr会变为['A', 'B', 'C', undefined, undefined, 'F']; 获取对应元素的索引 12345var arr = [10, 20 ,'30', 'xyz'];arr.indexOf(10);//元素10的索引是0arr.indexOf(20);//元素20的索引是1arr.indexOf(30);//元素30的索引是 -1 因为没有找到元素arr.indexOf('30');//元素'30'的索引是2 注意：数字30和&#39;30&#39;是不同的元素 获取数组中的部分元素 123var arr =['A','B','C','D','E','F','G'];arr.slice(0,3);//从索引0开始,到索引3结束,但不包括索引3:['A','B','C']arr.slice(3);//从索引3开始到结束:['D','E','F','G'] 注意:slice()的起止参数包括开始索引,不包括结束索引如果不给slice()传递任何参数,它会从头到尾截取所有元素,这个方法可以复制一个array 123456789var arr = ['A','B','C','D','E','F','G'];var aCopy = arr.slice();aCopy; //['A','B','C','D','E','F','G'];aCopy === arr; //falseif(aCopy.toString() === arr.toString()) &#123; alert('一样');//数组相同&#125;else &#123; alert('不一样');//数组不同&#125; 注意:JavaScript比较两个数组是否相同不能直接使用=== 要比较两个数组是否相同,需要先把数组转换成字符串,然后再比较 在数组末尾添加或删除若干元素,push()和pop() 123456789var arr = [1 , 2];arr.push('A','B'); //返回新的长度为4的数组arr; //[1,2,'A','B']arr.pop();//pop()返回'B'arr; // [1,2,'A']arr.pop();arr.pop();arr.pop(); //连续pop 3次arr; //[]arr.pop(); //空数组继续pop不会报错,而是返回undefinedarr;//[] 在数组头部添加或删除若干元素,unshift()和shift() 123456789var arr =[1,2];arr.unshift('A','B');//返回新的长度为4的数组arr;//['A','B',1,2]arr.shift();//'A'arr;//['B',1,2]arr.shift();arr.shift();arr.shift();//连续shift 3次arr;//[]arr.shift();//空数组继续shift不会报错,而是返回undefinedarr;//[] 数组排序sort()可以对当前数组进行排序,它会直接修改当前的数组元素的位置,直接调用时,会按照默认顺序排序 123var arr = ['B','C','A'];arr.sort();arr;//['A','B','C'] 注意 在函数中可以自定义排序条件 数组反转 reverse()可以把数组的元素反转 123var arr = ['A','B','C'];arr.reverse();arr;//['three','two','one'] 数组修改的”万能方法”,可以从指定索引开始删除若干元素,然后再从该位置添加若干元素 123456var arr =['Microsoft','Apple','Yahoo','AOL','Excite','Oracle']arr.splice(2,3,'Google','Facebook');//从索引2开始删除3个元素,然后再添加两个元素,返回删除的元素['Yahoo','AOL','Excite']arr.splice(2,2);//只删除不添加,返回['Google','Facebook']arr;//['Microsoft','Apple','Oracle']arr.splice(2.0,'Google','Facebook');//只添加,不删除,返回[]arr;//['Microsoft','Apple','Google','Facebook','Oracle'] 把两个数组连接起来,返回一个新的数组 1234var arr = ['A','B','C'];var added = arr.concat([1,2,3]);added; //['A','B','C',1,2,3]ARR;//['A','B','C'] 注意 concat()方法并没有修改当前数组,而是返回了一个新的数组 而且concat()可以接收任意个元素和数组,并把所有数组自动拆开,添加到新的数组中 12var arr = ['A','B','C'];arr.concat(1,2,[3,4]);//['A','B','C',1,2,3,4] 把数组的每个元素都用指定的字符串连接起来,然后返回字符串 12var arr = ['A','B','C',1,2,3];arr.join('-'); //'A-B-C-1-2-3' 注意如果数组的元素不是字符串,会自动转换成字符串再连接 多维数组,指的是数组中的某个元素又是一个数组 1var arr = [[1,2,3],[400,500,600],'-']; 上述Array包含3个元素,其中头两个元素本身也是Array 对象对象是一组由键-值组成的无序集合: 12345678var person = &#123; name: 'XiaoWang', tags: ['js', 'web', 'mobile'], age: 12, city: 'shanghai', hasCar: false, zipcode: null&#125;; JavaScript用一个{...} 表示一个对象,键值对以xxx: xxx形式申明,用,隔开,最后一个键值对不需要加 JavaScript对象的键都是字符串类型,值可以是任意数据类型,每个键都是对象的一个属性,获取属性的方法: 12person.name; // 'XiaoWang'person.zipcode; // null 注:var person 是JavaScript的一个变量,person是变量名,变量名是大小写英文,数字,$和_的组合,且不能用数字开头,也不能使用JavaScript中的关键字 strict模式蛋疼的布兰登在设计JavaScript的时候为了赶工期,并没有强制使用var声明变量,如果一个变量没有通过var声明就被使用,这个变量就会被自动声明为全局变量 1i = 10; //i就是一个全局变量 如果在不同的JavaScript文件中,你都使用了同样名字的变量,而且都没有用var声明,那么你就麻烦了. 因此,为了给布兰登填坑,ECMA在后续的规范中推出了strict模式,在strict模式下运行JavaScript代码不允许使用没有var声明的变量,如果有那么就给你报错 启动strict模式的方法很简单,就是在JavaScript代码的第一行写上: 1'use strict'; 注:如果你用的是老爷机,你的浏览器太老了,他会自以为是的把上面那就话当做一个字符串语句执行,如果这样的话还是换个最新版的浏览器吧 Advanced Operaters (高级运算符)取余运算 x = y % 2累加运算 a = 5 c = a++/Users/YaoWanXin/Desktop/app.html resulets : c = 5 and a = 6 c = ++a resulets : c = 6 and a = 6累减运算 a = 5 c = a-- resulets : c = 5 and a = 4 c = --a resulets : c = 4 and a = 4","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"使用命令行启动Sublime","date":"2017-10-06T14:10:38.000Z","path":"2017/10/06/使用命令行启动Sublime/","text":"使用终端启动Sublime工作中需要经常使用终端，有时候查看文本文件又需要使用Sublime,所以可以用终端调用Sublime是一件很方便的事情 准备工作系统：mac ox 软件：sublime 第一步 查看终端是否能打开Sublime打开终端，cd到任意一个文件夹，输入如下命令： 1/Applications/Sublime\\ Text.app/Contents/SharedSupport/bin/subl . 这时候如果Sublime成功的打开了当前命令所在的文件夹，就说明终端启动成功。 如果无法启动，请查看sublime的路径和名称是否和你安装的相同 .表示打开当前文件夹，如果输入具体文件名称，也可以打开具体文件 第二步 查看终端环境变量在终端输入： 1vim ~/.bash_profile 在里面找到当前系统的环境变量 1export PATH= 注意：如果你安装过zsh,那么你的环境变量应该到~/.zshrc中寻找 如果你的环境变量文件编辑了，那么你需要source 环境变量文件一下你的环境变量文件，使他生效 第三步 创建命令终端执行： 1ln -s /Applications/Sublime\\ Text.app/Contents/SharedSupport/bin/subl /usr/local/bin/subl 然后就搞定了。 前面的路径是sublime的安装路径，后面的路径是设置好的环境变量 在终端中使用下面命令测试一下 1subl . 如果成功打开当前路径文件夹就说明成了，以后使用subl 文件名就可以快速的在终端用Sublime打开文件啦 参考文件： Open Sublime Text from Terminal in macOS mac中的环境变量 sublime 官网描述","tags":[{"name":"日常","slug":"日常","permalink":"http://yoursite.com/tags/日常/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"iOS中的isEqual：和 “==”","date":"2017-06-13T15:32:00.000Z","path":"2017/06/13/iOS中的isEqual：和 “==”/","text":"前言在iOS开发中常常要比较两个值是否一样，通常的做法有两种，就是用isEqual：或者使用== “==” 比较如果用==比较的是两基本类型，则比较的是两个两个基本类型的值，如果比较的是两个对象类型，则比较的是对象的地址 这时如果有两个string： 12NSString *str1 = @&quot;hello&quot;;NSString *str2 = [NSString stringWithFormat:@&quot;hello&quot;]; 这两个string的内容明显是一样的，但是地址却不一样，如果使用==比较就会返回NO 这样就用到我们的isEqual： 注：isEqualToString：会在下面说 isEqual：比较使用isEqual：是想要比较对象的值，而不是地址，注意这里是想要 使用isEqual：比较上面两个字符串，会返回YES 但是这不代表所有的对象使用都会去自动比较对象的值，比如比较两个自己定义的对象的时候，默认情况下他其实还是比较的两个对象的地址 之所以比较字符串会比较两个值，是因为NSString的isEqual： 已经被重写了,注意这里是重写因为isEqual：是NSObject的方法 同时还增加了一个isEqualToString：方法，这里是增加，因为这是NSString自己的方法 同样的还有还多，比如NSDate,NSArray,NSDictionary,NSSet,甚至是UIColor 所以当我们想要比较自己定义的对象的值的时候，我们也要重写自己的isEqual： 重写的时候其实你可以说任何一个比较的对象都是一样的，换句话说只要你觉得符合你的业务逻辑，你就可以说他是一样 重写isEqual：123456789101112131415161718- (BOOL)isEqual:(id)other &#123; if (other == self) return YES; if (!other || ![other isKindOfClass:[self class]]) return NO; return [self isEqualToWidget:other]; &#125; - (BOOL)isEqualToWidget:(MyWidget *)aWidget &#123; if (self == aWidget) return YES; if (![(id)[self name] isEqual:[aWidget name]]) return NO; if (![[self data] isEqualToData:[aWidget data]]) return NO; return YES; &#125; 其实上面的方法可以随意返回，只要你觉得需要","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"OC使用静态库中的类别","date":"2017-06-05T12:02:30.000Z","path":"2017/06/05/OC使用静态库中的类别/","text":"OC中使用静态库中的类别的问题OC的源文件经过 clang 编译首先生成中间代码,接着通过优化生成目标代码(目标代码中包括符号表,标示了此代码中的全局符号和静态符号,还标示了导入符号等),连接器会根据符号表分析各个目标代码之间的调用关系,然后将使用到的代码进行连接和重定位,最后生成可执行文件. 在编译Objective-C源文件到目标文件时,编译器并不知道方法的对应实现,只能在运行时才知道,所以编译器只会为类生成连接符号,不会对类中的方法生成连接符号,由于Category方法并不对应一个新类,所以不会生成连接符号,连接器也不会将Category方法合并到原始的类中,最终导致连接器忽略了Category方法,不会将其连接到可执行文件中. 在OC使用静态库中的类别,需要设置下面5种方法中的一种 Other Linker Flags 设置 1.通过在Other Linder Flags 添加 -all\\_load 它会告诉编译器对”所有文档中的所有对象文件,不管里面的符号有没有被用到,全部都载入”,这样会产生比较大的二进制文件 2.通过在Other Linder Flags 添加 -force\\_load 和指定路径 e.g: -force\\_load $(SRCROOT)/RHAddressBook/libRHAddressBook.a 这种方法会只载入指定的归档 3.通过在Other Linder Flags 添加 -ObjC ,这个标识告诉编译器”如果在文档中发现了OC代码,就把文档载入” 4.在Xcode里build setting中的 Perform Single-Object PreLink，如果启用这个选项，所有的对象文件都会被合并成一个单文件（这不是真正的链接，所以叫做预链接），这个对象文件（有时被称做主对象文件(master object file)）被添加到文档中。现在如果主对象文件中的任何符号被认为是“在使用”，整个主对象文件都会被认为在使用，这样它里面的OC部分就会被载入了。因为里面的类都被正常符号化了，所以能使从这样的静态库中使用所有的Category 5.最后一种解决方法是在只有Category的源文件里添加Fake symbol。如果你想在运行时使用Category，一定要确保你以某种方法在编译时引用了fake symbol，这会使得对象文件以及它里面的OC代码被载入。例如，它可以是一个有空函数体的函数，也可以是一个被访问的全局变量（例如一个全局的int变量，只要它被读或者写了一次就足够了）。和上面其他的解决方法不一样，这种解决方法可以控制哪些category可以在运行时被编译后的代码使用（可以通过使用这个符号，使它们被链接并变得可用；也可以不使用这个符号，这样链接器就会忽略它）","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"synthesize和dynamic","date":"2017-05-24T15:07:32.000Z","path":"2017/05/24/synthesize和dynamic/","text":"@property@property 会生成一个ivar和他的getter/setter方法 但是在protocol和category中只会生成getter/setter方法的声明 @synthesize@synthesize 表示如果属性没有手动实现setter/getter方法，编译器会自动加上getter/setter两个方法,给后面的实例变量 eg： 1@syntheszie var = _var; 如果一个属性这么写了，表示你告诉编译器，生成一个以var命名的setter/getter方法，和一个实例变量_var。如果同时你又自己声明了一个名叫_var的实例变量，那么@synthesize就不会生成实例变量，而是用你声明的那个。也就是两个实例变量是一个。 如果_var你写的是另一个属性的实例变量，那么会编译错误，但是你可以交换两个属性的实例变量。（可是没什么意义） eg： 1@syntheszie var 如果这么写，那么生成的实例变量就是var,这时你自己声明一个_var和var是不冲突的，也就是两个，属性用的是var。 @dynamic@dynamic 表示属性的setter/getter方法由用户自己实现，不自动生成。若没有手动生成，则运行时会报错，因为方法没有实现 eg： 1@dynamic var;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"读《iOS与OS X多线程和内存管理》—— GCD","date":"2017-05-14T13:53:48.000Z","path":"2017/05/14/读《iOS与OS X多线程和内存管理》—— GCD/","text":"前言《iOS与OS X多线程和内存管理》的第三章是对GCD的介绍，GCD就是Grand Central Dispatch,是将应用程序中记述的线程管理用的代码在系统级中实现。说简单点就是，用简单的方法实现多线程 队列 Dispatch Queue队列（Dispatch Queue）是存放任务等待执行处理的地方。既然是队列，那么他要遵循FIFO先进先出原则。 队列有两种： Serial Dispatch Queue (串行队列) Concurrent Dispatch Queue (并行队列) Serial Dispatch Queue（串行队列）的特点是需要等待现在执行中的任务处理结束才可以处理下一个任务 Concurrent Dispatch Queue (并行队列)的特点是不等待现在执行中的任务处理结束，可以并行执行多个处理，但是并行处理的数量取决于当前系统的状态 线程一个CPU执行的CPU命令列是一条无分叉路径，这就是一个线程，所以从队列的种类来看，串行队列始终在使用一个线程处理任务，而并行队列使用的是多个线程处理任务，多个线程的数量取决于当前系统状态 APIGCD使用过程中的各种API 创建和获取队列创建一个串行队列: 1dispatch_queue_t serialDispatchQueue = dispatch_queue_create(&quot;queueName&quot;，DISPATCH_QUEUE_SERIAL); 创建一个并行队列： 1dispatch_queue_t concurrentDispatchQueue = dispatch_queue_create(&quot;queueName&quot;, DISPATCH_QUEUE_CONCURRENT); 创建串行队列和并行队列的方法是一样的，唯一的区别是第二个参数，如果创建的是串行队列，传入DISPATCH_QUEUE_SERIAL就好，如果是创建并行队列，则指定为DISPATCH_QUEUE_CONCURRENT。 创建队列的第一个参数，是队列的名称，他可以在调试器中显示，苹果推荐的名称是，逆序全程域名，你也可以传NULL 获取系统提供的队列： 1234567891011121314//获取主线程队列 （串行队列）dispatch_queue_t mainDispatchQueue = dispatch_get_main_queue();//获取全局队列--高优先级 （并行队列）dispatch_queue_t highQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);//获取全局队列--默认优先级 （并行队列）dispatch_queue_t defaultQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);//获取全局队列--低优先级 （并行队列）dispatch_queue_t lowQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0);//获取全局队列--后台优先级 （并行队列）dispatch_queue_t backgroundQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0); 改变队列优先级在使用dispatch_queue_create函数生成的队列，不管是串行还是并行的都是默认优先级的。要改变优先级需要使用dispatch_set_target_queue函数。 123dispatch_queue_t myQueue = dispatch_queue_create(&quot;queueName&quot;, DISPATCH_QUEUE_SERIAL);dispatch_queue_t globalBackgroundQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND,0);dispatch_set_target_queue(myQueue, globalBackgroundQueue); 这样myQueue的优先级就是DISPATCH_QUEUE_PRIORITY_BACKGROUND的了。 注意，不能改变系统提供的队列的优先级，也就是系统提供的队列不能写在第一个参数中 dispatch_set_target_queue还可以改变队列执行优先级，如果有多个串行任务在多个串行队列中执行，这时如果要防止并行，就可以将多个串行队列，指定到同一个目标串行队列中，原本并行执行的多个串行队列就会变成真正的串行，同时执行一个处理。 延迟执行使用dispatch_after可以实现延迟指定时间执行 12345dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 3ull*NSEC_PER_SEC);dispatch_after(time, dispatch_get_main_queue(), ^&#123; //延迟执行的任务内容&#125;); 注意，这里的延迟是在指定时间追加任务到指定队列，所以有可能有延时，不算绝对精确。 Dispatch GroupDispatch Group可以在多个队列都执行完成后，执行指定队列 123456789dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_group_t group = dispatch_group_create();dispatch_group_async(group,queue, ^&#123;NSLog(@&quot;blk1&quot;);&#125;);dispatch_group_async(group,queue, ^&#123;NSLog(@&quot;blk2&quot;);&#125;);dispatch_group_async(group,queue, ^&#123;NSLog(@&quot;blk3&quot;);&#125;);dispatch_group_notify(group, dispatch_get_main_queue(),^&#123;NSLog(@&quot;done&quot;);&#125;);//dispatch_group_wait(group,DISPATCH_TIME_FOREVER); //指定超时时间 dispatch_barrier_asyncdispatch_barrier_asyne函数会等待在他前面追加在并行队列上的任务全部执行完，然后执行他的任务，在他的任务执行完再恢复并行队列的任务 eg： 123456789dispatch_queue_t queue = dispatch_queue_create(&quot;queueName&quot;,DISPATCH_QUEUE_CONCURRENT);dispatch_async(queue,blk0_for_reading);dispatch_async(queue,blk1_for_reading);dispatch_async(queue,blk2_for_reading);dispatch_async(queue,blk3_for_reading);dispatch_barrier_async(queue, blk_for_writing);dispatch_async(queue,blk4_for_reading);dispatch_async(queue,blk5_for_reading);dispatch_async(queue,blk6_for_reading); dispatch_syncdispatch_sync是同步将block追加到队列中，dispatch_async是非同步的将block追加到队列中，区别就是dispatch_sync会在追加完成后，等待任务执行完，而dispatch_async不做任何等待。 一旦调用dispatch_sync函数，在指定的处理执行结束之前，该函数不会返回，所以该函数容易引起死锁问题，比如在主线程同步添加任务。 dispatch_applydispatch_apply可以按照指定的次数将指定的block追加到指定的队列中，并等待全部处理执行结束 1234dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);dispatch_apply(10, queue, ^(size_t index) &#123; NSLog(@&quot;%zu&quot;,index);&#125;); 因为他也会等待处理执行结束，所以也会有死锁问题。 dispatch_suspend/dispatch_resumedispatch_suspend函数可以挂起指定的队列 dispatch_resume函数可以恢复指定的队列 dispatch_once这是经常写单例使用的方法，dispatch_once函数可以保证在应用程序执行中只执行一次。 eg： 12345static dispatch_once_t pred;dispatch_once(&amp;pred, ^&#123; //do something&#125;);","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"读《iOS与OS X多线程和内存管理》—— 属性","date":"2017-05-10T11:26:12.000Z","path":"2017/05/10/读《iOS与OS X多线程和内存管理》—— 属性/","text":"前言在ARC中是使用所有权修饰符来实现自动引用计数的，但是编程中我们几乎很少显式的写所有权修饰符，而是写属性关键字。 属性与所有权修饰符的对应关系 属性 所有权修饰符 assign __unsafe_unretained copy __strong (赋值的是被复制对象) retain __strong strong __strong unsafe_unretained __unsafe_unretained weak __weak __strong 实现123&#123;id __strong obj = [NSObject alloc] init];&#125; 在编译时会转换成 123id obj = objc_msgSend(NSObject, @selector(alloc));objc_msgSend(obj, @selector(init));objc_release(obj);//变量作用域结束编译器自动插入了release 使用alloc/new/copy/mutableCopy以外的方法 123&#123;id __strong obj = [NSMutableArray array];&#125; 在编译时会转换成 1234567891011id obj = objc_msgSend(NSMutableArray,@selector(array));/*array方法在编译时转换成了&#123;id obj = objc_msgSend(NSMutableArray, @selector(alloc));objc_msgSend(obj, @selector(init));return objc_autoreleaseReturnValue(obj);&#125;*/objc_retainAutoreleasedReturnValue(obj);objc_release(obj);//变量作用域结束编译器自动插入了release objc_retainAutoreleasedReturnValue() 和 objc_autoreleaseReturnValue是成对出现的，用在alloc/new/copy/mutableCopy以外的类方法时 objc_autoreleaseReturnValue函数和objc_autorelease函数不同，objc_autorelease函数会注册对象到autoreleasepool中objc_autoreleaseReturnValue函数会检查使用该函数的方法或函数调用方的执行命令列表，如果在后面紧接着调用objc_retainAutoreleaseReturnValue()函数，则将返回的对象直接传递到方法或函数的调用方，而不注册到autoreleasepool objc_retainAutoreleasedReturnValue函数和objc_retain函数不同，它即便不注册到autoreleasepool中而返回对象，也能够正确地获取对象通过objc_autoreleaseReturnValue函数和objc_retainAutoreleasedReturnValue函数，可以不将对象注册到autoreleasepool中而直接传递 __weak 实现123&#123;id __weak obj1 = obj;//此处假设变量obj附加__strong修饰符且对象被赋值&#125; 在编译时会转换成 123456789101112id obj1;objc_initWeak(&amp;obj1, obj);/*objc_initWeak函数在这里转换成obj1 = 0；objc_storeWeak(&amp;obj1, obj);*/objc_destroyWeak(&amp;obj1);/*objc_destroyWeak函数在这里相当于objc_storeWeak(&amp;obj1, 0);*/ objc_stroeWeak函数把第二个参数的赋值对象的地址作为键值，将第一个参数的附有__weak修饰符的变量的地址注册到weak表中，如果第二个参数为0，则把变量的地址从weak表中删除 weak表与引用计数表相同，都是作为散列表实现的。使用weak表，将废弃的对象的地址作为键值进行检索，就能高速地获取对应的附有__weak修饰符的变量的地址由于一个对象可同时赋值给多个附有__weak修饰符的变量中，所以对于一个键值，可注册多个变量的地址 对象释放时，程序的将进行下面几步： objc_release 执行dealloc _objc_rootDealloc object_dispose objc_destructInstance objc_clear_deallocating objc_clear_deallocating函数做了下面几件事： 从weak表中获取废弃对象的地址为键值的记录（获取所有的__weak修饰的变量的地址） 将所有的__weak修饰的变量的地址，赋值为nil 从weak表中删除该记录 从引用计数表中删除废弃对象的地址为键值的记录 经过以上步骤，__weak修饰符的变量所引用的对象被废弃，且将nil赋值给该变量。由此可知，如果大量使用附有__weak修饰符的变量，则会销毁相应的CPU资源，因此只是在需要避免循环引用时使用__weak修饰符 将自己生成并持有的对象赋值给__weak修饰符修饰的变量时，会引起编译器警告 123&#123;id __weak obj = [[NSObject alloc] init];&#125; 在编译时转换成： 123456id obj;id tmp = objc_msgSend(NSObject, @selector(alloc));objc_msgSend(tmp, @selector(init));objc_initWeak(&amp;obj, tmp);objc_release(tmp);objc_destroyWeak(&amp;object); 自己生成并持有的对象通过objc_initWeak函数被赋值给附有__weak修饰符的变量中，但变量无法持有，故编译器判断其没有持有者，则该对象立即通过objc_release函数被释放和废弃，同时变量也被置nil 使用附有__weak修饰符的变量，即是使用注册到autoreleasepool中的对象 1234&#123;id __weak obj1 = obj;NSLog(@&quot;%@&quot;,obj1);&#125; 可以转化成如下形式 123456id obj1;objc_initWeak(&amp;obj1, obj);id tmp = objc_loadWeakRetained(&amp;obj1);objc_autorelease(tmp);NSLog(@&quot;%@&quot; ,tmp);objc_destroyWeak(&amp;obj1); 和被赋值相比，此处增加了objc_loadWeakRetained函数和objc_autorelease函数 objc_loadWeakRetained函数取出附有__weak 修饰符变量所引用的对象并retain。 objc_autorelease函数将对象注册到autoreleasepool中。 由此可知，__weak修饰符变量所引用的对象像这样被注册到autoreleasepool中，所以在@autoreleasepool 块结束之前都可以放心使用。但是，如果大量地使用附有__weak 修饰符的变量，注册到autorpool的对象也会大量地增加，因此，在使用附有__weak修饰符的变量时，最好先暂时赋值给附有__strong修饰符的变量后再使用 eg： 12345678&#123;id __weak o = obj;NSLog(@&quot;1 %@&quot;, o);NSLog(@&quot;2 %@&quot;, o);NSLog(@&quot;3 %@&quot;, o);NSLog(@&quot;4 %@&quot;, o);NSLog(@&quot;5 %@&quot;, o);&#125; 这样o所赋值的对象注册到autoreleasepool中5次 但使用 123456789&#123;id __weak o = obj;id tmp = o;NSLog(@&quot;1 %@&quot;, tmp);NSLog(@&quot;2 %@&quot;, tmp);NSLog(@&quot;3 %@&quot;, tmp);NSLog(@&quot;4 %@&quot;, tmp);NSLog(@&quot;5 %@&quot;, tmp);&#125; 只会在”tmp = o”时，对象会登录到autoreleasepool中1次 在一些特定环境中是不能使用__weak 修饰符的，而且也存在着不支持__weak修饰符的类，这些类重写了retain/release并实现该类独自的引用计数机制。因此独自实现引用计数机制的类大多数不支持weak修饰符。不支持weak修饰符的类，其类声明中附加了&quot;__attribute__((objc_arc_weak_reference_unavailable))&quot;这一属性，同时定义了&quot;NS_AUTOMATED_REFCOUNT_WEAK_UNAVAILABLE&quot;。如果将不支持__weak声明类的对象赋值给附有__weak修饰符的变量，那么一旦编译器检验出来就会报告编译错误。而且Cocoa框架类中，不支持__weak修饰符的类极为罕见 allowsWeakReference/retainWeakReference方法当allowsWeakReference/retainWeakReference实例方法返回NO时，同样不能使用__weak修饰符 在赋值给__weak修饰符的变量时，如果赋值对象的allowsWeakReference 方法返回NO,程序将异常终止 在赋值给__weak修饰符的变量时，如果赋值对象的retainWeakReference 方法返回NO,该变量将使用nil eg： 123456789&#123;id __strong obj = [[NSObject alloc] init];id __weak o = obj;NSLog(@&quot;1 %@&quot;,o);NSLog(@&quot;2 %@&quot;,o);NSLog(@&quot;3 %@&quot;,o);NSLog(@&quot;4 %@&quot;,o);NSLog(@&quot;5 %@&quot;,o);&#125; 运行结果所有的NSLog都可以打印出地址 如果自定义一个MyObject继承自NSObject的类，并实现retainWeakReference方法 12345- (BOOL)retainWeakReference &#123; if (++count &gt; 3) return NO; return [super retainWeakReference];&#125; 使用MyObject类生成并持有对象 123456789&#123;id __strong obj = [[MyObject alloc] init];id __weak o = obj;NSLog(@&quot;1 %@&quot;,o);NSLog(@&quot;2 %@&quot;,o);NSLog(@&quot;3 %@&quot;,o);NSLog(@&quot;4 %@&quot;,o);NSLog(@&quot;5 %@&quot;,o);&#125; 运行结果4和5的NSLog打印的为nil __autoreleasing 实现123@autoreleasepool &#123; id __autoreleaseing obj = [[NSObject alloc] init];&#125; 在编译的时候转换为 12345id pool = objc_autoreleasePoolPush();id obj = objc_msgSend(NSObject, @selector(alloc));objc_msgSend(obj, @selector(init));objc_autorelease(obj);objc_autoreleasePoolPop(pool); 在alloc/new/copy/mutableCopy方法群之外的方法使用 123@autoreleasepool &#123; id __autoreleasing obj = [NSMutableArray array];&#125; 在编译时转换为 12345id pool = objc_autoreleasePoolPush();id obj = objc_msgSend(NSMutableArray, @selector(array));objc_retainAutoreleasedReturnValue(obj);objc_autorelease(obj);objc_autoreleasePoolPop(pool);","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"读《iOS与OS X多线程和内存管理》—— ARC规则","date":"2017-05-05T13:14:13.000Z","path":"2017/05/05/读《iOS与OS X多线程和内存管理》—— ARC规则/","text":"前言在ARC有效的情况下编译源代码需要遵守的规则 不能使用 retain/release/retainCount/autorelease这些方法都是在MRC中手动管理引用计数的方法，在ARC中，既然自动管理了引用计数了，自然不可以使用了，因为都管理，就会出现冲突 不能使用 NSAllocateObject/NSDeallocateObject不能使用的原因同上 须遵守内存管理的方法命名规则alloc/new/copy/mutableCopy/init以这些名称开始的方法在返回对象是，必须返回给调用方所应当持有的对象。 init是ARC追加的命名规则，切init必须是实例方法，必须要返回对象 不要显式调用 dealloc在对象被释放的时候，系统会自动调用dealloc方法，不需要我们手动调用，原因也很简单，如果手动调用了，就意味着要释放对象，但是这时候如果对象的引用计数不是0，那么引用计数为0就释放对象的规则就失效了。 在MRC时，在dealloc方法中需要显式的调用[super dealloc],但是在ARC时，这是不需要的 使用@autoreleasepool 块替代 NSAutoreleasePool在ARC中使用NSAutoreleasePool会引起编译器报错 不能使用区域（NSZone）无论MRC还是ARC都无法使用。 对象型变量不能作为C语言结构体的成员原因是C语言没有方法来管理结构体成员的生存周期，ARC的内存管理是编译器完成的，所以编译器必须能知道并管理对象的生存周期。 要想把对象型变量加入结构体成员中，可以强制转换为void *或是附加__unsafe_unretained修饰符 显式转换 id 和 void *在MRC时，将id变量强制转换void *变量并不会出问题,如下面代码： 123id obj = [[NSObject alloc] init];void *p = obj;id o = p; 但是在ARC时，是会引起编译错误的，要想在id和void *之间相互赋值，需要__bridge转换。 123id obj = [[NSObject alloc] init];void *p = (__bridge void *)obj;id o = (__bridge id)p; __bridge还有两种转换： __bridge_retained 可以使转换赋值的变量也持有所赋值的对象，相当于目标变量retain __bridge_transfer 可以是被转换的变量所持有的对象在该变量被赋值给转换目标变量后随之释放，就是目标变量retain,自己release","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"读《iOS与OS X多线程和内存管理》—— 自动引用计数","date":"2017-04-26T15:32:33.000Z","path":"2017/04/26/读《iOS与OS X多线程和内存管理》—— 自动引用计数/","text":"前言下面是自动引用计数部分书中内容的笔记 自动引用计数设置前面说到过，自动引用计数（Automatic Reference Counting）简称就是我们现在使用的ARC了，顾名思义自动引用计数就是编译器自动帮我们处理引用计数 在编译的时候，我们可以指定每个文件是否使用ARC，Xcode4.2以后编译器默认为ARC有效。 在创建完工程的时候，我们可以在工程的配置文件中设置工程模式是MRC还是ARC，设置的方法是： 在工程配置文件的，Build Settings中，找到Objective-C Automatic Reference Counting 选项，设置为YES,就是ARC工程模式，设置为NO就是MRC工程模式。 在ARC工程模式或MRC工程模式也可以设置部分文件编译模式与之相反，设置方法： 在Build pyases中的compile source找到对应的文件设置参数-fno-objc-arc为MRC模式，反之-fobjc-arc为ARC模式。 所有权修饰符在引用计数中，我们知道，对象的销毁，是通过引用计数的值来判断的，但是引用计数的值是需要我们手动去维护的，那么要想让编译器去维护引用计数，我们就要通过一些修饰符，去告诉编译器，变量什么时候需要引用计数加一，什么时候引用计数需要减一，那么这个修饰符就是所有权修饰符 在ARC模式下，所有权修饰符有四种： __strong __weak __unsafe_unretained __autoreleasing __strong__strong修饰符是id类型和对象类型的默认所有权修饰符 1id obj = [[NSObject alloc] init]; 1id __strong obj = [[NSObject alloc] init]; 这两种表示方法的结果是一样的 在ARC中，被__strong修饰符修饰的变量，表示对对象的强引用，持有强引用的变量在超出其作用域时被废弃，随着强引用的失效，引用的对象会随之释放 在变量赋值的时候，也会对对象强引用，如果赋值为nil,则强引用失效 __strong也可以修饰在方法参数上，虽然平常我们写的方法上都没有，那是因为默认是不用写的 __weak__weak修饰符，提供弱引用，弱引用不能持有对象实例。__weak修饰符是为了解决__strong修饰符会产生循环引用出现的。 所谓循环引用，就是自己引用自己，或者多个对象相互引用，导致谁都无法释放的问题 __weak修饰符，的另一个作用是，在持有某对象的弱引用时，若该对象被废弃，则此弱引用将自动失效且处于nil被赋值的状态（空弱引用）。 所以，检查__weak修饰符的变量是否为空，可以判断被赋值的对象是否已废弃 __unsafe_unretained__unsafe_unretained修饰符，是不安全的所有权修饰符，被他修饰的变量，是不属于编译器的内存管理对象。 __unsafe_unretained修饰符，和__weak修饰符的作用相似，他也无法持有对象实例，但是他在对象已经释放的时候，仍然指向对象，形成垂悬指针。 所以，在使用__unsafe_unretained修饰符的变量的时候，必须确保被赋值的对象确实存在，不然会导致程序崩溃 __autoreleasing在MRC的时候，NSAutoreleasePool类中的要想让对象自动释放，有个autorelease方法，但是在ARC中，NSAutoreleasePool已经改用@autoreleasepool了，所以，需要__autoreleasing修饰符，来表示对象自动释放。 __autoreleasing和__strong修饰符都不需要显示的添加，因为在使用alloc/new/copy/mutableCopy以外的方法取来的对象，已经被注册到autoreleasepool中了。 在__weak修饰符修饰的变量在访问对象的时候，也会把对象注册到autoreleasepool中 id的指针或者对象的指针在没有显式指定是，也会被加上__autoreleasing修饰符","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"读《iOS与OS X多线程和内存管理》——引用计数(总结)","date":"2017-04-22T14:05:43.000Z","path":"2017/04/22/读《iOS与OS X多线程和内存管理》——引用计数(总结)/","text":"前言上一篇文章介绍了引用计数，用GNUstep的实现，推测了cocoa框架的实现，现在总结一下个人觉得重要的地方，和上一篇没说的地方 非自己生成的对象，自己也能持有这一条内存管理举的例子是 12id obj = [NSArray array];[obj retain]; 开始不是很明白，这里的工厂方法，和普通的初始化有什么区别，个人当时认为的是这也应该算做是自己生成的对象，自己所持有 但是后面说了，[NSArray array]的时候，其实他面会把生成的临时对象[tempObj autorelease],那么反回的时候，就需要[obj retain],因为之前说了，这个地方的内容还没涉及到ARC，所以需要retain一下 NSAutoreleasePool这个东西，说的简单点，就是一个块，让在他里面的东西，都保持状态，不释放，但是出了他的作用域，就全部释放一遍 继续用开关灯那个例子的话，NSAutoreleasePool就相当于一个屋子里面多了一个管理员，对象在NSAutoreleasePool中，就好比管理员在屋子中，所以屋子会一直亮着，而且，管理员肯定是第一个进来，最后一个走，这就保证了，屋子的灯可以由管理员控制，也就是对象的释放时机，是出了NSAutoreleasePool的时候 在ARC中，NSAutoreleasePool是不只直接使用的，你可以使用下面这个： 12345@autoreleasepool&#123;// Code benefitting from a local autorelease pool.&#125; 在自动释放池中，一个对象如果被autorelease了多次，那么在池子释放的时候，对象会被执行多次release 在运行时系统中调用方法 12345/* 函数声明 */extern void _objc_autoreleasePoolPrint();/* 调试处调用 */_objc_autoreleasePoolPrint(); 这个方法在ARC中的调试中可以使用，可以打印出，当前缓冲池中的所有对象，还是比较有用的。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"读《iOS与OS X多线程和内存管理》——引用计数","date":"2017-04-17T11:34:12.000Z","path":"2017/04/17/读《iOS与OS X多线程和内存管理》——引用计数/","text":"前言上一章说了看这本的目的，下面就算是读书笔记吧 1. 什么是自动引用计数(ARC)ARC（Automatic Reference Counting）简而言之就是编译器自动进行内存管理，那为什么不叫”自动内存管理”，而叫”自动引用计数”，当然是因为内存管理是的方法是通过引用计数实现的 要说自动引用计数，首先要说什么是”引用计数” 1.1引用计数什么是引用计数，书中举了一个生活中开关房间灯的例子。 简单的描述一下就是，第一个人来屋子的时候要开灯(创建对象)，最后一个人走的时候要关灯(释放对象)，中间来人走人都不需要开关灯。那么办公室里的人数就是引用计数。也就是有多少个人用着灯 1.2内存管理的思考方式内存管理的思考方式总结出来就是下面四点 注：这里还没到ARC所以还是非ARC 1.自己生成的对象，自己所持有 (指通过alloc/new/copy/mutableCopy等创建的对象)eg: 1id obj = [NSObject new]; 2.非自己生成的对象，自己也能持有 (指持有通过类方法创建的对象)eg: 12id obj = [NSArray array];[obj retain]; 3.不再需要自己持有的对象时释放 (释放对象)eg: 12id obj = [[NSObject alloc] init];[obj release]; 4.非自己持有的对象无法释放 (多次释放，或未持有释放）eg: 123id obj = [[NSObject alloc] init];[obj release];[obj release]; 对象的操作与Objective-C方法的对应生成并持有对象—— alloc/new/copy/mutableCopy 等持有对象———– retain释放对象———– release废弃对象———– dealloc 2.alloc/retain/release/dealloc 实现这一节研究的是alloc/retain/release/dealloc的实现。 讲之前先说一个常识，那就是Objective-C的框架，底层的是一个叫Cocoa框架其中包含一个Foundation框架 首先Objective-C内存管理的方法是包含在Cocoa框架中的，这里所说的内存管理是的方法alloc/retain/release/dealloc 指的是NSObject类的alloc类方法,retain实例方法,release实例方法和dealloc实例方法，但是NSObject类的Foundation框架没有公开过源码，所以这里使用开源软件GNUstep的框架，一个能和Cocoa框架互换的框架，来理解苹果Cocoa框架的实现。 这里我把代码给大家写出来，供大家参考，但书的作者把有些地方的源码在不改变意思的范围进行了修改 2.1 alloc 实现GNUstep的123456789101112131415161718192021222324252627282930313233```mm+(id)alloc&#123; return [self allocWithZone:NSDefaultMallocZone()];&#125;+ (id)allocWithZone:(NSZone *)z&#123; return NSAllocateObject (self, 0, z);&#125;/* ------- NSAllocateObject ------- */struct obj_layout &#123; NSUInteger retained;&#125;;inline id NSAllocateObject (Class aClass, NSUInteger extraBytes, NSZone *zone)&#123; int size = 计算容纳对象所需内存大小； id new = NSZoneMalloc(zone,size); memset(new, 0, size); new = (id)&amp;((struct obj_layout *) new)[1];&#125;/* ----- 简化版alloc ----- */+ alloc&#123; int size = sizeof(struct obj_layout) + 对象大小; struct obj_layout *p = (struct obj_layout *)calloc(1,size); return(id)(p+1);&#125; 简化版的是去掉了NSZone之后的代码，NSZone是为了防止内存碎片化引入的结构，对内存管理没有影响，所以可以忽略。从简化版的代码中可以看出GNUstep申请的对象的内存比需要的大了sizeof(struct obj_layout)，这个多出来的空间就是用来存放引用计数的 在非ARC即MRC中是可以通过retainCount查看对象的引用计数的。 retainCount的实现: 123456789- (NSUInteger)retainCount&#123; return NSExtraRefCount(self) + 1;&#125;inline NSUInteger NSExtraRefCount(id anObject)&#123; return((struct obj_layout *) anObject)[-1].retained;&#125; 2.2 retain 实现GNUstep的retain实现： 123456789101112- (id)retain&#123; NSIncrementExtraRefCount(self); return self;&#125;inline void NSIncrementExtraRefCount(id anObject)&#123; if(((struct obj_layout *)anObject)[-1].retained == UINT_MAX -1) 抛出异常 ((struct obj_layout *)anObject)[-1].retained++;&#125; 2.3 release 实现GNUstep的release实现： 123456789101112131415- (void)release&#123; if(NSDecrementExtraRefCountWasZero(self)) [self dealloc];&#125;BOOL NSDecrementExtraRefCountWasZero(id anObject)&#123; if(((struct obj_layout *)anObject)[-1].retained == 0)&#123; return YES; &#125;else &#123; ((struct obj_layout *)anObject)[-1].retained--; return NO; &#125;&#125; 2.4 dealloc 实现GNUstep的dealloc实现： 12345678910- (void)dealloc&#123; NSDeallocateObject(self);&#125;inline void NSDeallocateObject(id anObject)&#123; struct obj_layout *o = &amp;((struct obj_layout *) anObject)[-1]; free(o);&#125; 可以看到GNUstep实现引用计数的方法是在变量在内存块头部保存的当前对象的引用计数，默认是0，当调用retainCount时会自动+1，这就说明了自己生成的对象，自己所持有。 2.5 苹果实现苹果由于官方未公开源代码，根据运行时调用的代码可以看出苹果实现引用计数和GNUsetp的主要区别就是GNUsetp将引用计数存放在内存块头，而苹果使用的是散列表（键为内存块地址的散列值） 存放在头部管理引用计数的好处： 代码量少 能够统一管理引用计数用内存块和对象用内存块 用散列表(引用计数表)管理引用计数的好处： 对象用内存块的分配无需考虑内存块头部 引用计数表各记录中存有内存块地址，可从各个记录追溯到各对象的内存块 3 autorelease所谓autorelease就是自动释放，原理就是若某自动变量超出其作用域，该自动变量将被自动废弃 GNUstep的autorelease实现： 1234567891011121314- (id)autorelease&#123; [NSAutoreleasePool addObject:self];&#125;+ (void) addObject:(id)anObj&#123; NSAutoreleasePool *pool = 取得当前NSAutoreleasePool对象 if(pool != nil) &#123; [pool addObject:anObj]; &#125;else &#123; NSLog(@\"NSAutoreleasePool对象非存在状态下调用autorelease\")； &#125;&#125; 废弃NSAutoreleasePool方法drain实现 1234567891011121314151617- (void)drain&#123; [self dealloc];&#125;- (void)dealloc&#123; [self emptyPool]; [array release];&#125;- (void)emptyPool&#123; for(id obj in array) &#123; [obj release]; &#125;&#125; 查看AutoreleasePool中的内容 1[NSAutoreleasePool showPools];//此方法只能在iOS中使用 在运行时系统中调用方法 12345/* 函数声明 */extern void _objc_autoreleasePoolPrint();/* 调试处调用 */_objc_autoreleasePoolPrint(); 注：(1).上面的内容全部是本人读《Objective-C高级编程 iOS与OS X多线程和内存管理》一书觉得重点的部分，如果大家感兴趣可以支持一下正版。(2).如果各位看官觉得有什么是小弟说的不对的地方，欢迎指出。(3).这篇基本上都是说引用计数的实现的，还没有涉及到前言提出的问题的解答。(4).看到这里的都是真爱啊。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"读《iOS与OS X多线程和内存管理》——前言","date":"2017-04-13T03:10:12.000Z","path":"2017/04/13/读《iOS与OS X多线程和内存管理》——前言/","text":"前言 都说不会写部落格的程序猿不是好作家，本作家本来想着当一个小小的初级工程师，每天码码界面，终其一生就算了。谁知天有不测风云，人有祸福旦夕，那天在工程中多看了一眼别人的代码，顿时觉得自己的知识储备实在是太匮乏了。 那么究竟是什么样的代码，居然有如此神奇的功效，闲话少叙，上代码： 代码一： 1234567891011121314151617@interface MyView ()@property (nonatomic, weak) UILabel *label;@end@implementation MyView- (void)setupSubview &#123; UILabel *label = [[UILabel alloc] init]; label.font = [UIFont systemFontOfSize:14]; label.textColor = [UIColor whiteColor]; label.textAlignment = NSTextAlignmentCenter; label.text = @\"你好\"; [self addSubview:label]; _label = label;&#125;@end 就是这么一段代码，如果要让楼主写 则是下面这样的 代码二： 12345678910111213141516@interface MyView ()@property (nonatomic, strong) UILabel *label;@end@implementation MyView- (void)setupSubview &#123; self.label = [[UILabel alloc] init]; self.label.font = [UIFont systemFontOfSize:14]; self.label.textColor = [UIColor whiteColor]; self.label.textAlignment = NSTextAlignmentCenter; self.label.text = @\"你好\"; [self addSubview:self.label];&#125;@end 当然你也可以直接用_label赋值，这里问题的重点不是set方法和成员变量的区别，而是我的属性用的是strong修饰而他的是使用weak修饰。 本着不耻下问，虚心求教的态度我问了一下我同事，得到了这样的解答： 代码一的属性使用的weak修饰，因为在addSubview：的时候self会强引用label对象weak修饰的成员变量_label弱引用着label对象 代码二的属性使用strong修饰， 在addSubview：的时候self会强引用label对象 strong 修饰的成员变量_label也强引用着label对象 第一种代码的好处是在self移除label的时候label对象就释放了。因为label只有一个self强引用着 第二种代码在self移除label的时候label对象不会释放，因为还有个_label的变量强引用这label对象，只有在self释放的时候label对象才会释放。 本人读书少，仔细一想确实是这么回事，用weak修饰，label对象只被self强引用，从view上移除后就可以释放，不用等到self释放的时候才释放，创建和释放都很合理(哪里创建哪里释放)。 但是细思极恐，难道我多年来的开发经验是错误的么，用了n年的strong原来是个低效的使用方法。这时候我突然想到了一个面试题， 那就是你真的了解属性修饰符的用法么？ 好吧我承认！我不了解，这就是我看这本书的原因。 注： 上面的解释不一定是正确的。 小弟初来乍到要是有啥说的不对的地方希望各位大大不吝赐教。 要是你们有什么意见和建议，也可以随便吐槽。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"Xcode8 报错resource fork, Finder information, or similar detritus not allowed","date":"2017-03-31T03:02:30.000Z","path":"2017/03/31/Xcode8报错/","text":"Xcode8 报错resource fork, Finder information, or similar detritus not allowed 原因这是因为Xcode8引进的新的安全机制, Code signing不允许app的bundle里面的文件有未知的文件系统扩展属性 解决方法在终端中输入xattr -lr &lt;path_to_app_bundle&gt;可以查看存在未知扩展属性的文件 在终端中输入xattr -cr &lt;path_to_app_bundle&gt;可以移除所有未知的扩展属性 然后清理Xcode 重新build 工程","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"iOS的CF和OC中间的类型转换","date":"2017-01-11T03:10:12.000Z","path":"2017/01/11/iOS的CF和OC中间的类型转换/","text":"iOS的CF和OC中间的类型转换Toll-Free bridgedToll-Free bridged 是Core Foundation和Foundation之间交换使用数据类型的技术.即同一数据类型既可作为Core Foundation函数的参数,也可以作为接收者向其发送Objective-C消息. 说的简单点,就是OC中的有些类型,通过Toll-Free bridged 既可以当做Core Foundation的类型使用(CFxxxx),又可以当做Foundation的类型使用(NSxxxx). Toll-Free bridged原理每一个能够bridge的ObjC类，都是一个类簇（class cluster）。类簇是一个公开的抽象类，但其核心功能的是在不同的私有子类中实现的，公开类只暴露一致的接口和实现一些辅助的创建方法。而与该ObjC类相对应的Core Foundation类的内存结构，正好与类簇的其中一个私有子类相同。 举个例子，NSString是一个类簇，一个公开的抽象类，但每次创建一个NSString的实例时，实际上我们会获得其中一个私有子类的实例。而NSString的其中一个私有子类实现既为NSCFString，其内存的结构与CFString是相同的，CFString的isa指针就指向NSCFString类，即CFString对象就是一个NSCFString类的实例。所以，当NSString的实现刚好是NSCFString的时候，他们两者之间的转换是相当容易而直接的，他们就是同一个类的实例。 当NSString的实现不是NSCFString的时候（比如我们自己subclass了NSString），我们调用CF函数，就需要先检查对象的具体实现。如果发现其不是NSCFString，我们不会调用CF函数的实现来获得结果，而是通过给对象发送与函数功能相对应的ObjC消息（调用相对应的NSString的接口）来获得其结果。 例如CFStringGetLength函数，当收到一个作为参数传递进来的对象时，会先确认该对象到底是不是NSCFString实现。如果是的话，就会直接调用CFStringGetLength函数的实现来获得字符串的长度；如果不是的话，会给对象发送length消息（调用NSString的length接口），来得到字符串的长度。 Toll-Free bridged的内存管理在ARC中编译器不知道如何处理这个同时拥有ObjC和CFTypeRef指向的对象,所以你必须为编译器提供额外的信息：将类型显示转换为互换类型；同时可能需明确对象的声明周期。 因此我们需要使用 __bridge, __bridge_retained, __bridge_transfer 修饰符告诉编译器该如何去做。 __bridge1234//objc to cf NSString *str = @\"hello\"; CFStringRef cfStr = (__bridge CFStringRef)str; CFRelease(cfStr);//这里不需要release 编译器会继续负责nsStr的内存管理的事情，不会在bridge的时候retain对象，所以也不需要开发者在CF 一端释放。需要注意的是，当nsStr被释放的时候（比如出了作用域），意味着cfStr指向的对象被释放了，这时如果继续使用cfStr将会引起程序崩溃。 1234//cf to objc CFStringRef cfStr = CFStringCreateWithCString(kCFAllpacatorDefaule,\"hello\",kCFStringEncodingUTF8); NSString *str = (__bridge NSString *)(cfStr); CFRelease(cfStr);//这里需要release bridge的时候编译器不会做任何内存管理的事情，bridge之后，编译器会负责ObjC一端的内存管理的事情。同时，开发者需要负责管理CF 一端的内存管理的事情，需要在bridge之后，负责release对象。 __bridge_retained接着上面的例子，Foundation类型对应的Core Foundation类型时，为了防止str被释放，引起我们使用cfStr的时候程序崩溃，可以使用__bridge_retained修饰符。这意味着，在bridge的时候，编译器会retain对象，而由开发者在CF一端负责release。这样，就算str在objc一端被释放，只要开发者不手动去释放cfStr，其指向的对象就不会被真的销毁。但同时，开发者也必须保证和负责对象的释放。 1234//objc to cf NSString *str = @\"hello\"; CFStringRef cfStr = (__bridge_retained CFStringRef)str; CFRelease(cfStr);//这里不需要release __bridge_transfer当Core Foundation类型转化为Foundation类型时，如果使用bridge修饰符在cf转objc的时候非常的麻烦，我们既需要一个CFTypeRef的变量，还需要在bridge之后负责释放。这时我们可以使用bridge_transfer，意味着在bridge的时候，编译器转移了对象的所有权，开发者不再需要负责对象的释放。 1234//cf to objc CFStringRef cfStr = CFStringCreateWithCString(kCFAllpacatorDefaule,\"hello\",kCFStringEncodingUTF8); NSString *str = (__bridge NSString *)(cfStr); CFRelease(cfStr);//这里需要release 总结 __bridge :编译器在bridge的时候不要做任何事情 __bridge_retained :（ObjC转CF的时候使用）编译器在bridge的时候retain对象，开发者需要在CF一端负责释放对象 __bridge_transfer :（CF转ObjC的时候使用）编译器转移CF对象的所有权，开发者不再需要在CF一端负责释放对象","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"centOS Linux系统命令--VPS那些事","date":"2016-12-11T03:02:30.000Z","path":"2016/12/11/centOS系统命令/","text":"升级系统1yum update -y 安装wgetwget是一个从网络上自动下载文件的自由工具，支持通过HTTP、HTTPS、FTP三个最常见的TCP/IP协议下载，并可以使用HTTP代理。wget名称的由来是“World Wide Web”与“get”的结合 1yum -y install wget 查看当前内核版本1uname -r 修改内核1rpm -ivh http://gongju.wn789.com/neihei/kernel-firmware-2.6.32-504.3.3.el6.noarch.rpm 1rpm -ivh http://gongju.wn789.com/neihei/kernel-2.6.32-504.3.3.el6.x86_64.rpm --force 查看内核1rpm -qa | grep kernel 安装锐速破解版1wget -N --no-check-certificate https://github.com/91yun/serverspeeder/raw/master/serverspeeder.sh &amp;&amp; bash serverspeeder.sh 锐速卸载1chattr -i /serverspeeder/etc/apx* &amp;&amp; /serverspeeder/bin/serverSpeeder.sh uninstall -f 查看锐速状态1service serverSpeeder status 锐速相关1service serverSpeeder start | stop | restart 搭建shadowsocks 安装 安装pip 1yum install python-setuptools &amp;&amp; easy_install pip 安装shadowsocks 1pip install shadowsocks 配置 创建一个文件在/etc/shadowsocks.json 123cd /etcvi shadowsocks.json 在json文件中写入如下信息 12345678&#123; &quot;server&quot;:&quot;x.x.x.x&quot;, #服务器IP地址 &quot;server_port&quot;:8388, #服务监听端口 &quot;local_port&quot;:1080, #本地连接端口 &quot;password&quot;:&quot;barfoo&quot;, #加密传输使用到的密码 &quot;timeout&quot;:600, #连接超时时间 &quot;method&quot;:&quot;aes-256-cfb&quot; #加密算法&#125; 启动、停止 1ssserver -c /etc/shadowsocks.json -d start | stop 配置定时任务 在vps的内存比较小的时候，shadowsocks容易被系统给kill掉，这时，我们就要有个定时任务去查看shadowsocks的服务状态 首先，创建一个查看服务脚本 1234567891011#! /bin/shproc_name=&quot;shadowsocks.json&quot;number=`ps -ef | grep $proc_name | grep -v grep | wc -l`if [ $number -eq 0 ];then ssserver -c /etc/shadowsocks.json -d startelse ssserver -c /etc/shadowsocks.json -d restartfi 给脚本添加运行权限 1chmod 777 xxxx.sh 将脚本加入定时任务中 1crontab -e //打开定时任务配置 加入上面的脚本 1*/1 * * * * ./xxx.sh //注意脚本路径 启动定时任务 1service crond start 安装使用Apache在Linux中Apache的名字叫httpd 查看服务器版本 1apachectl -v 安装Apache 1yum install httpd 打开Apache 123/etc/init.d/httpd start或者httpd -k start | stop | restart Apache的配置文件路径 1/etc/httpd/conf/httpd.conf 安装Mysql12345678910yum list installed | grep mysql#查看是否已经安装yum install mysql-server#安装服务端yum install mysql-devel#这个应该是组件，不知道有什么用yum install mysql#安装客户端service mysqld start#启动service mysqld stop#停止service mysqld restart#重启mysqladmin -u root password 123456#设置密码mysql -u root -p #登录","tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"ssh连接报错","date":"2016-12-11T03:02:30.000Z","path":"2016/12/11/ssh连接报错/","text":"使用ssh连接远程服务器在使用VPS的时候由于更换了数据中心，导致远程服务ip地址改变，使用ssh连接的时候报如下错误 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!Someone could be eavesdropping on you right now (man-in-the-middle attack)!It is also possible that a host key has just been changed.The fingerprint for the RSA key sent by the remote host is6e:45:f9:a8:af:38:3d:a1:a5:c7:76:1d:02:f8:77:00.Please contact your system administrator.Add correct host key in /home/hostname /.ssh/known_hosts to get rid of this message.Offending RSA key in /var/lib/sss/pubconf/known_hosts:4RSA host key for pong has changed and you have requested strict checking.Host key verification failed. 解决办法找到~/.ssh/路径下的known_hosts打开，删除对应的ip以及对应信息保存就好","tags":[{"name":"VPS那些事","slug":"VPS那些事","permalink":"http://yoursite.com/tags/VPS那些事/"}]},{"title":"Hexo创建一个blog","date":"2016-08-03T12:38:44.000Z","path":"2016/08/03/Hexo创建一个blog/","text":"post布局当你的Hexo已经搭建完成的时候，你就可以写blog了，最简单的创建一个blog的方法就是调用 1hexo new blog_title 执行完成之后，hexo会在根目录的source文件夹下创建一个_post文件夹，并在里面生成一个blog_title.md文件。 这个创建blog的完整命令是 1hexo new post blog_title 这个就是post布局，当hexo g 或者 s 或者 d的时候，会把_post文件夹中的文件都生成静态页面 draft布局1hexo new draft blog_title 当使用draft布局创建一个博客的时候，hexo也会在根目录的source文件夹下创建一个_draft文件夹，并在里面生成一个blog_title.md文件， 但是在hexo g 或者 s 或者 d的时候，是无法看到你创建的博客的 因为draft布局是草稿布局，在_draft文件夹中的博客都认为是草稿，不能发布 那当你想看看你的草稿写出来的效果怎么样的时候，你可以使用下面命令将草稿部署到本地 12hexo g --drafthexo s --draft 如果你的博客已经完成了，你可以使用下面的命令将他发布 1hexo publish draft blog_title.md page布局1hexo new page &quot;about&quot; 当使用page布局创建一个博客的时候，hexo会在根目录的source文件夹下创建一个about文件夹，并在里面生成一个index.md文件 当你部署完，你需要使用子路径去访问他 eg： 1http://localhost:4000/about","tags":[{"name":"日常","slug":"日常","permalink":"http://yoursite.com/tags/日常/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"Hexo的安装和使用","date":"2016-08-02T11:13:00.000Z","path":"2016/08/02/Hexo的安装和使用/","text":"一、hexo的安装1、安装Node.jsHexo是基于Node.js的静态博客框架，所以要安装Hexo先要安装Node.js。 Node.js的安装方法非常简单，从Node.js官网下载安装包安装就好 2、安装gitmac下安装了Xcode就会有git 3、安装Hexo在终端执行如下命令 1sudo npm install -g hexo 等待安装成功 安装完成后使用查看版本命令，看看是否安装成功 1hexo -v 如果正常显示版本说明安装成功 注意如果报如下错误： 123456789101112Error: The module &apos;/Users/***/Desktop/***/node_modules/dtrace-provider/build/Release/DTraceProviderBindings.node&apos;was compiled against a different Node.js version usingNODE_MODULE_VERSION 48. This version of Node.js requiresNODE_MODULE_VERSION 67. Please try re-compiling or re-installingthe module (for instance, using `npm rebuild` or `npm install`). at Object.Module._extensions..node (internal/modules/cjs/loader.js:751:18) at Module.load (internal/modules/cjs/loader.js:620:32) at tryModuleLoad (internal/modules/cjs/loader.js:560:12) at Function.Module._load (internal/modules/cjs/loader.js:552:3) at Module.require (internal/modules/cjs/loader.js:658:17) ... 执行下面操作： 1231. cd hexo 根目录2. rm -rvf node_modules3. npm install 这是因为node_modules的缓存存在版本问题 二、hexo的使用创建一个blog库1hexo init blog blog是文件夹的名称，可以随便起 创建一个blog1hexo new blog_title 这个样就可以创建一个title是blog_title的博客了 这个只是一个默认参数的简写命令 生成静态页面123hexo generate 或者：hexo g 部署到本地123hexo server 或者：hexo s 部署完可以在浏览器中打开预设的地址查看blog 部署到远端123hexo deploy 或者：hexo d 要部署到远端需要配置博客更目录下的_config.yml文件中的内容 1234deploy: type: git repo: 自己的git地址 branch: master","tags":[{"name":"日常","slug":"日常","permalink":"http://yoursite.com/tags/日常/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"iOS中的枚举","date":"2016-05-11T03:02:30.000Z","path":"2016/05/11/枚举的实现方式(移位枚举)/","text":"普通的枚举第一种实现方式1234typedef enum &#123; EnumTypeTop, EnumTypeBottom&#125;EnumType 第二种实现方式1234typedef NS_ENUM(NSInteger,EnumType) &#123; EnumTypeTop, EnumTypeBottom&#125;; 枚举的作用就是增加程序的可读性,将原来使用数值代表的状态转换成自然语言中有相应含义的单词,所以这样写出来的代码更易读懂。编译器会为枚举分配一个独有的编号,从0开始,每个枚举递增1，也可以使用= 指定需要的值 移位枚举实现方式12345678910typedef NS_OPTIONS(NSUInteger, EnumType) &#123; EnumTypeNone = 0, // 0000 0000 0 EnumTypeTop = 1&lt;&lt;0, // 0000 0001 1 EnumTypeBottom = 1&lt;&lt;1, // 0000 0010 2 EnumTypeLeft = 1&lt;&lt;2, // 0000 0100 4 EnumTypeRight = 1&lt;&lt;3, // 0000 1000 8 EnumTypeCenter = 1&lt;&lt;4, // 0001 0000 16 EnumTypeHeight = 1&lt;&lt;5, // 0010 0000 32 EnumTypeWidth = 1&lt;&lt;6 // 0100 0000 64&#125; 上面就是一个移位枚举, 和普通的枚举的区别就是,每个状态的值不是递增的,而是用只有1个二进制位的值是1数字表示的,这么做的好处就是可以对状态值进行”位或”运算,从而实现同时使用多个枚举 1234567891011121314151617181920212223242526272829303132333435- (void)testEnum &#123; [self needMutEnum:EnumTypeTop | EnumTypeBottom | EnumTypeLeft | EnumTypeRight | EnumTypeCenter];&#125;- (void)needMutEnum:(EnumType) type &#123; if (type==0) &#123; NSLog(@\"EnumTypeNone\"); return; &#125; if (type &amp; EnumTypeTop) &#123; NSLog(@\"EnumTypeTop\"); &#125; if (type &amp; EnumTypeBottom) &#123; NSLog(@\"EnumTypeBottom\"); &#125; if (type &amp; EnumTypeLeft) &#123; NSLog(@\"EnumTypeLeft\"); &#125; if (type &amp; EnumTypeRight) &#123; NSLog(@\"EnumTypeRight\"); &#125; if (type &amp; EnumTypeCenter) &#123; NSLog(@\"EnumTypeCenter\"); &#125; if (type &amp; EnumTypeHeight) &#123; NSLog(@\"EnumTypeHeight\"); &#125; if (type &amp; EnumTypeWidth) &#123; NSLog(@\"EnumTypeWidth\"); &#125;&#125; 输出 12345EnumTypeTopEnumTypeBottomEnumTypeLeftEnumTypeRightEnumTypeCenter 这样就实现了同时使用多个枚举 原因“位或”和”位与”运算“位或”: 0 | 0 = 0 ; 0 | 1 = 1 ; 1 | 1 = 1; “位与”: 0 &amp; 0 = 0 ; 0 &amp; 1 = 0 ; 1 &amp; 1 = 1; 对移位枚举进行”位或”运算EnumTypeTop | EnumTypeBottom | EnumTypeLeft | EnumTypeRight | EnumTypeCenter 转换成二进制就是 0000 0001 | 0000 0010 | 0000 0100 | 0000 1000 | 0010 0000 = 0011 1111 其10进制的值时63 所以”needMutEnum”这个方法传入的值type是十进制的63, 当使用的时候又用type的值和枚举做”位与运算”,63的二进制是 0011 1111 EnumTypeTop的二进制是 0000 0001 ,”位与”运算的结果就是 0000 0001 , 也就是说传入的type的值转换成二进制,哪个位上是1,对应的那个类型的枚举就被传入了, 但是要注意的是,如果不需要None的状态,就不要把第一个枚举状态设置成0,直接从0000 0001 设置","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]}]