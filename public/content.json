[{"title":"","date":"2018-12-03T14:55:12.065Z","path":"2018/12/03/枚举的实现方式(移位枚举)/枚举的实现方式(移位枚举)/","text":"##普通的枚举 ###第一种实现方式 1234typedef enum &#123; EnumTypeTop, EnumTypeBottom&#125;EnumType ###第二种实现方式 1234typedef NS_ENUM(NSInteger,EnumType) &#123; EnumTypeTop, EnumTypeBottom&#125;; 枚举的作用就是增加程序的可读性,将原来使用数值代表的状态转换成自然语言中有相应含义的单词,所以这样写出来的代码更易读懂。编译器会为枚举分配一个独有的编号,从0开始,每个枚举递增1 ##移位枚举 ###实现方式 1234567891011typedef NS_OPTIONS(NSUInteger, EnumType) &#123; EnumTypeNone = 0, // 0000 0000 0 EnumTypeTop = 1&lt;&lt;0, // 0000 0001 1 EnumTypeBottom = 1&lt;&lt;1, // 0000 0010 2 EnumTypeLeft = 1&lt;&lt;2, // 0000 0100 4 EnumTypeRight = 1&lt;&lt;3, // 0000 1000 8 EnumTypeCenter = 1&lt;&lt;4, // 0001 0000 16 EnumTypeHeight = 1&lt;&lt;5, // 0010 0000 32 EnumTypeWidth = 1&lt;&lt;6 // 0100 0000 64 &#125; 上面就是一个移位枚举, 和普通的枚举的区别就是,每个状态的值不是递增的,而是用只有1个二进制位的值是1数字表示的,这么做的好处就是可以对状态值进行”位或”运算,从而实现同时使用多个枚举 123456789101112131415161718192021222324252627282930313233343536- (void)testEnum &#123; [self needMutEnum:EnumTypeTop | EnumTypeBottom | EnumTypeLeft | EnumTypeRight | EnumTypeCenter];&#125; - (void)needMutEnum:(EnumType) type &#123; if (type==0) &#123; NSLog(@\"EnumTypeNone\"); return; &#125; if (type &amp; EnumTypeTop) &#123; NSLog(@\"EnumTypeTop\"); &#125; if (type &amp; EnumTypeBottom) &#123; NSLog(@\"EnumTypeBottom\"); &#125; if (type &amp; EnumTypeLeft) &#123; NSLog(@\"EnumTypeLeft\"); &#125; if (type &amp; EnumTypeRight) &#123; NSLog(@\"EnumTypeRight\"); &#125; if (type &amp; EnumTypeCenter) &#123; NSLog(@\"EnumTypeCenter\"); &#125; if (type &amp; EnumTypeHeight) &#123; NSLog(@\"EnumTypeHeight\"); &#125; if (type &amp; EnumTypeWidth) &#123; NSLog(@\"EnumTypeWidth\"); &#125;&#125; 输出 12345EnumTypeTopEnumTypeBottomEnumTypeLeftEnumTypeRightEnumTypeCenter 这样就实现了同时使用多个枚举 ####原因“位或”和”位与”运算“位或”: 0 | 0 = 0 ; 0 | 1 = 1 ; 1 | 1 = 1;“位与”: 0 &amp; 0 = 0 ; 0 &amp; 1 = 0 ; 1 &amp; 1 = 1; 对移位枚举进行”位或”运算EnumTypeTop | EnumTypeBottom | EnumTypeLeft | EnumTypeRight | EnumTypeCenter 转换成二进制就是 0000 0001 | 0000 0010 | 0000 0100 | 0000 1000 | 0010 0000 = 0011 1111 其10进制的值时63 所以”needMutEnum”这个方法传入的值123456789使用的时候又用```type```的值和枚举做&quot;位与运算&quot;63的二进制是 0011 1111 EnumTypeTop的二进制是 0000 0001&quot;位与&quot;运算的结果就是 0000 0001也就是说传入的```type```的值转换成二进制,那个位上是```1```,对应的那个类型的枚举就被传入了但是要注意的是,如果不需要None的状态,就不要把第一个枚举状态设置成```0","tags":[]},{"title":"","date":"2018-12-03T14:55:12.064Z","path":"2018/12/03/Xcode8 报错resource fork, Finder information, or similar detritus not allowed/Xcode8 报错resource fork, Finder information, or similar detritus not allowed/","text":"原因这是因为Xcode8引进的新的安全机制, Code signing不允许app的bundle里面的文件有未知的文件系统扩展属性 解决方法在终端中输入 xattr -lr &lt;path_to_app_bundle&gt; 可以查看存在未知扩展属性的文件 在终端中输入 xattr -cr &lt;path_to_app_bundle&gt; 可以移除所有未知的扩展属性 然后清理Xcode 重新build 工程","tags":[]},{"title":"","date":"2018-12-03T14:55:12.064Z","path":"2018/12/03/内存管理/内存管理/","text":"NSObject 类的alloc方法执行过程当一个NSObject类调用了 alloc 类方法,其内部的调用顺序是 1.+alloc 2.+allocWithZone: 3.class_createInstance 4.calloc retainCount/retain/release 实例方法的实现1234567891011- retainCount__CFDoExternRefOperationCFBasicHashGetCountOfKey- retain__CFDoExternRefOperationCFBasicHashAddValue- release__CFDoExternRefOperationCFBasicHashRemoveValue //CFBasicHashRemoveValue返回0时 release会调用dealloc __CFDoExternRefOperation 干的事情就是获取对应对象存放引用计数的hash(散列)表,然后对表调用对应的操作的hash(散列)表操作 _objc_autoreleasePoolPrint() 运行此函数,会在控制台打印出AutoreleasePoolPage类使用情况 ARC同一个程序中按文件为单位可以选择ARC有效/无效 设置ARC有效的编译方法1.使用clang(LLVM编译器)3.0或以上版本2.指定编译器属性为”-fobjc-arc” 具体步骤 在工程文件中选择Build Phases =&gt; Compile Sources =&gt; 找到对应要修改的类双击 =&gt;在里面输入”-fobjc-arc”则当前类开启arc,如果输入”-fno-objc-arc”则当前类使用mrc; 注意:xcode 从4.2之后默认是开启arc的","tags":[]},{"title":"","date":"2018-12-03T14:55:12.064Z","path":"2018/12/03/加密算法/加密算法/","text":"假设有当前情景:A要发送一条消息”你好”给B 如果不使用任何加密方法,直接发送,消息一旦被C截获,C就知道了消息的内容 对称加密算法如果A和B事先约定好了一个规则,比如”1”代表”你”,”2”代表”好”,那么A给B发送消息的时候就可以发送”12”,B收到消息后通过查看约定的规则知道A发送的消息是”你好”,如果消息被C截获,C并不知道约定的规则,所以C得到的消息就是”12”,这对C来说是完全没有意义的,因为C并不知道”12”的真正的意义,这就做到了简单的数据加密 上面的过程就是一个简化的”对称加密算法” 数据发信方将明文（原始数据）和加密密钥（miyao）一起经过特殊加密算法处理后，使其变成复杂的加密密文发送出去。收信方收到密文后，若想解读原文，则需要使用加密用过的密钥及相同算法的逆算法对密文进行解密，才能使其恢复成可读明文。在对称加密算法中，使用的密钥只有一个，发收信双方都使用这个密钥对数据进行加密和解密，这就要求解密方事先必须知道加密密钥","tags":[]},{"title":"","date":"2018-12-03T14:55:12.063Z","path":"2018/12/03/Blocks/","text":"Blocks什么是Blocks12345678910111213匿名函数，通过```Blocks``` 源码中能够使用不带名称的函数## Block 截获自动变量的值 ##```blocks```被称为“带有自动变量（局部变量）的匿名函数”那么```blocks```如何带自动变量呢？ void subMain() { int val = 10; char *fmt = &quot;the val is %d&quot;; void (^blk)(void) = ^{printf(fmt,val);}; blk();//the val is 10 val = 2; blk();//the val is 10 }123456上面这个函数中两次调用block变量 blk，输出的都是“the val is 10”，因为block截获自动变量的值，所谓block截获自动变量的值，指的是在block表达式中会保存该自动变量的瞬间值如果要在block中改变局部变量呢？ void subMain() { int val = 10; char *fmt = &quot;the val is %d&quot;; void (^blk)(void) = ^{ val = 2}; blk(); }1234这个函数想在block中改变局部变量的值，但是会报编译错误，显然，直接在block中改变自动变量的值也是不可以的如果想要在block中改变局部变量的值需要在局部变量前面加上一个```__blcok```修饰 void subMain() { __block int val = 10; char *fmt = &quot;the val is %d&quot;; void (^blk)(void) = ^{ val = 2}; blk(); }123456789101112131415161718192021222324252627282930313233343536373839404142434445464748这样就不会报错，而且可以改变局部变量的值clang -rewrite-objcblock 会在以下情况从栈拷贝到堆上1. 调用copy的实例方法2. block作为函数返回值返回时3. 将block赋值给附有__strong修饰符id类型的类或block类型成员变量时4. 在方法名中含有usingBlock的cocoa框架方法或GCD的API中传递Block时栈区(stack)概述：栈是向低地址扩展的数据结构，是一块连续的内存区域。由栈顶的地址和栈的最大容量是系统预先规定好的。栈的空间很小，大概1-2M。超出overflow。使用：栈区，就是函数(方法)运行时向系统请求的内存。栈中的局部变量，参数由编译器分配和释放，函数运行就分配，函数结束就释放，由系统完成。是系统数据结构，对应进程唯一。特别注意：系统栈的剩余空间 大于 所申请的空间，系统为程序提供内存，不然，报错异常，提示栈的溢出。堆区(heap)概述：堆是向高地址扩展的数据结构，不连续的内存区域。系统用链表储存空闲地址的。链表遍历由低向高。堆大小直接受设备有效虚拟内存影响。1.首先应该知道操作系统有一个记录空闲内存地址的链表。2.当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。3.由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中123使用: 存放实体对象的。由程序员分配和释放(arc自动插入分配和释放代码)，例如alloc 申请的会放入堆中。全局\\静态区(static)静态变量和全局变量是存储在一起的。初始化的全局变量和静态变量存放在一块区域，未初始化的全局变量和静态变量在相邻的另一块区域，程序结束后有系统释放。int a;//未初始化的静态区int b = 10;//初始化的静态区12文字常量区存放常量字符串，程序结束系统释放程序代码区存放函数的二进制代码 main{ int b; 栈区 char s[] = “abc” 栈 char p1; 栈 char p2 = “123456”; //123456在文字常量区，p2在栈上。 static int c =0； 全局（静态）初始化区 w1 = (char )malloc(10); w2 = (char )malloc(20); 分配得来得10和20字节的区域就在堆区。 } 123456789101112131415161718192021222324252627282930313233343536373839404142434445# GCD同步添加dispatch_sync(Queue,Block) 等待 queue 中的所有任务都完成了之后，把block任务添加进入异步添加dispatch_async(Queue,Block) 不做任何等待，直接把block中的任务添加进入queue注意：1. 如果是dispatch_sync（同步添加），但是queue 就是当前dispatch_sync运行的队列，就会造成死锁打比方：block ：每个学生queue ： 学生所站的队 （有两类）dispatch_sync 和 dispatch_async线程 ： 在哪个跑道上跑步把一个任务使用GCD让其在线程中执行，比喻下来就是安排一个学生到跑道上跑步queue：这里有两种队列，一直叫串行队列，一种叫并行队列，串行队列：只能有一个学生在排队，如果有多个学生想要去排队，只能等前一个学生跑玩步，跑道空出来才能去排队eg：异步并行队列： void GCD_async_Test() { dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); //获得一个并行队列 NSLog(@”任务1加入队列1前”); dispatch_async(queue, ^{ NSLog(@”开始长时间任务1”); [NSThread sleepForTimeInterval:3]; NSLog(@”长时间任务1完成”); });//把任务放入并行队列中 NSLog(@”任务1加入队列后”);}` 输出： 任务1加入队列1前任务1加入队列后开始长时间任务1长时间任务1完成","tags":[]},{"title":"","date":"2018-12-03T14:55:12.063Z","path":"2018/12/03/WeView 2 使用翻译/WeView 2 使用翻译/","text":"WeView 介绍WeView 使用的一个简单的demo WeView 是一个用来给iOS界面自动布局的工具库 WeView 2是iOS Auto Layout 的替代品. WeView 2旨在提供一个”简单”,”自然”,”易描述”,”易维护”的方法通过UIKit去创建动态适应的界面 WeView 2使用直观的描述性方法来布局,如”alignment”(对齐),”margins”(边距),”spacing” (间距). WeView 2构建在iOS现有的大小和布局机制. WeView 2是轻量级的:不超过5k行代码而且没有别的依赖. WeView 2兼容iOS5及以上版本. WeView 2是免费开源的,遵循” Apache License Version 2.0” WeView 2是易学的. 为什么使用动态布局 使用动态布局的原因有很多,不管你使用的是iOS Auto Layout还是WeView.动态布局会让界面做到如下几点: 适应不同的屏幕尺寸 适应方向的改变(eg:横屏和竖屏) 适应设计的改变(eg:字体大小的改变,添加或移除子view,改变图片大小等) 适应文本内容的改变 适应动态内容的改变(eg:下载完成的内容) 为什么使用WeView 2 摘要: iOS Auto Layout 是一种复杂笨拙效率低下的编码方式 概念复杂:在使用iOS Auto Layout的时候,你需要考虑”约束优先级”,”约束是否完全”,”约束是否冲突”(eg:过约束布局),”最近共同祖先”等,这些问题也使代码重构变的复杂 缺乏基准:iOS Auto Layout 是基于一个复杂的约束处理系统,任何view的最终位置和大小都会收受到约束系统中的所有约束的影响,这些约束不需要被他们的父view持有,如果不能理解相邻view的层级就不能进行约束 编码复杂:用iOS Auto Layout布局一个按钮水平居中,底部距离父view20pt iOS Auto Layout 代码123456789101112131415161718UIButton *button = ...;UIView *superview = ...;NSLayoutConstraint *cn = [NSLayoutConstraint constraintWithItem:button attribute:NSLayoutAttributeCenterX relatedBy:NSLayoutRelationEqual toItem:superview attribute:NSLayoutAttributeCenterX multiplier:1.0 constant:0.0];[superview addConstraint:cn];cn = [NSLayoutConstraint constraintWithItem:button attribute:NSLayoutAttributeBottom relatedBy:NSLayoutRelationEqual toItem:superview attribute:NSLayoutAttributeBottom multiplier:1.0 constant:-20.0];[superview addConstraint:cn]; 使用Visual Format Language的Auto Layout12345678910111213UIButton *button = ...;UIView *superview = ...;NSDictionary *variableMap = NSDictionaryOfVariableBindings(label, superview);NSLayoutConstraint *cn = [NSLayoutConstraint constraintsWithVisualFormat:@&quot;V:[button]-12-[superview]&quot; options:0 metrics:nil views:variableMap];[superview addConstraint:cn];cn = [NSLayoutConstraint constraintsWithVisualFormat:@&quot;H:[superview]-(&lt;=1)-[button]&quot; options:NSLayoutFormatAlignAllCenterY metrics:nil views:variableMap];[superview addConstraint:cn]; 使用WeView12345678#import &quot;WeView.h&quot;UIButton *button = ...; WeView *panelView = [[WeView alloc] init]; [[[[panelView addSubviewWithCustomLayout:button] setHAlign:H_ALIGN_CENTER] setVAlign:V_ALIGN_BOTTOM]setMargin:20]; iOS Auto Layout 在xib中比较有优势,而且xib已经在Xcode5中被显著提高,但是在代码编程中自动布局还是很复杂的 WeView 只能被用作代码编程,但可以被设计的简洁明了,利于维护的代码 指导 1: 概述略 指导 2: 安装添加WeView文件夹到工程中就好. WeView 2只依赖Foundation ,UIKit 和 Quartz Core库而且需要iOS 5及以上版本 Headers头文件通常只需要导入 #import &quot;WeView.h&quot; Classes WeView 容器是核心类,他本身只有添加子view和他们布局的方法 WeView 的布局是由WeViewLayout实现的 UIView + WeView 类别为UIView添加了许多布局属性,用来控制view怎么作为子view布局在他的父view上,这些属性存放在一个关联的对象中,且这个对象只有一个 指导 3:术语View Hierarchy (图层)图层是布局作用的上下文,通常我们只需要关系我们布局view的子view和父view Superview &amp; Subviews (父view和子view)在布局上下文中,Superview是父view,而他的子view是Subviews(注意:Superview只有一个但是Subviews是可以有多个的),在使用WeView 2布局的时候,通常父view是一个WeView,子View可以是任何类型的UIView WeView 2工作的时候子View不需要引用任何类或实现任何界面 Widgets vs. Containers (控件和容器)widgets(控件) :一个界面上可见的元素 eg:button或label等 containers(容器) :通常是一些不可见的view,用来组织结构和布局其他view eg:在HTML中DIVs通常被用作容器,在UIKit中,空白view也通常被使用.WeView 2的核心就是WeView容器类,通过给容器添加子view作为内容 Measurement and ArrangementMeasurement :是view的size推测位置的过程eg:measurement 类似于[UIView sizeThatFies:]方法 Arrangement :是view的size决定位置的过程eg:arrangement 类似于[UIView layoutSubviews]方法 Desired Size有时候view想要一个他们想要的大小.eg:一个button想要大小是icon的大小,或label想要大小是文本的大小.这时候的大小就是view的Desired Size 使用Weview 2的时候我们可以完全放心的忽视 intrinsic size(固有大小) Frame and BoundsUIViews 使用了两套坐标系统.frame :UIView的frame是他在他父view的坐标系统中的大小和位置bounds :UIView的bounds是他在他自己的坐标系统中的大小和位置 布局子view的时候是在他的父view的坐标系中操作的,所以操作的是子view的frame. 改变一个view的frame会影响他的bounds,反之也是一样的","tags":[]},{"title":"","date":"2018-06-10T14:07:06.000Z","path":"2018/06/10/Untitled/","text":"AFNetworking 相关网络通讯建立一个TCP协议的连接通常需要三次”握手”,断开一个TCP协议的连接需要四次”挥手” 三次”握手” 1.”Client”端(客户端)发送连接请求报文. 2.”Server”端(服务端)接受连接后回复ACK(指令正确)报文,并为这次连接分配资源 3.”Client”端(客户端)收到ACK报文后像”Server”端发送ACK(指令正确报文),并分配资源 举个栗子: A(客户端)和B(服务端)进行交易 A:”我要的东西带来了么?” (客户端向服务端请求) B:”天王盖地府,先对暗号” (服务端给客户端一个回应,表示知道客户端要请求了,并且准备好了请求资源) A:”小鸡炖蘑菇” (客户端给服务端一个回应,表示自己知道已经连接上服务端,并且知道服务端准备好了,且自己也准备好了) 接头完成,进行可以进行交易(连接成功)","tags":[]},{"title":"Hello World","date":"2018-06-10T14:07:06.000Z","path":"2018/06/10/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"OC使用静态库中的类别","date":"2017-04-05T12:02:30.000Z","path":"2017/04/05/OC使用静态库中的类别/","text":"OC中使用静态库中的类别的问题OC的源文件经过 clang 编译首先生成中间代码,接着通过优化生成目标代码(目标代码中包括符号表,标示了此代码中的全局符号和静态符号,还标示了导入符号等),连接器会根据符号表分析各个目标代码之间的调用关系,然后将使用到的代码进行连接和重定位,最后生成可执行文件. 在编译Objective-C源文件到目标文件时,编译器并不知道方法的对应实现,只能在运行时才知道,所以编译器只会为类生成连接符号,不会对类中的方法生成连接符号,由于Category方法并不对应一个新类,所以不会生成连接符号,连接器也不会将Category方法合并到原始的类中,最终导致连接器忽略了Category方法,不会将其连接到可执行文件中. 在OC使用静态库中的类别,需要设置下面5种方法中的一种 Other Linker Flags 设置 1.通过在Other Linder Flags 添加 -all\\_load 它会告诉编译器对”所有文档中的所有对象文件,不管里面的符号有没有被用到,全部都载入”,这样会产生比较大的二进制文件 2.通过在Other Linder Flags 添加 -force\\_load 和指定路径 e.g: -force\\_load $(SRCROOT)/RHAddressBook/libRHAddressBook.a 这种方法会只载入指定的归档 3.通过在Other Linder Flags 添加 -ObjC ,这个标识告诉编译器”如果在文档中发现了OC代码,就把文档载入” 4.在Xcode里build setting中的 Perform Single-Object PreLink，如果启用这个选项，所有的对象文件都会被合并成一个单文件（这不是真正的链接，所以叫做预链接），这个对象文件（有时被称做主对象文件(master object file)）被添加到文档中。现在如果主对象文件中的任何符号被认为是“在使用”，整个主对象文件都会被认为在使用，这样它里面的OC部分就会被载入了。因为里面的类都被正常符号化了，所以能使从这样的静态库中使用所有的Category 5.最后一种解决方法是在只有Category的源文件里添加Fake symbol。如果你想在运行时使用Category，一定要确保你以某种方法在编译时引用了fake symbol，这会使得对象文件以及它里面的OC代码被载入。例如，它可以是一个有空函数体的函数，也可以是一个被访问的全局变量（例如一个全局的int变量，只要它被读或者写了一次就足够了）。和上面其他的解决方法不一样，这种解决方法可以控制哪些category可以在运行时被编译后的代码使用（可以通过使用这个符号，使它们被链接并变得可用；也可以不使用这个符号，这样链接器就会忽略它）","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"OC使用静态库中的类别","date":"2017-04-05T12:02:30.000Z","path":"2017/04/05/OC使用静态库中的类别/OC使用静态库中的类别/","text":"OC中使用静态库中的类别的问题OC的源文件经过 clang 编译首先生成中间代码,接着通过优化生成目标代码(目标代码中包括符号表,标示了此代码中的全局符号和静态符号,还标示了导入符号等),连接器会根据符号表分析各个目标代码之间的调用关系,然后将使用到的代码进行连接和重定位,最后生成可执行文件. 在编译Objective-C源文件到目标文件时,编译器并不知道方法的对应实现,只能在运行时才知道,所以编译器只会为类生成连接符号,不会对类中的方法生成连接符号,由于Category方法并不对应一个新类,所以不会生成连接符号,连接器也不会将Category方法合并到原始的类中,最终导致连接器忽略了Category方法,不会将其连接到可执行文件中. 在OC使用静态库中的类别,需要设置下面5种方法中的一种 Other Linker Flags 设置 通过在Other Linder Flags 添加 -all\\_load 它会告诉编译器对”所有文档中的所有对象文件,不管里面的符号有没有被用到,全部都载入”,这样会产生比较大的二进制文件 2.通过在Other Linder Flags 添加 -force\\_load 和指定路径 e.g: -force\\_load $(SRCROOT)/RHAddressBook/libRHAddressBook.a 这种方法会只载入指定的归档 3.通过在Other Linder Flags 添加 -ObjC ,这个标识告诉编译器”如果在文档中发现了OC代码,就把文档载入” 4.在Xcode里build setting中的 Perform Single-Object PreLink，如果启用这个选项，所有的对象文件都会被合并成一个单文件（这不是真正的链接，所以叫做预链接），这个对象文件（有时被称做主对象文件(master object file)）被添加到文档中。现在如果主对象文件中的任何符号被认为是“在使用”，整个主对象文件都会被认为在使用，这样它里面的OC部分就会被载入了。因为里面的类都被正常符号化了，所以能使从这样的静态库中使用所有的Category 5.最后一种解决方法是在只有Category的源文件里添加Fake symbol。如果你想在运行时使用Category，一定要确保你以某种方法在编译时引用了fake symbol，这会使得对象文件以及它里面的OC代码被载入。例如，它可以是一个有空函数体的函数，也可以是一个被访问的全局变量（例如一个全局的int变量，只要它被读或者写了一次就足够了）。和上面其他的解决方法不一样，这种解决方法可以控制哪些category可以在运行时被编译后的代码使用（可以通过使用这个符号，使它们被链接并变得可用；也可以不使用这个符号，这样链接器就会忽略它）","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"Xcode8报错","date":"2017-03-31T03:02:30.000Z","path":"2017/03/31/Xcode8 报错resource fork, Finder information, or similar detritus not allowed/","text":"Xcode8 报错resource fork, Finder information, or similar detritus not allowed 原因这是因为Xcode8引进的新的安全机制, Code signing不允许app的bundle里面的文件有未知的文件系统扩展属性 解决方法在终端中输入 xattr -lr &lt;path_to_app_bundle&gt; 可以查看存在未知扩展属性的文件 在终端中输入 xattr -cr &lt;path_to_app_bundle&gt; 可以移除所有未知的扩展属性 然后清理Xcode 重新build 工程","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"appium测试时候的那些事","date":"2017-01-11T03:10:12.000Z","path":"2017/01/11/appium测试时候的那些事/","text":"遇到的问题1.org.openqa.selenium.WebDriverException: Method has not yet been implemented 在使用appium跑java脚本的时候,如果出现异常,提示如上面显示的,说明你的appium安装出现了问题,具体原因是我的appium当时卸载的时候没有完全卸载干净,导致appium无法连接到WebDriverException 解决方法: 卸载appium ,最好再使用清理工具如:cleanMyMac 清理一下残留文件,然后从新安装新的appium ,问题就可以解决,如果还不行,可以新建一个电脑账户,在新的账户中重新搭建appium也可以","tags":[{"name":"appium","slug":"appium","permalink":"http://yoursite.com/tags/appium/"}]},{"title":"iOS的CF和OC中间的类型转换","date":"2017-01-11T03:10:12.000Z","path":"2017/01/11/bridged/","text":"iOS的CF和OC中间的类型转换Toll-Free bridgedToll-Free bridged 是Core Foundation和Foundation之间交换使用数据类型的技术.即同一数据类型既可作为Core Foundation函数的参数,也可以作为接收者向其发送Objective-C消息. 说的简单点,就是OC中的有些类型,通过Toll-Free bridged 既可以当做Core Foundation的类型使用(CFxxxx),又可以当做Foundation的类型使用(NSxxxx). Toll-Free bridged原理每一个能够bridge的ObjC类，都是一个类簇（class cluster）。类簇是一个公开的抽象类，但其核心功能的是在不同的私有子类中实现的，公开类只暴露一致的接口和实现一些辅助的创建方法。而与该ObjC类相对应的Core Foundation类的内存结构，正好与类簇的其中一个私有子类相同。 举个例子，NSString是一个类簇，一个公开的抽象类，但每次创建一个NSString的实例时，实际上我们会获得其中一个私有子类的实例。而NSString的其中一个私有子类实现既为NSCFString，其内存的结构与CFString是相同的，CFString的isa指针就指向NSCFString类，即CFString对象就是一个NSCFString类的实例。所以，当NSString的实现刚好是NSCFString的时候，他们两者之间的转换是相当容易而直接的，他们就是同一个类的实例。 当NSString的实现不是NSCFString的时候（比如我们自己subclass了NSString），我们调用CF函数，就需要先检查对象的具体实现。如果发现其不是NSCFString，我们不会调用CF函数的实现来获得结果，而是通过给对象发送与函数功能相对应的ObjC消息（调用相对应的NSString的接口）来获得其结果。 例如CFStringGetLength函数，当收到一个作为参数传递进来的对象时，会先确认该对象到底是不是NSCFString实现。如果是的话，就会直接调用CFStringGetLength函数的实现来获得字符串的长度；如果不是的话，会给对象发送length消息（调用NSString的length接口），来得到字符串的长度。 Toll-Free bridged的内存管理在ARC中编译器不知道如何处理这个同时拥有ObjC和CFTypeRef指向的对象,所以你必须为编译器提供额外的信息：将类型显示转换为互换类型；同时可能需明确对象的声明周期。 因此我们需要使用 __bridge, __bridge_retained, __bridge_transfer 修饰符告诉编译器该如何去做。 __bridge1234//objc to cf NSString *str = @\"hello\"; CFStringRef cfStr = (__bridge CFStringRef)str; CFRelease(cfStr);//这里不需要release 编译器会继续负责nsStr的内存管理的事情，不会在bridge的时候retain对象，所以也不需要开发者在CF 一端释放。需要注意的是，当nsStr被释放的时候（比如出了作用域），意味着cfStr指向的对象被释放了，这时如果继续使用cfStr将会引起程序崩溃。 1234//cf to objc CFStringRef cfStr = CFStringCreateWithCString(kCFAllpacatorDefaule,\"hello\",kCFStringEncodingUTF8); NSString *str = (__bridge NSString *)(cfStr); CFRelease(cfStr);//这里需要release bridge的时候编译器不会做任何内存管理的事情，bridge之后，编译器会负责ObjC一端的内存管理的事情。同时，开发者需要负责管理CF 一端的内存管理的事情，需要在bridge之后，负责release对象。 __bridge_retained接着上面的例子，Foundation类型对应的Core Foundation类型时，为了防止str被释放，引起我们使用cfStr的时候程序崩溃，可以使用__bridge_retained修饰符。这意味着，在bridge的时候，编译器会retain对象，而由开发者在CF一端负责release。这样，就算str在objc一端被释放，只要开发者不手动去释放cfStr，其指向的对象就不会被真的销毁。但同时，开发者也必须保证和负责对象的释放。 1234//objc to cf NSString *str = @\"hello\"; CFStringRef cfStr = (__bridge_retained CFStringRef)str; CFRelease(cfStr);//这里不需要release __bridge_transfer当Core Foundation类型转化为Foundation类型时，如果使用bridge修饰符在cf转objc的时候非常的麻烦，我们既需要一个CFTypeRef的变量，还需要在bridge之后负责释放。这时我们可以使用bridge_transfer，意味着在bridge的时候，编译器转移了对象的所有权，开发者不再需要负责对象的释放。 1234//cf to objc CFStringRef cfStr = CFStringCreateWithCString(kCFAllpacatorDefaule,\"hello\",kCFStringEncodingUTF8); NSString *str = (__bridge NSString *)(cfStr); CFRelease(cfStr);//这里需要release 总结 __bridge :编译器在bridge的时候不要做任何事情 __bridge_retained :（ObjC转CF的时候使用）编译器在bridge的时候retain对象，开发者需要在CF一端负责释放对象 __bridge_transfer :（CF转ObjC的时候使用）编译器转移CF对象的所有权，开发者不再需要在CF一端负责释放对象","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"读《iOS与OS X多线程和内存管理》——前言","date":"2017-01-11T03:10:12.000Z","path":"2017/01/11/读《iOS与OS X多线程和内存管理》——前言/","text":"前言 都说不会写部落格的程序猿不是好作家，本作家本来想着当一个小小的初级工程师，每天码码界面，终其一生就算了。谁知天有不测风云，人有祸福旦夕，那天在工程中多看了一眼别人的代码，顿时觉得自己的知识储备实在是太匮乏了。 那么究竟是什么样的代码，居然有如此神奇的功效，闲话少叙，上代码： 代码一： 1234567891011121314151617@interface MyView ()@property (nonatomic, weak) UILabel *label;@end@implementation MyView&#123;UILabel *label = [[UILabel alloc] init];label.font = [UIFont systemFontOfSize:14];label.textColor = [UIColor whiteColor];label.textAlignment = NSTextAlignmentCenter;label.text = @\"你好\";[self addSubview:label];_label = label;&#125;@end 就是这么一段代码，如果要让楼主写 则是下面这样的 代码二： 12345678910111213141516@interface MyView ()@property (nonatomic, strong) UILabel *label;@end@implementation MyView&#123;self.label = [[UILabel alloc] init];self.label.font = [UIFont systemFontOfSize:14];self.label.textColor = [UIColor whiteColor];self.label.textAlignment = NSTextAlignmentCenter;self.label.text = @\"你好\";[self addSubview:self.label];&#125;@end 当然你也可以直接用 _label 赋值，这里问题的重点不是set方法和成员变量的区别，而是我的属性用的是 strong 修饰而他的是使用 weak修饰。 本着不耻下问，虚心求教的态度我问了一下我同事，得到了这样的解答： 代码一的属性使用的 weak 修饰，因为在 addSubview： 的时候 self 会强引用 label 对象 weak 修饰的成员变量 _label 弱引用着 label对象 代码二的属性使用 strong 修饰， 在 addSubview： 的时候 self 会强引用 label对象 strong 修饰的成员变量 _label 也强引用着 label 对象 第一种代码的好处是在 self移除 label的时候 label对象就释放了。因为 label只有一个 self强引用着 第二种代码在 self移除label的时候label对象不会释放，因为还有个 _label的变量强引用这 label对象，只有在 self 释放的时候 label 对象才会释放。 本人读书少，仔细一想确实是这么回事，用weak修饰，label对象只被 self强引用，从view上移除后就可以释放，不用等到self释放的时候才释放，创建和释放都很合理(哪里创建哪里释放)。 但是细思极恐，难道我多年来的开发经验是错误的么，用了n年的strong原来是个低效的使用方法。这时候我突然想到了一个面试题，那就是你真的了解属性修饰符的用法么？ 好吧我承认！我不了解，这就是我看这本书的原因。 注：(1).上面的解释不一定是正确的.(2).小弟初来乍到要是有啥说的不对的地方希望各位大大不吝赐教。(3).要是你们有什么意见和建议，也可以随便吐槽。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"读《iOS与OS X多线程和内存管理》——引用计数","date":"2017-01-11T03:10:12.000Z","path":"2017/01/11/读《iOS与OS X多线程和内存管理》——引用计数/","text":"1. 什么是自动引用计数(ARC)ARC简而言之就是编译器自动进行内存管理，那为什么不叫”自动内存管理”，而叫”自动引用计数”，当然是因为内存管理是的方法是通过引用计数实现的 要说自动引用计数，首先要说什么是”引用计数” 1.1引用计数什么是引用计数，书中举了一个生活中开关房间灯的例子。 简单的描述一下就是，第一个人来的时候要开灯(创建对象)，最后一个人走的时候要关灯(释放对象)，中间来人走人都不需要开关灯。那么办公室里的人数就是引用计数。 1.2内存管理的思考方式内存管理的思考方式总结出来就是下面四点 注：这里还没到ARC所以还是非ARC 1.自己生成的对象，自己所持有 (指通过1234eg:```mmid obj = [NSObject new]; 2.非自己生成的对象，自己也能持有 (指持有通过类方法创建的对象)eg: 12id obj = [NSArray array];[obj retain]; 3.不再需要自己持有的对象时释放 (释放对象)eg: 12id obj = [[NSObject alloc] init];[obj release]; 4.非自己持有的对象无法释放 (多次释放，或未持有释放）eg: 123id obj = [[NSObject alloc] init];[obj release];[obj release]; 对象的操作与Objective-C方法的对应生成并持有对象—— alloc/new/copy/mutableCopy 等持有对象———– retain释放对象———– release废弃对象———– dealloc 2.alloc/retain/release/dealloc 实现书中这个节研究的是alloc/retain/release/dealloc的实现。 讲之前先说一个我不知道的常识，那就是Objective-C的框架，底层的是一个叫Cocoa框架其中包含一个Foundation框架 首先Objective-C内存管理的方法是包含在Cocoa框架中的，这里所说的内存管理是的方法alloc/retain/release/dealloc 指的是 NSObject类的alloc类方法,retain实例方法,release实例方法和dealloc实例方法，但是NSObject类的 Foundation123456789101112131415161718192021222324252627282930313233343536373839这里我把代码给大家写出来，供大家参考，但书的作者把有些地方的源码在不改变意思的范围进行了修改### 2.1 alloc 实现 ###GNUstep的```alloc```实现：```mm+(id)alloc&#123; return [self allocWithZone:NSDefaultMallocZone()];&#125;+ (id)allocWithZone:(NSZone *)z&#123; return NSAllocateObject (self, 0, z);&#125;/* ------- NSAllocateObject ------- */struct obj_layout &#123; NSUInteger retained;&#125;;inline id NSAllocateObject (Class aClass, NSUInteger extraBytes, NSZone *zone)&#123; int size = 计算容纳对象所需内存大小； id new = NSZoneMalloc(zone,size); memset(new, 0, size); new = (id)&amp;((struct obj_layout *) new)[1];&#125;/* ----- 简化版alloc ----- */+ alloc&#123; int size = sizeof(struct obj_layout) + 对象大小; struct obj_layout *p = (struct obj_layout *)calloc(1,size); return(id)(p+1);&#125; 简化版的是去掉了 之后的代码，```NSZone``` 是为了防止内存碎片化引入的结构，对内存管理没有影响，所以可以忽略。从简化版的代码中可以看出 ```GNUstep``` 申请的对象的内存比需要的大了 ```sizeof(struct obj_layout)```，这个多出来的空间就是用来存放引用计数的123456789101112131415在非ARC即MRC中是可以通过 ```retainCount``` 查看对象的引用计数的。retainCount的实现:```mm- (NSUInteger)retainCount&#123; return NSExtraRefCount(self) + 1;&#125;inline NSUInteger NSExtraRefCount(id anObject)&#123; return((struct obj_layout *) anObject)[-1].retained;&#125; 2.2 retain 实现GNUstep的 实现：1234567891011121314```mm- (id)retain&#123; NSIncrementExtraRefCount(self); return self;&#125;inline void NSIncrementExtraRefCount(id anObject)&#123; if(((struct obj_layout *)anObject)[-1].retained == UINT_MAX -1) 抛出异常 ((struct obj_layout *)anObject)[-1].retained++;&#125; 2.3 release 实现GNUstep的 实现：1234567891011121314151617```mm- (void)release&#123; if(NSDecrementExtraRefCountWasZero(self)) [self dealloc];&#125;BOOL NSDecrementExtraRefCountWasZero(id anObject)&#123; if(((struct obj_layout *)anObject)[-1].retained == 0)&#123; return YES; &#125;else &#123; ((struct obj_layout *)anObject)[-1].retained--; return NO; &#125;&#125; 2.4dealloc 实现GNUstep的123456789101112```mm- (void)dealloc&#123; NSDeallocateObject(self);&#125;inline void NSDeallocateObject(id anObject)&#123; struct obj_layout *o = &amp;((struct obj_layout *) anObject)[-1]; free(o);&#125; 可以看到 实现引用计数的方法是在变量在内存块头部保存的当前对象的引用计数，默认是0，当调用 ```retainCount``` 时会自动+1，这就说明了自己生成的对象，自己所持有。1234567891011121314151617181920212223242526272829303132333435### 2.5 苹果实现 ###苹果由于官方未公开源代码，根据运行时调用的代码可以看出苹果实现引用计数和 ```GNUsetp``` 的主要区别就是 ```GNUsetp``` 将引用计数存放在内存块头，而苹果使用的是散列表（键为内存块地址的散列值）存放在头部管理引用计数的好处：- 代码量少- 能够统一管理引用计数用内存块和对象用内存块用散列表(引用计数表)管理引用计数的好处：- 对象用内存块的分配无需考虑内存块头部- 引用计数表各记录中存有内存块地址，可从各个记录追溯到各对象的内存块### autorelease ###所谓 ```autorelease``` 就是自动释放，原理就是若某自动变量超出其作用域，该自动变量将被自动废弃GNUstep的 ```autorelease``` 实现：```mm- (id)autorelease&#123; [NSAutoreleasePool addObject:self];&#125;+ (void) addObject:(id)anObj&#123; NSAutoreleasePool *pool = 取得当前NSAutoreleasePool对象 if(pool != nil) &#123; [pool addObject:anObj]; &#125;else &#123; NSLog(@&quot;NSAutoreleasePool对象非存在状态下调用autorelease&quot;)； &#125;&#125; 废弃 方法 ``` drain``` 实现1234567891011121314151617181920```mm- (void)drain&#123; [self dealloc];&#125;- (void)dealloc&#123; [self emptyPool]; [array release];&#125;- (void)emptyPool&#123; for(id obj in array) &#123; [obj release]; &#125;&#125; 查看 中的内容123```mm[NSAutoreleasePool showPools];//此方法只能在iOS中使用 在运行时系统中调用方法 12345/* 函数声明 */extern void _objc_autoreleasePoolPrint();/* 调试处调用 */_objc_autoreleasePoolPrint(); 注：(1).上面的内容全部是本人读《Objective-C高级编程 iOS与OS X多线程和内存管理》一书觉得重点的部分，如果大家感兴趣可以支持一下正版。(2).如果各位看官觉得有什么事小弟说的不对的地方，欢迎指出。(3).这篇基本上都是说引用计数的实现的，还没有涉及到前言提出的问题的解答。(4).看到这里的都是真爱啊。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"Learn JavaScript","date":"2017-01-11T03:10:12.000Z","path":"2017/01/11/JavaScript/","text":"Equality (相等比较符)1234var foo = 42;var bar = 42;var baz = \"42\";var qux = \"life\"; 定义了四个变量在Javascript中 ==是用来比较两个值但是不会判断类型故 foo == baz返回的值是true 使用==比较的时候编译器会先把类型转换成相同的类型,再去比较 因此在JavaScript 要是比较不同类型的两个值可以使用===这样会先判断类型,如果类型不同就会返回false 所以推荐使用===比较 注意: 1.NaN是个特殊的Number,他与所有其他值都不相等,包括它自己1NaN === NaN ; // false 唯一能判断NaN的方法是通过isNaN()函数:1isNaN(NaN); // true 2.浮点数的比较:11/3 === (1 - 2 / 3); //false 这个结果是正确的,出现这个结果这是因为浮点数在运算过程中会产生误差,计算机无法精确的表示无限小数,所以要比较两个浮点数是否相等,只能计算他们之差的绝对值,看是否小于某个阈值: 1Math.abs(1/3 - (1 - 2 / 3)) &lt; 0.0000001; //true TypesnumbersJavaScript中只有一种数字类型 – 64-bit float point,类似于Java中的double类型,所以在JavaScript中1和1.0是相同的值number可以直接做四则运算，规则和数学一致 字符串字符串是以’单引号’或”双引号”括起来的文本,如&#39;abc&#39; &quot;xyz&quot; 注意&#39; &#39;和&quot; &quot;并不是字符串的一部分 如果字符串中包含&#39; 就使用&quot;&quot;把文本包起来,如果字符串中包含&quot; 就需要使用转义字符了\\ 在多行字符串中换行使用的是\\n 但是如果行数太多\\n需要写多个,不方便,在JavaScript中又增加了一种表示方法(ES6),就是将多行文本用`… `括起来,就是键盘上tab键上边的那个按键. 模板字符串多个字符串可以使用+连接起来.字符串也可以是变量如: 123var name = '小王吧';var age = '100';var message = '你好,' + name + ',你现在' + age + '岁'; 同样,如果要连接的变量有很多,使用+就会很不方便,在JavaScript中增加了一种模板字符串的表示(ES6): 123var name = '小王吧';var age = '101';var message = `$&#123;name&#125;,你今年$&#123;age&#125;岁,是不是?` 注意:新的表示方法使用的是` ,就是新的多行文本使用的符号,就是键盘上tab按键上边的那个按键,不能使用&quot;&quot;或&#39;&#39;,那样无法转换变量 字符串操作获取字符的长度 12var name = 'xiao wang ba.';alert(name.length); //13 获取指定位置字符,可以把字符串看成是特殊的数组,对字符串进行下标操作,从0索引开始 123456var name = 'xiao wang ba.';name[0]; //'x'name[1]; //'i'name[4]; //' 'name[12];//'.'name[13];//undefined 超出范围的索引一律返回undefined 注意:给字符串的索引赋值不会有报错,也不会有任何效果,字符串也不会改变 改变字符串为大写 12var name = 'xiao wang ba.';name.toUpperCase(); //返回'XIAO WANG BA.' 改变字符串为小写 12var name = 'Xiao Wang Ba.';name.toLowerCase(); //返回'xiao wang ba.' 注意:如果字符串是中文,则没效果 返回字符串出现的位置 123var name = 'Xiao Wang Ba.';name.indexOf('Wang');//返回5name.indexOf('wang');//如果没有找到指定的子串,返回-1 获取字符串中的子串 123var name = 'xiao wang ba.';name.substring(0,4);//从索引0开始到4(不包括4),返回'xiao'name.substring(10);//从索引10开始到结束,返回'ba.' 布尔值JavaScript中的布尔值有true和false两种值,可以直接用true或false表示,也可以通过布尔运算计算出来 null和undefinednull表示一个”空”的值,同Java中的null,Swift中的nil,Python中的None用法类似.undefined表示”未定义”.JavaScript设计的时候希望用null表示一个空的值,用undefined表示值未定义,但是大多数情况下我们都应该用null.undefined仅仅在判断函数参数是否传递的情况下有用 数组数组是一组按顺序排列的集合,集合的每个值称为元素.JavaScript的数组可以包括任意数据类型.创建方法: 1[1,2,3.14,\"hello\",null,true]; //推荐使用 另一种创建方法: 1new Array(1,2,3); 获取数组的长度 12345var arr = [1,2,3.14,\"hello\",null,true];arr.length;//6//可以给数组的长度赋值,改变数组的大小arr.length = 7;//数组改变为[1,2,3.14,\"hello\",null,true,undefined]arr.length = 4;//数组改变为[1,2,3.14,\"hello\"] 数组可以通过索引来访问每个元素的值,也可以改变索引对应元素的值: 123var arr = [1,2,3.14,\"hello\",null,true];arr[0]; //数组第一个元素,值为1arr[1] = 10;//修改数组第二个元素的值为10 注意:如果通过索引给数组赋值的时候,索引超过了数组长度,数组会被变大 12var arr = ['A', 'B', 'C'];arr[5] = 'F';//arr会变为['A', 'B', 'C', undefined, undefined, 'F']; 获取对应元素的索引 12345var arr = [10, 20 ,'30', 'xyz'];arr.indexOf(10);//元素10的索引是0arr.indexOf(20);//元素20的索引是1arr.indexOf(30);//元素30的索引是 -1 因为没有找到元素arr.indexOf('30');//元素'30'的索引是2 注意：数字30和&#39;30&#39;是不同的元素 获取数组中的部分元素 123var arr =['A','B','C','D','E','F','G'];arr.slice(0,3);//从索引0开始,到索引3结束,但不包括索引3:['A','B','C']arr.slice(3);//从索引3开始到结束:['D','E','F','G'] 注意:slice()的起止参数包括开始索引,不包括结束索引如果不给slice()传递任何参数,它会从头到尾截取所有元素,这个方法可以复制一个array 123456789var arr = ['A','B','C','D','E','F','G'];var aCopy = arr.slice();aCopy; //['A','B','C','D','E','F','G'];aCopy === arr; //falseif(aCopy.toString() === arr.toString()) &#123; alert('一样');//数组相同&#125;else &#123; alert('不一样');//数组不同&#125; 注意:JavaScript比较两个数组是否相同不能直接使用=== 要比较两个数组是否相同,需要先把数组转换成字符串,然后再比较 在数组末尾添加或删除若干元素,push()和pop() 123456789var arr = [1 , 2];arr.push('A','B'); //返回新的长度为4的数组arr; //[1,2,'A','B']arr.pop();//pop()返回'B'arr; // [1,2,'A']arr.pop();arr.pop();arr.pop(); //连续pop 3次arr; //[]arr.pop(); //空数组继续pop不会报错,而是返回undefinedarr;//[] 在数组头部添加或删除若干元素,unshift()和shift() 123456789var arr =[1,2];arr.unshift('A','B');//返回新的长度为4的数组arr;//['A','B',1,2]arr.shift();//'A'arr;//['B',1,2]arr.shift();arr.shift();arr.shift();//连续shift 3次arr;//[]arr.shift();//空数组继续shift不会报错,而是返回undefinedarr;//[] 数组排序sort()可以对当前数组进行排序,它会直接修改当前的数组元素的位置,直接调用时,会按照默认顺序排序 123var arr = ['B','C','A'];arr.sort();arr;//['A','B','C'] 注意 在函数中可以自定义排序条件 数组反转 reverse()可以把数组的元素反转 123var arr = ['A','B','C'];arr.reverse();arr;//['three','two','one'] 数组修改的”万能方法”,可以从指定索引开始删除若干元素,然后再从该位置添加若干元素 123456var arr =['Microsoft','Apple','Yahoo','AOL','Excite','Oracle']arr.splice(2,3,'Google','Facebook');//从索引2开始删除3个元素,然后再添加两个元素,返回删除的元素['Yahoo','AOL','Excite']arr.splice(2,2);//只删除不添加,返回['Google','Facebook']arr;//['Microsoft','Apple','Oracle']arr.splice(2.0,'Google','Facebook');//只添加,不删除,返回[]arr;//['Microsoft','Apple','Google','Facebook','Oracle'] 把两个数组连接起来,返回一个新的数组 1234var arr = ['A','B','C'];var added = arr.concat([1,2,3]);added; //['A','B','C',1,2,3]ARR;//['A','B','C'] 注意 concat()方法并没有修改当前数组,而是返回了一个新的数组 而且concat()可以接收任意个元素和数组,并把所有数组自动拆开,添加到新的数组中 12var arr = ['A','B','C'];arr.concat(1,2,[3,4]);//['A','B','C',1,2,3,4] 把数组的每个元素都用指定的字符串连接起来,然后返回字符串 12var arr = ['A','B','C',1,2,3];arr.join('-'); //'A-B-C-1-2-3' 注意如果数组的元素不是字符串,会自动转换成字符串再连接 多维数组,指的是数组中的某个元素又是一个数组 1var arr = [[1,2,3],[400,500,600],'-']; 上述Array包含3个元素,其中头两个元素本身也是Array 对象对象是一组由键-值组成的无序集合: 12345678var person = &#123; name: 'XiaoWang', tags: ['js', 'web', 'mobile'], age: 12, city: 'shanghai', hasCar: false, zipcode: null&#125;; JavaScript用一个{...} 表示一个对象,键值对以xxx: xxx形式申明,用,隔开,最后一个键值对不需要加 JavaScript对象的键都是字符串类型,值可以是任意数据类型,每个键都是对象的一个属性,获取属性的方法: 12person.name; // 'XiaoWang'person.zipcode; // null 注:var person 是JavaScript的一个变量,person是变量名,变量名是大小写英文,数字,$和_的组合,且不能用数字开头,也不能使用JavaScript中的关键字 strict模式蛋疼的布兰登在设计JavaScript的时候为了赶工期,并没有强制使用var声明变量,如果一个变量没有通过var声明就被使用,这个变量就会被自动声明为全局变量 1i = 10; //i就是一个全局变量 如果在不同的JavaScript文件中,你都使用了同样名字的变量,而且都没有用var声明,那么你就麻烦了. 因此,为了给布兰登填坑,ECMA在后续的规范中推出了strict模式,在strict模式下运行JavaScript代码不允许使用没有var声明的变量,如果有那么就给你报错 启动strict模式的方法很简单,就是在JavaScript代码的第一行写上: 1'use strict'; 注:如果你用的是老爷机,你的浏览器太老了,他会自以为是的把上面那就话当做一个字符串语句执行,如果这样的话还是换个最新版的浏览器吧 Advanced Operaters (高级运算符)取余运算 x = y % 2累加运算 a = 5 c = a++/Users/YaoWanXin/Desktop/app.html resulets : c = 5 and a = 6 c = ++a resulets : c = 6 and a = 6累减运算 a = 5 c = a-- resulets : c = 5 and a = 4 c = --a resulets : c = 4 and a = 4","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"my first blog","date":"2017-01-11T03:02:30.000Z","path":"2017/01/11/my-first-blog/","text":"这就是传说中的第一个blog #超级偶像","tags":[{"name":"hello","slug":"hello","permalink":"http://yoursite.com/tags/hello/"}]},{"title":"centOS Linux系统命令--VPS那些事","date":"2016-12-11T03:02:30.000Z","path":"2016/12/11/centOS系统命令/","text":"升级系统1yum update -y 安装wgetwget是一个从网络上自动下载文件的自由工具，支持通过HTTP、HTTPS、FTP三个最常见的TCP/IP协议下载，并可以使用HTTP代理。wget名称的由来是“World Wide Web”与“get”的结合 1yum -y install wget 查看当前内核版本1uname -r 修改内核1rpm -ivh http://gongju.wn789.com/neihei/kernel-firmware-2.6.32-504.3.3.el6.noarch.rpm 1rpm -ivh http://gongju.wn789.com/neihei/kernel-2.6.32-504.3.3.el6.x86_64.rpm --force 查看内核1rpm -qa | grep kernel 安装锐速破解版1wget -N --no-check-certificate https://github.com/91yun/serverspeeder/raw/master/serverspeeder.sh &amp;&amp; bash serverspeeder.sh 锐速卸载1chattr -i /serverspeeder/etc/apx* &amp;&amp; /serverspeeder/bin/serverSpeeder.sh uninstall -f 查看锐速状态1service serverSpeeder status 锐速相关1service serverSpeeder start | stop | restart 搭建shadowsocks 安装 安装pip1yum install python-setuptools &amp;&amp; easy_install pip 安装shadowsocks1pip install shadowsocks 配置 创建一个文件在1234```cd /etcvi shadowsocks.json 在json文件中写入如下信息 12345678&#123; &quot;server&quot;:&quot;x.x.x.x&quot;, #服务器IP地址 &quot;server_port&quot;:8388, #服务监听端口 &quot;local_port&quot;:1080, #本地连接端口 &quot;password&quot;:&quot;barfoo&quot;, #加密传输使用到的密码 &quot;timeout&quot;:600, #连接超时时间 &quot;method&quot;:&quot;aes-256-cfb&quot; #加密算法&#125; 启动、停止 1ssserver -c /etc/shadowsocks.json -d start | stop 配置定时任务 在vps的内存比较小的时候，shadowsocks容易被系统给kill掉，这时，我们就要有个定时任务去查看shadowsocks的服务状态 首先，创建一个查看服务脚本 1234567891011#! /bin/shproc_name=&quot;shadowsocks.json&quot;number=`ps -ef | grep $proc_name | grep -v grep | wc -l`if [ $number -eq 0 ];then ssserver -c /etc/shadowsocks.json -d startelse ssserver -c /etc/shadowsocks.json -d restartfi 给脚本添加运行权限 1chmod 777 xxxx.sh 将脚本加入定时任务中 1crontab -e //打开定时任务配置 加入上面的脚本 1*/1 * * * * ./xxx.sh //注意脚本路径 启动定时任务 1service crond start 安装使用Apache在Linux中Apache的名字叫 12查看服务器版本 apachectl -v12安装Apache yum install httpd12打开Apache /etc/init.d/httpd start或者httpd -k start | stop | restart12Apache的配置文件路径 /etc/httpd/conf/httpd.conf12## 安装Mysql ## yum list installed | grep mysql#查看是否已经安装yum install mysql-server#安装服务端yum install mysql-devel#这个应该是组件，不知道有什么用yum install mysql#安装客户端 service mysqld start#启动service mysqld stop#停止service mysqld restart#重启mysqladmin -u root password 123456#设置密码mysql -u root -p #登录`","tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"ssh连接报错","date":"2016-12-11T03:02:30.000Z","path":"2016/12/11/ssh连接报错/","text":"使用ssh连接远程服务器在使用VPS的时候由于更换了数据中心，导致远程服务ip地址改变，使用ssh连接的时候报如下错误 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!Someone could be eavesdropping on you right now (man-in-the-middle attack)!It is also possible that a host key has just been changed.The fingerprint for the RSA key sent by the remote host is6e:45:f9:a8:af:38:3d:a1:a5:c7:76:1d:02:f8:77:00.Please contact your system administrator.Add correct host key in /home/hostname /.ssh/known_hosts to get rid of this message.Offending RSA key in /var/lib/sss/pubconf/known_hosts:4RSA host key for pong has changed and you have requested strict checking.Host key verification failed. 解决办法找到~/.ssh/路径下的known_hosts打开，删除对应的ip以及对应信息保存就好","tags":[{"name":"VPS那些事","slug":"VPS那些事","permalink":"http://yoursite.com/tags/VPS那些事/"}]},{"title":"iOS中的枚举","date":"2016-05-11T03:02:30.000Z","path":"2016/05/11/枚举的实现方式(移位枚举)/","text":"普通的枚举第一种实现方式1234typedef enum &#123; EnumTypeTop, EnumTypeBottom&#125;EnumType 第二种实现方式1234typedef NS_ENUM(NSInteger,EnumType) &#123; EnumTypeTop, EnumTypeBottom&#125;; 枚举的作用就是增加程序的可读性,将原来使用数值代表的状态转换成自然语言中有相应含义的单词,所以这样写出来的代码更易读懂。编译器会为枚举分配一个独有的编号,从0开始,每个枚举递增1 移位枚举实现方式12345678910typedef NS_OPTIONS(NSUInteger, EnumType) &#123; EnumTypeNone = 0, // 0000 0000 0 EnumTypeTop = 1&lt;&lt;0, // 0000 0001 1 EnumTypeBottom = 1&lt;&lt;1, // 0000 0010 2 EnumTypeLeft = 1&lt;&lt;2, // 0000 0100 4 EnumTypeRight = 1&lt;&lt;3, // 0000 1000 8 EnumTypeCenter = 1&lt;&lt;4, // 0001 0000 16 EnumTypeHeight = 1&lt;&lt;5, // 0010 0000 32 EnumTypeWidth = 1&lt;&lt;6 // 0100 0000 64&#125; 上面就是一个移位枚举, 和普通的枚举的区别就是,每个状态的值不是递增的,而是用只有1个二进制位的值是1数字表示的,这么做的好处就是可以对状态值进行”位或”运算,从而实现同时使用多个枚举 1234567891011121314151617181920212223242526272829303132333435- (void)testEnum &#123; [self needMutEnum:EnumTypeTop | EnumTypeBottom | EnumTypeLeft | EnumTypeRight | EnumTypeCenter];&#125;- (void)needMutEnum:(EnumType) type &#123; if (type==0) &#123; NSLog(@\"EnumTypeNone\"); return; &#125; if (type &amp; EnumTypeTop) &#123; NSLog(@\"EnumTypeTop\"); &#125; if (type &amp; EnumTypeBottom) &#123; NSLog(@\"EnumTypeBottom\"); &#125; if (type &amp; EnumTypeLeft) &#123; NSLog(@\"EnumTypeLeft\"); &#125; if (type &amp; EnumTypeRight) &#123; NSLog(@\"EnumTypeRight\"); &#125; if (type &amp; EnumTypeCenter) &#123; NSLog(@\"EnumTypeCenter\"); &#125; if (type &amp; EnumTypeHeight) &#123; NSLog(@\"EnumTypeHeight\"); &#125; if (type &amp; EnumTypeWidth) &#123; NSLog(@\"EnumTypeWidth\"); &#125;&#125; 输出 12345EnumTypeTopEnumTypeBottomEnumTypeLeftEnumTypeRightEnumTypeCenter 这样就实现了同时使用多个枚举 原因“位或”和”位与”运算“位或”: 0 | 0 = 0 ; 0 | 1 = 1 ; 1 | 1 = 1;“位与”: 0 &amp; 0 = 0 ; 0 &amp; 1 = 0 ; 1 &amp; 1 = 1; 对移位枚举进行”位或”运算 EnumTypeTop | EnumTypeBottom | EnumTypeLeft | EnumTypeRight | EnumTypeCenter 转换成二进制就是 0000 0001 | 0000 0010 | 0000 0100 | 0000 1000 | 0010 0000 = 0011 1111 其10进制的值时63 所以”needMutEnum”这个方法传入的值 type 是十进制的63, 当使用的时候又用 type 的值和枚举做”位与运算”,63的二进制是 0011 1111 EnumTypeTop的二进制是 0000 0001 ,”位与”运算的结果就是 0000 0001 , 也就是说传入的 type 的值转换成二进制,哪个位上是 1 ,对应的那个类型的枚举就被传入了, 但是要注意的是,如果不需要None的状态,就不要把第一个枚举状态设置成 0 ,直接从0000 0001 设置","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]}]