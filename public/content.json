[{"title":"anaconda的安装和使用","date":"2021-04-12T10:43:57.000Z","path":"2021/04/12/anaconda的安装和使用/","text":"前言最近在搭建一个python工程的环境的时候，发现需要使用一些指定版本的软件环境，所以就想到了使用Anaconda 简介 Anaconda指的是一个开源的Python发行版本，其包含了conda、Python等180多个科学包及其依赖项。 [1] 因为包含了大量的科学包，Anaconda 的下载文件比较大（约 531 MB），如果只需要某些包，或者需要节省带宽或存储空间，也可以使用Miniconda这个较小的发行版（仅包含conda和 Python）。 安装Anaconda有两种安装方式，都可以从官网下载 图形界面双击下载好的pkg ,然后无脑下一步就好 命令行下载好命令行安装包，其实就是一个sh脚本,然后运行安装 1bash ~/Downloads/xxx.sh 使用安装完没有任何反应，在终端敲conda --version 也显示找不到conda命令 这时候需要在终端启动一下 12345678910111213//如果安装的时候，选的是为所有人安装，则运行此命令source /opt/anaconda3/bin/activate//如果安装的时候，选的是自己的账号，则运行此命令，可以用 echo $USER 查看usernamesource /Users/my_username/opt/anaconda3/bin/activate//初始化一下命令行 zsh 使用：conda init zsh//bash shell 使用conda init//查看是否设置成功conda list 环境管理创建新环境1234conda create --name &lt;env_name&gt; &lt;package_names&gt;//eg:conda create -n python python=3.8 切换环境1234source activate &lt;env_name&gt;//eg:source activate python 查看环境12345conda info --envs//orconda info -e//orconda info --envs 退出环境1source deactivate 删除环境1conda remove --name &lt;env_name&gt; --all","tags":[]},{"title":"我家云搞OMV","date":"2020-11-11T15:10:12.000Z","path":"2020/11/11/我家云搞OMV/","text":"前言最近闲的蛋疼，收了两个矿渣我家云，想着玩玩NAS，这里记录一下折腾过程 网上有一些现成的教程，都是大佬折腾好的，直接刷入，就可以使用了，基本没什么坑，但是我在使用过程中，发现transmission老是爆内存，然后被系统杀死，一个不能挂PT的NAS还是一个好NAS么，所以我打算自己搞一个OMV看看能解决这个问题不 安装linux我家云的CPU是RK3328，多少核心啥的，自己百度一下吧，但是重点是，这个U是开源的，也就是你可以定制自己的系统，国外这里有详细的介绍，包括刷机，点击这里 刷linux系统你需要如下东西： 硬件： 我家云， 公对公USB线一条 Windows电脑一台 软件： DriverAssistant （驱动） AndroidTool （刷机软件） boot.img (引导镜像) linux.img (系统镜像) 刷机过程： 首先，运行DriverInstall.exe安装驱动，然后，我家云用usb线连接电脑（使用白色2.0接口），运行刷机软件，选则上面两个镜像，按住我家云reset键，接入电源，软件找到设备，点击执行，等待刷写完成 成功以后，我家云接入有线网，使用ssh登录 12ssh root@我家云ip密码默认 1234 这里就进入了我家云linux系统 执行12apt update apt upgrade 更新系统 omv安装12345678910111213&lt;!--下载key--&gt;wget http://packages.openmediavault.org/public/archive.key&lt;!--添加key--&gt;apt-key add archive.key&lt;!--创建服务列表--&gt;vim /etc/apt/sources.list.d/openmediavault.list&lt;!--在列表中添加下面两个源--&gt;deb http://packages.openmediavault.org/public arrakis maindeb http://packages.openmediavault.org/public usul main&lt;!--更新源--&gt;apt update&lt;!--安装omv--&gt;apt install openmediavaul 漫长的等待之后，就安装好了OMV，用浏览器访问我家云ip，就能看到登录页面。账号： admin密码： openmediavault 安装OMV-ExtrasOMV5默认是没有OMV-Extras的，需要我们自己安装官网给出的教程是这样的，在终端使用root用户运行下面命令 1wget -O - https://github.com/OpenMediaVault-Plugin-Developers/packages/raw/master/install | bash 显示done就表示完成了 OMV的使用在终端对OMV做一些配置，可以使用如下命令 1omv-firstaid 如果出现ip无法访问OMV，可以使用这个命令初始化端口和软件 docker安装安装完OMV-Extras在OMV的web页面，左边系统栏下面会多一个OMV-Extras的选项，点击进入，然后选择docker，选择安装，就会自动安装完成docker，同样的可以把portainer安装完成，portainer是docker的可视化管理工具，可以用来创建容器，安装镜像 transmission安装进入portainer管理页，选择local，在container容器中，新建一个容器，名字随便输入，image镜像输入docker hub中搜索到的名字linuxserver/transmission，从dockerhub说明页中的配置信息可以看到，transmission,需要映射9019，51413，51413udp，三个端口，同时在volumes中将对的的路径映射到本地，添加env变量，接下来部署，等待完成就可以使用transmission了 其他网上有个设置好的omv但是，使用过程中风扇一直狂转，声音有些大，所以我找到一个改风扇的文件，估计就是恩山的，但是恩山要币，我下载不下来，不知道是不是同一个，使用方法 在系统 - 计划任务中，停掉/opt/fan任务，启动放入文件的任务","tags":[{"name":"我家云","slug":"我家云","permalink":"http://yoursite.com/tags/我家云/"},{"name":"OMV","slug":"OMV","permalink":"http://yoursite.com/tags/OMV/"},{"name":"armbian","slug":"armbian","permalink":"http://yoursite.com/tags/armbian/"}]},{"title":"吃黑苹果--Clover美化","date":"2019-07-11T15:10:12.000Z","path":"2019/07/11/吃黑苹果--Clover美化/","text":"前言Clover是用来引导黑苹果的，但是默认设置有时候会满足不了我们的需求，所以需要美化 修改Clover分辨率 关闭CSM， CSM是BIOS的一个设置项，它是一个兼容支持模块，可以让新的UEFI BIOS兼容老的legacy+MBR启动模式。关闭方法在:BIOS中设置 使用Clover configurator，打开‎⁨EFI⁩ ▸ ⁨EFI⁩ ▸ ⁨CLOVER ▸ config.plist,在左边点击GUI栏，然后在右边Screen Resolution设置需要的分辨率 修改默认启动系统 使用Clover configurator，打开‎⁨EFI⁩ ▸ ⁨EFI⁩ ▸ ⁨CLOVER ▸ config.plist，在左边点击boot栏，在右边找到Default Boot Volume，选择LastBootedVolume， 在右边找到Timeout，并设置需要延迟的时间，如果勾选-1则不延迟，如果选择Fast则不显示Clover,快速启动系统 查找所有启动项 使用Clover configurator，打开‎⁨EFI⁩ ▸ ⁨EFI⁩ ▸ ⁨CLOVER ▸ config.plist，点击左边的Boot.log,再点击右下角的Generate log 从里面搜索ScanLoader，ScanLoader下面的[xx]:启动项就是启动项名 隐藏无用启动项 使用Clover configurator，打开‎⁨EFI⁩ ▸ ⁨EFI⁩ ▸ ⁨CLOVER ▸ config.plist，点击左边的Gui栏，在右边的Hide Volume里填入上面查找到的想要隐藏的启动项名称 修改Clover主题 下载喜欢的clover主题，并将文件夹放到‎⁨EFI⁩ ▸ ⁨EFI⁩ ▸ ⁨CLOVER ▸ themes文件夹中 修改‎⁨EFI⁩ ▸ ⁨EFI⁩ ▸ ⁨CLOVER ▸ config.plist，点击左边的Gui栏，在右边Theme填入对应主题的文件夹名称 如果找不到喜欢的主题，可以试试Clover Theme Manager,这个软件","tags":[{"name":"黑苹果","slug":"黑苹果","permalink":"http://yoursite.com/tags/黑苹果/"}]},{"title":"吃黑苹果--声卡驱动","date":"2019-07-11T15:10:12.000Z","path":"2019/07/11/吃黑苹果--声卡驱动/","text":"前言电脑升级10.14.5之后声卡不能切换设备，不能调整音量，怀疑是声卡驱动不是最新的，所以更新声卡驱动就好 查看声卡要找到对应的驱动，首先要知道声卡的型号，我的主板是华硕B150-A,中关村在线搜索得知搭载的板载声卡型号是集成Realtek ALC887 8声道音效芯片 下载驱动知道声卡型号就可以去下载最新的声卡驱动AppleALC，下载地址 同时下载对最新Lilu, 下载地址 更新驱动将下载好的声卡驱动文件AppleALC和Lilu解压，并放在‎⁨EFI⁩ ▸ ⁨EFI⁩ ▸ ⁨CLOVER⁩ ▸ ⁨kexts⁩ 修改ID首先在这里查看你的声卡支持的ID 然后使用Clover configurator或者其他plist编辑文件，编辑你EFI分区下的Clover配置文件，我的路径是‎⁨EFI⁩ ▸ ⁨EFI⁩ ▸ ⁨CLOVER ▸ config.plist 用Clover configurator打开config.plist,选择左边的Devices,然后在右边Audio下面填写上面查到的声卡支持的ID,保存，重启 注意 替换驱动的时候记得做好备份 如果没有效果，请确定没安装其他的声卡驱动 更新系统后，有可能要更新驱动和ID 如果还没有效果，那么你可以使用Kext Utility更新S/L/E下的AppleHDA.kext,同时使用命令sudo kextcache -i /更新缓存","tags":[{"name":"黑苹果","slug":"黑苹果","permalink":"http://yoursite.com/tags/黑苹果/"}]},{"title":"Mac软件--mos","date":"2019-06-30T03:02:30.000Z","path":"2019/06/30/Mac软件--mos/","text":"前言Mac黑苹果使用鼠标的时候，鼠标滚轮不是特别灵敏，经常向下滚动的时候，会出现页面向上的问题，使用这个mos软件可以完美解决这个问题 安装方法软件源码地址mos地址 安装1brew cask install mos 命令会自动安装软件到/Applications/Mos.app 更新12brew updatebrew cask reinstall mos 更新后重新启动应用即可","tags":[{"name":"Mac软件","slug":"Mac软件","permalink":"http://yoursite.com/tags/Mac软件/"}]},{"title":"Mac软件--Keyboard Maestro","date":"2019-06-29T03:02:30.000Z","path":"2019/06/29/Mac软件--Keyboard Maestro/","text":"前言平时不使用电脑的时候，通常是让电脑睡眠，而不是关机，但是当电脑屏幕太大的时候，左上角的小苹果就不是那么容易点到了，每次都要先找到鼠标，然后去左上角让电脑睡眠，这么操作台麻烦了，所以要是睡眠有快捷键，就会方便很多了 安装下载好软件安装即可 设置 打开程序，在Macros栏，点击加号添加一个事件 在右边的设置中输入事件名称 点击New Trigger,选择Hot Key Trigger Type中输入需要设置的事件对应的按键 在下面Will execute the following actions中选择对应的事件","tags":[{"name":"Mac软件","slug":"Mac软件","permalink":"http://yoursite.com/tags/Mac软件/"}]},{"title":"Heroku使用记录","date":"2019-03-17T03:02:30.000Z","path":"2019/03/17/Heroku使用记录/","text":"前言Heroku是一个免费的云服务，据说还可以跑VPN,但是这不是我这次研究的问题，这次想把listen1-api,构建出来的js代码部署到上面，当做接口使用 一 、注册官网地址 ： https://www.heroku.com/ 注册没有难度，使用国外邮箱，能翻墙就OK 二、安装工具这个工具就是一个能在终端部署的工具heroku-cli 工具地址： https://devcenter.heroku.com/articles/heroku-cli 这个工具和hexo是一个意思，但是有一个坑的地方就是，你的终端也要可以FQ,不然登录不上去 终端FQ方法以前记录过，这里在贴一下，方便使用 12345export http_proxy=socks5://127.0.0.1:1080 # 配置http 代理访问export https_proxy=socks5://127.0.0.1:1080 # 配置https 代理访问export all_proxy=socks5://127.0.0.1:1080 # 配置http和https访问unset http_proxy # 取消http 代理访问unset https_proxy # 取消https 代理访问 上面命令中的端口号和地址，需要和shadowsock中socks5监听的地址和端口号一致,而且这个只是临时使用，要想长期使用，需要加入到shell中 卸载命令： 1rm -rf /usr/local/heroku /usr/local/lib/heroku /usr/local/bin/heroku ~/.local/share/heroku ~/Library/Caches/heroku 三 、使用查看工具版本1heroku -v 登录1heroku login 创建程序1heroku create app-name 创建完成会有两个地址，一个是访问的网址，一个是代码仓库的地址 我的测试的地址是如下 1https://nodetestdemo.herokuapp.com/ | https://git.heroku.com/nodetestdemo.git 推送代码使用git把代码推送到上面生成的仓库中 123456git initgit add .git commit -m &quot;commit&quot;git remote add origin https://git.heroku.com/app-name.gitgit remote -vgit push -u origin master 推送完成后，就可以访问上面的地址，查看代码是否部署成功","tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Python相关--Numpy使用","date":"2019-03-01T12:10:12.000Z","path":"2019/03/01/Python相关--Numpy使用/","text":"前言NumPy(Numerical Python) 是 Python 语言的一个扩展程序库，支持大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。 numpy 方法创建矩阵 1234567891011121314151617np.array([1,2,3],[2,3,4])np.array([2,3,4],dtype=np.int) //同时指定类型np.zeros((3,4)) //生成3行4列全部为0的矩阵np.ones((3,4),dtype=np.int) //生成3行4列全部为1的矩阵np.empty((3,4)) //生成3行4列为空的矩阵，里面的值全部都是接近0的值np.arange(10,20,2) //生成一个从10到20，步长为2的矩阵，不包括20np.arange(12).reshape((3,4)) //生成一个从0到11的3行4列的矩阵np.linspace(1,10,20) //生成一个从1到10，一共20段的矩阵，起始值是1结束值是10np.random.random((2,4)) //生成一个随机的2行4列矩阵 查看数组维度 1array.ndim 查看数组的形状 1array.shape 查看数组的元素 1array.size numpy的运算1234567891011121314151617181920212223242526272829303132333435363738a=np.array([10,20,30,40]) //[10 20 30 40]b=np.arange(4) //[0 1 2 3]c=a+b //[10 21 32 43]c=a-b //[10 19 28 37]c=a*b //[0 20 60 120]c=b**4 //表示b的4次方c=10*np.sin(a) //对a的每个元素求sin再乘以10c=b&lt;3 //[True True True False] 每个元素是否小于3/******/a=np.array([[1,1],[0,1]])b=np.arange(4).reshape((2,2))c=a*b //元素逐个相乘 [[0 1] [0 3]]c=np.dot(a,b) //矩阵的乘法 [[2 4] [2 3]]c=a.dot(b) //矩阵乘法的另一种表示/******/a=np.random.random((2,4))np.sum(a,axis=1) //不加axis=1表示所有元素求和，axis=1表示维度,1是以行求和，0是以列求和np.min(a,axis=0) //求最小值 同上np.max(a,axis=1) //求最大值 同上/******/a=np.arange(2,14).reshape((3,4))b=np.argmin(a) //获取最小值的索引c=np.argmax(a) //获取最大值的索引d=np.mean(a) //获取平均值e=np.average(a) //另一种平均值算法f=np.median(a) //中位数g=np.cumsum(a) //累加，第一个值是第一个元素的值。第二个值是前两个元素相加的值h=np.diff(a) //相邻的差i=np.sort(a) //从小到大排序，每行排每行的j=np.transpose(a) //矩阵反向，行变成列，列变成行j=a.T //也是矩阵的反向k=np.clip(a,5,9) //小于5的数变成5，大于9的数变成9","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"MAC使用密钥登录VPS","date":"2019-02-12T13:30:12.000Z","path":"2019/02/12/MAC使用密钥登录VPS/","text":"前言今天登录VPS,突然提示如下信息 12Last failed login: Tue Feb 12 07:55:56 EST 2019 from 218.92.1.143 on ssh:nottyThere were 49 failed login attempts since the last successful login. 貌似被别人跑猴子了，所以我就关了密码登录 使用密钥登录MAC默认是有一个密钥的，没有的话先生成一对 接下运行如下命令： 1ssh-copy-id root@X.X.X.X root是你VPS的用户名，后面是IP 运行完会提示输入VPS的密码 如下 123456789/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: &quot;/Users/xxx/.ssh/id_rsa.pub&quot;/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keysroot@X.X.X.X&apos;s password:Number of key(s) added: 1Now try logging into the machine, with: &quot;ssh &apos;root@X.X.X.X&apos;&quot;and check to make sure that only the key(s) you wanted were added. 接下来尝试登录： 1ssh &apos;root@X.X.X.X&apos; 没有问题会直接登录成功 关闭密码登录打开VPS的ssh配置文件 1vi /etc/ssh/sshd_config 找到PasswordAuthentication改yes为no,如果没有就手动添加上 然后保存重启ssh服务 1systemctl restart sshd.service","tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"vim 编辑器使用","date":"2018-11-23T15:32:12.000Z","path":"2018/11/23/vim编辑器使用/","text":"前言最近突然觉得使用vim在终端查看文本特别高大上，就打算研究一下，但是感觉学习成本太大，效率不高，就简单记录一下，方便以后有需要查询 vim 命令打开文件 1vim 文件名 如果没有会新建一个文件 非正常关闭会有.swp的缓存文件 默认打开是命令模式,要想输入要进入 命令模式 yy复制光标所在行 4yy复制光标所在行及下面三行 dd剪切(如果不粘贴就是删除)光标所在行 4dd剪切(如果不粘贴就是删除)光标所在行及下面三行 p粘贴到光标的下面一行 h左移光标 j下移光标 k上移光标 l右移光标 H移动光标到当前屏幕上方 M移动光标到当前屏幕中间 L移动光标到当前屏幕下方 ctrl+f下翻一页 ctrl+b上翻一页 ctrl+d下翻半页 ctrl+u上翻半页 20G光标移动到20行 G光标移动到最后一行 gg光标移动到第一行 w向后跳一个单词的长度,下一个单词的开始 b向前跳一个单词的长度,上一个单词的开始 D删除当前行光标以及后面的内容 u撤销刚刚的操作 ctrl+r反撤销 d0删除当前行光标之前的内容 x删除当前光标的一个内容 X删除当前光标前面的一个内容 v + 移动光标 选中块内容(字母选) V + 移动光标 选中块内容(正行选) &gt;右缩进 &lt;左缩进 .重复上一个命令 r 替换光标内容 R 替换光标以及后面的内容 /+内容搜索内容, (n上一个搜索内容,N下一个搜索内容) 编辑模式命令模式输入i从光标的前面开始编辑 命令模式输入a从光标的后面开始编辑 命令模式输入o从光标下面新起一行编辑 命令模式输入O从光标上面新起一行编辑 命令模式输入I从光标行首开始编辑 命令模式输入A从光标行末开始编辑 按esc退出编辑模式 末行模式末行模式 (命令模式输入:) w保存 q退出 q!强制退出 shift+vv相当于wq %s/abc/123/g把所有的abc替换成123 1,10s/abc/123/g把1到10行的abc替换成123 按esc退出编辑模式","tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Flutter的安装","date":"2018-11-10T11:26:12.000Z","path":"2018/11/10/Flutter的安装/","text":"前言记录一下安装flutter的过程，方便以后查询 安装下载flutter: 终端输入： 1git clone -b beta https://github.com/flutter/flutter.git 添加临时环境变量： 1export PATH=`pwd`/flutter/bin:$PATH 注意：pwd表示当前路径，后面的flutter就是你git下来的文件夹，里面会有一个bin文件夹，这里如果git下来的文件夹不叫flutter，需要改上面的命令为对应的文件名称，而且要和pwd打印出来的路径能连接上 检查依赖： 1flutter doctor 这一步可能需要翻墙，解决办法是添加这两个镜像 12export PUB_HOSTED_URL=https://pub.flutter-io.cnexport FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn 如果flutter doctor跑出什么问题，按照提示解决就好 如果是如下错误，需要在android studio中添加插件 1234 ✗ Flutter plugin not installed; this adds Flutter specific functionality. ✗ Dart plugin not installed; this adds Dart specific functionality.[!] Connected device ! No devices available 如果需要安装dart点同意就好，如果没有其他错误，就表示flutter安装成功","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://yoursite.com/tags/Flutter/"}]},{"title":"UITableViewCell的创建","date":"2018-10-20T11:58:55.000Z","path":"2018/10/20/UITableViewCell的创建/","text":"前言cell的创建通常有两种方法，平时使用的时候没有注意，这里记录一下 UITableViewCell的创建我们都知道iOS中tableview的cell在创建的时候会用到重用机制，简单的说，就是把每个cell绑定一个标识，然后当cell在屏幕中显示的时候，系统首先会去缓冲池中取对应标志的cell，如果没有那就创建一个cell，如果有就直接拿出来使用，当cell滚动出屏幕的时候，系统会把cell放回缓冲池中，这样，缓冲池中最多也就一两个对象，而系统也不需要每次显示都创建对象。 12345678- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;identiffier&quot;]; if (!cell) &#123; cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:@&quot;identiffier&quot;]; &#125; return cell;&#125; 这个是一个默认的tablecell的创建，可以看到 1UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;identiffier&quot;]; 先是去缓冲池去取cell，如果没有再去创建 所以这个写法必须要加上下面的if判断，如果不加，而且缓冲池中没有cell，那么程序就会因为返回一个nil崩溃 12345- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;identiffier&quot; forIndexPath:indexPath]; return cell;&#125; 在iOS6之后，又有了这种创建cell的方法，这种方法不需要写if，也就是说，如果缓冲池中没有，系统会自动的去创建一个cell，但是如果只是这么写还是不够的，系统还是会崩溃，因为你你要告诉tableview用什么标识创建一个什么cell 简单的说，你还要在tableview创建的时候写上下面的方法 1[tableView registerClass:[UITableViewCell class] forCellReuseIdentifier:@&quot;identiffier&quot;]; 这样tableview就知道，在缓冲池中没有cell的时候，需要用什么类创建一个什么标识的cell 总结tableviewcell的重用有两种方法 1UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;identiffier&quot;]; 这种方法不需要注册cell，但如果缓冲池没有需要手动创建 1UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;identiffier&quot; forIndexPath:indexPath]; 这种方法需要注册cell，但是不需要手动创建了","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"rvm管理ruby","date":"2018-08-13T12:13:12.000Z","path":"2018/08/13/rvm管理ruby/","text":"前言最近工程更新开发环境，需要使用ruby的2.4.0以上的版本，而本地的开发环境是2.3.0，记录一下更换ruby方法 1、安装rvmrvm就是Ruby Version Manager，是Ruby的版本管理器 查看rvm版本： 1rvm -v 安装rvm 1curl -L get.rvm.io | bash -s stable 更新修改配置文件使之生效 12source ~/.bashrc source ~/.bash_profile 安装完成后可以再次查看rvm版本，判断是否安装成功 2、升级ruby查看ruby当前版本,以及本地所安装的所有版本 1rvm list 查看ruby所有版本 1rvm list known 安装新版本ruby 2.4.4 1rvm install 2.4.4 切换ruby到需要的版本 1rvm --default use 2.4.4","tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Linux系统使用--斐讯T1安装Armbian","date":"2018-06-14T03:10:12.000Z","path":"2018/06/14/Linux系统使用--斐讯T1安装Armbian/","text":"前言之前买过一个斐讯T1，用来当电视盒子配置还是够的，但是我没有看电视的需求，后来发现可以安装Linux，于是拿来尝试了一下，增加它的可玩性 准备工作 U盘一个 斐讯T1 电脑 注意：我在安装的时候使用的使用的一个U盘怎么也无法启动到Linux，看网上说是对U盘有要求，解决办法就是换一个U盘，所以在多次安装完成后遇到，无法启动Linux时，建议更换U盘，我后来换成了TF卡就没有出现无法启动的问题 还有安装的时候斐讯的系统版本不能是最新版的，最好刷一个降级包 下载系统斐讯T1的cpu是Amlogic 晶晨S912，对应的系统被国外的大神制作好上传到Yandex Disk,所以下载系统可能需要FQ 系统下载地址 进去会有各个版本的文件夹，我使用的是5.91,所以进入5.91文件中，下载需要的系统。 一个版本会有多个种类的系统文件，区别是Debian和Ubuntu,还有对应的桌面版还是服务版，下载自己需要的一个就好。 写入U盘下载完系统，就可以把写入U盘了 我使用的软件是balenaEtcher, 下载地址，选择对应系统的版本就好（是你电脑的系统） balenaEtcher的使用也很简单，第一项选择上面下载好的linux系统，第二项选择你的U盘（写入操作会格式化U盘，注意U盘数据备份），接着点击第三项Flash,等待写入成功 修改dtb写入完成的U盘会有个叫BOOT的盘符，这时我们需要修改里面的dtb,斐讯T1使用的dtb叫做meson-gxm-q201.dtb,我们可以在Boot/dtb/文件夹中找到。 使用文本编辑器打开BOOT盘符中的boot.ini文件，修改里面的setenv dtb_name为&quot;/dtb/meson-gxm-q201.dtb&quot;,修改完该行如下： 1setenv dtb_name &quot;/dtb/meson-gxm-q201.dtb&quot; 使用文本编辑器打开BOOT盘符中的uEnv.ini文件，修改里面的dtb_name为/dtb/meson-gxm-q201.dtb,修改完该行如下： 1dtb_name=/dtb/meson-gxm-q201.dtb 使用文本编辑器打开BOOT盘符中extlinux文件夹下的extlinux.conf文件，修改里面的FDT为/dtb/meson-gxm-q201.dtb,修改完该行如下： 1FDT /dtb/meson-gxm-q201.dtb 启动Linux将修改好的U盘插入斐讯T1的usb接口，然后给斐讯通电，斐讯启动会自动进入Linux系统，如果没有进入，网上的教程说在安卓的终端输入reboot update,斐讯T1会重启，就进入Linux系统了，但是我用这个不起作用，所以，我建议，没有启动Linux,就更换U盘，或者更换系统试试 进入系统如果启动了Linux,等待加载完成，如果加载过程中失败了，则可能是系统问题，建议更换别的版本的Linux系统。 如果加载完成了，输入root登录超级用户，密码1234,登录成功会提示设置新的root密码，先输入默认密码1234,在输入两次新密码，设定成功。 接下来按照提示，设置新用户名，和密码，已经用户信息。设置完成，就可以用新用户登录了。 如果是有图形界面版本的系统，没有进入桌面，按ctrl+alt+F7进入桌面系统 设置中文字体开启中文字体1sudo vim /etc/locale.gen # 将里面的zh_CN.UTF-8前面的#去掉 更新程序列表1sudo apt update 更新程序1sudo apt upgrade 安装字体包（两种字体选一种就好）123sudo apt install fonts-noto-cjksudo apt install ttf-wqy-zenhei 更新字体列表1sudo fc-cache -v 生成locale文件1sudo locale-gen 重启系统 远程桌面安装x11vnc 1sudo apt install x11vnc 生成vnc密码 1sudo x11vnc -storepasswd 启动vnc 1x11vnc -auth guess -forever -loop -noxdamage -repeat -rfbauth /home/USERNAME/.vnc/passwd -rfbport 5900 -shared 设置开机自启动 1234567891011121314#新建servicesudo vim /etc/systemd/system/x11vnc.service#添加如下内容[Unit]Description=Start x11vnc at startup.After=multi-user.target [Service]Type=simpleExecStart=/usr/bin/x11vnc -auth guess -forever -loop -noxdamage -repeat -rfbauth /home/USERNAME/.vnc/passwd -rfbport 5900 -shared [Install]WantedBy=multi-user.target 依次执行下面的命令123sudo chmod u+x /etc/systemd/system/x11vnc.servicesudo systemctl daemon-reloadsudo systemctl enable x11vnc.service","tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"SSH Key","date":"2018-06-01T07:41:23.000Z","path":"2018/06/01/SSH Key/","text":"前言记录SSH的使用 SSH Key 的生成 一个ssh key是由两个文件组成,一个是私钥名字默认是id_rsa,另一个就是公钥默认名字是id_rsa.pub,两个是配套使用的 Mac系统默认秘钥的存放路径是~/.ssh 如果在存放路径中有公钥和私钥就不需要生成,可以直接使用,如果没有就需要使用下面命令生成一个 1ssh-keygen -t rsa -C &quot;your_email@example.com&quot; 敲完回车首先会让你填写一个文件名,就是生成的ssh文件的文件名,不填写默认会是id_rsa和id_rsa.pub或id_dsa和id_dsa.pub 注意:这里的文件如果输入了文件名,生成的公钥和私钥文件存放的位置是当前命令的位置 输入完文件名回车后会让你输出密码和确认密码,可以为空,但是如果输出了,每次使用ssh的时候都会让你输入密码 输入完密码生成一个ssh key文件就大功告成了 最后会给你一个randomart image这个东西是用来方便比对key是否一样的,以为人们对不图片比对不字符串的接受更容易 SSH Key 的参数-t xxxxxx可以是rsa rsa1 或dsa,这个是几种不同的加密算法 -C &quot;your_email@example.com&quot;生成的时候添加一个注释 -f ~/.ssh/id_rsa_soho 指定保存文件名和位置 其他参数暂时用不到,就不介绍了 多个SSH Key 同时使用如果需要使用多ssh文件给不同的服务器时,就要使用配置文件了 在~/.ssh目录创建一个名字为dconfig的文本文件 里面写如下内容 1234567891011121314151617# 配置github.comHost github.com# 这个是真实的域名地址 HostName github.com# 这是id_rsa的路径 IdentityFile ~/.ssh/id_rsa_github# 配置登录时用什么权限认证--可设为publickey,password,publickey,keyboard-interactive等 PreferredAuthentications publickey# 配置使用用户名 User username1# 配置git.oschina.net Host git.oschina.net HostName git.oschina.net IdentityFile ~/.ssh/id_rsa_oschina PreferredAuthentications publickey User username2 每个ssh文件单独配置一个Host，Host可以随便起，只要配置好HostName和IdentityFile两个属性即可 注意：如果 Host mygithub这样定义的话，命令如下，git的命令应该写成:git clone git@mygithub:123.git 测试配置是否成功,使用如下命令: 1ssh -T git@github.com 附录: Mac下开启/关闭 显示隐藏文件的方法 12显示：defaults write com.apple.finder AppleShowAllFiles -bool true隐藏：defaults write com.apple.finder AppleShowAllFiles -bool false","tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"RAS 加密算法原理","date":"2018-05-02T13:45:12.000Z","path":"2018/05/02/RSA非对称加密/","text":"前言网上看了一下李永乐老师讲的非对称加密的原理，挺有意思的，记录一下 非对称加密传递信息的非对称加密过程： A想要把信息m发送给B B生成两个有相关性的数字，e（公钥）和d（私钥） B把公钥e以公开的形式传给A A通过公钥的某一种算法得到密文C A把密文C传给B B通过私钥d解密密文C，得到信息m RSA加密算法RSA就是一种非对称加密的算法 RSA加密过程： 首页B找出两个质数p，q n = p*q 带入欧拉函数 Φ（n）= （p-1）*（q-1） 找出公钥e ，e需要满足两个条件（1）1&lt;e&lt;Φ（n）(2) e 和 Φ（n）互质 找出私钥d ，d需要满足e*d/Φ（n）余数是1 加密算法：m的e次幂除以n求余数C 解密算法：C的d次方除以n求余数m 安全性A在传播信息的时候传播了n，e，c 解密需要n，d，c 如果想知道私钥d，由上面可知，需要知道Φ（n） Φ（n）需要知道p，q p，q需要知道n，因为n=p*q 求p，q的过程叫分解质因数 但是大数的质因数特别难分解，所以RSA加密算法安全，当然如果可以做到大数质因数分解那么就。。。 eg：量子计算机","tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Linux执行定时脚本","date":"2018-04-11T03:10:12.000Z","path":"2018/04/11/Linux执行定时脚本/","text":"前言新租的的服务器内存有点小，经常在使用一段时间后，就回因为内存不够，导致服务停止，所以写了一个定时启动服务的脚本 定时服务脚本这个脚本的作用就是找到当前任务中有没有叫shadowsocks.json的任务，如果有，就证明服务没挂，那就重启一下，如果没有，就证明服务挂了，那就启动一下 脚本内容如下: 1234567891011#! /bin/shproc_name=&quot;shadowsocks.json&quot;number=`ps -ef | grep $proc_name | grep -v grep | wc -l`if [ $number -eq 0 ];then ssserver -c /etc/shadowsocks.json -d startelse ssserver -c /etc/shadowsocks.json -d restartfi 使用vi编辑完成后保存为xxx.sh 给脚本添加执行权限1chmod 777 xxx.sh 添加定时任务通过crontab命令，在固定时间间隔执行指定的系统指令或shell脚本 crontab其实就是一个定时任务，如果开启的时候，他会按照配置文件中的时间，定时执行指定脚本 crontab服务的开启方法： 12345sudo service crond start #启动服务sudo service crond stop #关闭服务sudo service crond restart #重启服务sudo service crond reload #重新载入配置sudo service crond status #查看服务状态 crontab配置文件的编辑方法： 123crontab -l #查看配置文件内容crontab -e #编辑配置文件内容 crontab配置文件格式： 12345678910# .---------------- minute (0 - 59) # | .------------- hour (0 - 23)# | | .---------- day of month (1 - 31)# | | | .------- month (1 - 12) OR jan,feb,mar,apr ... # | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat # | | | | |# * * * * * command to be executed#eg:* */4 * * * ~/xxx.sh #表示每四分之一小时执行一次xxx.sh脚本","tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Linux系统使用--Bash基础","date":"2018-04-11T03:10:12.000Z","path":"2018/04/11/Linux系统使用--Bash基础/","text":"前言linux的bash使用相关 bash的特性命令行展开： ~ {}命令别名： alias，unalias命令历史： history文件名通配：glob快捷键：Ctrl+a,e,u,k,l命名补全： $PATH路径补全： Tab ####命令hash####bash 会将使用过的命令缓存下来，再次输入命令的时候会先从缓存中去寻找命令，如果没有找到再去$PATH中去自左向右寻找 查看缓存历史命令:123hash-d //删除缓存中的指定命令-r //清空缓存 变量bash的变量无需事先声明bash把所有变量统统视作字符类型bash不支持浮点数据，需借助外在工具变量名只能包含数字，字母和下划线，且不能以数字开头 bash变量类型: 一、本地变量: 作用域为当前shell进程 变量使用: ${var_name}, 或$var_name, &quot;&quot;变量名会替换为其值, &#39;&#39;变量名不会替换为其值 查看变量: set 撤销变量: unset name 二、环境变量: 作用域为当前shell进程及其子进程 变量赋值: 1. export name=value 2. name=value export name 3. declare -x name=value 4. name=value declare -x name 注意: bash内嵌了许多环境变量(通常为全大写字符)，用于定义bash的工作环境。eg: `PATH, HISTFILE, HISTSIZE, HISTFILESIZE, HISTCONTROL, SHELL, HOME, UID, PWD, OLDPWD` 查看环境变量: 1234exportdeclare -xprintenvenv 撤销变量: `unset name` 只读变量: 1. declare -r name 2. readonly name 只读变量无法重新赋值，且不支持撤销，存活时间为当前shell进程的生命周期，随shell进程终止而终止 三、局部变量: 作用域为函数 四、位置参数变量: 当执行脚本的shell进程传递的参数 五、特殊变量: shell内置的有特殊功用的变量 eg:`$? 表示命令运行状态0表示成功，1-255表示失败` 多命令执行1~]# COMMAND1; COMMAND2; COMMAND3; ... 短路法则:123~]# COMMAND1 &amp;&amp; COMMAND2 //如果命令1失败，则命令2不执行~]# COMMAND1 || COMMAND2 //如果命令1成功，则命令2不执行 bash的配置文件登录类型： 交互式登录shell进程： 直接通过某终端输入账号和密码后打开的shell进程 使用su - USERNAME或者su -l USERNAME执行的登录切换 非交互式登录shell进程： 使用su USERNAME执行登录切换 图形界面下打开的终端 运行脚本 profile类： 全局：对所有用户都生效 12/etc/profile/etc.profile.d/*.sh 用户个人：仅对当前用户有效 1~/.bash_profile 作用： 用于定义环境变量 运行命令或脚本 bashrc类 全局： 1/etc/bashrc 用户个人： 1~/.bashrc 作用： 1. 定义本地变量 2. 定义命令别名 加载顺序： 交互式 1/etc/profile --&gt; /etc/profile.d/* --&gt; ~/bash_profile --&gt; ~/.bashrc --&gt; /etc/bashrc 非交互式 1~/.bashrc --&gt; /etc/bashrc --&gt; /etc/profile.d/* 让shell进程重读配置文件 12~]# source /PATH/FROM/CONF_FILE~]# . /PATH/FROM/CONF_FILE","tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Linux系统使用--shell脚本编程","date":"2018-04-11T03:10:12.000Z","path":"2018/04/11/Linux系统使用--shell脚本编程/","text":"前言linux的shell脚本编程使用相关 Linux系统使用–shell脚本编程shell脚本编程是利用系统上的命令及编程组件进行编程的过程式编程语言，简单的说shell脚本就是命令的堆积，但是需要程序逻辑来判断运行条件是否满足，以避免其运行中发生错误 shell脚本格式 第一行，顶格给出shebang(解释器路径)，用于指明解释执行当前脚本的解释器程序文件 常见的解释器路径： 123#!/bin/bash#!/usr/bin/python#!/usr/bin/perl shell脚本运行 赋予执行权限，直接运行 12chmod +x /PATH/TO/SCRIPT_FILE/PATH/TO/SCRIPT_FILE 直接运行解释器，将脚本以命令行参数传递给解释器程序 1bash /PATH/TO/SCRIPT_FILE","tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Linux系统使用--用户权限管理","date":"2018-04-11T03:10:12.000Z","path":"2018/04/11/Linux系统使用--用户权限管理/","text":"前言在linux/unix上面执行脚本的时候，通常需要脚本有执行权限，这里记录一下设置权限的方法 chmod 命令-rw-rw-r– 权限描述一共十位 第一位表示文件类型:-是文件 d是文件夹 第二位到第四位 表示文件拥有者的权限 第五位到第七位 表示同组者的权限 第八位到第十位 表示其他人的权限 r是读权限 w是写权限 x是运行权限 修改权限: 字母法 u文件拥有者 g文件同组者 o其它人 chmod u=rwx 文件名 chmod g=w 文件名 chmod u=r,g=r,o=r 文件名 所有用户都是读权限 chmod u=,g=,o= 文件名 所以用户都没有权限 数字法 r—4w—2x—1 数字的来源就是二进制，三位二进制的各个值 chmod 137 文件名 拥有者是执行权限,同组者是写执行权限,其它人是读写执行权限","tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"MAC下安装Python3","date":"2018-03-24T14:32:17.000Z","path":"2018/03/24/MAC下安装Python3/","text":"前言MAC os本身是自带Python的,但是不是Python3，这里记录一下安装Python3的步骤 1、安装Xcode步骤： 1）、打开App Store 搜索Xcode,点击安装，安装完成后打开 如果是第一次打开Xcode需要同意License Agreement 2）、然后安装Xcode command line tool 在终端输入 1xcode-select --install 在弹出的窗口中点击安装等待完成 2、安装HOMEBREWHomeBrew的介绍和安装方法可以在其官网找到 HomeBrew官网 1）、在终端输入： 1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 等待HomeBrew安装完成 2）、验证安装结果，在终端输入： 1brew doctor 如果显示Your system is ready to brew. 代表Homebrew安装成功 3、安装Python如前言所说其实MAC os是自带一个Python的,我们可以使用下面命令查看Python版本 1python --version 首先安装Python 终端输入： 1brew install python 完成后Python3就会被安装到/usr/local/Cellar目录下 输入which python3查看python3的命令路径 4、修改系统路径首先查看系统路径，输入： 1echo $PATH 显示出来的路径就是系统搜索命令的路径 如果里面没有Python3的路径，就需要我们手动添加一下 输入： 1sudo emacs /etc/paths 把Python3的路径添加进去 然后按：ctrl+x+c 回复y保存退出 5、注意TensorFlow在Python3.7下目前不支持，而brew的新版本又不支持指定版本Python安装，所以最简单的解决办法是从Python官网下载3.6版本的pkg安装，pkg安装的路径是/Library/Frameworks/Python.framework/ 移除brew安装的Python 12#移除所有版本Pythonbrew uninstall --force python","tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Mac下打造属于你自己的终端","date":"2018-03-16T14:46:17.000Z","path":"2018/03/16/Mac下打造属于你自己的终端/","text":"item2的自定义样式让你的终端用上主题 准备工具 item2 item2是Mac下超好用的一款终端产品,而且是免费的,你可以点击这里 下载到. oh-my-zsh oh-my-zsh是一个管理自己zsh的工具,可以方便得管理自己的item2样式主题 Powerline (可选) Powerline是一个字体补丁,不安装有可能出现乱码,但不是所有的主题都需要 安装过程安装oh-my-zsh首先下载item2,从上面的官网点击download,然后解压下载下来的解压包,拷贝到应用程序中,item2就安装完成了 接着安装oh-my-zsh,直接在终端输入下面的命令 1curl -L https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh | sh 如果想要卸载oh-my-zsh需要在终端输入下面的命令 1uninstall_oh_my_zsh oh-my-zsh安装完成会有如下提示: 1Please look over the ~/.zshrc file to select plugins, themes, and options. 此时你的oh-my-zsh就安装完成了 关掉你的item2然后再重新启动一下看看,样子是不是已经发生变化了 配置oh-my-zshoh-my-zsh安装完成会有一个默认主题的,上面重启之后看到的主题就是默认的主题,下面我们配置一下自定义主题 安装完成后在你的用户目录下面(就是通常的123456789101112`.oh-my-zsh`这个文件夹里面存放着oh-my-zsh的主题文件夹`themes`,配置模板`templates`,字体文件夹`plugins`,日志`log`,库`lib`,工具`tools`等`.zshrc`这个文件是`oh-my-zsh`的配置文件好知道了这些就可以更换主题了:1. 创建一个zsh配置文件到`~`目录 使用`cp`命令拷贝`~/.oh-my-zsh/templates/zshrc.zsh-template`这个文件到`~/.zshrc` 输入: cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc 12注意: 如果你的`~/.zshrc`存在,最好使用下面命令备份一下 cp ~/.zshrc ~/.zshrc.orig 1234 2. 设置zsh为默认的shell 输入: chsh -s /bin/zsh 123456 3. 查看主题 到主题文件夹目录中选一个主题 输入: cd ~/.oh-my-zsh/themes 12345678 查看并选择一个想要设置的主题 4. 修改配置文件 用vim打开oh-my-zsh的配置文件,修改主题名字 输入: vim ~/.zshrc 12345678910111213修改`ZSH_THEME=&quot;xxx&quot;`一行引号中的内容为想要设置的主题名字,保存退出,重启item2.附录:想知道每个主题的样式可以点击这里,[官方对照表](https://github.com/robbyrussell/oh-my-zsh/wiki/themes)如果有自己下载的主题也可以放到`~/.oh-my-zsh/themes`中然后按照上面的方法设置如果有的主题显示乱码,就需要上面的字体补丁,安装方法输入: pip install powerline-status 12如果提示: zsh: command not found: pip 12则先安装pip,输入: sudo easy_install pip ```","tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"hexo部署报错解决","date":"2017-12-06T15:21:15.000Z","path":"2017/12/06/hexo部署报错解决/","text":"前言由于换了一个电脑搭建hexo,在部署的时候报错了，这里记录一下解决办法： 删除.deploy_git 报错操作从git拉下代码，在新搭建的hexo环境中hexo d部署的时候报一下错误 1234567891011121314~/Desktop/myBlog (master ✘)✖✹✭ ᐅ hexo dINFO Deploying: gitINFO Clearing .deploy_git folder...INFO Copying files from public folder...fatal: in unpopulated submodule &apos;.deploy_git&apos;FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlError: fatal: in unpopulated submodule &apos;.deploy_git&apos; at ChildProcess.&lt;anonymous&gt; (/Users/xxx/Desktop/myBlog/node_modules/hexo-util/lib/spawn.js:37:17) at ChildProcess.emit (events.js:182:13) at maybeClose (internal/child_process.js:978:16) at Socket.stream.socket.on (internal/child_process.js:395:11) at Socket.emit (events.js:182:13) at Pipe._handle.close (net.js:616:12) 解决办法解决办法很简单，把博客目录下的.deploy_git删除重新构建部署就好，命令如下 123rm -rf .deploy_githexo ghexo d 看来以后要把这个文件夹添加到.gitignore文件中试试","tags":[{"name":"日常","slug":"日常","permalink":"http://yoursite.com/tags/日常/"}]},{"title":"Learn JavaScript","date":"2017-11-11T13:10:12.000Z","path":"2017/11/11/JavaScript/","text":"前言闲来无事看了看JavaScript,这里记录部分内容。 Equality (相等比较符)1234var foo = 42;var bar = 42;var baz = \"42\";var qux = \"life\"; 定义了四个变量在Javascript中==是用来比较两个值但是不会判断类型故foo == baz返回的值是true 使用==比较的时候编译器会先把类型转换成相同的类型,再去比较 因此在JavaScript 要是比较不同类型的两个值可以使用===这样会先判断类型,如果类型不同就会返回false 所以推荐使用===比较 注意: 1.NaN是个特殊的Number,他与所有其他值都不相等,包括它自己 1NaN === NaN ; // false 唯一能判断NaN的方法是通过isNaN()函数: 1isNaN(NaN); // true 2.浮点数的比较: 11/3 === (1 - 2 / 3); //false 这个结果是正确的,出现这个结果这是因为浮点数在运算过程中会产生误差,计算机无法精确的表示无限小数,所以要比较两个浮点数是否相等,只能计算他们之差的绝对值,看是否小于某个阈值: 1Math.abs(1/3 - (1 - 2 / 3)) &lt; 0.0000001; //true TypesnumbersJavaScript中只有一种数字类型 – 64-bit float point,类似于Java中的double类型,所以在JavaScript中1和1.0是相同的值number可以直接做四则运算，规则和数学一致 字符串字符串是以’单引号’或”双引号”括起来的文本,如&#39;abc&#39; &quot;xyz&quot; 注意&#39; &#39;和&quot; &quot;并不是字符串的一部分 如果字符串中包含&#39; 就使用&quot;&quot;把文本包起来,如果字符串中包含&quot; 就需要使用转义字符了\\ 在多行字符串中换行使用的是\\n 但是如果行数太多\\n需要写多个,不方便,在JavaScript中又增加了一种表示方法(ES6),就是将多行文本用`… `括起来,就是键盘上tab键上边的那个按键. 模板字符串多个字符串可以使用+连接起来.字符串也可以是变量如: 123var name = '小王吧';var age = '100';var message = '你好,' + name + ',你现在' + age + '岁'; 同样,如果要连接的变量有很多,使用+就会很不方便,在JavaScript中增加了一种模板字符串的表示(ES6): 123var name = '小王吧';var age = '101';var message = `$&#123;name&#125;,你今年$&#123;age&#125;岁,是不是?` 注意:新的表示方法使用的是` ,就是新的多行文本使用的符号,就是键盘上tab按键上边的那个按键,不能使用&quot;&quot;或&#39;&#39;,那样无法转换变量 字符串操作获取字符的长度 12var name = 'xiao wang ba.';alert(name.length); //13 获取指定位置字符,可以把字符串看成是特殊的数组,对字符串进行下标操作,从0索引开始 123456var name = 'xiao wang ba.';name[0]; //'x'name[1]; //'i'name[4]; //' 'name[12];//'.'name[13];//undefined 超出范围的索引一律返回undefined 注意:给字符串的索引赋值不会有报错,也不会有任何效果,字符串也不会改变 改变字符串为大写 12var name = 'xiao wang ba.';name.toUpperCase(); //返回'XIAO WANG BA.' 改变字符串为小写 12var name = 'Xiao Wang Ba.';name.toLowerCase(); //返回'xiao wang ba.' 注意:如果字符串是中文,则没效果 返回字符串出现的位置 123var name = 'Xiao Wang Ba.';name.indexOf('Wang');//返回5name.indexOf('wang');//如果没有找到指定的子串,返回-1 获取字符串中的子串 123var name = 'xiao wang ba.';name.substring(0,4);//从索引0开始到4(不包括4),返回'xiao'name.substring(10);//从索引10开始到结束,返回'ba.' 布尔值JavaScript中的布尔值有true和false两种值,可以直接用true或false表示,也可以通过布尔运算计算出来 null和undefinednull表示一个”空”的值,同Java中的null,Swift中的nil,Python中的None用法类似.undefined表示”未定义”.JavaScript设计的时候希望用null表示一个空的值,用undefined表示值未定义,但是大多数情况下我们都应该用null.undefined仅仅在判断函数参数是否传递的情况下有用 数组数组是一组按顺序排列的集合,集合的每个值称为元素.JavaScript的数组可以包括任意数据类型.创建方法: 1[1,2,3.14,\"hello\",null,true]; //推荐使用 另一种创建方法: 1new Array(1,2,3); 获取数组的长度 12345var arr = [1,2,3.14,\"hello\",null,true];arr.length;//6//可以给数组的长度赋值,改变数组的大小arr.length = 7;//数组改变为[1,2,3.14,\"hello\",null,true,undefined]arr.length = 4;//数组改变为[1,2,3.14,\"hello\"] 数组可以通过索引来访问每个元素的值,也可以改变索引对应元素的值: 123var arr = [1,2,3.14,\"hello\",null,true];arr[0]; //数组第一个元素,值为1arr[1] = 10;//修改数组第二个元素的值为10 注意:如果通过索引给数组赋值的时候,索引超过了数组长度,数组会被变大 12var arr = ['A', 'B', 'C'];arr[5] = 'F';//arr会变为['A', 'B', 'C', undefined, undefined, 'F']; 获取对应元素的索引 12345var arr = [10, 20 ,'30', 'xyz'];arr.indexOf(10);//元素10的索引是0arr.indexOf(20);//元素20的索引是1arr.indexOf(30);//元素30的索引是 -1 因为没有找到元素arr.indexOf('30');//元素'30'的索引是2 注意：数字30和&#39;30&#39;是不同的元素 获取数组中的部分元素 123var arr =['A','B','C','D','E','F','G'];arr.slice(0,3);//从索引0开始,到索引3结束,但不包括索引3:['A','B','C']arr.slice(3);//从索引3开始到结束:['D','E','F','G'] 注意:slice()的起止参数包括开始索引,不包括结束索引如果不给slice()传递任何参数,它会从头到尾截取所有元素,这个方法可以复制一个array 123456789var arr = ['A','B','C','D','E','F','G'];var aCopy = arr.slice();aCopy; //['A','B','C','D','E','F','G'];aCopy === arr; //falseif(aCopy.toString() === arr.toString()) &#123; alert('一样');//数组相同&#125;else &#123; alert('不一样');//数组不同&#125; 注意:JavaScript比较两个数组是否相同不能直接使用=== 要比较两个数组是否相同,需要先把数组转换成字符串,然后再比较 在数组末尾添加或删除若干元素,push()和pop() 123456789var arr = [1 , 2];arr.push('A','B'); //返回新的长度为4的数组arr; //[1,2,'A','B']arr.pop();//pop()返回'B'arr; // [1,2,'A']arr.pop();arr.pop();arr.pop(); //连续pop 3次arr; //[]arr.pop(); //空数组继续pop不会报错,而是返回undefinedarr;//[] 在数组头部添加或删除若干元素,unshift()和shift() 123456789var arr =[1,2];arr.unshift('A','B');//返回新的长度为4的数组arr;//['A','B',1,2]arr.shift();//'A'arr;//['B',1,2]arr.shift();arr.shift();arr.shift();//连续shift 3次arr;//[]arr.shift();//空数组继续shift不会报错,而是返回undefinedarr;//[] 数组排序sort()可以对当前数组进行排序,它会直接修改当前的数组元素的位置,直接调用时,会按照默认顺序排序 123var arr = ['B','C','A'];arr.sort();arr;//['A','B','C'] 注意 在函数中可以自定义排序条件 数组反转 reverse()可以把数组的元素反转 123var arr = ['A','B','C'];arr.reverse();arr;//['three','two','one'] 数组修改的”万能方法”,可以从指定索引开始删除若干元素,然后再从该位置添加若干元素 123456var arr =['Microsoft','Apple','Yahoo','AOL','Excite','Oracle']arr.splice(2,3,'Google','Facebook');//从索引2开始删除3个元素,然后再添加两个元素,返回删除的元素['Yahoo','AOL','Excite']arr.splice(2,2);//只删除不添加,返回['Google','Facebook']arr;//['Microsoft','Apple','Oracle']arr.splice(2.0,'Google','Facebook');//只添加,不删除,返回[]arr;//['Microsoft','Apple','Google','Facebook','Oracle'] 把两个数组连接起来,返回一个新的数组 1234var arr = ['A','B','C'];var added = arr.concat([1,2,3]);added; //['A','B','C',1,2,3]ARR;//['A','B','C'] 注意 concat()方法并没有修改当前数组,而是返回了一个新的数组 而且concat()可以接收任意个元素和数组,并把所有数组自动拆开,添加到新的数组中 12var arr = ['A','B','C'];arr.concat(1,2,[3,4]);//['A','B','C',1,2,3,4] 把数组的每个元素都用指定的字符串连接起来,然后返回字符串 12var arr = ['A','B','C',1,2,3];arr.join('-'); //'A-B-C-1-2-3' 注意如果数组的元素不是字符串,会自动转换成字符串再连接 多维数组,指的是数组中的某个元素又是一个数组 1var arr = [[1,2,3],[400,500,600],'-']; 上述Array包含3个元素,其中头两个元素本身也是Array 对象对象是一组由键-值组成的无序集合: 12345678var person = &#123; name: 'XiaoWang', tags: ['js', 'web', 'mobile'], age: 12, city: 'shanghai', hasCar: false, zipcode: null&#125;; JavaScript用一个{...} 表示一个对象,键值对以xxx: xxx形式申明,用,隔开,最后一个键值对不需要加 JavaScript对象的键都是字符串类型,值可以是任意数据类型,每个键都是对象的一个属性,获取属性的方法: 12person.name; // 'XiaoWang'person.zipcode; // null 注:var person 是JavaScript的一个变量,person是变量名,变量名是大小写英文,数字,$和_的组合,且不能用数字开头,也不能使用JavaScript中的关键字 strict模式蛋疼的布兰登在设计JavaScript的时候为了赶工期,并没有强制使用var声明变量,如果一个变量没有通过var声明就被使用,这个变量就会被自动声明为全局变量 1i = 10; //i就是一个全局变量 如果在不同的JavaScript文件中,你都使用了同样名字的变量,而且都没有用var声明,那么你就麻烦了. 因此,为了给布兰登填坑,ECMA在后续的规范中推出了strict模式,在strict模式下运行JavaScript代码不允许使用没有var声明的变量,如果有那么就给你报错 启动strict模式的方法很简单,就是在JavaScript代码的第一行写上: 1'use strict'; 注:如果你用的是老爷机,你的浏览器太老了,他会自以为是的把上面那就话当做一个字符串语句执行,如果这样的话还是换个最新版的浏览器吧 Advanced Operaters (高级运算符)取余运算 x = y % 2累加运算 a = 5 c = a++/Users/YaoWanXin/Desktop/app.html resulets : c = 5 and a = 6 c = ++a resulets : c = 6 and a = 6累减运算 a = 5 c = a-- resulets : c = 5 and a = 4 c = --a resulets : c = 4 and a = 4","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"使用命令行启动Sublime","date":"2017-10-06T14:10:38.000Z","path":"2017/10/06/使用命令行启动Sublime/","text":"使用终端启动Sublime工作中需要经常使用终端，有时候查看文本文件又需要使用Sublime,所以可以用终端调用Sublime是一件很方便的事情 准备工作系统：mac ox 软件：sublime 第一步 查看终端是否能打开Sublime打开终端，cd到任意一个文件夹，输入如下命令： 1/Applications/Sublime\\ Text.app/Contents/SharedSupport/bin/subl . 这时候如果Sublime成功的打开了当前命令所在的文件夹，就说明终端启动成功。 如果无法启动，请查看sublime的路径和名称是否和你安装的相同 .表示打开当前文件夹，如果输入具体文件名称，也可以打开具体文件 第二步 查看终端环境变量在终端输入： 1vim ~/.bash_profile 在里面找到当前系统的环境变量 1export PATH= 注意：如果你安装过zsh,那么你的环境变量应该到~/.zshrc中寻找 如果你的环境变量文件编辑了，那么你需要source 环境变量文件一下你的环境变量文件，使他生效 第三步 创建命令终端执行： 1ln -s /Applications/Sublime\\ Text.app/Contents/SharedSupport/bin/subl /usr/local/bin/subl 然后就搞定了。 前面的路径是sublime的安装路径，后面的路径是设置好的环境变量 在终端中使用下面命令测试一下 1subl . 如果成功打开当前路径文件夹就说明成了，以后使用subl 文件名就可以快速的在终端用Sublime打开文件啦 参考文件： Open Sublime Text from Terminal in macOS mac中的环境变量 sublime 官网描述","tags":[{"name":"日常","slug":"日常","permalink":"http://yoursite.com/tags/日常/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"iOS中的isEqual：和 “==”","date":"2017-06-13T15:32:00.000Z","path":"2017/06/13/iOS中的isEqual：和 “==”/","text":"前言在iOS开发中常常要比较两个值是否一样，通常的做法有两种，就是用isEqual：或者使用== “==” 比较如果用==比较的是两基本类型，则比较的是两个两个基本类型的值，如果比较的是两个对象类型，则比较的是对象的地址 这时如果有两个string： 12NSString *str1 = @&quot;hello&quot;;NSString *str2 = [NSString stringWithFormat:@&quot;hello&quot;]; 这两个string的内容明显是一样的，但是地址却不一样，如果使用==比较就会返回NO 这样就用到我们的isEqual： 注：isEqualToString：会在下面说 isEqual：比较使用isEqual：是想要比较对象的值，而不是地址，注意这里是想要 使用isEqual：比较上面两个字符串，会返回YES 但是这不代表所有的对象使用都会去自动比较对象的值，比如比较两个自己定义的对象的时候，默认情况下他其实还是比较的两个对象的地址 之所以比较字符串会比较两个值，是因为NSString的isEqual： 已经被重写了,注意这里是重写因为isEqual：是NSObject的方法 同时还增加了一个isEqualToString：方法，这里是增加，因为这是NSString自己的方法 同样的还有还多，比如NSDate,NSArray,NSDictionary,NSSet,甚至是UIColor 所以当我们想要比较自己定义的对象的值的时候，我们也要重写自己的isEqual： 重写的时候其实你可以说任何一个比较的对象都是一样的，换句话说只要你觉得符合你的业务逻辑，你就可以说他是一样 重写isEqual：123456789101112131415161718- (BOOL)isEqual:(id)other &#123; if (other == self) return YES; if (!other || ![other isKindOfClass:[self class]]) return NO; return [self isEqualToWidget:other]; &#125; - (BOOL)isEqualToWidget:(MyWidget *)aWidget &#123; if (self == aWidget) return YES; if (![(id)[self name] isEqual:[aWidget name]]) return NO; if (![[self data] isEqualToData:[aWidget data]]) return NO; return YES; &#125; 其实上面的方法可以随意返回，只要你觉得需要","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"OC使用静态库中的类别","date":"2017-06-05T12:02:30.000Z","path":"2017/06/05/OC使用静态库中的类别/","text":"OC中使用静态库中的类别的问题OC的源文件经过 clang 编译首先生成中间代码,接着通过优化生成目标代码(目标代码中包括符号表,标示了此代码中的全局符号和静态符号,还标示了导入符号等),连接器会根据符号表分析各个目标代码之间的调用关系,然后将使用到的代码进行连接和重定位,最后生成可执行文件. 在编译Objective-C源文件到目标文件时,编译器并不知道方法的对应实现,只能在运行时才知道,所以编译器只会为类生成连接符号,不会对类中的方法生成连接符号,由于Category方法并不对应一个新类,所以不会生成连接符号,连接器也不会将Category方法合并到原始的类中,最终导致连接器忽略了Category方法,不会将其连接到可执行文件中. 在OC使用静态库中的类别,需要设置下面5种方法中的一种 Other Linker Flags 设置 1.通过在Other Linder Flags 添加 -all\\_load 它会告诉编译器对”所有文档中的所有对象文件,不管里面的符号有没有被用到,全部都载入”,这样会产生比较大的二进制文件 2.通过在Other Linder Flags 添加 -force\\_load 和指定路径 e.g: -force\\_load $(SRCROOT)/RHAddressBook/libRHAddressBook.a 这种方法会只载入指定的归档 3.通过在Other Linder Flags 添加 -ObjC ,这个标识告诉编译器”如果在文档中发现了OC代码,就把文档载入” 4.在Xcode里build setting中的 Perform Single-Object PreLink，如果启用这个选项，所有的对象文件都会被合并成一个单文件（这不是真正的链接，所以叫做预链接），这个对象文件（有时被称做主对象文件(master object file)）被添加到文档中。现在如果主对象文件中的任何符号被认为是“在使用”，整个主对象文件都会被认为在使用，这样它里面的OC部分就会被载入了。因为里面的类都被正常符号化了，所以能使从这样的静态库中使用所有的Category 5.最后一种解决方法是在只有Category的源文件里添加Fake symbol。如果你想在运行时使用Category，一定要确保你以某种方法在编译时引用了fake symbol，这会使得对象文件以及它里面的OC代码被载入。例如，它可以是一个有空函数体的函数，也可以是一个被访问的全局变量（例如一个全局的int变量，只要它被读或者写了一次就足够了）。和上面其他的解决方法不一样，这种解决方法可以控制哪些category可以在运行时被编译后的代码使用（可以通过使用这个符号，使它们被链接并变得可用；也可以不使用这个符号，这样链接器就会忽略它）","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"synthesize和dynamic","date":"2017-05-24T15:07:32.000Z","path":"2017/05/24/synthesize和dynamic/","text":"@property@property 会生成一个ivar和他的getter/setter方法 但是在protocol和category中只会生成getter/setter方法的声明 @synthesize@synthesize 表示如果属性没有手动实现setter/getter方法，编译器会自动加上getter/setter两个方法,给后面的实例变量 eg： 1@syntheszie var = _var; 如果一个属性这么写了，表示你告诉编译器，生成一个以var命名的setter/getter方法，和一个实例变量_var。如果同时你又自己声明了一个名叫_var的实例变量，那么@synthesize就不会生成实例变量，而是用你声明的那个。也就是两个实例变量是一个。 如果_var你写的是另一个属性的实例变量，那么会编译错误，但是你可以交换两个属性的实例变量。（可是没什么意义） eg： 1@syntheszie var 如果这么写，那么生成的实例变量就是var,这时你自己声明一个_var和var是不冲突的，也就是两个，属性用的是var。 @dynamic@dynamic 表示属性的setter/getter方法由用户自己实现，不自动生成。若没有手动生成，则运行时会报错，因为方法没有实现 eg： 1@dynamic var;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"读《iOS与OS X多线程和内存管理》—— GCD","date":"2017-05-14T13:53:48.000Z","path":"2017/05/14/读《iOS与OS X多线程和内存管理》—— GCD/","text":"前言《iOS与OS X多线程和内存管理》的第三章是对GCD的介绍，GCD就是Grand Central Dispatch,是将应用程序中记述的线程管理用的代码在系统级中实现。说简单点就是，用简单的方法实现多线程 队列 Dispatch Queue队列（Dispatch Queue）是存放任务等待执行处理的地方。既然是队列，那么他要遵循FIFO先进先出原则。 队列有两种： Serial Dispatch Queue (串行队列) Concurrent Dispatch Queue (并行队列) Serial Dispatch Queue（串行队列）的特点是需要等待现在执行中的任务处理结束才可以处理下一个任务 Concurrent Dispatch Queue (并行队列)的特点是不等待现在执行中的任务处理结束，可以并行执行多个处理，但是并行处理的数量取决于当前系统的状态 线程一个CPU执行的CPU命令列是一条无分叉路径，这就是一个线程，所以从队列的种类来看，串行队列始终在使用一个线程处理任务，而并行队列使用的是多个线程处理任务，多个线程的数量取决于当前系统状态 APIGCD使用过程中的各种API 创建和获取队列创建一个串行队列: 1dispatch_queue_t serialDispatchQueue = dispatch_queue_create(&quot;queueName&quot;，DISPATCH_QUEUE_SERIAL); 创建一个并行队列： 1dispatch_queue_t concurrentDispatchQueue = dispatch_queue_create(&quot;queueName&quot;, DISPATCH_QUEUE_CONCURRENT); 创建串行队列和并行队列的方法是一样的，唯一的区别是第二个参数，如果创建的是串行队列，传入DISPATCH_QUEUE_SERIAL就好，如果是创建并行队列，则指定为DISPATCH_QUEUE_CONCURRENT。 创建队列的第一个参数，是队列的名称，他可以在调试器中显示，苹果推荐的名称是，逆序全程域名，你也可以传NULL 获取系统提供的队列： 1234567891011121314//获取主线程队列 （串行队列）dispatch_queue_t mainDispatchQueue = dispatch_get_main_queue();//获取全局队列--高优先级 （并行队列）dispatch_queue_t highQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);//获取全局队列--默认优先级 （并行队列）dispatch_queue_t defaultQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);//获取全局队列--低优先级 （并行队列）dispatch_queue_t lowQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0);//获取全局队列--后台优先级 （并行队列）dispatch_queue_t backgroundQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0); 改变队列优先级在使用dispatch_queue_create函数生成的队列，不管是串行还是并行的都是默认优先级的。要改变优先级需要使用dispatch_set_target_queue函数。 123dispatch_queue_t myQueue = dispatch_queue_create(&quot;queueName&quot;, DISPATCH_QUEUE_SERIAL);dispatch_queue_t globalBackgroundQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND,0);dispatch_set_target_queue(myQueue, globalBackgroundQueue); 这样myQueue的优先级就是DISPATCH_QUEUE_PRIORITY_BACKGROUND的了。 注意，不能改变系统提供的队列的优先级，也就是系统提供的队列不能写在第一个参数中 dispatch_set_target_queue还可以改变队列执行优先级，如果有多个串行任务在多个串行队列中执行，这时如果要防止并行，就可以将多个串行队列，指定到同一个目标串行队列中，原本并行执行的多个串行队列就会变成真正的串行，同时执行一个处理。 延迟执行使用dispatch_after可以实现延迟指定时间执行 12345dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 3ull*NSEC_PER_SEC);dispatch_after(time, dispatch_get_main_queue(), ^&#123; //延迟执行的任务内容&#125;); 注意，这里的延迟是在指定时间追加任务到指定队列，所以有可能有延时，不算绝对精确。 Dispatch GroupDispatch Group可以在多个队列都执行完成后，执行指定队列 123456789dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_group_t group = dispatch_group_create();dispatch_group_async(group,queue, ^&#123;NSLog(@&quot;blk1&quot;);&#125;);dispatch_group_async(group,queue, ^&#123;NSLog(@&quot;blk2&quot;);&#125;);dispatch_group_async(group,queue, ^&#123;NSLog(@&quot;blk3&quot;);&#125;);dispatch_group_notify(group, dispatch_get_main_queue(),^&#123;NSLog(@&quot;done&quot;);&#125;);//dispatch_group_wait(group,DISPATCH_TIME_FOREVER); //指定超时时间 dispatch_barrier_asyncdispatch_barrier_asyne函数会等待在他前面追加在并行队列上的任务全部执行完，然后执行他的任务，在他的任务执行完再恢复并行队列的任务 eg： 123456789dispatch_queue_t queue = dispatch_queue_create(&quot;queueName&quot;,DISPATCH_QUEUE_CONCURRENT);dispatch_async(queue,blk0_for_reading);dispatch_async(queue,blk1_for_reading);dispatch_async(queue,blk2_for_reading);dispatch_async(queue,blk3_for_reading);dispatch_barrier_async(queue, blk_for_writing);dispatch_async(queue,blk4_for_reading);dispatch_async(queue,blk5_for_reading);dispatch_async(queue,blk6_for_reading); dispatch_syncdispatch_sync是同步将block追加到队列中，dispatch_async是非同步的将block追加到队列中，区别就是dispatch_sync会在追加完成后，等待任务执行完，而dispatch_async不做任何等待。 一旦调用dispatch_sync函数，在指定的处理执行结束之前，该函数不会返回，所以该函数容易引起死锁问题，比如在主线程同步添加任务。 dispatch_applydispatch_apply可以按照指定的次数将指定的block追加到指定的队列中，并等待全部处理执行结束 1234dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);dispatch_apply(10, queue, ^(size_t index) &#123; NSLog(@&quot;%zu&quot;,index);&#125;); 因为他也会等待处理执行结束，所以也会有死锁问题。 dispatch_suspend/dispatch_resumedispatch_suspend函数可以挂起指定的队列 dispatch_resume函数可以恢复指定的队列 dispatch_once这是经常写单例使用的方法，dispatch_once函数可以保证在应用程序执行中只执行一次。 eg： 12345static dispatch_once_t pred;dispatch_once(&amp;pred, ^&#123; //do something&#125;);","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"读《iOS与OS X多线程和内存管理》—— 属性","date":"2017-05-10T11:26:12.000Z","path":"2017/05/10/读《iOS与OS X多线程和内存管理》—— 属性/","text":"前言在ARC中是使用所有权修饰符来实现自动引用计数的，但是编程中我们几乎很少显式的写所有权修饰符，而是写属性关键字。 属性与所有权修饰符的对应关系 属性 所有权修饰符 assign __unsafe_unretained copy __strong (赋值的是被复制对象) retain __strong strong __strong unsafe_unretained __unsafe_unretained weak __weak __strong 实现123&#123;id __strong obj = [NSObject alloc] init];&#125; 在编译时会转换成 123id obj = objc_msgSend(NSObject, @selector(alloc));objc_msgSend(obj, @selector(init));objc_release(obj);//变量作用域结束编译器自动插入了release 使用alloc/new/copy/mutableCopy以外的方法 123&#123;id __strong obj = [NSMutableArray array];&#125; 在编译时会转换成 1234567891011id obj = objc_msgSend(NSMutableArray,@selector(array));/*array方法在编译时转换成了&#123;id obj = objc_msgSend(NSMutableArray, @selector(alloc));objc_msgSend(obj, @selector(init));return objc_autoreleaseReturnValue(obj);&#125;*/objc_retainAutoreleasedReturnValue(obj);objc_release(obj);//变量作用域结束编译器自动插入了release objc_retainAutoreleasedReturnValue() 和 objc_autoreleaseReturnValue是成对出现的，用在alloc/new/copy/mutableCopy以外的类方法时 objc_autoreleaseReturnValue函数和objc_autorelease函数不同，objc_autorelease函数会注册对象到autoreleasepool中objc_autoreleaseReturnValue函数会检查使用该函数的方法或函数调用方的执行命令列表，如果在后面紧接着调用objc_retainAutoreleaseReturnValue()函数，则将返回的对象直接传递到方法或函数的调用方，而不注册到autoreleasepool objc_retainAutoreleasedReturnValue函数和objc_retain函数不同，它即便不注册到autoreleasepool中而返回对象，也能够正确地获取对象通过objc_autoreleaseReturnValue函数和objc_retainAutoreleasedReturnValue函数，可以不将对象注册到autoreleasepool中而直接传递 __weak 实现123&#123;id __weak obj1 = obj;//此处假设变量obj附加__strong修饰符且对象被赋值&#125; 在编译时会转换成 123456789101112id obj1;objc_initWeak(&amp;obj1, obj);/*objc_initWeak函数在这里转换成obj1 = 0；objc_storeWeak(&amp;obj1, obj);*/objc_destroyWeak(&amp;obj1);/*objc_destroyWeak函数在这里相当于objc_storeWeak(&amp;obj1, 0);*/ objc_stroeWeak函数把第二个参数的赋值对象的地址作为键值，将第一个参数的附有__weak修饰符的变量的地址注册到weak表中，如果第二个参数为0，则把变量的地址从weak表中删除 weak表与引用计数表相同，都是作为散列表实现的。使用weak表，将废弃的对象的地址作为键值进行检索，就能高速地获取对应的附有__weak修饰符的变量的地址由于一个对象可同时赋值给多个附有__weak修饰符的变量中，所以对于一个键值，可注册多个变量的地址 对象释放时，程序的将进行下面几步： objc_release 执行dealloc _objc_rootDealloc object_dispose objc_destructInstance objc_clear_deallocating objc_clear_deallocating函数做了下面几件事： 从weak表中获取废弃对象的地址为键值的记录（获取所有的__weak修饰的变量的地址） 将所有的__weak修饰的变量的地址，赋值为nil 从weak表中删除该记录 从引用计数表中删除废弃对象的地址为键值的记录 经过以上步骤，__weak修饰符的变量所引用的对象被废弃，且将nil赋值给该变量。由此可知，如果大量使用附有__weak修饰符的变量，则会销毁相应的CPU资源，因此只是在需要避免循环引用时使用__weak修饰符 将自己生成并持有的对象赋值给__weak修饰符修饰的变量时，会引起编译器警告 123&#123;id __weak obj = [[NSObject alloc] init];&#125; 在编译时转换成： 123456id obj;id tmp = objc_msgSend(NSObject, @selector(alloc));objc_msgSend(tmp, @selector(init));objc_initWeak(&amp;obj, tmp);objc_release(tmp);objc_destroyWeak(&amp;object); 自己生成并持有的对象通过objc_initWeak函数被赋值给附有__weak修饰符的变量中，但变量无法持有，故编译器判断其没有持有者，则该对象立即通过objc_release函数被释放和废弃，同时变量也被置nil 使用附有__weak修饰符的变量，即是使用注册到autoreleasepool中的对象 1234&#123;id __weak obj1 = obj;NSLog(@&quot;%@&quot;,obj1);&#125; 可以转化成如下形式 123456id obj1;objc_initWeak(&amp;obj1, obj);id tmp = objc_loadWeakRetained(&amp;obj1);objc_autorelease(tmp);NSLog(@&quot;%@&quot; ,tmp);objc_destroyWeak(&amp;obj1); 和被赋值相比，此处增加了objc_loadWeakRetained函数和objc_autorelease函数 objc_loadWeakRetained函数取出附有__weak 修饰符变量所引用的对象并retain。 objc_autorelease函数将对象注册到autoreleasepool中。 由此可知，__weak修饰符变量所引用的对象像这样被注册到autoreleasepool中，所以在@autoreleasepool 块结束之前都可以放心使用。但是，如果大量地使用附有__weak 修饰符的变量，注册到autorpool的对象也会大量地增加，因此，在使用附有__weak修饰符的变量时，最好先暂时赋值给附有__strong修饰符的变量后再使用 eg： 12345678&#123;id __weak o = obj;NSLog(@&quot;1 %@&quot;, o);NSLog(@&quot;2 %@&quot;, o);NSLog(@&quot;3 %@&quot;, o);NSLog(@&quot;4 %@&quot;, o);NSLog(@&quot;5 %@&quot;, o);&#125; 这样o所赋值的对象注册到autoreleasepool中5次 但使用 123456789&#123;id __weak o = obj;id tmp = o;NSLog(@&quot;1 %@&quot;, tmp);NSLog(@&quot;2 %@&quot;, tmp);NSLog(@&quot;3 %@&quot;, tmp);NSLog(@&quot;4 %@&quot;, tmp);NSLog(@&quot;5 %@&quot;, tmp);&#125; 只会在”tmp = o”时，对象会登录到autoreleasepool中1次 在一些特定环境中是不能使用__weak 修饰符的，而且也存在着不支持__weak修饰符的类，这些类重写了retain/release并实现该类独自的引用计数机制。因此独自实现引用计数机制的类大多数不支持weak修饰符。不支持weak修饰符的类，其类声明中附加了&quot;__attribute__((objc_arc_weak_reference_unavailable))&quot;这一属性，同时定义了&quot;NS_AUTOMATED_REFCOUNT_WEAK_UNAVAILABLE&quot;。如果将不支持__weak声明类的对象赋值给附有__weak修饰符的变量，那么一旦编译器检验出来就会报告编译错误。而且Cocoa框架类中，不支持__weak修饰符的类极为罕见 allowsWeakReference/retainWeakReference方法当allowsWeakReference/retainWeakReference实例方法返回NO时，同样不能使用__weak修饰符 在赋值给__weak修饰符的变量时，如果赋值对象的allowsWeakReference 方法返回NO,程序将异常终止 在赋值给__weak修饰符的变量时，如果赋值对象的retainWeakReference 方法返回NO,该变量将使用nil eg： 123456789&#123;id __strong obj = [[NSObject alloc] init];id __weak o = obj;NSLog(@&quot;1 %@&quot;,o);NSLog(@&quot;2 %@&quot;,o);NSLog(@&quot;3 %@&quot;,o);NSLog(@&quot;4 %@&quot;,o);NSLog(@&quot;5 %@&quot;,o);&#125; 运行结果所有的NSLog都可以打印出地址 如果自定义一个MyObject继承自NSObject的类，并实现retainWeakReference方法 12345- (BOOL)retainWeakReference &#123; if (++count &gt; 3) return NO; return [super retainWeakReference];&#125; 使用MyObject类生成并持有对象 123456789&#123;id __strong obj = [[MyObject alloc] init];id __weak o = obj;NSLog(@&quot;1 %@&quot;,o);NSLog(@&quot;2 %@&quot;,o);NSLog(@&quot;3 %@&quot;,o);NSLog(@&quot;4 %@&quot;,o);NSLog(@&quot;5 %@&quot;,o);&#125; 运行结果4和5的NSLog打印的为nil __autoreleasing 实现123@autoreleasepool &#123; id __autoreleaseing obj = [[NSObject alloc] init];&#125; 在编译的时候转换为 12345id pool = objc_autoreleasePoolPush();id obj = objc_msgSend(NSObject, @selector(alloc));objc_msgSend(obj, @selector(init));objc_autorelease(obj);objc_autoreleasePoolPop(pool); 在alloc/new/copy/mutableCopy方法群之外的方法使用 123@autoreleasepool &#123; id __autoreleasing obj = [NSMutableArray array];&#125; 在编译时转换为 12345id pool = objc_autoreleasePoolPush();id obj = objc_msgSend(NSMutableArray, @selector(array));objc_retainAutoreleasedReturnValue(obj);objc_autorelease(obj);objc_autoreleasePoolPop(pool);","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"读《iOS与OS X多线程和内存管理》—— ARC规则","date":"2017-05-05T13:14:13.000Z","path":"2017/05/05/读《iOS与OS X多线程和内存管理》—— ARC规则/","text":"前言在ARC有效的情况下编译源代码需要遵守的规则 不能使用 retain/release/retainCount/autorelease这些方法都是在MRC中手动管理引用计数的方法，在ARC中，既然自动管理了引用计数了，自然不可以使用了，因为都管理，就会出现冲突 不能使用 NSAllocateObject/NSDeallocateObject不能使用的原因同上 须遵守内存管理的方法命名规则alloc/new/copy/mutableCopy/init以这些名称开始的方法在返回对象是，必须返回给调用方所应当持有的对象。 init是ARC追加的命名规则，切init必须是实例方法，必须要返回对象 不要显式调用 dealloc在对象被释放的时候，系统会自动调用dealloc方法，不需要我们手动调用，原因也很简单，如果手动调用了，就意味着要释放对象，但是这时候如果对象的引用计数不是0，那么引用计数为0就释放对象的规则就失效了。 在MRC时，在dealloc方法中需要显式的调用[super dealloc],但是在ARC时，这是不需要的 使用@autoreleasepool 块替代 NSAutoreleasePool在ARC中使用NSAutoreleasePool会引起编译器报错 不能使用区域（NSZone）无论MRC还是ARC都无法使用。 对象型变量不能作为C语言结构体的成员原因是C语言没有方法来管理结构体成员的生存周期，ARC的内存管理是编译器完成的，所以编译器必须能知道并管理对象的生存周期。 要想把对象型变量加入结构体成员中，可以强制转换为void *或是附加__unsafe_unretained修饰符 显式转换 id 和 void *在MRC时，将id变量强制转换void *变量并不会出问题,如下面代码： 123id obj = [[NSObject alloc] init];void *p = obj;id o = p; 但是在ARC时，是会引起编译错误的，要想在id和void *之间相互赋值，需要__bridge转换。 123id obj = [[NSObject alloc] init];void *p = (__bridge void *)obj;id o = (__bridge id)p; __bridge还有两种转换： __bridge_retained 可以使转换赋值的变量也持有所赋值的对象，相当于目标变量retain __bridge_transfer 可以是被转换的变量所持有的对象在该变量被赋值给转换目标变量后随之释放，就是目标变量retain,自己release","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"读《iOS与OS X多线程和内存管理》—— 自动引用计数","date":"2017-04-26T15:32:33.000Z","path":"2017/04/26/读《iOS与OS X多线程和内存管理》—— 自动引用计数/","text":"前言下面是自动引用计数部分书中内容的笔记 自动引用计数设置前面说到过，自动引用计数（Automatic Reference Counting）简称就是我们现在使用的ARC了，顾名思义自动引用计数就是编译器自动帮我们处理引用计数 在编译的时候，我们可以指定每个文件是否使用ARC，Xcode4.2以后编译器默认为ARC有效。 在创建完工程的时候，我们可以在工程的配置文件中设置工程模式是MRC还是ARC，设置的方法是： 在工程配置文件的，Build Settings中，找到Objective-C Automatic Reference Counting 选项，设置为YES,就是ARC工程模式，设置为NO就是MRC工程模式。 在ARC工程模式或MRC工程模式也可以设置部分文件编译模式与之相反，设置方法： 在Build pyases中的compile source找到对应的文件设置参数-fno-objc-arc为MRC模式，反之-fobjc-arc为ARC模式。 所有权修饰符在引用计数中，我们知道，对象的销毁，是通过引用计数的值来判断的，但是引用计数的值是需要我们手动去维护的，那么要想让编译器去维护引用计数，我们就要通过一些修饰符，去告诉编译器，变量什么时候需要引用计数加一，什么时候引用计数需要减一，那么这个修饰符就是所有权修饰符 在ARC模式下，所有权修饰符有四种： __strong __weak __unsafe_unretained __autoreleasing __strong__strong修饰符是id类型和对象类型的默认所有权修饰符 1id obj = [[NSObject alloc] init]; 1id __strong obj = [[NSObject alloc] init]; 这两种表示方法的结果是一样的 在ARC中，被__strong修饰符修饰的变量，表示对对象的强引用，持有强引用的变量在超出其作用域时被废弃，随着强引用的失效，引用的对象会随之释放 在变量赋值的时候，也会对对象强引用，如果赋值为nil,则强引用失效 __strong也可以修饰在方法参数上，虽然平常我们写的方法上都没有，那是因为默认是不用写的 __weak__weak修饰符，提供弱引用，弱引用不能持有对象实例。__weak修饰符是为了解决__strong修饰符会产生循环引用出现的。 所谓循环引用，就是自己引用自己，或者多个对象相互引用，导致谁都无法释放的问题 __weak修饰符，的另一个作用是，在持有某对象的弱引用时，若该对象被废弃，则此弱引用将自动失效且处于nil被赋值的状态（空弱引用）。 所以，检查__weak修饰符的变量是否为空，可以判断被赋值的对象是否已废弃 __unsafe_unretained__unsafe_unretained修饰符，是不安全的所有权修饰符，被他修饰的变量，是不属于编译器的内存管理对象。 __unsafe_unretained修饰符，和__weak修饰符的作用相似，他也无法持有对象实例，但是他在对象已经释放的时候，仍然指向对象，形成垂悬指针。 所以，在使用__unsafe_unretained修饰符的变量的时候，必须确保被赋值的对象确实存在，不然会导致程序崩溃 __autoreleasing在MRC的时候，NSAutoreleasePool类中的要想让对象自动释放，有个autorelease方法，但是在ARC中，NSAutoreleasePool已经改用@autoreleasepool了，所以，需要__autoreleasing修饰符，来表示对象自动释放。 __autoreleasing和__strong修饰符都不需要显示的添加，因为在使用alloc/new/copy/mutableCopy以外的方法取来的对象，已经被注册到autoreleasepool中了。 在__weak修饰符修饰的变量在访问对象的时候，也会把对象注册到autoreleasepool中 id的指针或者对象的指针在没有显式指定是，也会被加上__autoreleasing修饰符","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"读《iOS与OS X多线程和内存管理》——引用计数(总结)","date":"2017-04-22T14:05:43.000Z","path":"2017/04/22/读《iOS与OS X多线程和内存管理》——引用计数(总结)/","text":"前言上一篇文章介绍了引用计数，用GNUstep的实现，推测了cocoa框架的实现，现在总结一下个人觉得重要的地方，和上一篇没说的地方 非自己生成的对象，自己也能持有这一条内存管理举的例子是 12id obj = [NSArray array];[obj retain]; 开始不是很明白，这里的工厂方法，和普通的初始化有什么区别，个人当时认为的是这也应该算做是自己生成的对象，自己所持有 但是后面说了，[NSArray array]的时候，其实他面会把生成的临时对象[tempObj autorelease],那么反回的时候，就需要[obj retain],因为之前说了，这个地方的内容还没涉及到ARC，所以需要retain一下 NSAutoreleasePool这个东西，说的简单点，就是一个块，让在他里面的东西，都保持状态，不释放，但是出了他的作用域，就全部释放一遍 继续用开关灯那个例子的话，NSAutoreleasePool就相当于一个屋子里面多了一个管理员，对象在NSAutoreleasePool中，就好比管理员在屋子中，所以屋子会一直亮着，而且，管理员肯定是第一个进来，最后一个走，这就保证了，屋子的灯可以由管理员控制，也就是对象的释放时机，是出了NSAutoreleasePool的时候 在ARC中，NSAutoreleasePool是不只直接使用的，你可以使用下面这个： 12345@autoreleasepool&#123;// Code benefitting from a local autorelease pool.&#125; 在自动释放池中，一个对象如果被autorelease了多次，那么在池子释放的时候，对象会被执行多次release 在运行时系统中调用方法 12345/* 函数声明 */extern void _objc_autoreleasePoolPrint();/* 调试处调用 */_objc_autoreleasePoolPrint(); 这个方法在ARC中的调试中可以使用，可以打印出，当前缓冲池中的所有对象，还是比较有用的。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"读《iOS与OS X多线程和内存管理》——引用计数","date":"2017-04-17T11:34:12.000Z","path":"2017/04/17/读《iOS与OS X多线程和内存管理》——引用计数/","text":"前言上一章说了看这本的目的，下面就算是读书笔记吧 1. 什么是自动引用计数(ARC)ARC（Automatic Reference Counting）简而言之就是编译器自动进行内存管理，那为什么不叫”自动内存管理”，而叫”自动引用计数”，当然是因为内存管理是的方法是通过引用计数实现的 要说自动引用计数，首先要说什么是”引用计数” 1.1引用计数什么是引用计数，书中举了一个生活中开关房间灯的例子。 简单的描述一下就是，第一个人来屋子的时候要开灯(创建对象)，最后一个人走的时候要关灯(释放对象)，中间来人走人都不需要开关灯。那么办公室里的人数就是引用计数。也就是有多少个人用着灯 1.2内存管理的思考方式内存管理的思考方式总结出来就是下面四点 注：这里还没到ARC所以还是非ARC 1.自己生成的对象，自己所持有 (指通过alloc/new/copy/mutableCopy等创建的对象)eg: 1id obj = [NSObject new]; 2.非自己生成的对象，自己也能持有 (指持有通过类方法创建的对象)eg: 12id obj = [NSArray array];[obj retain]; 3.不再需要自己持有的对象时释放 (释放对象)eg: 12id obj = [[NSObject alloc] init];[obj release]; 4.非自己持有的对象无法释放 (多次释放，或未持有释放）eg: 123id obj = [[NSObject alloc] init];[obj release];[obj release]; 对象的操作与Objective-C方法的对应生成并持有对象—— alloc/new/copy/mutableCopy 等持有对象———– retain释放对象———– release废弃对象———– dealloc 2.alloc/retain/release/dealloc 实现这一节研究的是alloc/retain/release/dealloc的实现。 讲之前先说一个常识，那就是Objective-C的框架，底层的是一个叫Cocoa框架其中包含一个Foundation框架 首先Objective-C内存管理的方法是包含在Cocoa框架中的，这里所说的内存管理是的方法alloc/retain/release/dealloc 指的是NSObject类的alloc类方法,retain实例方法,release实例方法和dealloc实例方法，但是NSObject类的Foundation框架没有公开过源码，所以这里使用开源软件GNUstep的框架，一个能和Cocoa框架互换的框架，来理解苹果Cocoa框架的实现。 这里我把代码给大家写出来，供大家参考，但书的作者把有些地方的源码在不改变意思的范围进行了修改 2.1 alloc 实现GNUstep的123456789101112131415161718192021222324252627282930313233```mm+(id)alloc&#123; return [self allocWithZone:NSDefaultMallocZone()];&#125;+ (id)allocWithZone:(NSZone *)z&#123; return NSAllocateObject (self, 0, z);&#125;/* ------- NSAllocateObject ------- */struct obj_layout &#123; NSUInteger retained;&#125;;inline id NSAllocateObject (Class aClass, NSUInteger extraBytes, NSZone *zone)&#123; int size = 计算容纳对象所需内存大小； id new = NSZoneMalloc(zone,size); memset(new, 0, size); new = (id)&amp;((struct obj_layout *) new)[1];&#125;/* ----- 简化版alloc ----- */+ alloc&#123; int size = sizeof(struct obj_layout) + 对象大小; struct obj_layout *p = (struct obj_layout *)calloc(1,size); return(id)(p+1);&#125; 简化版的是去掉了NSZone之后的代码，NSZone是为了防止内存碎片化引入的结构，对内存管理没有影响，所以可以忽略。从简化版的代码中可以看出GNUstep申请的对象的内存比需要的大了sizeof(struct obj_layout)，这个多出来的空间就是用来存放引用计数的 在非ARC即MRC中是可以通过retainCount查看对象的引用计数的。 retainCount的实现: 123456789- (NSUInteger)retainCount&#123; return NSExtraRefCount(self) + 1;&#125;inline NSUInteger NSExtraRefCount(id anObject)&#123; return((struct obj_layout *) anObject)[-1].retained;&#125; 2.2 retain 实现GNUstep的retain实现： 123456789101112- (id)retain&#123; NSIncrementExtraRefCount(self); return self;&#125;inline void NSIncrementExtraRefCount(id anObject)&#123; if(((struct obj_layout *)anObject)[-1].retained == UINT_MAX -1) 抛出异常 ((struct obj_layout *)anObject)[-1].retained++;&#125; 2.3 release 实现GNUstep的release实现： 123456789101112131415- (void)release&#123; if(NSDecrementExtraRefCountWasZero(self)) [self dealloc];&#125;BOOL NSDecrementExtraRefCountWasZero(id anObject)&#123; if(((struct obj_layout *)anObject)[-1].retained == 0)&#123; return YES; &#125;else &#123; ((struct obj_layout *)anObject)[-1].retained--; return NO; &#125;&#125; 2.4 dealloc 实现GNUstep的dealloc实现： 12345678910- (void)dealloc&#123; NSDeallocateObject(self);&#125;inline void NSDeallocateObject(id anObject)&#123; struct obj_layout *o = &amp;((struct obj_layout *) anObject)[-1]; free(o);&#125; 可以看到GNUstep实现引用计数的方法是在变量在内存块头部保存的当前对象的引用计数，默认是0，当调用retainCount时会自动+1，这就说明了自己生成的对象，自己所持有。 2.5 苹果实现苹果由于官方未公开源代码，根据运行时调用的代码可以看出苹果实现引用计数和GNUsetp的主要区别就是GNUsetp将引用计数存放在内存块头，而苹果使用的是散列表（键为内存块地址的散列值） 存放在头部管理引用计数的好处： 代码量少 能够统一管理引用计数用内存块和对象用内存块 用散列表(引用计数表)管理引用计数的好处： 对象用内存块的分配无需考虑内存块头部 引用计数表各记录中存有内存块地址，可从各个记录追溯到各对象的内存块 3 autorelease所谓autorelease就是自动释放，原理就是若某自动变量超出其作用域，该自动变量将被自动废弃 GNUstep的autorelease实现： 1234567891011121314- (id)autorelease&#123; [NSAutoreleasePool addObject:self];&#125;+ (void) addObject:(id)anObj&#123; NSAutoreleasePool *pool = 取得当前NSAutoreleasePool对象 if(pool != nil) &#123; [pool addObject:anObj]; &#125;else &#123; NSLog(@\"NSAutoreleasePool对象非存在状态下调用autorelease\")； &#125;&#125; 废弃NSAutoreleasePool方法drain实现 1234567891011121314151617- (void)drain&#123; [self dealloc];&#125;- (void)dealloc&#123; [self emptyPool]; [array release];&#125;- (void)emptyPool&#123; for(id obj in array) &#123; [obj release]; &#125;&#125; 查看AutoreleasePool中的内容 1[NSAutoreleasePool showPools];//此方法只能在iOS中使用 在运行时系统中调用方法 12345/* 函数声明 */extern void _objc_autoreleasePoolPrint();/* 调试处调用 */_objc_autoreleasePoolPrint(); 注：(1).上面的内容全部是本人读《Objective-C高级编程 iOS与OS X多线程和内存管理》一书觉得重点的部分，如果大家感兴趣可以支持一下正版。(2).如果各位看官觉得有什么是小弟说的不对的地方，欢迎指出。(3).这篇基本上都是说引用计数的实现的，还没有涉及到前言提出的问题的解答。(4).看到这里的都是真爱啊。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"读《iOS与OS X多线程和内存管理》——前言","date":"2017-04-13T03:10:12.000Z","path":"2017/04/13/读《iOS与OS X多线程和内存管理》——前言/","text":"前言 都说不会写部落格的程序猿不是好作家，本作家本来想着当一个小小的初级工程师，每天码码界面，终其一生就算了。谁知天有不测风云，人有祸福旦夕，那天在工程中多看了一眼别人的代码，顿时觉得自己的知识储备实在是太匮乏了。 那么究竟是什么样的代码，居然有如此神奇的功效，闲话少叙，上代码： 代码一： 1234567891011121314151617@interface MyView ()@property (nonatomic, weak) UILabel *label;@end@implementation MyView- (void)setupSubview &#123; UILabel *label = [[UILabel alloc] init]; label.font = [UIFont systemFontOfSize:14]; label.textColor = [UIColor whiteColor]; label.textAlignment = NSTextAlignmentCenter; label.text = @\"你好\"; [self addSubview:label]; _label = label;&#125;@end 就是这么一段代码，如果要让楼主写 则是下面这样的 代码二： 12345678910111213141516@interface MyView ()@property (nonatomic, strong) UILabel *label;@end@implementation MyView- (void)setupSubview &#123; self.label = [[UILabel alloc] init]; self.label.font = [UIFont systemFontOfSize:14]; self.label.textColor = [UIColor whiteColor]; self.label.textAlignment = NSTextAlignmentCenter; self.label.text = @\"你好\"; [self addSubview:self.label];&#125;@end 当然你也可以直接用_label赋值，这里问题的重点不是set方法和成员变量的区别，而是我的属性用的是strong修饰而他的是使用weak修饰。 本着不耻下问，虚心求教的态度我问了一下我同事，得到了这样的解答： 代码一的属性使用的weak修饰，因为在addSubview：的时候self会强引用label对象weak修饰的成员变量_label弱引用着label对象 代码二的属性使用strong修饰， 在addSubview：的时候self会强引用label对象 strong 修饰的成员变量_label也强引用着label对象 第一种代码的好处是在self移除label的时候label对象就释放了。因为label只有一个self强引用着 第二种代码在self移除label的时候label对象不会释放，因为还有个_label的变量强引用这label对象，只有在self释放的时候label对象才会释放。 本人读书少，仔细一想确实是这么回事，用weak修饰，label对象只被self强引用，从view上移除后就可以释放，不用等到self释放的时候才释放，创建和释放都很合理(哪里创建哪里释放)。 但是细思极恐，难道我多年来的开发经验是错误的么，用了n年的strong原来是个低效的使用方法。这时候我突然想到了一个面试题， 那就是你真的了解属性修饰符的用法么？ 好吧我承认！我不了解，这就是我看这本书的原因。 注： 上面的解释不一定是正确的。 小弟初来乍到要是有啥说的不对的地方希望各位大大不吝赐教。 要是你们有什么意见和建议，也可以随便吐槽。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"Xcode8 报错resource fork, Finder information, or similar detritus not allowed","date":"2017-03-31T03:02:30.000Z","path":"2017/03/31/Xcode8报错/","text":"Xcode8 报错resource fork, Finder information, or similar detritus not allowed 原因这是因为Xcode8引进的新的安全机制, Code signing不允许app的bundle里面的文件有未知的文件系统扩展属性 解决方法在终端中输入xattr -lr &lt;path_to_app_bundle&gt;可以查看存在未知扩展属性的文件 在终端中输入xattr -cr &lt;path_to_app_bundle&gt;可以移除所有未知的扩展属性 然后清理Xcode 重新build 工程","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"iOS的CF和OC中间的类型转换","date":"2017-01-11T03:10:12.000Z","path":"2017/01/11/iOS的CF和OC中间的类型转换/","text":"iOS的CF和OC中间的类型转换Toll-Free bridgedToll-Free bridged 是Core Foundation和Foundation之间交换使用数据类型的技术.即同一数据类型既可作为Core Foundation函数的参数,也可以作为接收者向其发送Objective-C消息. 说的简单点,就是OC中的有些类型,通过Toll-Free bridged 既可以当做Core Foundation的类型使用(CFxxxx),又可以当做Foundation的类型使用(NSxxxx). Toll-Free bridged原理每一个能够bridge的ObjC类，都是一个类簇（class cluster）。类簇是一个公开的抽象类，但其核心功能的是在不同的私有子类中实现的，公开类只暴露一致的接口和实现一些辅助的创建方法。而与该ObjC类相对应的Core Foundation类的内存结构，正好与类簇的其中一个私有子类相同。 举个例子，NSString是一个类簇，一个公开的抽象类，但每次创建一个NSString的实例时，实际上我们会获得其中一个私有子类的实例。而NSString的其中一个私有子类实现既为NSCFString，其内存的结构与CFString是相同的，CFString的isa指针就指向NSCFString类，即CFString对象就是一个NSCFString类的实例。所以，当NSString的实现刚好是NSCFString的时候，他们两者之间的转换是相当容易而直接的，他们就是同一个类的实例。 当NSString的实现不是NSCFString的时候（比如我们自己subclass了NSString），我们调用CF函数，就需要先检查对象的具体实现。如果发现其不是NSCFString，我们不会调用CF函数的实现来获得结果，而是通过给对象发送与函数功能相对应的ObjC消息（调用相对应的NSString的接口）来获得其结果。 例如CFStringGetLength函数，当收到一个作为参数传递进来的对象时，会先确认该对象到底是不是NSCFString实现。如果是的话，就会直接调用CFStringGetLength函数的实现来获得字符串的长度；如果不是的话，会给对象发送length消息（调用NSString的length接口），来得到字符串的长度。 Toll-Free bridged的内存管理在ARC中编译器不知道如何处理这个同时拥有ObjC和CFTypeRef指向的对象,所以你必须为编译器提供额外的信息：将类型显示转换为互换类型；同时可能需明确对象的声明周期。 因此我们需要使用 __bridge, __bridge_retained, __bridge_transfer 修饰符告诉编译器该如何去做。 __bridge1234//objc to cf NSString *str = @\"hello\"; CFStringRef cfStr = (__bridge CFStringRef)str; CFRelease(cfStr);//这里不需要release 编译器会继续负责nsStr的内存管理的事情，不会在bridge的时候retain对象，所以也不需要开发者在CF 一端释放。需要注意的是，当nsStr被释放的时候（比如出了作用域），意味着cfStr指向的对象被释放了，这时如果继续使用cfStr将会引起程序崩溃。 1234//cf to objc CFStringRef cfStr = CFStringCreateWithCString(kCFAllpacatorDefaule,\"hello\",kCFStringEncodingUTF8); NSString *str = (__bridge NSString *)(cfStr); CFRelease(cfStr);//这里需要release bridge的时候编译器不会做任何内存管理的事情，bridge之后，编译器会负责ObjC一端的内存管理的事情。同时，开发者需要负责管理CF 一端的内存管理的事情，需要在bridge之后，负责release对象。 __bridge_retained接着上面的例子，Foundation类型对应的Core Foundation类型时，为了防止str被释放，引起我们使用cfStr的时候程序崩溃，可以使用__bridge_retained修饰符。这意味着，在bridge的时候，编译器会retain对象，而由开发者在CF一端负责release。这样，就算str在objc一端被释放，只要开发者不手动去释放cfStr，其指向的对象就不会被真的销毁。但同时，开发者也必须保证和负责对象的释放。 1234//objc to cf NSString *str = @\"hello\"; CFStringRef cfStr = (__bridge_retained CFStringRef)str; CFRelease(cfStr);//这里不需要release __bridge_transfer当Core Foundation类型转化为Foundation类型时，如果使用bridge修饰符在cf转objc的时候非常的麻烦，我们既需要一个CFTypeRef的变量，还需要在bridge之后负责释放。这时我们可以使用bridge_transfer，意味着在bridge的时候，编译器转移了对象的所有权，开发者不再需要负责对象的释放。 1234//cf to objc CFStringRef cfStr = CFStringCreateWithCString(kCFAllpacatorDefaule,\"hello\",kCFStringEncodingUTF8); NSString *str = (__bridge NSString *)(cfStr); CFRelease(cfStr);//这里需要release 总结 __bridge :编译器在bridge的时候不要做任何事情 __bridge_retained :（ObjC转CF的时候使用）编译器在bridge的时候retain对象，开发者需要在CF一端负责释放对象 __bridge_transfer :（CF转ObjC的时候使用）编译器转移CF对象的所有权，开发者不再需要在CF一端负责释放对象","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"centOS Linux系统命令--VPS那些事","date":"2016-12-11T03:02:30.000Z","path":"2016/12/11/centOS系统命令/","text":"升级系统1yum update -y 安装wgetwget是一个从网络上自动下载文件的自由工具，支持通过HTTP、HTTPS、FTP三个最常见的TCP/IP协议下载，并可以使用HTTP代理。wget名称的由来是“World Wide Web”与“get”的结合 1yum -y install wget 查看当前内核版本1uname -r 修改内核1rpm -ivh http://gongju.wn789.com/neihei/kernel-firmware-2.6.32-504.3.3.el6.noarch.rpm 1rpm -ivh http://gongju.wn789.com/neihei/kernel-2.6.32-504.3.3.el6.x86_64.rpm --force 查看内核1rpm -qa | grep kernel 安装锐速破解版1wget -N --no-check-certificate https://github.com/91yun/serverspeeder/raw/master/serverspeeder.sh &amp;&amp; bash serverspeeder.sh 锐速卸载1chattr -i /serverspeeder/etc/apx* &amp;&amp; /serverspeeder/bin/serverSpeeder.sh uninstall -f 查看锐速状态1service serverSpeeder status 锐速相关1service serverSpeeder start | stop | restart 搭建shadowsocks 安装 安装pip 1yum install python-setuptools &amp;&amp; easy_install pip 安装shadowsocks 1pip install shadowsocks 配置 创建一个文件在/etc/shadowsocks.json 123cd /etcvi shadowsocks.json 在json文件中写入如下信息 12345678&#123; &quot;server&quot;:&quot;x.x.x.x&quot;, #服务器IP地址 &quot;server_port&quot;:8388, #服务监听端口 &quot;local_port&quot;:1080, #本地连接端口 &quot;password&quot;:&quot;barfoo&quot;, #加密传输使用到的密码 &quot;timeout&quot;:600, #连接超时时间 &quot;method&quot;:&quot;aes-256-cfb&quot; #加密算法&#125; 启动、停止 1ssserver -c /etc/shadowsocks.json -d start | stop 配置定时任务 在vps的内存比较小的时候，shadowsocks容易被系统给kill掉，这时，我们就要有个定时任务去查看shadowsocks的服务状态 首先，创建一个查看服务脚本 1234567891011#! /bin/shproc_name=&quot;shadowsocks.json&quot;number=`ps -ef | grep $proc_name | grep -v grep | wc -l`if [ $number -eq 0 ];then ssserver -c /etc/shadowsocks.json -d startelse ssserver -c /etc/shadowsocks.json -d restartfi 给脚本添加运行权限 1chmod 777 xxxx.sh 将脚本加入定时任务中 1crontab -e //打开定时任务配置 加入上面的脚本 1*/1 * * * * ./xxx.sh //注意脚本路径 启动定时任务 1service crond start 5.mac终端使用ss 在终端中输入如下命令： 12345export http_proxy=socks5://127.0.0.1:1080 # 配置http 代理访问export https_proxy=socks5://127.0.0.1:1080 # 配置https 代理访问export all_proxy=socks5://127.0.0.1:1080 # 配置http和https访问unset http_proxy # 取消http 代理访问unset https_proxy # 取消https 代理访问 这样设置只能在当前启动的终端中有效，如果需要每次都走代理，则需要在shell文件中添加上述设置。 上面命令中的端口号和地址，需要和shadowsock中socks5监听的地址和端口号一致 安装使用Apache在Linux中Apache的名字叫httpd 查看服务器版本 1apachectl -v 安装Apache 1yum install httpd 打开Apache 123/etc/init.d/httpd start或者httpd -k start | stop | restart Apache的配置文件路径 1/etc/httpd/conf/httpd.conf 安装Mysql12345678910yum list installed | grep mysql#查看是否已经安装yum install mysql-server#安装服务端yum install mysql-devel#这个应该是组件，不知道有什么用yum install mysql#安装客户端service mysqld start#启动service mysqld stop#停止service mysqld restart#重启mysqladmin -u root password 123456#设置密码mysql -u root -p #登录","tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"ssh连接报错","date":"2016-12-11T03:02:30.000Z","path":"2016/12/11/ssh连接报错/","text":"使用ssh连接远程服务器在使用VPS的时候由于更换了数据中心，导致远程服务ip地址改变，使用ssh连接的时候报如下错误 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!Someone could be eavesdropping on you right now (man-in-the-middle attack)!It is also possible that a host key has just been changed.The fingerprint for the RSA key sent by the remote host is6e:45:f9:a8:af:38:3d:a1:a5:c7:76:1d:02:f8:77:00.Please contact your system administrator.Add correct host key in /home/hostname /.ssh/known_hosts to get rid of this message.Offending RSA key in /var/lib/sss/pubconf/known_hosts:4RSA host key for pong has changed and you have requested strict checking.Host key verification failed. 解决办法找到~/.ssh/路径下的known_hosts打开，删除对应的ip以及对应信息保存就好","tags":[{"name":"VPS那些事","slug":"VPS那些事","permalink":"http://yoursite.com/tags/VPS那些事/"}]},{"title":"Hexo创建一个blog","date":"2016-08-03T12:38:44.000Z","path":"2016/08/03/Hexo创建一个blog/","text":"post布局当你的Hexo已经搭建完成的时候，你就可以写blog了，最简单的创建一个blog的方法就是调用 1hexo new blog_title 执行完成之后，hexo会在根目录的source文件夹下创建一个_post文件夹，并在里面生成一个blog_title.md文件。 这个创建blog的完整命令是 1hexo new post blog_title 这个就是post布局，当hexo g 或者 s 或者 d的时候，会把_post文件夹中的文件都生成静态页面 draft布局1hexo new draft blog_title 当使用draft布局创建一个博客的时候，hexo也会在根目录的source文件夹下创建一个_draft文件夹，并在里面生成一个blog_title.md文件， 但是在hexo g 或者 s 或者 d的时候，是无法看到你创建的博客的 因为draft布局是草稿布局，在_draft文件夹中的博客都认为是草稿，不能发布 那当你想看看你的草稿写出来的效果怎么样的时候，你可以使用下面命令将草稿部署到本地 12hexo g --drafthexo s --draft 如果你的博客已经完成了，你可以使用下面的命令将他发布 1hexo publish draft blog_title.md page布局1hexo new page &quot;about&quot; 当使用page布局创建一个博客的时候，hexo会在根目录的source文件夹下创建一个about文件夹，并在里面生成一个index.md文件 当你部署完，你需要使用子路径去访问他 eg： 1http://localhost:4000/about","tags":[{"name":"日常","slug":"日常","permalink":"http://yoursite.com/tags/日常/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"Hexo的安装和使用","date":"2016-08-02T11:13:00.000Z","path":"2016/08/02/Hexo的安装和使用/","text":"一、hexo的安装1、安装Node.jsHexo是基于Node.js的静态博客框架，所以要安装Hexo先要安装Node.js。 Node.js的安装方法非常简单，从Node.js官网下载安装包安装就好 2、安装gitmac下安装了Xcode就会有git 3、安装Hexo在终端执行如下命令 1sudo npm install -g hexo 等待安装成功 安装完成后使用查看版本命令，看看是否安装成功 1hexo -v 如果正常显示版本说明安装成功 注意如果报如下错误： 123456789101112Error: The module &apos;/Users/***/Desktop/***/node_modules/dtrace-provider/build/Release/DTraceProviderBindings.node&apos;was compiled against a different Node.js version usingNODE_MODULE_VERSION 48. This version of Node.js requiresNODE_MODULE_VERSION 67. Please try re-compiling or re-installingthe module (for instance, using `npm rebuild` or `npm install`). at Object.Module._extensions..node (internal/modules/cjs/loader.js:751:18) at Module.load (internal/modules/cjs/loader.js:620:32) at tryModuleLoad (internal/modules/cjs/loader.js:560:12) at Function.Module._load (internal/modules/cjs/loader.js:552:3) at Module.require (internal/modules/cjs/loader.js:658:17) ... 执行下面操作： 1231. cd hexo 根目录2. rm -rvf node_modules3. npm install 这是因为node_modules的缓存存在版本问题 二、hexo的使用创建一个blog库1hexo init blog blog是文件夹的名称，可以随便起 创建一个blog1hexo new blog_title 这个样就可以创建一个title是blog_title的博客了 这个只是一个默认参数的简写命令 生成静态页面123hexo generate 或者：hexo g 部署到本地123hexo server 或者：hexo s 部署完可以在浏览器中打开预设的地址查看blog 部署到远端123hexo deploy 或者：hexo d 要部署到远端需要配置博客更目录下的_config.yml文件中的内容 1234deploy: type: git repo: 自己的git地址 branch: master 2021更新问题今天在一台新电脑上部署的时候发现进入的是空白页，在本地测试的时候有如下错误提示 1234567(node:9876) Warning: Accessing non-existent property 'lineno' of module exports inside circular dependency(Use `node --trace-warnings ...` to show where the warning was created)(node:9876) Warning: Accessing non-existent property 'column' of module exports inside circular dependency(node:9876) Warning: Accessing non-existent property 'filename' of module exports inside circular dependency(node:9876) Warning: Accessing non-existent property 'lineno' of module exports inside circular dependency(node:9876) Warning: Accessing non-existent property 'column' of module exports inside circular dependency(node:9876) Warning: Accessing non-existent property 'filename' of module exports inside circular dependency 在github上看，部署的index文件没有内容, 问题原因： node.js版本太高了 解决办法： 降级node.js 步骤： 12345678//安装node.js版本管理软件 nsudo npm install -g n//查看n 是否安装成功n -V//安装指定版本 nodesudo n 13.14","tags":[{"name":"日常","slug":"日常","permalink":"http://yoursite.com/tags/日常/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"iOS中的枚举","date":"2016-05-11T03:02:30.000Z","path":"2016/05/11/枚举的实现方式(移位枚举)/","text":"普通的枚举第一种实现方式1234typedef enum &#123; EnumTypeTop, EnumTypeBottom&#125;EnumType 第二种实现方式1234typedef NS_ENUM(NSInteger,EnumType) &#123; EnumTypeTop, EnumTypeBottom&#125;; 枚举的作用就是增加程序的可读性,将原来使用数值代表的状态转换成自然语言中有相应含义的单词,所以这样写出来的代码更易读懂。编译器会为枚举分配一个独有的编号,从0开始,每个枚举递增1，也可以使用= 指定需要的值 移位枚举实现方式12345678910typedef NS_OPTIONS(NSUInteger, EnumType) &#123; EnumTypeNone = 0, // 0000 0000 0 EnumTypeTop = 1&lt;&lt;0, // 0000 0001 1 EnumTypeBottom = 1&lt;&lt;1, // 0000 0010 2 EnumTypeLeft = 1&lt;&lt;2, // 0000 0100 4 EnumTypeRight = 1&lt;&lt;3, // 0000 1000 8 EnumTypeCenter = 1&lt;&lt;4, // 0001 0000 16 EnumTypeHeight = 1&lt;&lt;5, // 0010 0000 32 EnumTypeWidth = 1&lt;&lt;6 // 0100 0000 64&#125; 上面就是一个移位枚举, 和普通的枚举的区别就是,每个状态的值不是递增的,而是用只有1个二进制位的值是1数字表示的,这么做的好处就是可以对状态值进行”位或”运算,从而实现同时使用多个枚举 1234567891011121314151617181920212223242526272829303132333435- (void)testEnum &#123; [self needMutEnum:EnumTypeTop | EnumTypeBottom | EnumTypeLeft | EnumTypeRight | EnumTypeCenter];&#125;- (void)needMutEnum:(EnumType) type &#123; if (type==0) &#123; NSLog(@\"EnumTypeNone\"); return; &#125; if (type &amp; EnumTypeTop) &#123; NSLog(@\"EnumTypeTop\"); &#125; if (type &amp; EnumTypeBottom) &#123; NSLog(@\"EnumTypeBottom\"); &#125; if (type &amp; EnumTypeLeft) &#123; NSLog(@\"EnumTypeLeft\"); &#125; if (type &amp; EnumTypeRight) &#123; NSLog(@\"EnumTypeRight\"); &#125; if (type &amp; EnumTypeCenter) &#123; NSLog(@\"EnumTypeCenter\"); &#125; if (type &amp; EnumTypeHeight) &#123; NSLog(@\"EnumTypeHeight\"); &#125; if (type &amp; EnumTypeWidth) &#123; NSLog(@\"EnumTypeWidth\"); &#125;&#125; 输出 12345EnumTypeTopEnumTypeBottomEnumTypeLeftEnumTypeRightEnumTypeCenter 这样就实现了同时使用多个枚举 原因“位或”和”位与”运算“位或”: 0 | 0 = 0 ; 0 | 1 = 1 ; 1 | 1 = 1; “位与”: 0 &amp; 0 = 0 ; 0 &amp; 1 = 0 ; 1 &amp; 1 = 1; 对移位枚举进行”位或”运算EnumTypeTop | EnumTypeBottom | EnumTypeLeft | EnumTypeRight | EnumTypeCenter 转换成二进制就是 0000 0001 | 0000 0010 | 0000 0100 | 0000 1000 | 0010 0000 = 0011 1111 其10进制的值时63 所以”needMutEnum”这个方法传入的值type是十进制的63, 当使用的时候又用type的值和枚举做”位与运算”,63的二进制是 0011 1111 EnumTypeTop的二进制是 0000 0001 ,”位与”运算的结果就是 0000 0001 , 也就是说传入的type的值转换成二进制,哪个位上是1,对应的那个类型的枚举就被传入了, 但是要注意的是,如果不需要None的状态,就不要把第一个枚举状态设置成0,直接从0000 0001 设置","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]}]