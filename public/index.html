<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>小商店飞的地盘</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="小商店飞的地盘">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="小商店飞的地盘">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="小商店飞的地盘">
  
    <link rel="alternative" href="/atom.xml" title="小商店飞的地盘" type="application/atom+xml">
  
  
    <link rel="icon" href="http://7xkj1z.com1.z0.glb.clouddn.com/head.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
  
  

  <script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>
  <script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>

  
</head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xkj1z.com1.z0.glb.clouddn.com/head.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">小商店飞</a></h1>
		</hgroup>

		
		<p class="header-subtitle">一切都是梵天的一场梦</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/VPS那些事/" style="font-size: 10px;">VPS那些事</a> <a href="/tags/appium/" style="font-size: 10px;">appium</a> <a href="/tags/hello/" style="font-size: 10px;">hello</a> <a href="/tags/iOS/" style="font-size: 20px;">iOS</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/smackgg/hexo-theme-smackdown">smackdown</a>
			        
			        </div>
				</section>
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">小商店飞</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="http://7xkj1z.com1.z0.glb.clouddn.com/head.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">小商店飞</h1>
			</hgroup>
			
			<p class="header-subtitle">一切都是梵天的一场梦</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-Xcode8 报错resource fork, Finder information, or similar detritus not allowed/Xcode8 报错resource fork, Finder information, or similar detritus not allowed" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/07/04/Xcode8 报错resource fork, Finder information, or similar detritus not allowed/Xcode8 报错resource fork, Finder information, or similar detritus not allowed/" class="article-date">
  	<time datetime="2018-07-04T09:32:37.570Z" itemprop="datePublished">2018-07-04</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>这是因为Xcode8引进的新的安全机制, Code signing不允许app的bundle里面的文件有未知的文件系统扩展属性</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>在终端中输入 <code>xattr -lr &lt;path_to_app_bundle&gt;</code> 可以查看存在未知扩展属性的文件</p>
<p>在终端中输入 <code>xattr -cr &lt;path_to_app_bundle&gt;</code> 可以移除所有未知的扩展属性</p>
<p>然后清理Xcode 重新build 工程</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-WeView 2 使用翻译/WeView 2 使用翻译" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/07/04/WeView 2 使用翻译/WeView 2 使用翻译/" class="article-date">
  	<time datetime="2018-07-04T09:32:19.676Z" itemprop="datePublished">2018-07-04</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="WeView-介绍"><a href="#WeView-介绍" class="headerlink" title="WeView 介绍"></a>WeView 介绍</h1><h2 id="WeView-使用的一个简单的demo"><a href="#WeView-使用的一个简单的demo" class="headerlink" title="WeView 使用的一个简单的demo"></a>WeView 使用的一个简单的demo</h2><p> <img src="resources/9AF089FB76B2ADB18C4B3E9423098F77.jpg" alt="WeView_demo.png"></p>
<blockquote>
<p>WeView 是一个用来给iOS界面自动布局的工具库</p>
</blockquote>
<ul>
<li>WeView 2是iOS Auto Layout 的替代品.</li>
<li>WeView 2旨在提供一个”简单”,”自然”,”易描述”,”易维护”的方法通过UIKit去创建动态适应的界面</li>
<li>WeView 2使用直观的描述性方法来布局,如”alignment”(对齐),”margins”(边距),”spacing” (间距).</li>
<li>WeView 2构建在iOS现有的大小和布局机制.</li>
<li>WeView 2是轻量级的:不超过5k行代码而且没有别的依赖.</li>
<li>WeView 2兼容iOS5及以上版本.</li>
<li>WeView 2是免费开源的,遵循” Apache License Version 2.0”</li>
<li>WeView 2是易学的.</li>
</ul>
<h1 id="为什么使用动态布局"><a href="#为什么使用动态布局" class="headerlink" title="为什么使用动态布局"></a>为什么使用动态布局</h1><blockquote>
<p>使用动态布局的原因有很多,不管你使用的是iOS Auto Layout还是WeView.动态布局会让界面做到如下几点:</p>
</blockquote>
<ol>
<li>适应不同的屏幕尺寸</li>
<li>适应方向的改变(eg:横屏和竖屏)</li>
<li>适应设计的改变(eg:字体大小的改变,添加或移除子view,改变图片大小等)</li>
<li>适应文本内容的改变</li>
<li>适应动态内容的改变(eg:下载完成的内容)</li>
</ol>
<h1 id="为什么使用WeView-2"><a href="#为什么使用WeView-2" class="headerlink" title="为什么使用WeView 2"></a>为什么使用WeView 2</h1><blockquote>
<p>摘要: iOS Auto Layout 是一种复杂笨拙效率低下的编码方式</p>
</blockquote>
<ul>
<li>概念复杂:在使用iOS Auto Layout的时候,你需要考虑”约束优先级”,”约束是否完全”,”约束是否冲突”(eg:过约束布局),”最近共同祖先”等,这些问题也使代码重构变的复杂</li>
<li>缺乏基准:iOS Auto Layout 是基于一个复杂的约束处理系统,任何view的最终位置和大小都会收受到约束系统中的所有约束的影响,这些约束不需要被他们的父view持有,如果不能理解相邻view的层级就不能进行约束</li>
<li>编码复杂:用iOS Auto Layout布局一个按钮水平居中,底部距离父view20pt</li>
</ul>
<h2 id="iOS-Auto-Layout-代码"><a href="#iOS-Auto-Layout-代码" class="headerlink" title="iOS Auto Layout 代码"></a>iOS Auto Layout 代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">UIButton *button = ...;</div><div class="line">UIView *superview = ...;</div><div class="line">NSLayoutConstraint *cn = [NSLayoutConstraint constraintWithItem:button</div><div class="line">                                                      attribute:NSLayoutAttributeCenterX</div><div class="line">                                                      relatedBy:NSLayoutRelationEqual</div><div class="line">                                                         toItem:superview</div><div class="line">                                                      attribute:NSLayoutAttributeCenterX</div><div class="line">                                                     multiplier:1.0</div><div class="line">                                                       constant:0.0];</div><div class="line">[superview addConstraint:cn];</div><div class="line">cn = [NSLayoutConstraint constraintWithItem:button</div><div class="line">                                  attribute:NSLayoutAttributeBottom</div><div class="line">                                  relatedBy:NSLayoutRelationEqual</div><div class="line">                                     toItem:superview</div><div class="line">                                  attribute:NSLayoutAttributeBottom</div><div class="line">                                 multiplier:1.0</div><div class="line">                                   constant:-20.0];</div><div class="line">[superview addConstraint:cn];</div></pre></td></tr></table></figure>
<h2 id="使用Visual-Format-Language的Auto-Layout"><a href="#使用Visual-Format-Language的Auto-Layout" class="headerlink" title="使用Visual Format Language的Auto Layout"></a>使用Visual Format Language的Auto Layout</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">UIButton *button = ...;</div><div class="line">UIView *superview = ...;</div><div class="line">NSDictionary *variableMap = NSDictionaryOfVariableBindings(label, superview);</div><div class="line">NSLayoutConstraint *cn = [NSLayoutConstraint constraintsWithVisualFormat:@&quot;V:[button]-12-[superview]&quot;</div><div class="line">                                                                 options:0</div><div class="line">                                                                 metrics:nil</div><div class="line">                                                                   views:variableMap];</div><div class="line">[superview addConstraint:cn];</div><div class="line">cn = [NSLayoutConstraint constraintsWithVisualFormat:@&quot;H:[superview]-(&lt;=1)-[button]&quot;</div><div class="line">                                             options:NSLayoutFormatAlignAllCenterY</div><div class="line">                                             metrics:nil</div><div class="line">                                               views:variableMap];</div><div class="line">[superview addConstraint:cn];</div></pre></td></tr></table></figure>
<h2 id="使用WeView"><a href="#使用WeView" class="headerlink" title="使用WeView"></a>使用WeView</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#import &quot;WeView.h&quot;</div><div class="line"></div><div class="line">UIButton *button = ...; </div><div class="line">WeView *panelView = [[WeView alloc] init]; </div><div class="line">[[[[panelView addSubviewWithCustomLayout:button]</div><div class="line">   setHAlign:H_ALIGN_CENTER]</div><div class="line">  setVAlign:V_ALIGN_BOTTOM]</div><div class="line">setMargin:20];</div></pre></td></tr></table></figure>
<p>iOS Auto Layout 在xib中比较有优势,而且xib已经在Xcode5中被显著提高,但是在代码编程中自动布局还是很复杂的</p>
<p>WeView 只能被用作代码编程,但可以被设计的简洁明了,利于维护的代码</p>
<h1 id="指导-1-概述"><a href="#指导-1-概述" class="headerlink" title="指导 1: 概述"></a>指导 1: 概述</h1><p>略</p>
<h1 id="指导-2-安装"><a href="#指导-2-安装" class="headerlink" title="指导 2: 安装"></a>指导 2: 安装</h1><p>添加WeView文件夹到工程中就好.</p>
<p>WeView 2只依赖Foundation ,UIKit 和 Quartz Core库而且需要iOS 5及以上版本</p>
<h2 id="Headers"><a href="#Headers" class="headerlink" title="Headers"></a>Headers</h2><p>头文件通常只需要导入 <code>#import &quot;WeView.h&quot;</code></p>
<h2 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a>Classes</h2><ul>
<li><code>WeView</code> 容器是核心类,他本身只有添加子view和他们布局的方法</li>
<li><code>WeView</code> 的布局是由WeViewLayout实现的</li>
<li><code>UIView + WeView</code> 类别为UIView添加了许多布局属性,用来控制view怎么作为子view布局在他的父view上,这些属性存放在一个关联的对象中,且这个对象只有一个</li>
</ul>
<h1 id="指导-3-术语"><a href="#指导-3-术语" class="headerlink" title="指导 3:术语"></a>指导 3:术语</h1><h2 id="View-Hierarchy-图层"><a href="#View-Hierarchy-图层" class="headerlink" title="View Hierarchy (图层)"></a>View Hierarchy (图层)</h2><p>图层是布局作用的上下文,通常我们只需要关系我们布局view的子view和父view</p>
<h2 id="Superview-amp-Subviews-父view和子view"><a href="#Superview-amp-Subviews-父view和子view" class="headerlink" title="Superview &amp; Subviews (父view和子view)"></a>Superview &amp; Subviews (父view和子view)</h2><p>在布局上下文中,Superview是父view,而他的子view是Subviews(注意:Superview只有一个但是Subviews是可以有多个的),在使用WeView 2布局的时候,通常父view是一个<code>WeView</code>,子View可以是任何类型的UIView</p>
<p>WeView 2工作的时候子View不需要引用任何类或实现任何界面</p>
<h2 id="Widgets-vs-Containers-控件和容器"><a href="#Widgets-vs-Containers-控件和容器" class="headerlink" title="Widgets vs. Containers (控件和容器)"></a>Widgets vs. Containers (控件和容器)</h2><p>widgets(控件) :一个界面上可见的元素 eg:button或label等</p>
<p>containers(容器) :通常是一些不可见的view,用来组织结构和布局其他view eg:在HTML中DIVs通常被用作容器,在UIKit中,空白view也通常被使用.WeView 2的核心就是<code>WeView</code>容器类,通过给容器添加子view作为内容</p>
<h2 id="Measurement-and-Arrangement"><a href="#Measurement-and-Arrangement" class="headerlink" title="Measurement and Arrangement"></a>Measurement and Arrangement</h2><p>Measurement :是view的size推测位置的过程<br>eg:measurement 类似于<code>[UIView sizeThatFies:]</code>方法</p>
<p>Arrangement :是view的size决定位置的过程<br>eg:arrangement 类似于<code>[UIView layoutSubviews]</code>方法</p>
<h2 id="Desired-Size"><a href="#Desired-Size" class="headerlink" title="Desired Size"></a>Desired Size</h2><p>有时候view想要一个他们想要的大小.eg:一个button想要大小是icon的大小,或label想要大小是文本的大小.这时候的大小就是view的Desired Size</p>
<p>使用Weview 2的时候我们可以完全放心的忽视 intrinsic size(固有大小)</p>
<h2 id="Frame-and-Bounds"><a href="#Frame-and-Bounds" class="headerlink" title="Frame and Bounds"></a>Frame and Bounds</h2><p>UIViews 使用了两套坐标系统.<br>frame :UIView的frame是他在他父view的坐标系统中的大小和位置<br>bounds :UIView的bounds是他在他自己的坐标系统中的大小和位置</p>
<p>布局子view的时候是在他的父view的坐标系中操作的,所以操作的是子view的frame.</p>
<p>改变一个view的frame会影响他的bounds,反之也是一样的</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-加密算法/加密算法" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/07/04/加密算法/加密算法/" class="article-date">
  	<time datetime="2018-07-04T09:32:10.073Z" itemprop="datePublished">2018-07-04</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>假设有当前情景:A要发送一条消息”你好”给B</p>
<p>如果不使用任何加密方法,直接发送,消息一旦被C截获,C就知道了消息的内容</p>
<h2 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h2><p>如果A和B事先约定好了一个规则,比如”1”代表”你”,”2”代表”好”,那么A给B发送消息的时候就可以发送”12”,B收到消息后通过查看约定的规则知道A发送的消息是”你好”,如果消息被C截获,C并不知道约定的规则,所以C得到的消息就是”12”,这对C来说是完全没有意义的,因为C并不知道”12”的真正的意义,这就做到了简单的数据加密</p>
<p>上面的过程就是一个简化的”对称加密算法”</p>
<p>数据发信方将明文（原始数据）和加密密钥（miyao）一起经过特殊加密算法处理后，使其变成复杂的加密密文发送出去。收信方收到密文后，若想解读原文，则需要使用加密用过的密钥及相同算法的逆算法对密文进行解密，才能使其恢复成可读明文。在对称加密算法中，使用的密钥只有一个，发收信双方都使用这个密钥对数据进行加密和解密，这就要求解密方事先必须知道加密密钥</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-内存管理/内存管理" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/07/04/内存管理/内存管理/" class="article-date">
  	<time datetime="2018-07-04T09:31:56.034Z" itemprop="datePublished">2018-07-04</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="NSObject-类的alloc方法执行过程"><a href="#NSObject-类的alloc方法执行过程" class="headerlink" title="NSObject 类的alloc方法执行过程"></a>NSObject 类的alloc方法执行过程</h2><p>当一个NSObject类调用了 <code>alloc</code> 类方法,其内部的调用顺序是 </p>
<p>1.+alloc</p>
<p>2.+allocWithZone:</p>
<p>3.class_createInstance</p>
<p>4.calloc</p>
<h2 id="retainCount-retain-release-实例方法的实现"><a href="#retainCount-retain-release-实例方法的实现" class="headerlink" title="retainCount/retain/release 实例方法的实现"></a>retainCount/retain/release 实例方法的实现</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- retainCount</div><div class="line">__CFDoExternRefOperation</div><div class="line"><span class="built_in">CFBasicHashGetCountOfKey</span></div><div class="line"></div><div class="line">- <span class="keyword">retain</span></div><div class="line">__CFDoExternRefOperation</div><div class="line"><span class="built_in">CFBasicHashAddValue</span></div><div class="line"></div><div class="line">- release</div><div class="line">__CFDoExternRefOperation</div><div class="line"><span class="built_in">CFBasicHashRemoveValue</span>  <span class="comment">//CFBasicHashRemoveValue返回0时 release会调用dealloc</span></div></pre></td></tr></table></figure>
<p>__CFDoExternRefOperation 干的事情就是获取对应对象存放引用计数的hash(散列)表,然后对表调用对应的操作的hash(散列)表操作</p>
<p>_objc_autoreleasePoolPrint() 运行此函数,会在控制台打印出AutoreleasePoolPage类使用情况</p>
<h2 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h2><p>同一个程序中按文件为单位可以选择ARC有效/无效</p>
<h3 id="设置ARC有效的编译方法"><a href="#设置ARC有效的编译方法" class="headerlink" title="设置ARC有效的编译方法"></a>设置ARC有效的编译方法</h3><p>1.使用clang(LLVM编译器)3.0或以上版本<br>2.指定编译器属性为”-fobjc-arc” 具体步骤<br>  在工程文件中选择Build Phases =&gt; Compile Sources =&gt; 找到对应要修改的类双击 =&gt;在里面输入”-fobjc-arc”则当前类开启arc,如果输入”-fno-objc-arc”则当前类使用mrc;</p>
<p>注意:xcode 从4.2之后默认是开启arc的</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-枚举的实现方式(移位枚举)/枚举的实现方式(移位枚举)" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/07/04/枚举的实现方式(移位枚举)/枚举的实现方式(移位枚举)/" class="article-date">
  	<time datetime="2018-07-04T09:31:39.035Z" itemprop="datePublished">2018-07-04</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##普通的枚举</p>
<p>###第一种实现方式</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</div><div class="line">    EnumTypeTop,</div><div class="line">    EnumTypeBottom</div><div class="line">&#125;EnumType</div></pre></td></tr></table></figure>
<p>###第二种实现方式</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>,EnumType) &#123;</div><div class="line">    EnumTypeTop,</div><div class="line">    EnumTypeBottom</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>枚举的作用就是增加程序的可读性,将原来使用数值代表的状态转换成自然语言中有相应含义的单词,所以这样写出来的代码更易读懂。编译器会为枚举分配一个独有的编号,从0开始,每个枚举递增1</p>
<p>##移位枚举</p>
<p>###实现方式</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, EnumType) &#123;</div><div class="line">   EnumTypeNone  = <span class="number">0</span>,     <span class="comment">// 0000 0000   0</span></div><div class="line">   EnumTypeTop    = <span class="number">1</span>&lt;&lt;<span class="number">0</span>, <span class="comment">// 0000 0001   1</span></div><div class="line">   EnumTypeBottom = <span class="number">1</span>&lt;&lt;<span class="number">1</span>, <span class="comment">// 0000 0010   2</span></div><div class="line">   EnumTypeLeft   = <span class="number">1</span>&lt;&lt;<span class="number">2</span>, <span class="comment">// 0000 0100   4</span></div><div class="line">   EnumTypeRight  = <span class="number">1</span>&lt;&lt;<span class="number">3</span>, <span class="comment">// 0000 1000   8</span></div><div class="line">   EnumTypeCenter = <span class="number">1</span>&lt;&lt;<span class="number">4</span>, <span class="comment">// 0001 0000   16</span></div><div class="line">   EnumTypeHeight = <span class="number">1</span>&lt;&lt;<span class="number">5</span>, <span class="comment">// 0010 0000   32</span></div><div class="line">   EnumTypeWidth  = <span class="number">1</span>&lt;&lt;<span class="number">6</span>  <span class="comment">// 0100 0000   64</span></div><div class="line">   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面就是一个移位枚举, 和普通的枚举的区别就是,每个状态的值不是递增的,而是用只有1个二进制位的值是1数字表示的,这么做的好处就是可以对状态值进行”位或”运算,从而实现同时使用多个枚举</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (<span class="keyword">void</span>)testEnum &#123;</div><div class="line">    [<span class="keyword">self</span> needMutEnum:EnumTypeTop | EnumTypeBottom | EnumTypeLeft | EnumTypeRight | EnumTypeCenter];</div><div class="line">&#125; </div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)needMutEnum:(EnumType) type &#123;</div><div class="line">    <span class="keyword">if</span> (type==<span class="number">0</span>) &#123;</div><div class="line">      <span class="built_in">NSLog</span>(<span class="string">@"EnumTypeNone"</span>);</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (type &amp; EnumTypeTop) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"EnumTypeTop"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (type &amp; EnumTypeBottom) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"EnumTypeBottom"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (type &amp; EnumTypeLeft) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"EnumTypeLeft"</span>);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (type &amp; EnumTypeRight) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"EnumTypeRight"</span>);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (type &amp; EnumTypeCenter) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"EnumTypeCenter"</span>);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (type &amp; EnumTypeHeight) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"EnumTypeHeight"</span>);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (type &amp; EnumTypeWidth) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"EnumTypeWidth"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">EnumTypeTop</div><div class="line">EnumTypeBottom</div><div class="line">EnumTypeLeft</div><div class="line">EnumTypeRight</div><div class="line">EnumTypeCenter</div></pre></td></tr></table></figure>
<p>这样就实现了同时使用多个枚举</p>
<p>####原因<br>“位或”和”位与”运算<br>“位或”: 0 | 0 = 0 ; 0 | 1 = 1 ; 1 | 1 = 1;<br>“位与”: 0 &amp; 0 = 0 ; 0 &amp; 1 = 0 ; 1 &amp; 1 = 1;</p>
<p>对移位枚举进行”位或”运算<br>EnumTypeTop | EnumTypeBottom | EnumTypeLeft | EnumTypeRight | EnumTypeCenter 转换成二进制就是</p>
<p>0000 0001 | 0000 0010 | 0000 0100 | 0000 1000 | 0010 0000 = 0011 1111  其10进制的值时63</p>
<p>所以”needMutEnum”这个方法传入的值<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">使用的时候又用```type```的值和枚举做&quot;位与运算&quot;</div><div class="line"></div><div class="line">63的二进制是 0011 1111  EnumTypeTop的二进制是 0000 0001</div><div class="line">&quot;位与&quot;运算的结果就是 0000 0001</div><div class="line"></div><div class="line">也就是说传入的```type```的值转换成二进制,那个位上是```1```,对应的那个类型的枚举就被传入了</div><div class="line"></div><div class="line">但是要注意的是,如果不需要None的状态,就不要把第一个枚举状态设置成```0</div></pre></td></tr></table></figure></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Blocks" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/07/04/Blocks/" class="article-date">
  	<time datetime="2018-07-04T09:21:59.101Z" itemprop="datePublished">2018-07-04</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Blocks"><a href="#Blocks" class="headerlink" title="Blocks"></a>Blocks</h1><h2 id="什么是Blocks"><a href="#什么是Blocks" class="headerlink" title="什么是Blocks"></a>什么是Blocks</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">匿名函数，通过```Blocks``` 源码中能够使用不带名称的函数</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">## Block 截获自动变量的值 ##</div><div class="line"></div><div class="line">```blocks```被称为“带有自动变量（局部变量）的匿名函数”</div><div class="line"></div><div class="line"></div><div class="line">那么```blocks```如何带自动变量呢？</div></pre></td></tr></table></figure>
<p>void subMain() {</p>
<pre><code>int val = 10;
char *fmt = &quot;the val is %d&quot;;

void (^blk)(void) = ^{printf(fmt,val);};
blk();//the val is 10
val = 2;
blk();//the val is 10
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">上面这个函数中两次调用block变量 blk，输出的都是“the val is 10”，因为block截获自动变量的值，</div><div class="line">所谓block截获自动变量的值，指的是在block表达式中会保存该自动变量的瞬间值</div><div class="line"></div><div class="line"></div><div class="line">如果要在block中改变局部变量呢？</div></pre></td></tr></table></figure></p>
<p>void subMain() {</p>
<pre><code>int val = 10;
char *fmt = &quot;the val is %d&quot;;

void (^blk)(void) = ^{ val = 2};
blk();
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">这个函数想在block中改变局部变量的值，但是会报编译错误，显然，直接在block中改变自动变量的值也是不可以的</div><div class="line"></div><div class="line">如果想要在block中改变局部变量的值需要在局部变量前面加上一个```__blcok```修饰</div></pre></td></tr></table></figure></p>
<p>void subMain() {</p>
<pre><code>__block int val = 10;
char *fmt = &quot;the val is %d&quot;;

void (^blk)(void) = ^{ val = 2};
blk();
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">这样就不会报错，而且可以改变局部变量的值</div><div class="line"></div><div class="line"></div><div class="line">clang -rewrite-objc</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">block 会在以下情况从栈拷贝到堆上</div><div class="line"></div><div class="line">1. 调用copy的实例方法</div><div class="line">2. block作为函数返回值返回时</div><div class="line">3. 将block赋值给附有__strong修饰符id类型的类或block类型成员变量时</div><div class="line">4. 在方法名中含有usingBlock的cocoa框架方法或GCD的API中传递Block时</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">栈区(stack)</div><div class="line">概述：栈是向低地址扩展的数据结构，是一块连续的内存区域。由栈顶的地址和栈的最大容量是系统预先规定好的。栈的空间很小，大概1-2M。超出overflow。</div><div class="line"></div><div class="line">使用：栈区，就是函数(方法)运行时向系统请求的内存。栈中的局部变量，参数由编译器分配和释放，函数运行就分配，函数结束就释放，由系统完成。是系统数据结构，对应进程唯一。</div><div class="line"></div><div class="line">特别注意：系统栈的剩余空间 大于 所申请的空间，系统为程序提供内存，不然，报错异常，提示栈的溢出。</div><div class="line"></div><div class="line">堆区(heap)</div><div class="line">概述：堆是向高地址扩展的数据结构，不连续的内存区域。系统用链表储存空闲地址的。链表遍历由低向高。堆大小直接受设备有效虚拟内存影响。</div><div class="line"></div><div class="line">1.首先应该知道操作系统有一个记录空闲内存地址的链表。</div><div class="line">2.当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。</div><div class="line">3.由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中</div><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">使用: 存放实体对象的。由程序员分配和释放(arc自动插入分配和释放代码)，例如alloc 申请的会放入堆中。</div><div class="line"></div><div class="line">全局\静态区(static)</div><div class="line">静态变量和全局变量是存储在一起的。初始化的全局变量和静态变量存放在一块区域，未初始化的全局变量和静态变量在相邻的另一块区域，程序结束后有系统释放。</div><div class="line"></div><div class="line">int a;//未初始化的静态区</div><div class="line">int b = 10;//初始化的静态区</div><div class="line">1</div><div class="line">2</div><div class="line">文字常量区</div><div class="line">存放常量字符串，程序结束系统释放</div><div class="line"></div><div class="line">程序代码区</div><div class="line">存放函数的二进制代码</div></pre></td></tr></table></figure></p>
<p>main{<br>   int b; 栈区<br>   char s[] = “abc” 栈<br>   char <em>p1; 栈<br>   char </em>p2 = “123456”;  //123456在文字常量区，p2在栈上。<br>   static int c =0； 全局（静态）初始化区 </p>
<p>   w1 = (char <em>)malloc(10);<br>   w2 = (char </em>)malloc(20);<br>   分配得来得10和20字节的区域就在堆区。<br> }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"># GCD</div><div class="line"></div><div class="line">同步添加</div><div class="line">dispatch_sync(Queue,Block) </div><div class="line"></div><div class="line">等待 queue 中的所有任务都完成了之后，把block任务添加进入</div><div class="line"></div><div class="line">异步添加</div><div class="line">dispatch_async(Queue,Block) </div><div class="line"></div><div class="line">不做任何等待，直接把block中的任务添加进入queue</div><div class="line"></div><div class="line"></div><div class="line">注意：</div><div class="line"></div><div class="line">1. 如果是dispatch_sync（同步添加），但是queue 就是当前dispatch_sync运行的队列，就会造成死锁</div><div class="line"></div><div class="line"></div><div class="line">打比方：</div><div class="line"></div><div class="line">block ：每个学生</div><div class="line"></div><div class="line">queue ： 学生所站的队 （有两类）</div><div class="line"></div><div class="line">dispatch_sync 和 dispatch_async</div><div class="line"></div><div class="line">线程 ： 在哪个跑道上跑步</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">把一个任务使用GCD让其在线程中执行，比喻下来就是安排一个学生到跑道上跑步</div><div class="line"></div><div class="line"></div><div class="line">queue：这里有两种队列，一直叫串行队列，一种叫并行队列，</div><div class="line"></div><div class="line">串行队列：只能有一个学生在排队，如果有多个学生想要去排队，只能等前一个学生跑玩步，跑道空出来才能去排队</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">eg：</div><div class="line"></div><div class="line">异步并行队列：</div></pre></td></tr></table></figure>
<p>void GCD_async_Test() {<br>    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); //获得一个并行队列<br>    NSLog(@”任务1加入队列1前”);<br>    dispatch_async(queue, ^{<br>        NSLog(@”开始长时间任务1”);<br>        [NSThread sleepForTimeInterval:3];<br>        NSLog(@”长时间任务1完成”);<br>    });//把任务放入并行队列中<br>    NSLog(@”任务1加入队列后”);<br>}<br>```</p>
<p>输出：</p>
<p>任务1加入队列1前<br>任务1加入队列后<br>开始长时间任务1<br>长时间任务1完成</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-OC使用静态库中的类别" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/04/05/OC使用静态库中的类别/" class="article-date">
  	<time datetime="2017-04-05T12:02:30.000Z" itemprop="datePublished">2017-04-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/05/OC使用静态库中的类别/">
        OC使用静态库中的类别
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="OC中使用静态库中的类别的问题"><a href="#OC中使用静态库中的类别的问题" class="headerlink" title="OC中使用静态库中的类别的问题"></a>OC中使用静态库中的类别的问题</h2><p>OC的源文件经过 <code>clang</code> 编译首先生成中间代码,接着通过优化生成目标代码(目标代码中包括符号表,标示了此代码中的全局符号和静态符号,还标示了导入符号等),连接器会根据符号表分析各个目标代码之间的调用关系,然后将使用到的代码进行连接和重定位,最后生成可执行文件.</p>
<p>在编译Objective-C源文件到目标文件时,编译器并不知道方法的对应实现,只能在运行时才知道,所以编译器只会为类生成连接符号,不会对类中的方法生成连接符号,由于Category方法并不对应一个新类,所以不会生成连接符号,连接器也不会将Category方法合并到原始的类中,最终导致连接器忽略了Category方法,不会将其连接到可执行文件中.</p>
<blockquote>
<p>在OC使用静态库中的类别,需要设置下面5种方法中的一种</p>
</blockquote>
<h2 id="Other-Linker-Flags-设置"><a href="#Other-Linker-Flags-设置" class="headerlink" title="Other Linker Flags 设置"></a>Other Linker Flags 设置</h2><ul>
<li><p>1.通过在Other Linder Flags 添加 <code>-all\_load</code> 它会告诉编译器对”所有文档中的所有对象文件,不管里面的符号有没有被用到,全部都载入”,这样会产生比较大的二进制文件</p>
</li>
<li><p>2.通过在Other Linder Flags 添加 <code>-force\_load 和指定路径</code> e.g: <code>-force\_load $(SRCROOT)/RHAddressBook/libRHAddressBook.a</code> 这种方法会只载入指定的归档</p>
</li>
<li><p>3.通过在Other Linder Flags 添加 <code>-ObjC</code> ,这个标识告诉编译器”如果在文档中发现了OC代码,就把文档载入” </p>
</li>
<li><p>4.在Xcode里build setting中的 Perform Single-Object PreLink，如果启用这个选项，所有的对象文件都会被合并成一个单文件（这不是真正的链接，所以叫做预链接），这个对象文件（有时被称做主对象文件(master object file)）被添加到文档中。现在如果主对象文件中的任何符号被认为是“在使用”，整个主对象文件都会被认为在使用，这样它里面的OC部分就会被载入了。因为里面的类都被正常符号化了，所以能使从这样的静态库中使用所有的Category</p>
</li>
<li><p>5.最后一种解决方法是在只有Category的源文件里添加Fake symbol。如果你想在运行时使用Category，一定要确保你以某种方法在编译时引用了fake symbol，这会使得对象文件以及它里面的OC代码被载入。例如，它可以是一个有空函数体的函数，也可以是一个被访问的全局变量（例如一个全局的int变量，只要它被读或者写了一次就足够了）。和上面其他的解决方法不一样，这种解决方法可以控制哪些category可以在运行时被编译后的代码使用（可以通过使用这个符号，使它们被链接并变得可用；也可以不使用这个符号，这样链接器就会忽略它）</p>
</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-OC使用静态库中的类别/OC使用静态库中的类别" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/04/05/OC使用静态库中的类别/OC使用静态库中的类别/" class="article-date">
  	<time datetime="2017-04-05T12:02:30.000Z" itemprop="datePublished">2017-04-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/05/OC使用静态库中的类别/OC使用静态库中的类别/">
        OC使用静态库中的类别
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="OC中使用静态库中的类别的问题"><a href="#OC中使用静态库中的类别的问题" class="headerlink" title="OC中使用静态库中的类别的问题"></a>OC中使用静态库中的类别的问题</h2><p>OC的源文件经过 <code>clang</code> 编译首先生成中间代码,接着通过优化生成目标代码(目标代码中包括符号表,标示了此代码中的全局符号和静态符号,还标示了导入符号等),连接器会根据符号表分析各个目标代码之间的调用关系,然后将使用到的代码进行连接和重定位,最后生成可执行文件.</p>
<p>在编译Objective-C源文件到目标文件时,编译器并不知道方法的对应实现,只能在运行时才知道,所以编译器只会为类生成连接符号,不会对类中的方法生成连接符号,由于Category方法并不对应一个新类,所以不会生成连接符号,连接器也不会将Category方法合并到原始的类中,最终导致连接器忽略了Category方法,不会将其连接到可执行文件中.</p>
<blockquote>
<p>在OC使用静态库中的类别,需要设置下面5种方法中的一种</p>
</blockquote>
<h2 id="Other-Linker-Flags-设置"><a href="#Other-Linker-Flags-设置" class="headerlink" title="Other Linker Flags 设置"></a>Other Linker Flags 设置</h2><ul>
<li><ol>
<li>通过在Other Linder Flags 添加 <code>-all\_load</code> 它会告诉编译器对”所有文档中的所有对象文件,不管里面的符号有没有被用到,全部都载入”,这样会产生比较大的二进制文件</li>
</ol>
</li>
<li><p>2.通过在Other Linder Flags 添加 <code>-force\_load 和指定路径</code> e.g: <code>-force\_load $(SRCROOT)/RHAddressBook/libRHAddressBook.a</code> 这种方法会只载入指定的归档</p>
</li>
<li><p>3.通过在Other Linder Flags 添加 <code>-ObjC</code> ,这个标识告诉编译器”如果在文档中发现了OC代码,就把文档载入” </p>
</li>
<li><p>4.在Xcode里build setting中的 Perform Single-Object PreLink，如果启用这个选项，所有的对象文件都会被合并成一个单文件（这不是真正的链接，所以叫做预链接），这个对象文件（有时被称做主对象文件(master object file)）被添加到文档中。现在如果主对象文件中的任何符号被认为是“在使用”，整个主对象文件都会被认为在使用，这样它里面的OC部分就会被载入了。因为里面的类都被正常符号化了，所以能使从这样的静态库中使用所有的Category</p>
</li>
<li><p>5.最后一种解决方法是在只有Category的源文件里添加Fake symbol。如果你想在运行时使用Category，一定要确保你以某种方法在编译时引用了fake symbol，这会使得对象文件以及它里面的OC代码被载入。例如，它可以是一个有空函数体的函数，也可以是一个被访问的全局变量（例如一个全局的int变量，只要它被读或者写了一次就足够了）。和上面其他的解决方法不一样，这种解决方法可以控制哪些category可以在运行时被编译后的代码使用（可以通过使用这个符号，使它们被链接并变得可用；也可以不使用这个符号，这样链接器就会忽略它）</p>
</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Xcode8 报错resource fork, Finder information, or similar detritus not allowed" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/03/31/Xcode8 报错resource fork, Finder information, or similar detritus not allowed/" class="article-date">
  	<time datetime="2017-03-31T03:02:30.000Z" itemprop="datePublished">2017-03-31</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/31/Xcode8 报错resource fork, Finder information, or similar detritus not allowed/">
        Xcode8报错
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Xcode8 报错resource fork, Finder information, or similar detritus not allowed</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>这是因为Xcode8引进的新的安全机制, Code signing不允许app的bundle里面的文件有未知的文件系统扩展属性</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>在终端中输入 <code>xattr -lr &lt;path_to_app_bundle&gt;</code> 可以查看存在未知扩展属性的文件</p>
<p>在终端中输入 <code>xattr -cr &lt;path_to_app_bundle&gt;</code> 可以移除所有未知的扩展属性</p>
<p>然后清理Xcode 重新build 工程</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Untitled" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/03/28/Untitled/" class="article-date">
  	<time datetime="2017-03-28T09:49:52.000Z" itemprop="datePublished">2017-03-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="AFNetworking-相关"><a href="#AFNetworking-相关" class="headerlink" title="AFNetworking 相关"></a>AFNetworking 相关</h1><h2 id="网络通讯"><a href="#网络通讯" class="headerlink" title="网络通讯"></a>网络通讯</h2><p>建立一个<code>TCP</code>协议的连接通常需要三次”握手”,断开一个<code>TCP</code>协议的连接需要四次”挥手”</p>
<h3 id="三次”握手”"><a href="#三次”握手”" class="headerlink" title="三次”握手”"></a>三次”握手”</h3><ul>
<li>1.”Client”端(客户端)发送连接请求报文.</li>
<li>2.”Server”端(服务端)接受连接后回复ACK(指令正确)报文,并为这次连接分配资源</li>
<li>3.”Client”端(客户端)收到ACK报文后像”Server”端发送ACK(指令正确报文),并分配资源</li>
</ul>
<p>举个栗子:<br>    A(客户端)和B(服务端)进行交易<br>    A:”我要的东西带来了么?” (客户端向服务端请求)<br>    B:”天王盖地府,先对暗号” (服务端给客户端一个回应,表示知道客户端要请求了,并且准备好了请求资源)<br>    A:”小鸡炖蘑菇” (客户端给服务端一个回应,表示自己知道已经连接上服务端,并且知道服务端准备好了,且自己也准备好了)<br>    接头完成,进行可以进行交易(连接成功)</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2018 小商店飞
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/smackgg/hexo-theme-smackdown" target="_blank">Smackdown</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: true
	}
</script>
<script src="/js/main.js"></script>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>


  </div>
</body>
</html>