---
title: swift_node_6
date: 2021-09-23 10:11:15
tags:
---

### 属性

* `Swift`中跟实例相关的属性可以分为(存储属性，计算属性)2大类



#### 存储属性

* 类似于成员变量
* 存储在实例的内存中
* 结构体、类可以定义存储属性
* 枚举不可以定义存储属性
* 在创建类或结构体的实例时，必须为所有的存储属性设置一个合适的初始值

#### 计算属性

* 本质就是方法（函数）
* 不占用实例的内存
* 枚举、结构体、类都可以定义计算属性 
* 计算属性只能用`var` 不能使用`let`
* 枚举的原始值`rawValue`是一个只读的计算属性
* 计算属性也可以用`&`修饰传入`inout`修饰的方法参数中，再传入前系统会调用`get`方法，同时将返回值存入局部变量中，并将地址传入方法参数中，在调用完成时，会调用`set`方法将局部变量设置回去

### 延迟存储属性

* 使用`lazy`可以定义一个延迟存储属性，在第一次用到属性的时候才会进行初始化
* `lazy`修饰的属性必须是`var`不能是`let`
* `let`必须在实例的初始化方法完成之前就拥有值
* 当结构体包含一个延迟存储属性时，只有`var`才能访问延迟存储属性（因为延迟属性初始化时需要改变结构体的内存）

### 属性观察器

* 可以为非`lazy`的`var`存储属性设置属性观察器
* `willSet`会传递新值，默认叫`newValue`
* `didSet`会传递旧值，默认叫`oldValue`
* 在初始化器中设置属性值不会触发`willSet`和`didSet`

属性观察器、计算属性的功能，同样可以应用在全局变量、局部变量上



### inout的本质

* 如果实参有物理内存地址（存储属性，全局变量），且没有设置属性观察器，直接将实参的内存地址传入参数（实参进行引用传递）
* 如果实参是计算属性或者设置了属性观察器，则采取了`Copy In Copy Out`的做法，调用该函数时，先复制实参的值，产生局部变量（调用get），将局部变量的内存地址传入函数，在函数内部可以修改局部变量的值，函数返回后，再将局部变量的值覆盖实参的值（调用set）

### 类型属性

* 通过`static`修饰的属性，在整个程序运行时，只有一份内存，要用类型调用，无法用实例调用
* 类型属性不需要设定初始值
* 枚举类型也可以定义类型属性

### 方法

* 枚举，结构体，类都可以定义实例方法和类型方法

### mutating

* 结构体和枚举是值类型，默认情况下，值类型的属性不能被自身的实例方法修改，（实例方法无法修改属性，如果要修改，要在方法前加上`mutating`）

### @discardableResult

* 在方法前面加上`@discardableResult`可以消除方法返回值没有使用的警告

### 下标

* 使用`subscript`可以给任意类型（枚举、结构体、类）增加下标功能，有些地方也翻译为：下标脚本
* `subscript`的语法类似于实例方法、计算属性，本质就是方法（函数）

```swift
class Point {
		var x = 0.0
		var y = 0.0
		subscript(index: Int) -> Double {
				set {
						if index == 0 {
								x = newValue
						}else if index == 1 {
								y = newValue
						}
				}
				get {
						if index == 0 {
								return x
						}else if index == 1 {
								return y
						}
						return 0
				}
		}
}
```

* `subscript`可以接受多个参数，并且类型任意
* `subscript`可以设置参数标签
* `subscript` 可以没有`set`方法，但必须要有`get`方法，只有`get`方法，可以省略`get`
* `static`修饰的是类型方法
