---
title: swift_node_8
date: 2021-10-13 20:41:36
tags:
---

### 可选链

* 如果可选项为`nil`,调用方法，下标，属性失败，结果为`nil`

* 如果可选项不为`nil`,调用方法，下标，属性成功，结果会被包装成可选项

* 如果结果本来就是可选项，不会进行再次包装

  ```swift
  var num1:  Int? = 5
  num1? = 10 // num1被赋值为10
  
  var num2: Int? = nil
  num2? = 10 //num2不会被赋值
  ```

### 协议（protocol）

* 协议可以用来定义方法、属性、下标的声明，协议可以被枚举、结构体、类遵守（多个协议之间用逗号隔开）
* 协议中定义方法时不能有默认参数值
* 默认情况下，协议中定义的内容必须全部都实现
* 协议中定义属性时必须使用`var`关键字
* 实现协议时的属性权限要不小于协议中定义的属性权限（协议定义get、set，用var存储属性或get、set计算属性去实现）
* 为了保证通用，协议中必须用`static`定义类型方法、类型属性、类型下标
* 只有将协议中的实例方法标记为`mutating`才允许结构体、枚举的具体实现修改自身内存，类在实现方法的时候不用加`mutating`,枚举、结构体才需要加
* 协议中可以定义初始化器`init`,非`final`类实现时必须加上`required`
* 如果从协议实现的初始化器，刚好是重写了父类的指定初始化器，那么这个初始化器必须同时加上`required`和`override` 
* 一个协议可以继承其他协议
* 协议组合，可以包含1个类类型

### 系统协议

#### CaseIterable

* 让枚举遵守这个协议，可以实现遍历枚举值

#### CustomStringConvertible

* 遵守这个协议，可以自定义实例的打印字符串

### Any和AnyObject

* `Any`: 可以代表任意类型（枚举、结构体、类，也包括函数类型）
* `AnyObject`:可以代表任意类类型（在协议后面写上`: AnyObject`代表只有类能遵守这个协议）

### is，as?，as! ，as

* is用来判断是否为某种类型，as用来做强制类型  

### X.self、X.Type、AnyClass

* X.self是一个元类型（metadata）的指针，metadata存放着类型相关信息
* X.self属于X.Type类型
* AnyClass = AnyObject.Type

### Self

* Self一般用作返回值类型，限定返回值跟方法调用者必须是同一类型（也可以作为参数类型）类似OC中的**instancetype**
* 如果Self用在类中，要求返回时调用的初始化器是`required`的

