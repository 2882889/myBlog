---
title: swift_node_7
date: 2021-09-26 19:39:16
tags:
---

### 继承

* 值类型（枚举、结构体）不支持继承，只有类支持继承
* 没有父类的类，称为：基类
* 子类可以重写父类的属性，方法，下标，重写需要加上`override`关键字
* 被`class`修饰的类型方法、下标允许被子类重写
* 被`static`修饰的类型方法、下标不允许被子类重写
* 父类是`class`修饰的类型方法，子类重写可以写成`static`但是，重写后的方法，无法继续被重写
* 子类可以将父类的属性（存储、计算）重写为计算属性
* 子类不可以将父类属性重写为存储属性
* 只能重写`var`属性，不能重写`let`属性
* 子类重写后的属性权限补鞥呢小于父类属性的权限（如果父类是只读属性，子类重写后可以是只读的，也可以是读写的，如果父类是读写的，子类重写后也必须是读写的）
* `class`修饰的类型计算属性可以被子类重写，`static`修饰的类型计算属性，不能被子类重写 （不能用`class`修饰类型存储属性）
* 可以在子类中为父类属性添加属性观察器(除了只读属性，let属性)，如果父类也有属性观察器，则调用顺序是`子类willSet`,`父类willSet`,`父类didSet`,`子类didSet`
* 可以子类中通过重写为父类的计算属性添加属性观察器,调用顺序为`父类get`,`子类willSet`,`父类set`,`父类get`,`子类didSet` （第一个get 是使用了`oleValue`,第二个get是使用了父类赋值后的属性）

### final

* 被`final`修饰的方法，下标，属性，禁止被重写
* 被`final`修饰的类，禁止被继承

### 初始化器

* 类、结构体、枚举都可以定义初始化器

* 类有2种初始化器： 指定初始化器、便捷初始化器

  ```swift
  // 指定初始化器
  init(parameters) {
  		statements
  }
  
  // 便捷初始化器
  convenience init(parameters) {
  		statements
  }
  ```

* 每个类至少有一个指定初始化器，指定初始化器是类的主要初始化器

* 默认初始化器总是类的指定初始化器

* 类偏向于少量指定初始化器，一个类通常只有一个指定初始化器

* 初始化器的相互调用规则：

  * 便捷初始化器必须从相同的类里调用另一个初始化器
  * 便捷初始化器最终必须调用一个指定初始化器
  * 指定初始化器必须从它的直系父类调用指定初始化器
  
* `Swift`在编码安全方面，为了保证初始化过程的安全，设定了两段式初始化、安全检查

  * 第一阶段： 初始化所有存储属性
    1. 外层调用指定/便携初始化器
    2. 分配内存给实例，但未初始化
    3. 指定初始化器确保当前类定义的存储属性都初始化
    4. 指定初始化器调用父类的初始化器，不断向上调用，形成初始化器链
  * 第二阶段： 设置新的存储属性
    1. 从顶部初始化器往下，链中的每个指定初始化器都有机会进一步定制实例
    2. 初始化器现在能够使用`self`(访问、修改它的属性， 调用它的实例方法)
    3. 最终，链中任何便捷初始化器都有机会定制实例以及使用`self`
  * 安全检查
    * 指定初始化器必须保证在调用父类初始化器之前，其所在类定义的所有存储属性都要初始化完成
    * 指定初始化器必须先调用父类初始化器，然后才能为继承属性设置新值
    * 便捷初始化器必须先调用同类中的其他初始化器，然后再为任意属性设置新值
    * 初始化器在第一阶段初始化完成之前，不能调用任何实例方法、不能读取任何实例属性的值，也不能引用`self`
    * 直到第一阶段结束，实例才算完全合法

### 重写初始化器

* 当重写父类的指定初始化器时，必须加上`override`(即使子类的实现是便捷初始化器)
* 如果子类写了一个匹配父类便捷初始化器的初始化器，不用加上`override`,(便捷初始化器只能本类调用，子类无法调用)

### 自动继承

* 如果子类没有定义任何指定初始化器，它会自动继承父类所有的指定初始化器
* 如果子类提供了父类所有指定初始化器的实现（要么通过继承，要么重写，包括重写为便捷初始化器），子类会自动继承父类所有的便捷初始化器
* 就算子类添加了更多的便捷初始化器，这些规则仍然适用

### required

* 用`required`修饰指定初始化器，表明其所有子类都必须实现该初始化器（通过继承或者重写实现）
* 如果子类重写了`required`初始化器，也必须加上`required`,不用加`override`

### 属性观察器

* 父类的属性在它自己的初始化器中赋值不会触发属性观察器，但在子类的初始化器中赋值会触发属性观察器

### 可失败初始化器

* 类、结构体、枚举都可以使用`init?`定义可失败初始化器（可返回`nil`的初始化器），用它创建出来的对象为可选型
* 不允许同时定义参数标签、参数个数、参数类型相同的可失败初始化器和非可失败初始化器
* 可以使用`init!`定义隐式解包的可失败初始化器 
* 可失败初始化器可以调用非可失败初始化器，非可失败初始化器调用可失败初始化器需要进行解包
* 如果初始化器调用一个可失败初始化器导致初始化失败，那么整个初始化过程都失败，并且之后的代码都停止执行
* 可以用一个非可失败初始化器重写一个可失败初始化器，但反过来不行

### 反初始化器（deinit）

* `deinit`叫做反初始化器，类似于C++的析构函数、OC中的dealloc方法
* 当类的实例对象被释放内存时，就会调用实例对象的`deinit`方法
* `deinit`不接受任何参数，不能写小括号，不能自行调用
* 子类的`deinit`实现执行完毕后会调用父类的`deinit`

